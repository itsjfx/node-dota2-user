/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * CLC_Messages enum.
     * @exports CLC_Messages
     * @enum {number}
     * @property {number} clc_ClientInfo=20 clc_ClientInfo value
     * @property {number} clc_Move=21 clc_Move value
     * @property {number} clc_VoiceData=22 clc_VoiceData value
     * @property {number} clc_BaselineAck=23 clc_BaselineAck value
     * @property {number} clc_ListenEvents=24 clc_ListenEvents value
     * @property {number} clc_RespondCvarValue=25 clc_RespondCvarValue value
     * @property {number} clc_FileCRCCheck=26 clc_FileCRCCheck value
     * @property {number} clc_LoadingProgress=27 clc_LoadingProgress value
     * @property {number} clc_SplitPlayerConnect=28 clc_SplitPlayerConnect value
     * @property {number} clc_ClientMessage=29 clc_ClientMessage value
     * @property {number} clc_SplitPlayerDisconnect=30 clc_SplitPlayerDisconnect value
     * @property {number} clc_ServerStatus=31 clc_ServerStatus value
     * @property {number} clc_ServerPing=32 clc_ServerPing value
     * @property {number} clc_RequestPause=33 clc_RequestPause value
     * @property {number} clc_CmdKeyValues=34 clc_CmdKeyValues value
     */
    $root.CLC_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[20] = "clc_ClientInfo"] = 20;
        values[valuesById[21] = "clc_Move"] = 21;
        values[valuesById[22] = "clc_VoiceData"] = 22;
        values[valuesById[23] = "clc_BaselineAck"] = 23;
        values[valuesById[24] = "clc_ListenEvents"] = 24;
        values[valuesById[25] = "clc_RespondCvarValue"] = 25;
        values[valuesById[26] = "clc_FileCRCCheck"] = 26;
        values[valuesById[27] = "clc_LoadingProgress"] = 27;
        values[valuesById[28] = "clc_SplitPlayerConnect"] = 28;
        values[valuesById[29] = "clc_ClientMessage"] = 29;
        values[valuesById[30] = "clc_SplitPlayerDisconnect"] = 30;
        values[valuesById[31] = "clc_ServerStatus"] = 31;
        values[valuesById[32] = "clc_ServerPing"] = 32;
        values[valuesById[33] = "clc_RequestPause"] = 33;
        values[valuesById[34] = "clc_CmdKeyValues"] = 34;
        return values;
    })();
    
    /**
     * SVC_Messages enum.
     * @exports SVC_Messages
     * @enum {number}
     * @property {number} svc_ServerInfo=40 svc_ServerInfo value
     * @property {number} svc_FlattenedSerializer=41 svc_FlattenedSerializer value
     * @property {number} svc_ClassInfo=42 svc_ClassInfo value
     * @property {number} svc_SetPause=43 svc_SetPause value
     * @property {number} svc_CreateStringTable=44 svc_CreateStringTable value
     * @property {number} svc_UpdateStringTable=45 svc_UpdateStringTable value
     * @property {number} svc_VoiceInit=46 svc_VoiceInit value
     * @property {number} svc_VoiceData=47 svc_VoiceData value
     * @property {number} svc_Print=48 svc_Print value
     * @property {number} svc_Sounds=49 svc_Sounds value
     * @property {number} svc_SetView=50 svc_SetView value
     * @property {number} svc_ClearAllStringTables=51 svc_ClearAllStringTables value
     * @property {number} svc_CmdKeyValues=52 svc_CmdKeyValues value
     * @property {number} svc_BSPDecal=53 svc_BSPDecal value
     * @property {number} svc_SplitScreen=54 svc_SplitScreen value
     * @property {number} svc_PacketEntities=55 svc_PacketEntities value
     * @property {number} svc_Prefetch=56 svc_Prefetch value
     * @property {number} svc_Menu=57 svc_Menu value
     * @property {number} svc_GetCvarValue=58 svc_GetCvarValue value
     * @property {number} svc_StopSound=59 svc_StopSound value
     * @property {number} svc_PeerList=60 svc_PeerList value
     * @property {number} svc_PacketReliable=61 svc_PacketReliable value
     * @property {number} svc_HLTVStatus=62 svc_HLTVStatus value
     * @property {number} svc_ServerSteamID=63 svc_ServerSteamID value
     * @property {number} svc_FullFrameSplit=70 svc_FullFrameSplit value
     */
    $root.SVC_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[40] = "svc_ServerInfo"] = 40;
        values[valuesById[41] = "svc_FlattenedSerializer"] = 41;
        values[valuesById[42] = "svc_ClassInfo"] = 42;
        values[valuesById[43] = "svc_SetPause"] = 43;
        values[valuesById[44] = "svc_CreateStringTable"] = 44;
        values[valuesById[45] = "svc_UpdateStringTable"] = 45;
        values[valuesById[46] = "svc_VoiceInit"] = 46;
        values[valuesById[47] = "svc_VoiceData"] = 47;
        values[valuesById[48] = "svc_Print"] = 48;
        values[valuesById[49] = "svc_Sounds"] = 49;
        values[valuesById[50] = "svc_SetView"] = 50;
        values[valuesById[51] = "svc_ClearAllStringTables"] = 51;
        values[valuesById[52] = "svc_CmdKeyValues"] = 52;
        values[valuesById[53] = "svc_BSPDecal"] = 53;
        values[valuesById[54] = "svc_SplitScreen"] = 54;
        values[valuesById[55] = "svc_PacketEntities"] = 55;
        values[valuesById[56] = "svc_Prefetch"] = 56;
        values[valuesById[57] = "svc_Menu"] = 57;
        values[valuesById[58] = "svc_GetCvarValue"] = 58;
        values[valuesById[59] = "svc_StopSound"] = 59;
        values[valuesById[60] = "svc_PeerList"] = 60;
        values[valuesById[61] = "svc_PacketReliable"] = 61;
        values[valuesById[62] = "svc_HLTVStatus"] = 62;
        values[valuesById[63] = "svc_ServerSteamID"] = 63;
        values[valuesById[70] = "svc_FullFrameSplit"] = 70;
        return values;
    })();
    
    /**
     * VoiceDataFormat_t enum.
     * @exports VoiceDataFormat_t
     * @enum {number}
     * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value
     * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value
     */
    $root.VoiceDataFormat_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VOICEDATA_FORMAT_STEAM"] = 0;
        values[valuesById[1] = "VOICEDATA_FORMAT_ENGINE"] = 1;
        return values;
    })();
    
    /**
     * RequestPause_t enum.
     * @exports RequestPause_t
     * @enum {number}
     * @property {number} RP_PAUSE=0 RP_PAUSE value
     * @property {number} RP_UNPAUSE=1 RP_UNPAUSE value
     * @property {number} RP_TOGGLEPAUSE=2 RP_TOGGLEPAUSE value
     */
    $root.RequestPause_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RP_PAUSE"] = 0;
        values[valuesById[1] = "RP_UNPAUSE"] = 1;
        values[valuesById[2] = "RP_TOGGLEPAUSE"] = 2;
        return values;
    })();
    
    /**
     * PrefetchType enum.
     * @exports PrefetchType
     * @enum {number}
     * @property {number} PFT_SOUND=0 PFT_SOUND value
     */
    $root.PrefetchType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PFT_SOUND"] = 0;
        return values;
    })();
    
    /**
     * ESplitScreenMessageType enum.
     * @exports ESplitScreenMessageType
     * @enum {number}
     * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value
     * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value
     */
    $root.ESplitScreenMessageType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MSG_SPLITSCREEN_ADDUSER"] = 0;
        values[valuesById[1] = "MSG_SPLITSCREEN_REMOVEUSER"] = 1;
        return values;
    })();
    
    /**
     * EQueryCvarValueStatus enum.
     * @exports EQueryCvarValueStatus
     * @enum {number}
     * @property {number} eQueryCvarValueStatus_ValueIntact=0 eQueryCvarValueStatus_ValueIntact value
     * @property {number} eQueryCvarValueStatus_CvarNotFound=1 eQueryCvarValueStatus_CvarNotFound value
     * @property {number} eQueryCvarValueStatus_NotACvar=2 eQueryCvarValueStatus_NotACvar value
     * @property {number} eQueryCvarValueStatus_CvarProtected=3 eQueryCvarValueStatus_CvarProtected value
     */
    $root.EQueryCvarValueStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "eQueryCvarValueStatus_ValueIntact"] = 0;
        values[valuesById[1] = "eQueryCvarValueStatus_CvarNotFound"] = 1;
        values[valuesById[2] = "eQueryCvarValueStatus_NotACvar"] = 2;
        values[valuesById[3] = "eQueryCvarValueStatus_CvarProtected"] = 3;
        return values;
    })();
    
    /**
     * DIALOG_TYPE enum.
     * @exports DIALOG_TYPE
     * @enum {number}
     * @property {number} DIALOG_MSG=0 DIALOG_MSG value
     * @property {number} DIALOG_MENU=1 DIALOG_MENU value
     * @property {number} DIALOG_TEXT=2 DIALOG_TEXT value
     * @property {number} DIALOG_ENTRY=3 DIALOG_ENTRY value
     * @property {number} DIALOG_ASKCONNECT=4 DIALOG_ASKCONNECT value
     */
    $root.DIALOG_TYPE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DIALOG_MSG"] = 0;
        values[valuesById[1] = "DIALOG_MENU"] = 1;
        values[valuesById[2] = "DIALOG_TEXT"] = 2;
        values[valuesById[3] = "DIALOG_ENTRY"] = 3;
        values[valuesById[4] = "DIALOG_ASKCONNECT"] = 4;
        return values;
    })();
    
    /**
     * SVC_Messages_LowFrequency enum.
     * @exports SVC_Messages_LowFrequency
     * @enum {number}
     * @property {number} svc_dummy=600 svc_dummy value
     */
    $root.SVC_Messages_LowFrequency = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[600] = "svc_dummy"] = 600;
        return values;
    })();
    
    /**
     * Bidirectional_Messages enum.
     * @exports Bidirectional_Messages
     * @enum {number}
     * @property {number} bi_RebroadcastGameEvent=16 bi_RebroadcastGameEvent value
     * @property {number} bi_RebroadcastSource=17 bi_RebroadcastSource value
     * @property {number} bi_GameEvent=18 bi_GameEvent value
     */
    $root.Bidirectional_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[16] = "bi_RebroadcastGameEvent"] = 16;
        values[valuesById[17] = "bi_RebroadcastSource"] = 17;
        values[valuesById[18] = "bi_GameEvent"] = 18;
        return values;
    })();
    
    /**
     * Bidirectional_Messages_LowFrequency enum.
     * @exports Bidirectional_Messages_LowFrequency
     * @enum {number}
     * @property {number} bi_RelayInfo=700 bi_RelayInfo value
     * @property {number} bi_RelayPacket=701 bi_RelayPacket value
     */
    $root.Bidirectional_Messages_LowFrequency = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[700] = "bi_RelayInfo"] = 700;
        values[valuesById[701] = "bi_RelayPacket"] = 701;
        return values;
    })();
    
    $root.CCLCMsg_ClientInfo = (function() {
    
        /**
         * Properties of a CCLCMsg_ClientInfo.
         * @exports ICCLCMsg_ClientInfo
         * @interface ICCLCMsg_ClientInfo
         * @property {number|null} [send_table_crc] CCLCMsg_ClientInfo send_table_crc
         * @property {number|null} [server_count] CCLCMsg_ClientInfo server_count
         * @property {boolean|null} [is_hltv] CCLCMsg_ClientInfo is_hltv
         * @property {number|null} [friends_id] CCLCMsg_ClientInfo friends_id
         * @property {string|null} [friends_name] CCLCMsg_ClientInfo friends_name
         */
    
        /**
         * Constructs a new CCLCMsg_ClientInfo.
         * @exports CCLCMsg_ClientInfo
         * @classdesc Represents a CCLCMsg_ClientInfo.
         * @implements ICCLCMsg_ClientInfo
         * @constructor
         * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
         */
        function CCLCMsg_ClientInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ClientInfo send_table_crc.
         * @member {number} send_table_crc
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.send_table_crc = 0;
    
        /**
         * CCLCMsg_ClientInfo server_count.
         * @member {number} server_count
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.server_count = 0;
    
        /**
         * CCLCMsg_ClientInfo is_hltv.
         * @member {boolean} is_hltv
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.is_hltv = false;
    
        /**
         * CCLCMsg_ClientInfo friends_id.
         * @member {number} friends_id
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.friends_id = 0;
    
        /**
         * CCLCMsg_ClientInfo friends_name.
         * @member {string} friends_name
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.friends_name = "";
    
        /**
         * Creates a new CCLCMsg_ClientInfo instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo instance
         */
        CCLCMsg_ClientInfo.create = function create(properties) {
            return new CCLCMsg_ClientInfo(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientInfo message. Does not implicitly {@link CCLCMsg_ClientInfo.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo} message CCLCMsg_ClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.send_table_crc != null && Object.hasOwnProperty.call(message, "send_table_crc"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.send_table_crc);
            if (message.server_count != null && Object.hasOwnProperty.call(message, "server_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.server_count);
            if (message.is_hltv != null && Object.hasOwnProperty.call(message, "is_hltv"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_hltv);
            if (message.friends_id != null && Object.hasOwnProperty.call(message, "friends_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.friends_id);
            if (message.friends_name != null && Object.hasOwnProperty.call(message, "friends_name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.friends_name);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientInfo message, length delimited. Does not implicitly {@link CCLCMsg_ClientInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo} message CCLCMsg_ClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.send_table_crc = reader.fixed32();
                    break;
                case 2:
                    message.server_count = reader.uint32();
                    break;
                case 3:
                    message.is_hltv = reader.bool();
                    break;
                case 5:
                    message.friends_id = reader.uint32();
                    break;
                case 6:
                    message.friends_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ClientInfo message.
         * @function verify
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ClientInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.send_table_crc != null && message.hasOwnProperty("send_table_crc"))
                if (!$util.isInteger(message.send_table_crc))
                    return "send_table_crc: integer expected";
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                if (!$util.isInteger(message.server_count))
                    return "server_count: integer expected";
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                if (typeof message.is_hltv !== "boolean")
                    return "is_hltv: boolean expected";
            if (message.friends_id != null && message.hasOwnProperty("friends_id"))
                if (!$util.isInteger(message.friends_id))
                    return "friends_id: integer expected";
            if (message.friends_name != null && message.hasOwnProperty("friends_name"))
                if (!$util.isString(message.friends_name))
                    return "friends_name: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ClientInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         */
        CCLCMsg_ClientInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ClientInfo)
                return object;
            var message = new $root.CCLCMsg_ClientInfo();
            if (object.send_table_crc != null)
                message.send_table_crc = object.send_table_crc >>> 0;
            if (object.server_count != null)
                message.server_count = object.server_count >>> 0;
            if (object.is_hltv != null)
                message.is_hltv = Boolean(object.is_hltv);
            if (object.friends_id != null)
                message.friends_id = object.friends_id >>> 0;
            if (object.friends_name != null)
                message.friends_name = String(object.friends_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ClientInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {CCLCMsg_ClientInfo} message CCLCMsg_ClientInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ClientInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.send_table_crc = 0;
                object.server_count = 0;
                object.is_hltv = false;
                object.friends_id = 0;
                object.friends_name = "";
            }
            if (message.send_table_crc != null && message.hasOwnProperty("send_table_crc"))
                object.send_table_crc = message.send_table_crc;
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                object.server_count = message.server_count;
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                object.is_hltv = message.is_hltv;
            if (message.friends_id != null && message.hasOwnProperty("friends_id"))
                object.friends_id = message.friends_id;
            if (message.friends_name != null && message.hasOwnProperty("friends_name"))
                object.friends_name = message.friends_name;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ClientInfo to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ClientInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ClientInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ClientInfo;
    })();
    
    $root.CCLCMsg_Move = (function() {
    
        /**
         * Properties of a CCLCMsg_Move.
         * @exports ICCLCMsg_Move
         * @interface ICCLCMsg_Move
         * @property {Uint8Array|null} [data] CCLCMsg_Move data
         * @property {number|null} [command_number] CCLCMsg_Move command_number
         * @property {number|null} [num_commands] CCLCMsg_Move num_commands
         */
    
        /**
         * Constructs a new CCLCMsg_Move.
         * @exports CCLCMsg_Move
         * @classdesc Represents a CCLCMsg_Move.
         * @implements ICCLCMsg_Move
         * @constructor
         * @param {ICCLCMsg_Move=} [properties] Properties to set
         */
        function CCLCMsg_Move(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_Move data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.data = $util.newBuffer([]);
    
        /**
         * CCLCMsg_Move command_number.
         * @member {number} command_number
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.command_number = 0;
    
        /**
         * CCLCMsg_Move num_commands.
         * @member {number} num_commands
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.num_commands = 0;
    
        /**
         * Creates a new CCLCMsg_Move instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move=} [properties] Properties to set
         * @returns {CCLCMsg_Move} CCLCMsg_Move instance
         */
        CCLCMsg_Move.create = function create(properties) {
            return new CCLCMsg_Move(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_Move message. Does not implicitly {@link CCLCMsg_Move.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move} message CCLCMsg_Move message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_Move.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            if (message.command_number != null && Object.hasOwnProperty.call(message, "command_number"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.command_number);
            if (message.num_commands != null && Object.hasOwnProperty.call(message, "num_commands"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.num_commands);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_Move message, length delimited. Does not implicitly {@link CCLCMsg_Move.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move} message CCLCMsg_Move message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_Move.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_Move message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_Move
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_Move.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.data = reader.bytes();
                    break;
                case 4:
                    message.command_number = reader.uint32();
                    break;
                case 5:
                    message.num_commands = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_Move message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_Move
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_Move.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_Move message.
         * @function verify
         * @memberof CCLCMsg_Move
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_Move.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.command_number != null && message.hasOwnProperty("command_number"))
                if (!$util.isInteger(message.command_number))
                    return "command_number: integer expected";
            if (message.num_commands != null && message.hasOwnProperty("num_commands"))
                if (!$util.isInteger(message.num_commands))
                    return "num_commands: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_Move message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_Move
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         */
        CCLCMsg_Move.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_Move)
                return object;
            var message = new $root.CCLCMsg_Move();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.command_number != null)
                message.command_number = object.command_number >>> 0;
            if (object.num_commands != null)
                message.num_commands = object.num_commands >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_Move message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_Move
         * @static
         * @param {CCLCMsg_Move} message CCLCMsg_Move
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_Move.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.command_number = 0;
                object.num_commands = 0;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.command_number != null && message.hasOwnProperty("command_number"))
                object.command_number = message.command_number;
            if (message.num_commands != null && message.hasOwnProperty("num_commands"))
                object.num_commands = message.num_commands;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_Move to JSON.
         * @function toJSON
         * @memberof CCLCMsg_Move
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_Move.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_Move;
    })();
    
    $root.CMsgVoiceAudio = (function() {
    
        /**
         * Properties of a CMsgVoiceAudio.
         * @exports ICMsgVoiceAudio
         * @interface ICMsgVoiceAudio
         * @property {VoiceDataFormat_t|null} [format] CMsgVoiceAudio format
         * @property {Uint8Array|null} [voice_data] CMsgVoiceAudio voice_data
         * @property {number|null} [sequence_bytes] CMsgVoiceAudio sequence_bytes
         * @property {number|null} [section_number] CMsgVoiceAudio section_number
         * @property {number|null} [sample_rate] CMsgVoiceAudio sample_rate
         * @property {number|null} [uncompressed_sample_offset] CMsgVoiceAudio uncompressed_sample_offset
         */
    
        /**
         * Constructs a new CMsgVoiceAudio.
         * @exports CMsgVoiceAudio
         * @classdesc Represents a CMsgVoiceAudio.
         * @implements ICMsgVoiceAudio
         * @constructor
         * @param {ICMsgVoiceAudio=} [properties] Properties to set
         */
        function CMsgVoiceAudio(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVoiceAudio format.
         * @member {VoiceDataFormat_t} format
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.format = 0;
    
        /**
         * CMsgVoiceAudio voice_data.
         * @member {Uint8Array} voice_data
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.voice_data = $util.newBuffer([]);
    
        /**
         * CMsgVoiceAudio sequence_bytes.
         * @member {number} sequence_bytes
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.sequence_bytes = 0;
    
        /**
         * CMsgVoiceAudio section_number.
         * @member {number} section_number
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.section_number = 0;
    
        /**
         * CMsgVoiceAudio sample_rate.
         * @member {number} sample_rate
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.sample_rate = 0;
    
        /**
         * CMsgVoiceAudio uncompressed_sample_offset.
         * @member {number} uncompressed_sample_offset
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.uncompressed_sample_offset = 0;
    
        /**
         * Creates a new CMsgVoiceAudio instance using the specified properties.
         * @function create
         * @memberof CMsgVoiceAudio
         * @static
         * @param {ICMsgVoiceAudio=} [properties] Properties to set
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio instance
         */
        CMsgVoiceAudio.create = function create(properties) {
            return new CMsgVoiceAudio(properties);
        };
    
        /**
         * Encodes the specified CMsgVoiceAudio message. Does not implicitly {@link CMsgVoiceAudio.verify|verify} messages.
         * @function encode
         * @memberof CMsgVoiceAudio
         * @static
         * @param {ICMsgVoiceAudio} message CMsgVoiceAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVoiceAudio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.format);
            if (message.voice_data != null && Object.hasOwnProperty.call(message, "voice_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.voice_data);
            if (message.sequence_bytes != null && Object.hasOwnProperty.call(message, "sequence_bytes"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sequence_bytes);
            if (message.section_number != null && Object.hasOwnProperty.call(message, "section_number"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.section_number);
            if (message.sample_rate != null && Object.hasOwnProperty.call(message, "sample_rate"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sample_rate);
            if (message.uncompressed_sample_offset != null && Object.hasOwnProperty.call(message, "uncompressed_sample_offset"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uncompressed_sample_offset);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVoiceAudio message, length delimited. Does not implicitly {@link CMsgVoiceAudio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVoiceAudio
         * @static
         * @param {ICMsgVoiceAudio} message CMsgVoiceAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVoiceAudio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVoiceAudio message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVoiceAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVoiceAudio.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVoiceAudio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.format = reader.int32();
                    break;
                case 2:
                    message.voice_data = reader.bytes();
                    break;
                case 3:
                    message.sequence_bytes = reader.int32();
                    break;
                case 4:
                    message.section_number = reader.uint32();
                    break;
                case 5:
                    message.sample_rate = reader.uint32();
                    break;
                case 6:
                    message.uncompressed_sample_offset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVoiceAudio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVoiceAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVoiceAudio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVoiceAudio message.
         * @function verify
         * @memberof CMsgVoiceAudio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVoiceAudio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.voice_data != null && message.hasOwnProperty("voice_data"))
                if (!(message.voice_data && typeof message.voice_data.length === "number" || $util.isString(message.voice_data)))
                    return "voice_data: buffer expected";
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                if (!$util.isInteger(message.sequence_bytes))
                    return "sequence_bytes: integer expected";
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                if (!$util.isInteger(message.section_number))
                    return "section_number: integer expected";
            if (message.sample_rate != null && message.hasOwnProperty("sample_rate"))
                if (!$util.isInteger(message.sample_rate))
                    return "sample_rate: integer expected";
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                if (!$util.isInteger(message.uncompressed_sample_offset))
                    return "uncompressed_sample_offset: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgVoiceAudio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVoiceAudio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio
         */
        CMsgVoiceAudio.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVoiceAudio)
                return object;
            var message = new $root.CMsgVoiceAudio();
            switch (object.format) {
            case "VOICEDATA_FORMAT_STEAM":
            case 0:
                message.format = 0;
                break;
            case "VOICEDATA_FORMAT_ENGINE":
            case 1:
                message.format = 1;
                break;
            }
            if (object.voice_data != null)
                if (typeof object.voice_data === "string")
                    $util.base64.decode(object.voice_data, message.voice_data = $util.newBuffer($util.base64.length(object.voice_data)), 0);
                else if (object.voice_data.length)
                    message.voice_data = object.voice_data;
            if (object.sequence_bytes != null)
                message.sequence_bytes = object.sequence_bytes | 0;
            if (object.section_number != null)
                message.section_number = object.section_number >>> 0;
            if (object.sample_rate != null)
                message.sample_rate = object.sample_rate >>> 0;
            if (object.uncompressed_sample_offset != null)
                message.uncompressed_sample_offset = object.uncompressed_sample_offset >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVoiceAudio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVoiceAudio
         * @static
         * @param {CMsgVoiceAudio} message CMsgVoiceAudio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVoiceAudio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.format = options.enums === String ? "VOICEDATA_FORMAT_STEAM" : 0;
                if (options.bytes === String)
                    object.voice_data = "";
                else {
                    object.voice_data = [];
                    if (options.bytes !== Array)
                        object.voice_data = $util.newBuffer(object.voice_data);
                }
                object.sequence_bytes = 0;
                object.section_number = 0;
                object.sample_rate = 0;
                object.uncompressed_sample_offset = 0;
            }
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.VoiceDataFormat_t[message.format] : message.format;
            if (message.voice_data != null && message.hasOwnProperty("voice_data"))
                object.voice_data = options.bytes === String ? $util.base64.encode(message.voice_data, 0, message.voice_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.voice_data) : message.voice_data;
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                object.sequence_bytes = message.sequence_bytes;
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                object.section_number = message.section_number;
            if (message.sample_rate != null && message.hasOwnProperty("sample_rate"))
                object.sample_rate = message.sample_rate;
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                object.uncompressed_sample_offset = message.uncompressed_sample_offset;
            return object;
        };
    
        /**
         * Converts this CMsgVoiceAudio to JSON.
         * @function toJSON
         * @memberof CMsgVoiceAudio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVoiceAudio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVoiceAudio;
    })();
    
    $root.CCLCMsg_VoiceData = (function() {
    
        /**
         * Properties of a CCLCMsg_VoiceData.
         * @exports ICCLCMsg_VoiceData
         * @interface ICCLCMsg_VoiceData
         * @property {ICMsgVoiceAudio|null} [audio] CCLCMsg_VoiceData audio
         * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid
         * @property {number|null} [tick] CCLCMsg_VoiceData tick
         */
    
        /**
         * Constructs a new CCLCMsg_VoiceData.
         * @exports CCLCMsg_VoiceData
         * @classdesc Represents a CCLCMsg_VoiceData.
         * @implements ICCLCMsg_VoiceData
         * @constructor
         * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
         */
        function CCLCMsg_VoiceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_VoiceData audio.
         * @member {ICMsgVoiceAudio|null|undefined} audio
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.audio = null;
    
        /**
         * CCLCMsg_VoiceData xuid.
         * @member {number|Long} xuid
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CCLCMsg_VoiceData tick.
         * @member {number} tick
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.tick = 0;
    
        /**
         * Creates a new CCLCMsg_VoiceData instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData instance
         */
        CCLCMsg_VoiceData.create = function create(properties) {
            return new CCLCMsg_VoiceData(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_VoiceData message. Does not implicitly {@link CCLCMsg_VoiceData.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData} message CCLCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_VoiceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.CMsgVoiceAudio.encode(message.audio, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tick);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_VoiceData message, length delimited. Does not implicitly {@link CCLCMsg_VoiceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData} message CCLCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_VoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio = $root.CMsgVoiceAudio.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.tick = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_VoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_VoiceData message.
         * @function verify
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_VoiceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio != null && message.hasOwnProperty("audio")) {
                var error = $root.CMsgVoiceAudio.verify(message.audio);
                if (error)
                    return "audio." + error;
            }
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_VoiceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         */
        CCLCMsg_VoiceData.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_VoiceData)
                return object;
            var message = new $root.CCLCMsg_VoiceData();
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".CCLCMsg_VoiceData.audio: object expected");
                message.audio = $root.CMsgVoiceAudio.fromObject(object.audio);
            }
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_VoiceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {CCLCMsg_VoiceData} message CCLCMsg_VoiceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_VoiceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.tick = 0;
            }
            if (message.audio != null && message.hasOwnProperty("audio"))
                object.audio = $root.CMsgVoiceAudio.toObject(message.audio, options);
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_VoiceData to JSON.
         * @function toJSON
         * @memberof CCLCMsg_VoiceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_VoiceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_VoiceData;
    })();
    
    $root.CCLCMsg_BaselineAck = (function() {
    
        /**
         * Properties of a CCLCMsg_BaselineAck.
         * @exports ICCLCMsg_BaselineAck
         * @interface ICCLCMsg_BaselineAck
         * @property {number|null} [baseline_tick] CCLCMsg_BaselineAck baseline_tick
         * @property {number|null} [baseline_nr] CCLCMsg_BaselineAck baseline_nr
         */
    
        /**
         * Constructs a new CCLCMsg_BaselineAck.
         * @exports CCLCMsg_BaselineAck
         * @classdesc Represents a CCLCMsg_BaselineAck.
         * @implements ICCLCMsg_BaselineAck
         * @constructor
         * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
         */
        function CCLCMsg_BaselineAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_BaselineAck baseline_tick.
         * @member {number} baseline_tick
         * @memberof CCLCMsg_BaselineAck
         * @instance
         */
        CCLCMsg_BaselineAck.prototype.baseline_tick = 0;
    
        /**
         * CCLCMsg_BaselineAck baseline_nr.
         * @member {number} baseline_nr
         * @memberof CCLCMsg_BaselineAck
         * @instance
         */
        CCLCMsg_BaselineAck.prototype.baseline_nr = 0;
    
        /**
         * Creates a new CCLCMsg_BaselineAck instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck instance
         */
        CCLCMsg_BaselineAck.create = function create(properties) {
            return new CCLCMsg_BaselineAck(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_BaselineAck message. Does not implicitly {@link CCLCMsg_BaselineAck.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck} message CCLCMsg_BaselineAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_BaselineAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.baseline_tick != null && Object.hasOwnProperty.call(message, "baseline_tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.baseline_tick);
            if (message.baseline_nr != null && Object.hasOwnProperty.call(message, "baseline_nr"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.baseline_nr);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_BaselineAck message, length delimited. Does not implicitly {@link CCLCMsg_BaselineAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck} message CCLCMsg_BaselineAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_BaselineAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_BaselineAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.baseline_tick = reader.int32();
                    break;
                case 2:
                    message.baseline_nr = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_BaselineAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_BaselineAck message.
         * @function verify
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_BaselineAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.baseline_tick != null && message.hasOwnProperty("baseline_tick"))
                if (!$util.isInteger(message.baseline_tick))
                    return "baseline_tick: integer expected";
            if (message.baseline_nr != null && message.hasOwnProperty("baseline_nr"))
                if (!$util.isInteger(message.baseline_nr))
                    return "baseline_nr: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_BaselineAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         */
        CCLCMsg_BaselineAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_BaselineAck)
                return object;
            var message = new $root.CCLCMsg_BaselineAck();
            if (object.baseline_tick != null)
                message.baseline_tick = object.baseline_tick | 0;
            if (object.baseline_nr != null)
                message.baseline_nr = object.baseline_nr | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_BaselineAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {CCLCMsg_BaselineAck} message CCLCMsg_BaselineAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_BaselineAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.baseline_tick = 0;
                object.baseline_nr = 0;
            }
            if (message.baseline_tick != null && message.hasOwnProperty("baseline_tick"))
                object.baseline_tick = message.baseline_tick;
            if (message.baseline_nr != null && message.hasOwnProperty("baseline_nr"))
                object.baseline_nr = message.baseline_nr;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_BaselineAck to JSON.
         * @function toJSON
         * @memberof CCLCMsg_BaselineAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_BaselineAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_BaselineAck;
    })();
    
    $root.CCLCMsg_ListenEvents = (function() {
    
        /**
         * Properties of a CCLCMsg_ListenEvents.
         * @exports ICCLCMsg_ListenEvents
         * @interface ICCLCMsg_ListenEvents
         * @property {Array.<number>|null} [event_mask] CCLCMsg_ListenEvents event_mask
         */
    
        /**
         * Constructs a new CCLCMsg_ListenEvents.
         * @exports CCLCMsg_ListenEvents
         * @classdesc Represents a CCLCMsg_ListenEvents.
         * @implements ICCLCMsg_ListenEvents
         * @constructor
         * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
         */
        function CCLCMsg_ListenEvents(properties) {
            this.event_mask = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ListenEvents event_mask.
         * @member {Array.<number>} event_mask
         * @memberof CCLCMsg_ListenEvents
         * @instance
         */
        CCLCMsg_ListenEvents.prototype.event_mask = $util.emptyArray;
    
        /**
         * Creates a new CCLCMsg_ListenEvents instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents instance
         */
        CCLCMsg_ListenEvents.create = function create(properties) {
            return new CCLCMsg_ListenEvents(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ListenEvents message. Does not implicitly {@link CCLCMsg_ListenEvents.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents} message CCLCMsg_ListenEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ListenEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_mask != null && message.event_mask.length)
                for (var i = 0; i < message.event_mask.length; ++i)
                    writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.event_mask[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ListenEvents message, length delimited. Does not implicitly {@link CCLCMsg_ListenEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents} message CCLCMsg_ListenEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ListenEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ListenEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.event_mask && message.event_mask.length))
                        message.event_mask = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.event_mask.push(reader.fixed32());
                    } else
                        message.event_mask.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ListenEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ListenEvents message.
         * @function verify
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ListenEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_mask != null && message.hasOwnProperty("event_mask")) {
                if (!Array.isArray(message.event_mask))
                    return "event_mask: array expected";
                for (var i = 0; i < message.event_mask.length; ++i)
                    if (!$util.isInteger(message.event_mask[i]))
                        return "event_mask: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ListenEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         */
        CCLCMsg_ListenEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ListenEvents)
                return object;
            var message = new $root.CCLCMsg_ListenEvents();
            if (object.event_mask) {
                if (!Array.isArray(object.event_mask))
                    throw TypeError(".CCLCMsg_ListenEvents.event_mask: array expected");
                message.event_mask = [];
                for (var i = 0; i < object.event_mask.length; ++i)
                    message.event_mask[i] = object.event_mask[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ListenEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {CCLCMsg_ListenEvents} message CCLCMsg_ListenEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ListenEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.event_mask = [];
            if (message.event_mask && message.event_mask.length) {
                object.event_mask = [];
                for (var j = 0; j < message.event_mask.length; ++j)
                    object.event_mask[j] = message.event_mask[j];
            }
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ListenEvents to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ListenEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ListenEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ListenEvents;
    })();
    
    $root.CCLCMsg_RespondCvarValue = (function() {
    
        /**
         * Properties of a CCLCMsg_RespondCvarValue.
         * @exports ICCLCMsg_RespondCvarValue
         * @interface ICCLCMsg_RespondCvarValue
         * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie
         * @property {number|null} [status_code] CCLCMsg_RespondCvarValue status_code
         * @property {string|null} [name] CCLCMsg_RespondCvarValue name
         * @property {string|null} [value] CCLCMsg_RespondCvarValue value
         */
    
        /**
         * Constructs a new CCLCMsg_RespondCvarValue.
         * @exports CCLCMsg_RespondCvarValue
         * @classdesc Represents a CCLCMsg_RespondCvarValue.
         * @implements ICCLCMsg_RespondCvarValue
         * @constructor
         * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
         */
        function CCLCMsg_RespondCvarValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_RespondCvarValue cookie.
         * @member {number} cookie
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.cookie = 0;
    
        /**
         * CCLCMsg_RespondCvarValue status_code.
         * @member {number} status_code
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.status_code = 0;
    
        /**
         * CCLCMsg_RespondCvarValue name.
         * @member {string} name
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.name = "";
    
        /**
         * CCLCMsg_RespondCvarValue value.
         * @member {string} value
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.value = "";
    
        /**
         * Creates a new CCLCMsg_RespondCvarValue instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue instance
         */
        CCLCMsg_RespondCvarValue.create = function create(properties) {
            return new CCLCMsg_RespondCvarValue(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_RespondCvarValue message. Does not implicitly {@link CCLCMsg_RespondCvarValue.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RespondCvarValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cookie);
            if (message.status_code != null && Object.hasOwnProperty.call(message, "status_code"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status_code);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_RespondCvarValue message, length delimited. Does not implicitly {@link CCLCMsg_RespondCvarValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RespondCvarValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.status_code = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RespondCvarValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_RespondCvarValue message.
         * @function verify
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_RespondCvarValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                if (!$util.isInteger(message.cookie))
                    return "cookie: integer expected";
            if (message.status_code != null && message.hasOwnProperty("status_code"))
                if (!$util.isInteger(message.status_code))
                    return "status_code: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_RespondCvarValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         */
        CCLCMsg_RespondCvarValue.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_RespondCvarValue)
                return object;
            var message = new $root.CCLCMsg_RespondCvarValue();
            if (object.cookie != null)
                message.cookie = object.cookie | 0;
            if (object.status_code != null)
                message.status_code = object.status_code | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_RespondCvarValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {CCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_RespondCvarValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cookie = 0;
                object.status_code = 0;
                object.name = "";
                object.value = "";
            }
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                object.cookie = message.cookie;
            if (message.status_code != null && message.hasOwnProperty("status_code"))
                object.status_code = message.status_code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_RespondCvarValue to JSON.
         * @function toJSON
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_RespondCvarValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_RespondCvarValue;
    })();
    
    $root.CCLCMsg_FileCRCCheck = (function() {
    
        /**
         * Properties of a CCLCMsg_FileCRCCheck.
         * @exports ICCLCMsg_FileCRCCheck
         * @interface ICCLCMsg_FileCRCCheck
         * @property {number|null} [code_path] CCLCMsg_FileCRCCheck code_path
         * @property {string|null} [path] CCLCMsg_FileCRCCheck path
         * @property {number|null} [code_filename] CCLCMsg_FileCRCCheck code_filename
         * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename
         * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc
         */
    
        /**
         * Constructs a new CCLCMsg_FileCRCCheck.
         * @exports CCLCMsg_FileCRCCheck
         * @classdesc Represents a CCLCMsg_FileCRCCheck.
         * @implements ICCLCMsg_FileCRCCheck
         * @constructor
         * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
         */
        function CCLCMsg_FileCRCCheck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_FileCRCCheck code_path.
         * @member {number} code_path
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.code_path = 0;
    
        /**
         * CCLCMsg_FileCRCCheck path.
         * @member {string} path
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.path = "";
    
        /**
         * CCLCMsg_FileCRCCheck code_filename.
         * @member {number} code_filename
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.code_filename = 0;
    
        /**
         * CCLCMsg_FileCRCCheck filename.
         * @member {string} filename
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.filename = "";
    
        /**
         * CCLCMsg_FileCRCCheck crc.
         * @member {number} crc
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.crc = 0;
    
        /**
         * Creates a new CCLCMsg_FileCRCCheck instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck instance
         */
        CCLCMsg_FileCRCCheck.create = function create(properties) {
            return new CCLCMsg_FileCRCCheck(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_FileCRCCheck message. Does not implicitly {@link CCLCMsg_FileCRCCheck.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_FileCRCCheck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code_path != null && Object.hasOwnProperty.call(message, "code_path"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code_path);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.code_filename != null && Object.hasOwnProperty.call(message, "code_filename"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code_filename);
            if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.filename);
            if (message.crc != null && Object.hasOwnProperty.call(message, "crc"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.crc);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_FileCRCCheck message, length delimited. Does not implicitly {@link CCLCMsg_FileCRCCheck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_FileCRCCheck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code_path = reader.int32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.code_filename = reader.int32();
                    break;
                case 4:
                    message.filename = reader.string();
                    break;
                case 5:
                    message.crc = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_FileCRCCheck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_FileCRCCheck message.
         * @function verify
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_FileCRCCheck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code_path != null && message.hasOwnProperty("code_path"))
                if (!$util.isInteger(message.code_path))
                    return "code_path: integer expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.code_filename != null && message.hasOwnProperty("code_filename"))
                if (!$util.isInteger(message.code_filename))
                    return "code_filename: integer expected";
            if (message.filename != null && message.hasOwnProperty("filename"))
                if (!$util.isString(message.filename))
                    return "filename: string expected";
            if (message.crc != null && message.hasOwnProperty("crc"))
                if (!$util.isInteger(message.crc))
                    return "crc: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_FileCRCCheck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         */
        CCLCMsg_FileCRCCheck.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_FileCRCCheck)
                return object;
            var message = new $root.CCLCMsg_FileCRCCheck();
            if (object.code_path != null)
                message.code_path = object.code_path | 0;
            if (object.path != null)
                message.path = String(object.path);
            if (object.code_filename != null)
                message.code_filename = object.code_filename | 0;
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.crc != null)
                message.crc = object.crc >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_FileCRCCheck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {CCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_FileCRCCheck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code_path = 0;
                object.path = "";
                object.code_filename = 0;
                object.filename = "";
                object.crc = 0;
            }
            if (message.code_path != null && message.hasOwnProperty("code_path"))
                object.code_path = message.code_path;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.code_filename != null && message.hasOwnProperty("code_filename"))
                object.code_filename = message.code_filename;
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.crc != null && message.hasOwnProperty("crc"))
                object.crc = message.crc;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_FileCRCCheck to JSON.
         * @function toJSON
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_FileCRCCheck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_FileCRCCheck;
    })();
    
    $root.CCLCMsg_LoadingProgress = (function() {
    
        /**
         * Properties of a CCLCMsg_LoadingProgress.
         * @exports ICCLCMsg_LoadingProgress
         * @interface ICCLCMsg_LoadingProgress
         * @property {number|null} [progress] CCLCMsg_LoadingProgress progress
         */
    
        /**
         * Constructs a new CCLCMsg_LoadingProgress.
         * @exports CCLCMsg_LoadingProgress
         * @classdesc Represents a CCLCMsg_LoadingProgress.
         * @implements ICCLCMsg_LoadingProgress
         * @constructor
         * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
         */
        function CCLCMsg_LoadingProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_LoadingProgress progress.
         * @member {number} progress
         * @memberof CCLCMsg_LoadingProgress
         * @instance
         */
        CCLCMsg_LoadingProgress.prototype.progress = 0;
    
        /**
         * Creates a new CCLCMsg_LoadingProgress instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress instance
         */
        CCLCMsg_LoadingProgress.create = function create(properties) {
            return new CCLCMsg_LoadingProgress(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_LoadingProgress message. Does not implicitly {@link CCLCMsg_LoadingProgress.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_LoadingProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.progress);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_LoadingProgress message, length delimited. Does not implicitly {@link CCLCMsg_LoadingProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_LoadingProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_LoadingProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.progress = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_LoadingProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_LoadingProgress message.
         * @function verify
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_LoadingProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_LoadingProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         */
        CCLCMsg_LoadingProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_LoadingProgress)
                return object;
            var message = new $root.CCLCMsg_LoadingProgress();
            if (object.progress != null)
                message.progress = object.progress | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_LoadingProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {CCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_LoadingProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.progress = 0;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_LoadingProgress to JSON.
         * @function toJSON
         * @memberof CCLCMsg_LoadingProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_LoadingProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_LoadingProgress;
    })();
    
    $root.CCLCMsg_SplitPlayerConnect = (function() {
    
        /**
         * Properties of a CCLCMsg_SplitPlayerConnect.
         * @exports ICCLCMsg_SplitPlayerConnect
         * @interface ICCLCMsg_SplitPlayerConnect
         * @property {string|null} [playername] CCLCMsg_SplitPlayerConnect playername
         */
    
        /**
         * Constructs a new CCLCMsg_SplitPlayerConnect.
         * @exports CCLCMsg_SplitPlayerConnect
         * @classdesc Represents a CCLCMsg_SplitPlayerConnect.
         * @implements ICCLCMsg_SplitPlayerConnect
         * @constructor
         * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
         */
        function CCLCMsg_SplitPlayerConnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_SplitPlayerConnect playername.
         * @member {string} playername
         * @memberof CCLCMsg_SplitPlayerConnect
         * @instance
         */
        CCLCMsg_SplitPlayerConnect.prototype.playername = "";
    
        /**
         * Creates a new CCLCMsg_SplitPlayerConnect instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect instance
         */
        CCLCMsg_SplitPlayerConnect.create = function create(properties) {
            return new CCLCMsg_SplitPlayerConnect(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerConnect message. Does not implicitly {@link CCLCMsg_SplitPlayerConnect.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playername != null && Object.hasOwnProperty.call(message, "playername"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playername);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerConnect message, length delimited. Does not implicitly {@link CCLCMsg_SplitPlayerConnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerConnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playername = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerConnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_SplitPlayerConnect message.
         * @function verify
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_SplitPlayerConnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playername != null && message.hasOwnProperty("playername"))
                if (!$util.isString(message.playername))
                    return "playername: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_SplitPlayerConnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         */
        CCLCMsg_SplitPlayerConnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_SplitPlayerConnect)
                return object;
            var message = new $root.CCLCMsg_SplitPlayerConnect();
            if (object.playername != null)
                message.playername = String(object.playername);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_SplitPlayerConnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {CCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_SplitPlayerConnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playername = "";
            if (message.playername != null && message.hasOwnProperty("playername"))
                object.playername = message.playername;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_SplitPlayerConnect to JSON.
         * @function toJSON
         * @memberof CCLCMsg_SplitPlayerConnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_SplitPlayerConnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_SplitPlayerConnect;
    })();
    
    $root.CCLCMsg_ClientMessage = (function() {
    
        /**
         * Properties of a CCLCMsg_ClientMessage.
         * @exports ICCLCMsg_ClientMessage
         * @interface ICCLCMsg_ClientMessage
         * @property {number|null} [msg_type] CCLCMsg_ClientMessage msg_type
         * @property {Uint8Array|null} [data] CCLCMsg_ClientMessage data
         */
    
        /**
         * Constructs a new CCLCMsg_ClientMessage.
         * @exports CCLCMsg_ClientMessage
         * @classdesc Represents a CCLCMsg_ClientMessage.
         * @implements ICCLCMsg_ClientMessage
         * @constructor
         * @param {ICCLCMsg_ClientMessage=} [properties] Properties to set
         */
        function CCLCMsg_ClientMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ClientMessage msg_type.
         * @member {number} msg_type
         * @memberof CCLCMsg_ClientMessage
         * @instance
         */
        CCLCMsg_ClientMessage.prototype.msg_type = 0;
    
        /**
         * CCLCMsg_ClientMessage data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_ClientMessage
         * @instance
         */
        CCLCMsg_ClientMessage.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_ClientMessage instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {ICCLCMsg_ClientMessage=} [properties] Properties to set
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage instance
         */
        CCLCMsg_ClientMessage.create = function create(properties) {
            return new CCLCMsg_ClientMessage(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientMessage message. Does not implicitly {@link CCLCMsg_ClientMessage.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {ICCLCMsg_ClientMessage} message CCLCMsg_ClientMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientMessage message, length delimited. Does not implicitly {@link CCLCMsg_ClientMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {ICCLCMsg_ClientMessage} message CCLCMsg_ClientMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ClientMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ClientMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ClientMessage message.
         * @function verify
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ClientMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ClientMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage
         */
        CCLCMsg_ClientMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ClientMessage)
                return object;
            var message = new $root.CCLCMsg_ClientMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ClientMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {CCLCMsg_ClientMessage} message CCLCMsg_ClientMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ClientMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ClientMessage to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ClientMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ClientMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ClientMessage;
    })();
    
    $root.CCLCMsg_SplitPlayerDisconnect = (function() {
    
        /**
         * Properties of a CCLCMsg_SplitPlayerDisconnect.
         * @exports ICCLCMsg_SplitPlayerDisconnect
         * @interface ICCLCMsg_SplitPlayerDisconnect
         * @property {number|null} [slot] CCLCMsg_SplitPlayerDisconnect slot
         */
    
        /**
         * Constructs a new CCLCMsg_SplitPlayerDisconnect.
         * @exports CCLCMsg_SplitPlayerDisconnect
         * @classdesc Represents a CCLCMsg_SplitPlayerDisconnect.
         * @implements ICCLCMsg_SplitPlayerDisconnect
         * @constructor
         * @param {ICCLCMsg_SplitPlayerDisconnect=} [properties] Properties to set
         */
        function CCLCMsg_SplitPlayerDisconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_SplitPlayerDisconnect slot.
         * @member {number} slot
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @instance
         */
        CCLCMsg_SplitPlayerDisconnect.prototype.slot = 0;
    
        /**
         * Creates a new CCLCMsg_SplitPlayerDisconnect instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {ICCLCMsg_SplitPlayerDisconnect=} [properties] Properties to set
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect instance
         */
        CCLCMsg_SplitPlayerDisconnect.create = function create(properties) {
            return new CCLCMsg_SplitPlayerDisconnect(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerDisconnect message. Does not implicitly {@link CCLCMsg_SplitPlayerDisconnect.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {ICCLCMsg_SplitPlayerDisconnect} message CCLCMsg_SplitPlayerDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerDisconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerDisconnect message, length delimited. Does not implicitly {@link CCLCMsg_SplitPlayerDisconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {ICCLCMsg_SplitPlayerDisconnect} message CCLCMsg_SplitPlayerDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerDisconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerDisconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerDisconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerDisconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerDisconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerDisconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_SplitPlayerDisconnect message.
         * @function verify
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_SplitPlayerDisconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_SplitPlayerDisconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect
         */
        CCLCMsg_SplitPlayerDisconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_SplitPlayerDisconnect)
                return object;
            var message = new $root.CCLCMsg_SplitPlayerDisconnect();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_SplitPlayerDisconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {CCLCMsg_SplitPlayerDisconnect} message CCLCMsg_SplitPlayerDisconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_SplitPlayerDisconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_SplitPlayerDisconnect to JSON.
         * @function toJSON
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_SplitPlayerDisconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_SplitPlayerDisconnect;
    })();
    
    $root.CCLCMsg_ServerStatus = (function() {
    
        /**
         * Properties of a CCLCMsg_ServerStatus.
         * @exports ICCLCMsg_ServerStatus
         * @interface ICCLCMsg_ServerStatus
         * @property {boolean|null} [simplified] CCLCMsg_ServerStatus simplified
         */
    
        /**
         * Constructs a new CCLCMsg_ServerStatus.
         * @exports CCLCMsg_ServerStatus
         * @classdesc Represents a CCLCMsg_ServerStatus.
         * @implements ICCLCMsg_ServerStatus
         * @constructor
         * @param {ICCLCMsg_ServerStatus=} [properties] Properties to set
         */
        function CCLCMsg_ServerStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ServerStatus simplified.
         * @member {boolean} simplified
         * @memberof CCLCMsg_ServerStatus
         * @instance
         */
        CCLCMsg_ServerStatus.prototype.simplified = false;
    
        /**
         * Creates a new CCLCMsg_ServerStatus instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {ICCLCMsg_ServerStatus=} [properties] Properties to set
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus instance
         */
        CCLCMsg_ServerStatus.create = function create(properties) {
            return new CCLCMsg_ServerStatus(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ServerStatus message. Does not implicitly {@link CCLCMsg_ServerStatus.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {ICCLCMsg_ServerStatus} message CCLCMsg_ServerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ServerStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.simplified != null && Object.hasOwnProperty.call(message, "simplified"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.simplified);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ServerStatus message, length delimited. Does not implicitly {@link CCLCMsg_ServerStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {ICCLCMsg_ServerStatus} message CCLCMsg_ServerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ServerStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ServerStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ServerStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ServerStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.simplified = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ServerStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ServerStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ServerStatus message.
         * @function verify
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ServerStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.simplified != null && message.hasOwnProperty("simplified"))
                if (typeof message.simplified !== "boolean")
                    return "simplified: boolean expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ServerStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus
         */
        CCLCMsg_ServerStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ServerStatus)
                return object;
            var message = new $root.CCLCMsg_ServerStatus();
            if (object.simplified != null)
                message.simplified = Boolean(object.simplified);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ServerStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {CCLCMsg_ServerStatus} message CCLCMsg_ServerStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ServerStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.simplified = false;
            if (message.simplified != null && message.hasOwnProperty("simplified"))
                object.simplified = message.simplified;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ServerStatus to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ServerStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ServerStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ServerStatus;
    })();
    
    $root.CCLCMsg_ServerPing = (function() {
    
        /**
         * Properties of a CCLCMsg_ServerPing.
         * @exports ICCLCMsg_ServerPing
         * @interface ICCLCMsg_ServerPing
         */
    
        /**
         * Constructs a new CCLCMsg_ServerPing.
         * @exports CCLCMsg_ServerPing
         * @classdesc Represents a CCLCMsg_ServerPing.
         * @implements ICCLCMsg_ServerPing
         * @constructor
         * @param {ICCLCMsg_ServerPing=} [properties] Properties to set
         */
        function CCLCMsg_ServerPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CCLCMsg_ServerPing instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {ICCLCMsg_ServerPing=} [properties] Properties to set
         * @returns {CCLCMsg_ServerPing} CCLCMsg_ServerPing instance
         */
        CCLCMsg_ServerPing.create = function create(properties) {
            return new CCLCMsg_ServerPing(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ServerPing message. Does not implicitly {@link CCLCMsg_ServerPing.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {ICCLCMsg_ServerPing} message CCLCMsg_ServerPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ServerPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ServerPing message, length delimited. Does not implicitly {@link CCLCMsg_ServerPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {ICCLCMsg_ServerPing} message CCLCMsg_ServerPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ServerPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ServerPing message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ServerPing} CCLCMsg_ServerPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ServerPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ServerPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ServerPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ServerPing} CCLCMsg_ServerPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ServerPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ServerPing message.
         * @function verify
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ServerPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ServerPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ServerPing} CCLCMsg_ServerPing
         */
        CCLCMsg_ServerPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ServerPing)
                return object;
            return new $root.CCLCMsg_ServerPing();
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ServerPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ServerPing
         * @static
         * @param {CCLCMsg_ServerPing} message CCLCMsg_ServerPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ServerPing.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CCLCMsg_ServerPing to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ServerPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ServerPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ServerPing;
    })();
    
    $root.CCLCMsg_RequestPause = (function() {
    
        /**
         * Properties of a CCLCMsg_RequestPause.
         * @exports ICCLCMsg_RequestPause
         * @interface ICCLCMsg_RequestPause
         * @property {RequestPause_t|null} [pause_type] CCLCMsg_RequestPause pause_type
         * @property {number|null} [pause_group] CCLCMsg_RequestPause pause_group
         */
    
        /**
         * Constructs a new CCLCMsg_RequestPause.
         * @exports CCLCMsg_RequestPause
         * @classdesc Represents a CCLCMsg_RequestPause.
         * @implements ICCLCMsg_RequestPause
         * @constructor
         * @param {ICCLCMsg_RequestPause=} [properties] Properties to set
         */
        function CCLCMsg_RequestPause(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_RequestPause pause_type.
         * @member {RequestPause_t} pause_type
         * @memberof CCLCMsg_RequestPause
         * @instance
         */
        CCLCMsg_RequestPause.prototype.pause_type = 0;
    
        /**
         * CCLCMsg_RequestPause pause_group.
         * @member {number} pause_group
         * @memberof CCLCMsg_RequestPause
         * @instance
         */
        CCLCMsg_RequestPause.prototype.pause_group = 0;
    
        /**
         * Creates a new CCLCMsg_RequestPause instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {ICCLCMsg_RequestPause=} [properties] Properties to set
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause instance
         */
        CCLCMsg_RequestPause.create = function create(properties) {
            return new CCLCMsg_RequestPause(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_RequestPause message. Does not implicitly {@link CCLCMsg_RequestPause.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {ICCLCMsg_RequestPause} message CCLCMsg_RequestPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RequestPause.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pause_type != null && Object.hasOwnProperty.call(message, "pause_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pause_type);
            if (message.pause_group != null && Object.hasOwnProperty.call(message, "pause_group"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pause_group);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_RequestPause message, length delimited. Does not implicitly {@link CCLCMsg_RequestPause.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {ICCLCMsg_RequestPause} message CCLCMsg_RequestPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RequestPause.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_RequestPause message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RequestPause.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RequestPause();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pause_type = reader.int32();
                    break;
                case 2:
                    message.pause_group = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_RequestPause message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RequestPause.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_RequestPause message.
         * @function verify
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_RequestPause.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pause_type != null && message.hasOwnProperty("pause_type"))
                switch (message.pause_type) {
                default:
                    return "pause_type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.pause_group != null && message.hasOwnProperty("pause_group"))
                if (!$util.isInteger(message.pause_group))
                    return "pause_group: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_RequestPause message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause
         */
        CCLCMsg_RequestPause.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_RequestPause)
                return object;
            var message = new $root.CCLCMsg_RequestPause();
            switch (object.pause_type) {
            case "RP_PAUSE":
            case 0:
                message.pause_type = 0;
                break;
            case "RP_UNPAUSE":
            case 1:
                message.pause_type = 1;
                break;
            case "RP_TOGGLEPAUSE":
            case 2:
                message.pause_type = 2;
                break;
            }
            if (object.pause_group != null)
                message.pause_group = object.pause_group | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_RequestPause message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {CCLCMsg_RequestPause} message CCLCMsg_RequestPause
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_RequestPause.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pause_type = options.enums === String ? "RP_PAUSE" : 0;
                object.pause_group = 0;
            }
            if (message.pause_type != null && message.hasOwnProperty("pause_type"))
                object.pause_type = options.enums === String ? $root.RequestPause_t[message.pause_type] : message.pause_type;
            if (message.pause_group != null && message.hasOwnProperty("pause_group"))
                object.pause_group = message.pause_group;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_RequestPause to JSON.
         * @function toJSON
         * @memberof CCLCMsg_RequestPause
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_RequestPause.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_RequestPause;
    })();
    
    $root.CCLCMsg_CmdKeyValues = (function() {
    
        /**
         * Properties of a CCLCMsg_CmdKeyValues.
         * @exports ICCLCMsg_CmdKeyValues
         * @interface ICCLCMsg_CmdKeyValues
         * @property {Uint8Array|null} [data] CCLCMsg_CmdKeyValues data
         */
    
        /**
         * Constructs a new CCLCMsg_CmdKeyValues.
         * @exports CCLCMsg_CmdKeyValues
         * @classdesc Represents a CCLCMsg_CmdKeyValues.
         * @implements ICCLCMsg_CmdKeyValues
         * @constructor
         * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
         */
        function CCLCMsg_CmdKeyValues(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_CmdKeyValues data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_CmdKeyValues
         * @instance
         */
        CCLCMsg_CmdKeyValues.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_CmdKeyValues instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues instance
         */
        CCLCMsg_CmdKeyValues.create = function create(properties) {
            return new CCLCMsg_CmdKeyValues(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_CmdKeyValues message. Does not implicitly {@link CCLCMsg_CmdKeyValues.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_CmdKeyValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_CmdKeyValues message, length delimited. Does not implicitly {@link CCLCMsg_CmdKeyValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_CmdKeyValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_CmdKeyValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_CmdKeyValues message.
         * @function verify
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_CmdKeyValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_CmdKeyValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         */
        CCLCMsg_CmdKeyValues.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_CmdKeyValues)
                return object;
            var message = new $root.CCLCMsg_CmdKeyValues();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_CmdKeyValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {CCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_CmdKeyValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_CmdKeyValues to JSON.
         * @function toJSON
         * @memberof CCLCMsg_CmdKeyValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_CmdKeyValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_CmdKeyValues;
    })();
    
    $root.CSVCMsg_ServerInfo = (function() {
    
        /**
         * Properties of a CSVCMsg_ServerInfo.
         * @exports ICSVCMsg_ServerInfo
         * @interface ICSVCMsg_ServerInfo
         * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol
         * @property {number|null} [server_count] CSVCMsg_ServerInfo server_count
         * @property {boolean|null} [is_dedicated] CSVCMsg_ServerInfo is_dedicated
         * @property {boolean|null} [is_hltv] CSVCMsg_ServerInfo is_hltv
         * @property {number|null} [c_os] CSVCMsg_ServerInfo c_os
         * @property {number|null} [max_clients] CSVCMsg_ServerInfo max_clients
         * @property {number|null} [max_classes] CSVCMsg_ServerInfo max_classes
         * @property {number|null} [player_slot] CSVCMsg_ServerInfo player_slot
         * @property {number|null} [tick_interval] CSVCMsg_ServerInfo tick_interval
         * @property {string|null} [game_dir] CSVCMsg_ServerInfo game_dir
         * @property {string|null} [map_name] CSVCMsg_ServerInfo map_name
         * @property {string|null} [sky_name] CSVCMsg_ServerInfo sky_name
         * @property {string|null} [host_name] CSVCMsg_ServerInfo host_name
         * @property {string|null} [addon_name] CSVCMsg_ServerInfo addon_name
         * @property {ICSVCMsg_GameSessionConfiguration|null} [game_session_config] CSVCMsg_ServerInfo game_session_config
         * @property {Uint8Array|null} [game_session_manifest] CSVCMsg_ServerInfo game_session_manifest
         */
    
        /**
         * Constructs a new CSVCMsg_ServerInfo.
         * @exports CSVCMsg_ServerInfo
         * @classdesc Represents a CSVCMsg_ServerInfo.
         * @implements ICSVCMsg_ServerInfo
         * @constructor
         * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
         */
        function CSVCMsg_ServerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ServerInfo protocol.
         * @member {number} protocol
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.protocol = 0;
    
        /**
         * CSVCMsg_ServerInfo server_count.
         * @member {number} server_count
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.server_count = 0;
    
        /**
         * CSVCMsg_ServerInfo is_dedicated.
         * @member {boolean} is_dedicated
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_dedicated = false;
    
        /**
         * CSVCMsg_ServerInfo is_hltv.
         * @member {boolean} is_hltv
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_hltv = false;
    
        /**
         * CSVCMsg_ServerInfo c_os.
         * @member {number} c_os
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.c_os = 0;
    
        /**
         * CSVCMsg_ServerInfo max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_ServerInfo max_classes.
         * @member {number} max_classes
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.max_classes = 0;
    
        /**
         * CSVCMsg_ServerInfo player_slot.
         * @member {number} player_slot
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.player_slot = 0;
    
        /**
         * CSVCMsg_ServerInfo tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_ServerInfo game_dir.
         * @member {string} game_dir
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.game_dir = "";
    
        /**
         * CSVCMsg_ServerInfo map_name.
         * @member {string} map_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.map_name = "";
    
        /**
         * CSVCMsg_ServerInfo sky_name.
         * @member {string} sky_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.sky_name = "";
    
        /**
         * CSVCMsg_ServerInfo host_name.
         * @member {string} host_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.host_name = "";
    
        /**
         * CSVCMsg_ServerInfo addon_name.
         * @member {string} addon_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.addon_name = "";
    
        /**
         * CSVCMsg_ServerInfo game_session_config.
         * @member {ICSVCMsg_GameSessionConfiguration|null|undefined} game_session_config
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.game_session_config = null;
    
        /**
         * CSVCMsg_ServerInfo game_session_manifest.
         * @member {Uint8Array} game_session_manifest
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.game_session_manifest = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_ServerInfo instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo instance
         */
        CSVCMsg_ServerInfo.create = function create(properties) {
            return new CSVCMsg_ServerInfo(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerInfo message. Does not implicitly {@link CSVCMsg_ServerInfo.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo} message CSVCMsg_ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
            if (message.server_count != null && Object.hasOwnProperty.call(message, "server_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.server_count);
            if (message.is_dedicated != null && Object.hasOwnProperty.call(message, "is_dedicated"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_dedicated);
            if (message.is_hltv != null && Object.hasOwnProperty.call(message, "is_hltv"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_hltv);
            if (message.c_os != null && Object.hasOwnProperty.call(message, "c_os"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.c_os);
            if (message.max_clients != null && Object.hasOwnProperty.call(message, "max_clients"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.max_clients);
            if (message.max_classes != null && Object.hasOwnProperty.call(message, "max_classes"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.max_classes);
            if (message.player_slot != null && Object.hasOwnProperty.call(message, "player_slot"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.player_slot);
            if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.tick_interval);
            if (message.game_dir != null && Object.hasOwnProperty.call(message, "game_dir"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.game_dir);
            if (message.map_name != null && Object.hasOwnProperty.call(message, "map_name"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.map_name);
            if (message.sky_name != null && Object.hasOwnProperty.call(message, "sky_name"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.sky_name);
            if (message.host_name != null && Object.hasOwnProperty.call(message, "host_name"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.host_name);
            if (message.addon_name != null && Object.hasOwnProperty.call(message, "addon_name"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.addon_name);
            if (message.game_session_config != null && Object.hasOwnProperty.call(message, "game_session_config"))
                $root.CSVCMsg_GameSessionConfiguration.encode(message.game_session_config, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.game_session_manifest != null && Object.hasOwnProperty.call(message, "game_session_manifest"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.game_session_manifest);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerInfo message, length delimited. Does not implicitly {@link CSVCMsg_ServerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo} message CSVCMsg_ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.server_count = reader.int32();
                    break;
                case 3:
                    message.is_dedicated = reader.bool();
                    break;
                case 4:
                    message.is_hltv = reader.bool();
                    break;
                case 6:
                    message.c_os = reader.int32();
                    break;
                case 10:
                    message.max_clients = reader.int32();
                    break;
                case 11:
                    message.max_classes = reader.int32();
                    break;
                case 12:
                    message.player_slot = reader.int32();
                    break;
                case 13:
                    message.tick_interval = reader.float();
                    break;
                case 14:
                    message.game_dir = reader.string();
                    break;
                case 15:
                    message.map_name = reader.string();
                    break;
                case 16:
                    message.sky_name = reader.string();
                    break;
                case 17:
                    message.host_name = reader.string();
                    break;
                case 18:
                    message.addon_name = reader.string();
                    break;
                case 19:
                    message.game_session_config = $root.CSVCMsg_GameSessionConfiguration.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.game_session_manifest = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ServerInfo message.
         * @function verify
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ServerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isInteger(message.protocol))
                    return "protocol: integer expected";
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                if (!$util.isInteger(message.server_count))
                    return "server_count: integer expected";
            if (message.is_dedicated != null && message.hasOwnProperty("is_dedicated"))
                if (typeof message.is_dedicated !== "boolean")
                    return "is_dedicated: boolean expected";
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                if (typeof message.is_hltv !== "boolean")
                    return "is_hltv: boolean expected";
            if (message.c_os != null && message.hasOwnProperty("c_os"))
                if (!$util.isInteger(message.c_os))
                    return "c_os: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.max_classes != null && message.hasOwnProperty("max_classes"))
                if (!$util.isInteger(message.max_classes))
                    return "max_classes: integer expected";
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                if (!$util.isInteger(message.player_slot))
                    return "player_slot: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (typeof message.tick_interval !== "number")
                    return "tick_interval: number expected";
            if (message.game_dir != null && message.hasOwnProperty("game_dir"))
                if (!$util.isString(message.game_dir))
                    return "game_dir: string expected";
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.sky_name != null && message.hasOwnProperty("sky_name"))
                if (!$util.isString(message.sky_name))
                    return "sky_name: string expected";
            if (message.host_name != null && message.hasOwnProperty("host_name"))
                if (!$util.isString(message.host_name))
                    return "host_name: string expected";
            if (message.addon_name != null && message.hasOwnProperty("addon_name"))
                if (!$util.isString(message.addon_name))
                    return "addon_name: string expected";
            if (message.game_session_config != null && message.hasOwnProperty("game_session_config")) {
                var error = $root.CSVCMsg_GameSessionConfiguration.verify(message.game_session_config);
                if (error)
                    return "game_session_config." + error;
            }
            if (message.game_session_manifest != null && message.hasOwnProperty("game_session_manifest"))
                if (!(message.game_session_manifest && typeof message.game_session_manifest.length === "number" || $util.isString(message.game_session_manifest)))
                    return "game_session_manifest: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ServerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         */
        CSVCMsg_ServerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ServerInfo)
                return object;
            var message = new $root.CSVCMsg_ServerInfo();
            if (object.protocol != null)
                message.protocol = object.protocol | 0;
            if (object.server_count != null)
                message.server_count = object.server_count | 0;
            if (object.is_dedicated != null)
                message.is_dedicated = Boolean(object.is_dedicated);
            if (object.is_hltv != null)
                message.is_hltv = Boolean(object.is_hltv);
            if (object.c_os != null)
                message.c_os = object.c_os | 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients | 0;
            if (object.max_classes != null)
                message.max_classes = object.max_classes | 0;
            if (object.player_slot != null)
                message.player_slot = object.player_slot | 0;
            if (object.tick_interval != null)
                message.tick_interval = Number(object.tick_interval);
            if (object.game_dir != null)
                message.game_dir = String(object.game_dir);
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.sky_name != null)
                message.sky_name = String(object.sky_name);
            if (object.host_name != null)
                message.host_name = String(object.host_name);
            if (object.addon_name != null)
                message.addon_name = String(object.addon_name);
            if (object.game_session_config != null) {
                if (typeof object.game_session_config !== "object")
                    throw TypeError(".CSVCMsg_ServerInfo.game_session_config: object expected");
                message.game_session_config = $root.CSVCMsg_GameSessionConfiguration.fromObject(object.game_session_config);
            }
            if (object.game_session_manifest != null)
                if (typeof object.game_session_manifest === "string")
                    $util.base64.decode(object.game_session_manifest, message.game_session_manifest = $util.newBuffer($util.base64.length(object.game_session_manifest)), 0);
                else if (object.game_session_manifest.length)
                    message.game_session_manifest = object.game_session_manifest;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ServerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {CSVCMsg_ServerInfo} message CSVCMsg_ServerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ServerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.protocol = 0;
                object.server_count = 0;
                object.is_dedicated = false;
                object.is_hltv = false;
                object.c_os = 0;
                object.max_clients = 0;
                object.max_classes = 0;
                object.player_slot = 0;
                object.tick_interval = 0;
                object.game_dir = "";
                object.map_name = "";
                object.sky_name = "";
                object.host_name = "";
                object.addon_name = "";
                object.game_session_config = null;
                if (options.bytes === String)
                    object.game_session_manifest = "";
                else {
                    object.game_session_manifest = [];
                    if (options.bytes !== Array)
                        object.game_session_manifest = $util.newBuffer(object.game_session_manifest);
                }
            }
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                object.server_count = message.server_count;
            if (message.is_dedicated != null && message.hasOwnProperty("is_dedicated"))
                object.is_dedicated = message.is_dedicated;
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                object.is_hltv = message.is_hltv;
            if (message.c_os != null && message.hasOwnProperty("c_os"))
                object.c_os = message.c_os;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.max_classes != null && message.hasOwnProperty("max_classes"))
                object.max_classes = message.max_classes;
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                object.player_slot = message.player_slot;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = options.json && !isFinite(message.tick_interval) ? String(message.tick_interval) : message.tick_interval;
            if (message.game_dir != null && message.hasOwnProperty("game_dir"))
                object.game_dir = message.game_dir;
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.sky_name != null && message.hasOwnProperty("sky_name"))
                object.sky_name = message.sky_name;
            if (message.host_name != null && message.hasOwnProperty("host_name"))
                object.host_name = message.host_name;
            if (message.addon_name != null && message.hasOwnProperty("addon_name"))
                object.addon_name = message.addon_name;
            if (message.game_session_config != null && message.hasOwnProperty("game_session_config"))
                object.game_session_config = $root.CSVCMsg_GameSessionConfiguration.toObject(message.game_session_config, options);
            if (message.game_session_manifest != null && message.hasOwnProperty("game_session_manifest"))
                object.game_session_manifest = options.bytes === String ? $util.base64.encode(message.game_session_manifest, 0, message.game_session_manifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.game_session_manifest) : message.game_session_manifest;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ServerInfo to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ServerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ServerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_ServerInfo;
    })();
    
    $root.CSVCMsg_ClassInfo = (function() {
    
        /**
         * Properties of a CSVCMsg_ClassInfo.
         * @exports ICSVCMsg_ClassInfo
         * @interface ICSVCMsg_ClassInfo
         * @property {boolean|null} [create_on_client] CSVCMsg_ClassInfo create_on_client
         * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes
         */
    
        /**
         * Constructs a new CSVCMsg_ClassInfo.
         * @exports CSVCMsg_ClassInfo
         * @classdesc Represents a CSVCMsg_ClassInfo.
         * @implements ICSVCMsg_ClassInfo
         * @constructor
         * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
         */
        function CSVCMsg_ClassInfo(properties) {
            this.classes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ClassInfo create_on_client.
         * @member {boolean} create_on_client
         * @memberof CSVCMsg_ClassInfo
         * @instance
         */
        CSVCMsg_ClassInfo.prototype.create_on_client = false;
    
        /**
         * CSVCMsg_ClassInfo classes.
         * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes
         * @memberof CSVCMsg_ClassInfo
         * @instance
         */
        CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_ClassInfo instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo instance
         */
        CSVCMsg_ClassInfo.create = function create(properties) {
            return new CSVCMsg_ClassInfo(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ClassInfo message. Does not implicitly {@link CSVCMsg_ClassInfo.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo} message CSVCMsg_ClassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.create_on_client != null && Object.hasOwnProperty.call(message, "create_on_client"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.create_on_client);
            if (message.classes != null && message.classes.length)
                for (var i = 0; i < message.classes.length; ++i)
                    $root.CSVCMsg_ClassInfo.class_t.encode(message.classes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ClassInfo message, length delimited. Does not implicitly {@link CSVCMsg_ClassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo} message CSVCMsg_ClassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.create_on_client = reader.bool();
                    break;
                case 2:
                    if (!(message.classes && message.classes.length))
                        message.classes = [];
                    message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ClassInfo message.
         * @function verify
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ClassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.create_on_client != null && message.hasOwnProperty("create_on_client"))
                if (typeof message.create_on_client !== "boolean")
                    return "create_on_client: boolean expected";
            if (message.classes != null && message.hasOwnProperty("classes")) {
                if (!Array.isArray(message.classes))
                    return "classes: array expected";
                for (var i = 0; i < message.classes.length; ++i) {
                    var error = $root.CSVCMsg_ClassInfo.class_t.verify(message.classes[i]);
                    if (error)
                        return "classes." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ClassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         */
        CSVCMsg_ClassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ClassInfo)
                return object;
            var message = new $root.CSVCMsg_ClassInfo();
            if (object.create_on_client != null)
                message.create_on_client = Boolean(object.create_on_client);
            if (object.classes) {
                if (!Array.isArray(object.classes))
                    throw TypeError(".CSVCMsg_ClassInfo.classes: array expected");
                message.classes = [];
                for (var i = 0; i < object.classes.length; ++i) {
                    if (typeof object.classes[i] !== "object")
                        throw TypeError(".CSVCMsg_ClassInfo.classes: object expected");
                    message.classes[i] = $root.CSVCMsg_ClassInfo.class_t.fromObject(object.classes[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ClassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {CSVCMsg_ClassInfo} message CSVCMsg_ClassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ClassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.classes = [];
            if (options.defaults)
                object.create_on_client = false;
            if (message.create_on_client != null && message.hasOwnProperty("create_on_client"))
                object.create_on_client = message.create_on_client;
            if (message.classes && message.classes.length) {
                object.classes = [];
                for (var j = 0; j < message.classes.length; ++j)
                    object.classes[j] = $root.CSVCMsg_ClassInfo.class_t.toObject(message.classes[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ClassInfo to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ClassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ClassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_ClassInfo.class_t = (function() {
    
            /**
             * Properties of a class_t.
             * @memberof CSVCMsg_ClassInfo
             * @interface Iclass_t
             * @property {number|null} [class_id] class_t class_id
             * @property {string|null} [data_table_name] class_t data_table_name
             * @property {string|null} [class_name] class_t class_name
             */
    
            /**
             * Constructs a new class_t.
             * @memberof CSVCMsg_ClassInfo
             * @classdesc Represents a class_t.
             * @implements Iclass_t
             * @constructor
             * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
             */
            function class_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * class_t class_id.
             * @member {number} class_id
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.class_id = 0;
    
            /**
             * class_t data_table_name.
             * @member {string} data_table_name
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.data_table_name = "";
    
            /**
             * class_t class_name.
             * @member {string} class_name
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.class_name = "";
    
            /**
             * Creates a new class_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
             * @returns {CSVCMsg_ClassInfo.class_t} class_t instance
             */
            class_t.create = function create(properties) {
                return new class_t(properties);
            };
    
            /**
             * Encodes the specified class_t message. Does not implicitly {@link CSVCMsg_ClassInfo.class_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t} message class_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            class_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.class_id);
                if (message.data_table_name != null && Object.hasOwnProperty.call(message, "data_table_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data_table_name);
                if (message.class_name != null && Object.hasOwnProperty.call(message, "class_name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.class_name);
                return writer;
            };
    
            /**
             * Encodes the specified class_t message, length delimited. Does not implicitly {@link CSVCMsg_ClassInfo.class_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t} message class_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            class_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a class_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            class_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.class_id = reader.int32();
                        break;
                    case 2:
                        message.data_table_name = reader.string();
                        break;
                    case 3:
                        message.class_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a class_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            class_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a class_t message.
             * @function verify
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            class_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.class_id != null && message.hasOwnProperty("class_id"))
                    if (!$util.isInteger(message.class_id))
                        return "class_id: integer expected";
                if (message.data_table_name != null && message.hasOwnProperty("data_table_name"))
                    if (!$util.isString(message.data_table_name))
                        return "data_table_name: string expected";
                if (message.class_name != null && message.hasOwnProperty("class_name"))
                    if (!$util.isString(message.class_name))
                        return "class_name: string expected";
                return null;
            };
    
            /**
             * Creates a class_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             */
            class_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_ClassInfo.class_t)
                    return object;
                var message = new $root.CSVCMsg_ClassInfo.class_t();
                if (object.class_id != null)
                    message.class_id = object.class_id | 0;
                if (object.data_table_name != null)
                    message.data_table_name = String(object.data_table_name);
                if (object.class_name != null)
                    message.class_name = String(object.class_name);
                return message;
            };
    
            /**
             * Creates a plain object from a class_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.class_t} message class_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            class_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.class_id = 0;
                    object.data_table_name = "";
                    object.class_name = "";
                }
                if (message.class_id != null && message.hasOwnProperty("class_id"))
                    object.class_id = message.class_id;
                if (message.data_table_name != null && message.hasOwnProperty("data_table_name"))
                    object.data_table_name = message.data_table_name;
                if (message.class_name != null && message.hasOwnProperty("class_name"))
                    object.class_name = message.class_name;
                return object;
            };
    
            /**
             * Converts this class_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            class_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return class_t;
        })();
    
        return CSVCMsg_ClassInfo;
    })();
    
    $root.CSVCMsg_SetPause = (function() {
    
        /**
         * Properties of a CSVCMsg_SetPause.
         * @exports ICSVCMsg_SetPause
         * @interface ICSVCMsg_SetPause
         * @property {boolean|null} [paused] CSVCMsg_SetPause paused
         */
    
        /**
         * Constructs a new CSVCMsg_SetPause.
         * @exports CSVCMsg_SetPause
         * @classdesc Represents a CSVCMsg_SetPause.
         * @implements ICSVCMsg_SetPause
         * @constructor
         * @param {ICSVCMsg_SetPause=} [properties] Properties to set
         */
        function CSVCMsg_SetPause(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SetPause paused.
         * @member {boolean} paused
         * @memberof CSVCMsg_SetPause
         * @instance
         */
        CSVCMsg_SetPause.prototype.paused = false;
    
        /**
         * Creates a new CSVCMsg_SetPause instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause=} [properties] Properties to set
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause instance
         */
        CSVCMsg_SetPause.create = function create(properties) {
            return new CSVCMsg_SetPause(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SetPause message. Does not implicitly {@link CSVCMsg_SetPause.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause} message CSVCMsg_SetPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetPause.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paused != null && Object.hasOwnProperty.call(message, "paused"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.paused);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SetPause message, length delimited. Does not implicitly {@link CSVCMsg_SetPause.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause} message CSVCMsg_SetPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetPause.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetPause.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paused = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SetPause message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetPause.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SetPause message.
         * @function verify
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SetPause.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paused != null && message.hasOwnProperty("paused"))
                if (typeof message.paused !== "boolean")
                    return "paused: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SetPause message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         */
        CSVCMsg_SetPause.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SetPause)
                return object;
            var message = new $root.CSVCMsg_SetPause();
            if (object.paused != null)
                message.paused = Boolean(object.paused);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SetPause message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {CSVCMsg_SetPause} message CSVCMsg_SetPause
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SetPause.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.paused = false;
            if (message.paused != null && message.hasOwnProperty("paused"))
                object.paused = message.paused;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SetPause to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SetPause
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SetPause.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_SetPause;
    })();
    
    $root.CSVCMsg_VoiceInit = (function() {
    
        /**
         * Properties of a CSVCMsg_VoiceInit.
         * @exports ICSVCMsg_VoiceInit
         * @interface ICSVCMsg_VoiceInit
         * @property {number|null} [quality] CSVCMsg_VoiceInit quality
         * @property {string|null} [codec] CSVCMsg_VoiceInit codec
         * @property {number|null} [version] CSVCMsg_VoiceInit version
         */
    
        /**
         * Constructs a new CSVCMsg_VoiceInit.
         * @exports CSVCMsg_VoiceInit
         * @classdesc Represents a CSVCMsg_VoiceInit.
         * @implements ICSVCMsg_VoiceInit
         * @constructor
         * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
         */
        function CSVCMsg_VoiceInit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_VoiceInit quality.
         * @member {number} quality
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.quality = 0;
    
        /**
         * CSVCMsg_VoiceInit codec.
         * @member {string} codec
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.codec = "";
    
        /**
         * CSVCMsg_VoiceInit version.
         * @member {number} version
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.version = 0;
    
        /**
         * Creates a new CSVCMsg_VoiceInit instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit instance
         */
        CSVCMsg_VoiceInit.create = function create(properties) {
            return new CSVCMsg_VoiceInit(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceInit message. Does not implicitly {@link CSVCMsg_VoiceInit.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit} message CSVCMsg_VoiceInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceInit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.quality);
            if (message.codec != null && Object.hasOwnProperty.call(message, "codec"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.codec);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceInit message, length delimited. Does not implicitly {@link CSVCMsg_VoiceInit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit} message CSVCMsg_VoiceInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceInit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceInit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.codec = reader.string();
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceInit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_VoiceInit message.
         * @function verify
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_VoiceInit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.codec != null && message.hasOwnProperty("codec"))
                if (!$util.isString(message.codec))
                    return "codec: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_VoiceInit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         */
        CSVCMsg_VoiceInit.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_VoiceInit)
                return object;
            var message = new $root.CSVCMsg_VoiceInit();
            if (object.quality != null)
                message.quality = object.quality | 0;
            if (object.codec != null)
                message.codec = String(object.codec);
            if (object.version != null)
                message.version = object.version | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_VoiceInit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {CSVCMsg_VoiceInit} message CSVCMsg_VoiceInit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_VoiceInit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.quality = 0;
                object.codec = "";
                object.version = 0;
            }
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.codec != null && message.hasOwnProperty("codec"))
                object.codec = message.codec;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_VoiceInit to JSON.
         * @function toJSON
         * @memberof CSVCMsg_VoiceInit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_VoiceInit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_VoiceInit;
    })();
    
    $root.CSVCMsg_Print = (function() {
    
        /**
         * Properties of a CSVCMsg_Print.
         * @exports ICSVCMsg_Print
         * @interface ICSVCMsg_Print
         * @property {string|null} [text] CSVCMsg_Print text
         */
    
        /**
         * Constructs a new CSVCMsg_Print.
         * @exports CSVCMsg_Print
         * @classdesc Represents a CSVCMsg_Print.
         * @implements ICSVCMsg_Print
         * @constructor
         * @param {ICSVCMsg_Print=} [properties] Properties to set
         */
        function CSVCMsg_Print(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Print text.
         * @member {string} text
         * @memberof CSVCMsg_Print
         * @instance
         */
        CSVCMsg_Print.prototype.text = "";
    
        /**
         * Creates a new CSVCMsg_Print instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print=} [properties] Properties to set
         * @returns {CSVCMsg_Print} CSVCMsg_Print instance
         */
        CSVCMsg_Print.create = function create(properties) {
            return new CSVCMsg_Print(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Print message. Does not implicitly {@link CSVCMsg_Print.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print} message CSVCMsg_Print message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Print.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Print message, length delimited. Does not implicitly {@link CSVCMsg_Print.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print} message CSVCMsg_Print message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Print.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Print message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Print
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Print.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Print message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Print
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Print.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Print message.
         * @function verify
         * @memberof CSVCMsg_Print
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Print.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Print message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Print
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         */
        CSVCMsg_Print.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Print)
                return object;
            var message = new $root.CSVCMsg_Print();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Print message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Print
         * @static
         * @param {CSVCMsg_Print} message CSVCMsg_Print
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Print.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Print to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Print
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Print.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Print;
    })();
    
    $root.CSVCMsg_Sounds = (function() {
    
        /**
         * Properties of a CSVCMsg_Sounds.
         * @exports ICSVCMsg_Sounds
         * @interface ICSVCMsg_Sounds
         * @property {boolean|null} [reliable_sound] CSVCMsg_Sounds reliable_sound
         * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds
         */
    
        /**
         * Constructs a new CSVCMsg_Sounds.
         * @exports CSVCMsg_Sounds
         * @classdesc Represents a CSVCMsg_Sounds.
         * @implements ICSVCMsg_Sounds
         * @constructor
         * @param {ICSVCMsg_Sounds=} [properties] Properties to set
         */
        function CSVCMsg_Sounds(properties) {
            this.sounds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Sounds reliable_sound.
         * @member {boolean} reliable_sound
         * @memberof CSVCMsg_Sounds
         * @instance
         */
        CSVCMsg_Sounds.prototype.reliable_sound = false;
    
        /**
         * CSVCMsg_Sounds sounds.
         * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds
         * @memberof CSVCMsg_Sounds
         * @instance
         */
        CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_Sounds instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds=} [properties] Properties to set
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds instance
         */
        CSVCMsg_Sounds.create = function create(properties) {
            return new CSVCMsg_Sounds(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Sounds message. Does not implicitly {@link CSVCMsg_Sounds.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds} message CSVCMsg_Sounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Sounds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliable_sound != null && Object.hasOwnProperty.call(message, "reliable_sound"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reliable_sound);
            if (message.sounds != null && message.sounds.length)
                for (var i = 0; i < message.sounds.length; ++i)
                    $root.CSVCMsg_Sounds.sounddata_t.encode(message.sounds[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Sounds message, length delimited. Does not implicitly {@link CSVCMsg_Sounds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds} message CSVCMsg_Sounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Sounds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Sounds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reliable_sound = reader.bool();
                    break;
                case 2:
                    if (!(message.sounds && message.sounds.length))
                        message.sounds = [];
                    message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Sounds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Sounds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Sounds message.
         * @function verify
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Sounds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliable_sound != null && message.hasOwnProperty("reliable_sound"))
                if (typeof message.reliable_sound !== "boolean")
                    return "reliable_sound: boolean expected";
            if (message.sounds != null && message.hasOwnProperty("sounds")) {
                if (!Array.isArray(message.sounds))
                    return "sounds: array expected";
                for (var i = 0; i < message.sounds.length; ++i) {
                    var error = $root.CSVCMsg_Sounds.sounddata_t.verify(message.sounds[i]);
                    if (error)
                        return "sounds." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Sounds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         */
        CSVCMsg_Sounds.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Sounds)
                return object;
            var message = new $root.CSVCMsg_Sounds();
            if (object.reliable_sound != null)
                message.reliable_sound = Boolean(object.reliable_sound);
            if (object.sounds) {
                if (!Array.isArray(object.sounds))
                    throw TypeError(".CSVCMsg_Sounds.sounds: array expected");
                message.sounds = [];
                for (var i = 0; i < object.sounds.length; ++i) {
                    if (typeof object.sounds[i] !== "object")
                        throw TypeError(".CSVCMsg_Sounds.sounds: object expected");
                    message.sounds[i] = $root.CSVCMsg_Sounds.sounddata_t.fromObject(object.sounds[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Sounds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {CSVCMsg_Sounds} message CSVCMsg_Sounds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Sounds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sounds = [];
            if (options.defaults)
                object.reliable_sound = false;
            if (message.reliable_sound != null && message.hasOwnProperty("reliable_sound"))
                object.reliable_sound = message.reliable_sound;
            if (message.sounds && message.sounds.length) {
                object.sounds = [];
                for (var j = 0; j < message.sounds.length; ++j)
                    object.sounds[j] = $root.CSVCMsg_Sounds.sounddata_t.toObject(message.sounds[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Sounds to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Sounds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Sounds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_Sounds.sounddata_t = (function() {
    
            /**
             * Properties of a sounddata_t.
             * @memberof CSVCMsg_Sounds
             * @interface Isounddata_t
             * @property {number|null} [origin_x] sounddata_t origin_x
             * @property {number|null} [origin_y] sounddata_t origin_y
             * @property {number|null} [origin_z] sounddata_t origin_z
             * @property {number|null} [volume] sounddata_t volume
             * @property {number|null} [delay_value] sounddata_t delay_value
             * @property {number|null} [sequence_number] sounddata_t sequence_number
             * @property {number|null} [entity_index] sounddata_t entity_index
             * @property {number|null} [channel] sounddata_t channel
             * @property {number|null} [pitch] sounddata_t pitch
             * @property {number|null} [flags] sounddata_t flags
             * @property {number|null} [sound_num] sounddata_t sound_num
             * @property {number|null} [sound_num_handle] sounddata_t sound_num_handle
             * @property {number|null} [speaker_entity] sounddata_t speaker_entity
             * @property {number|null} [random_seed] sounddata_t random_seed
             * @property {number|null} [sound_level] sounddata_t sound_level
             * @property {boolean|null} [is_sentence] sounddata_t is_sentence
             * @property {boolean|null} [is_ambient] sounddata_t is_ambient
             * @property {number|null} [guid] sounddata_t guid
             * @property {number|Long|null} [sound_resource_id] sounddata_t sound_resource_id
             */
    
            /**
             * Constructs a new sounddata_t.
             * @memberof CSVCMsg_Sounds
             * @classdesc Represents a sounddata_t.
             * @implements Isounddata_t
             * @constructor
             * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
             */
            function sounddata_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * sounddata_t origin_x.
             * @member {number} origin_x
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.origin_x = 0;
    
            /**
             * sounddata_t origin_y.
             * @member {number} origin_y
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.origin_y = 0;
    
            /**
             * sounddata_t origin_z.
             * @member {number} origin_z
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.origin_z = 0;
    
            /**
             * sounddata_t volume.
             * @member {number} volume
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.volume = 0;
    
            /**
             * sounddata_t delay_value.
             * @member {number} delay_value
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.delay_value = 0;
    
            /**
             * sounddata_t sequence_number.
             * @member {number} sequence_number
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sequence_number = 0;
    
            /**
             * sounddata_t entity_index.
             * @member {number} entity_index
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.entity_index = 0;
    
            /**
             * sounddata_t channel.
             * @member {number} channel
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.channel = 0;
    
            /**
             * sounddata_t pitch.
             * @member {number} pitch
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.pitch = 0;
    
            /**
             * sounddata_t flags.
             * @member {number} flags
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.flags = 0;
    
            /**
             * sounddata_t sound_num.
             * @member {number} sound_num
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_num = 0;
    
            /**
             * sounddata_t sound_num_handle.
             * @member {number} sound_num_handle
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_num_handle = 0;
    
            /**
             * sounddata_t speaker_entity.
             * @member {number} speaker_entity
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.speaker_entity = 0;
    
            /**
             * sounddata_t random_seed.
             * @member {number} random_seed
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.random_seed = 0;
    
            /**
             * sounddata_t sound_level.
             * @member {number} sound_level
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_level = 0;
    
            /**
             * sounddata_t is_sentence.
             * @member {boolean} is_sentence
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.is_sentence = false;
    
            /**
             * sounddata_t is_ambient.
             * @member {boolean} is_ambient
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.is_ambient = false;
    
            /**
             * sounddata_t guid.
             * @member {number} guid
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.guid = 0;
    
            /**
             * sounddata_t sound_resource_id.
             * @member {number|Long} sound_resource_id
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_resource_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new sounddata_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t instance
             */
            sounddata_t.create = function create(properties) {
                return new sounddata_t(properties);
            };
    
            /**
             * Encodes the specified sounddata_t message. Does not implicitly {@link CSVCMsg_Sounds.sounddata_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t} message sounddata_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sounddata_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.origin_x != null && Object.hasOwnProperty.call(message, "origin_x"))
                    writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.origin_x);
                if (message.origin_y != null && Object.hasOwnProperty.call(message, "origin_y"))
                    writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.origin_y);
                if (message.origin_z != null && Object.hasOwnProperty.call(message, "origin_z"))
                    writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.origin_z);
                if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.volume);
                if (message.delay_value != null && Object.hasOwnProperty.call(message, "delay_value"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.delay_value);
                if (message.sequence_number != null && Object.hasOwnProperty.call(message, "sequence_number"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sequence_number);
                if (message.entity_index != null && Object.hasOwnProperty.call(message, "entity_index"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.entity_index);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.channel);
                if (message.pitch != null && Object.hasOwnProperty.call(message, "pitch"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.pitch);
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.flags);
                if (message.sound_num != null && Object.hasOwnProperty.call(message, "sound_num"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sound_num);
                if (message.sound_num_handle != null && Object.hasOwnProperty.call(message, "sound_num_handle"))
                    writer.uint32(/* id 12, wireType 5 =*/101).fixed32(message.sound_num_handle);
                if (message.speaker_entity != null && Object.hasOwnProperty.call(message, "speaker_entity"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.speaker_entity);
                if (message.random_seed != null && Object.hasOwnProperty.call(message, "random_seed"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.random_seed);
                if (message.sound_level != null && Object.hasOwnProperty.call(message, "sound_level"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.sound_level);
                if (message.is_sentence != null && Object.hasOwnProperty.call(message, "is_sentence"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_sentence);
                if (message.is_ambient != null && Object.hasOwnProperty.call(message, "is_ambient"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.is_ambient);
                if (message.guid != null && Object.hasOwnProperty.call(message, "guid"))
                    writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.guid);
                if (message.sound_resource_id != null && Object.hasOwnProperty.call(message, "sound_resource_id"))
                    writer.uint32(/* id 19, wireType 1 =*/153).fixed64(message.sound_resource_id);
                return writer;
            };
    
            /**
             * Encodes the specified sounddata_t message, length delimited. Does not implicitly {@link CSVCMsg_Sounds.sounddata_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t} message sounddata_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sounddata_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a sounddata_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sounddata_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.origin_x = reader.sint32();
                        break;
                    case 2:
                        message.origin_y = reader.sint32();
                        break;
                    case 3:
                        message.origin_z = reader.sint32();
                        break;
                    case 4:
                        message.volume = reader.uint32();
                        break;
                    case 5:
                        message.delay_value = reader.float();
                        break;
                    case 6:
                        message.sequence_number = reader.int32();
                        break;
                    case 7:
                        message.entity_index = reader.int32();
                        break;
                    case 8:
                        message.channel = reader.int32();
                        break;
                    case 9:
                        message.pitch = reader.int32();
                        break;
                    case 10:
                        message.flags = reader.int32();
                        break;
                    case 11:
                        message.sound_num = reader.uint32();
                        break;
                    case 12:
                        message.sound_num_handle = reader.fixed32();
                        break;
                    case 13:
                        message.speaker_entity = reader.int32();
                        break;
                    case 14:
                        message.random_seed = reader.int32();
                        break;
                    case 15:
                        message.sound_level = reader.int32();
                        break;
                    case 16:
                        message.is_sentence = reader.bool();
                        break;
                    case 17:
                        message.is_ambient = reader.bool();
                        break;
                    case 18:
                        message.guid = reader.uint32();
                        break;
                    case 19:
                        message.sound_resource_id = reader.fixed64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a sounddata_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sounddata_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a sounddata_t message.
             * @function verify
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sounddata_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.origin_x != null && message.hasOwnProperty("origin_x"))
                    if (!$util.isInteger(message.origin_x))
                        return "origin_x: integer expected";
                if (message.origin_y != null && message.hasOwnProperty("origin_y"))
                    if (!$util.isInteger(message.origin_y))
                        return "origin_y: integer expected";
                if (message.origin_z != null && message.hasOwnProperty("origin_z"))
                    if (!$util.isInteger(message.origin_z))
                        return "origin_z: integer expected";
                if (message.volume != null && message.hasOwnProperty("volume"))
                    if (!$util.isInteger(message.volume))
                        return "volume: integer expected";
                if (message.delay_value != null && message.hasOwnProperty("delay_value"))
                    if (typeof message.delay_value !== "number")
                        return "delay_value: number expected";
                if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                    if (!$util.isInteger(message.sequence_number))
                        return "sequence_number: integer expected";
                if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                    if (!$util.isInteger(message.entity_index))
                        return "entity_index: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isInteger(message.channel))
                        return "channel: integer expected";
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    if (!$util.isInteger(message.pitch))
                        return "pitch: integer expected";
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                if (message.sound_num != null && message.hasOwnProperty("sound_num"))
                    if (!$util.isInteger(message.sound_num))
                        return "sound_num: integer expected";
                if (message.sound_num_handle != null && message.hasOwnProperty("sound_num_handle"))
                    if (!$util.isInteger(message.sound_num_handle))
                        return "sound_num_handle: integer expected";
                if (message.speaker_entity != null && message.hasOwnProperty("speaker_entity"))
                    if (!$util.isInteger(message.speaker_entity))
                        return "speaker_entity: integer expected";
                if (message.random_seed != null && message.hasOwnProperty("random_seed"))
                    if (!$util.isInteger(message.random_seed))
                        return "random_seed: integer expected";
                if (message.sound_level != null && message.hasOwnProperty("sound_level"))
                    if (!$util.isInteger(message.sound_level))
                        return "sound_level: integer expected";
                if (message.is_sentence != null && message.hasOwnProperty("is_sentence"))
                    if (typeof message.is_sentence !== "boolean")
                        return "is_sentence: boolean expected";
                if (message.is_ambient != null && message.hasOwnProperty("is_ambient"))
                    if (typeof message.is_ambient !== "boolean")
                        return "is_ambient: boolean expected";
                if (message.guid != null && message.hasOwnProperty("guid"))
                    if (!$util.isInteger(message.guid))
                        return "guid: integer expected";
                if (message.sound_resource_id != null && message.hasOwnProperty("sound_resource_id"))
                    if (!$util.isInteger(message.sound_resource_id) && !(message.sound_resource_id && $util.isInteger(message.sound_resource_id.low) && $util.isInteger(message.sound_resource_id.high)))
                        return "sound_resource_id: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a sounddata_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             */
            sounddata_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_Sounds.sounddata_t)
                    return object;
                var message = new $root.CSVCMsg_Sounds.sounddata_t();
                if (object.origin_x != null)
                    message.origin_x = object.origin_x | 0;
                if (object.origin_y != null)
                    message.origin_y = object.origin_y | 0;
                if (object.origin_z != null)
                    message.origin_z = object.origin_z | 0;
                if (object.volume != null)
                    message.volume = object.volume >>> 0;
                if (object.delay_value != null)
                    message.delay_value = Number(object.delay_value);
                if (object.sequence_number != null)
                    message.sequence_number = object.sequence_number | 0;
                if (object.entity_index != null)
                    message.entity_index = object.entity_index | 0;
                if (object.channel != null)
                    message.channel = object.channel | 0;
                if (object.pitch != null)
                    message.pitch = object.pitch | 0;
                if (object.flags != null)
                    message.flags = object.flags | 0;
                if (object.sound_num != null)
                    message.sound_num = object.sound_num >>> 0;
                if (object.sound_num_handle != null)
                    message.sound_num_handle = object.sound_num_handle >>> 0;
                if (object.speaker_entity != null)
                    message.speaker_entity = object.speaker_entity | 0;
                if (object.random_seed != null)
                    message.random_seed = object.random_seed | 0;
                if (object.sound_level != null)
                    message.sound_level = object.sound_level | 0;
                if (object.is_sentence != null)
                    message.is_sentence = Boolean(object.is_sentence);
                if (object.is_ambient != null)
                    message.is_ambient = Boolean(object.is_ambient);
                if (object.guid != null)
                    message.guid = object.guid >>> 0;
                if (object.sound_resource_id != null)
                    if ($util.Long)
                        (message.sound_resource_id = $util.Long.fromValue(object.sound_resource_id)).unsigned = false;
                    else if (typeof object.sound_resource_id === "string")
                        message.sound_resource_id = parseInt(object.sound_resource_id, 10);
                    else if (typeof object.sound_resource_id === "number")
                        message.sound_resource_id = object.sound_resource_id;
                    else if (typeof object.sound_resource_id === "object")
                        message.sound_resource_id = new $util.LongBits(object.sound_resource_id.low >>> 0, object.sound_resource_id.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a sounddata_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.sounddata_t} message sounddata_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            sounddata_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.origin_x = 0;
                    object.origin_y = 0;
                    object.origin_z = 0;
                    object.volume = 0;
                    object.delay_value = 0;
                    object.sequence_number = 0;
                    object.entity_index = 0;
                    object.channel = 0;
                    object.pitch = 0;
                    object.flags = 0;
                    object.sound_num = 0;
                    object.sound_num_handle = 0;
                    object.speaker_entity = 0;
                    object.random_seed = 0;
                    object.sound_level = 0;
                    object.is_sentence = false;
                    object.is_ambient = false;
                    object.guid = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sound_resource_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sound_resource_id = options.longs === String ? "0" : 0;
                }
                if (message.origin_x != null && message.hasOwnProperty("origin_x"))
                    object.origin_x = message.origin_x;
                if (message.origin_y != null && message.hasOwnProperty("origin_y"))
                    object.origin_y = message.origin_y;
                if (message.origin_z != null && message.hasOwnProperty("origin_z"))
                    object.origin_z = message.origin_z;
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = message.volume;
                if (message.delay_value != null && message.hasOwnProperty("delay_value"))
                    object.delay_value = options.json && !isFinite(message.delay_value) ? String(message.delay_value) : message.delay_value;
                if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                    object.sequence_number = message.sequence_number;
                if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                    object.entity_index = message.entity_index;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    object.pitch = message.pitch;
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                if (message.sound_num != null && message.hasOwnProperty("sound_num"))
                    object.sound_num = message.sound_num;
                if (message.sound_num_handle != null && message.hasOwnProperty("sound_num_handle"))
                    object.sound_num_handle = message.sound_num_handle;
                if (message.speaker_entity != null && message.hasOwnProperty("speaker_entity"))
                    object.speaker_entity = message.speaker_entity;
                if (message.random_seed != null && message.hasOwnProperty("random_seed"))
                    object.random_seed = message.random_seed;
                if (message.sound_level != null && message.hasOwnProperty("sound_level"))
                    object.sound_level = message.sound_level;
                if (message.is_sentence != null && message.hasOwnProperty("is_sentence"))
                    object.is_sentence = message.is_sentence;
                if (message.is_ambient != null && message.hasOwnProperty("is_ambient"))
                    object.is_ambient = message.is_ambient;
                if (message.guid != null && message.hasOwnProperty("guid"))
                    object.guid = message.guid;
                if (message.sound_resource_id != null && message.hasOwnProperty("sound_resource_id"))
                    if (typeof message.sound_resource_id === "number")
                        object.sound_resource_id = options.longs === String ? String(message.sound_resource_id) : message.sound_resource_id;
                    else
                        object.sound_resource_id = options.longs === String ? $util.Long.prototype.toString.call(message.sound_resource_id) : options.longs === Number ? new $util.LongBits(message.sound_resource_id.low >>> 0, message.sound_resource_id.high >>> 0).toNumber() : message.sound_resource_id;
                return object;
            };
    
            /**
             * Converts this sounddata_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            sounddata_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return sounddata_t;
        })();
    
        return CSVCMsg_Sounds;
    })();
    
    $root.CSVCMsg_Prefetch = (function() {
    
        /**
         * Properties of a CSVCMsg_Prefetch.
         * @exports ICSVCMsg_Prefetch
         * @interface ICSVCMsg_Prefetch
         * @property {number|null} [sound_index] CSVCMsg_Prefetch sound_index
         * @property {PrefetchType|null} [resource_type] CSVCMsg_Prefetch resource_type
         */
    
        /**
         * Constructs a new CSVCMsg_Prefetch.
         * @exports CSVCMsg_Prefetch
         * @classdesc Represents a CSVCMsg_Prefetch.
         * @implements ICSVCMsg_Prefetch
         * @constructor
         * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
         */
        function CSVCMsg_Prefetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Prefetch sound_index.
         * @member {number} sound_index
         * @memberof CSVCMsg_Prefetch
         * @instance
         */
        CSVCMsg_Prefetch.prototype.sound_index = 0;
    
        /**
         * CSVCMsg_Prefetch resource_type.
         * @member {PrefetchType} resource_type
         * @memberof CSVCMsg_Prefetch
         * @instance
         */
        CSVCMsg_Prefetch.prototype.resource_type = 0;
    
        /**
         * Creates a new CSVCMsg_Prefetch instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch instance
         */
        CSVCMsg_Prefetch.create = function create(properties) {
            return new CSVCMsg_Prefetch(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Prefetch message. Does not implicitly {@link CSVCMsg_Prefetch.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch} message CSVCMsg_Prefetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Prefetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sound_index != null && Object.hasOwnProperty.call(message, "sound_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sound_index);
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.resource_type);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Prefetch message, length delimited. Does not implicitly {@link CSVCMsg_Prefetch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch} message CSVCMsg_Prefetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Prefetch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Prefetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sound_index = reader.int32();
                    break;
                case 2:
                    message.resource_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Prefetch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Prefetch message.
         * @function verify
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Prefetch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sound_index != null && message.hasOwnProperty("sound_index"))
                if (!$util.isInteger(message.sound_index))
                    return "sound_index: integer expected";
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                switch (message.resource_type) {
                default:
                    return "resource_type: enum value expected";
                case 0:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Prefetch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         */
        CSVCMsg_Prefetch.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Prefetch)
                return object;
            var message = new $root.CSVCMsg_Prefetch();
            if (object.sound_index != null)
                message.sound_index = object.sound_index | 0;
            switch (object.resource_type) {
            case "PFT_SOUND":
            case 0:
                message.resource_type = 0;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Prefetch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {CSVCMsg_Prefetch} message CSVCMsg_Prefetch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Prefetch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sound_index = 0;
                object.resource_type = options.enums === String ? "PFT_SOUND" : 0;
            }
            if (message.sound_index != null && message.hasOwnProperty("sound_index"))
                object.sound_index = message.sound_index;
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                object.resource_type = options.enums === String ? $root.PrefetchType[message.resource_type] : message.resource_type;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Prefetch to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Prefetch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Prefetch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Prefetch;
    })();
    
    $root.CSVCMsg_SetView = (function() {
    
        /**
         * Properties of a CSVCMsg_SetView.
         * @exports ICSVCMsg_SetView
         * @interface ICSVCMsg_SetView
         * @property {number|null} [entity_index] CSVCMsg_SetView entity_index
         * @property {number|null} [slot] CSVCMsg_SetView slot
         */
    
        /**
         * Constructs a new CSVCMsg_SetView.
         * @exports CSVCMsg_SetView
         * @classdesc Represents a CSVCMsg_SetView.
         * @implements ICSVCMsg_SetView
         * @constructor
         * @param {ICSVCMsg_SetView=} [properties] Properties to set
         */
        function CSVCMsg_SetView(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SetView entity_index.
         * @member {number} entity_index
         * @memberof CSVCMsg_SetView
         * @instance
         */
        CSVCMsg_SetView.prototype.entity_index = 0;
    
        /**
         * CSVCMsg_SetView slot.
         * @member {number} slot
         * @memberof CSVCMsg_SetView
         * @instance
         */
        CSVCMsg_SetView.prototype.slot = 0;
    
        /**
         * Creates a new CSVCMsg_SetView instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView=} [properties] Properties to set
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView instance
         */
        CSVCMsg_SetView.create = function create(properties) {
            return new CSVCMsg_SetView(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SetView message. Does not implicitly {@link CSVCMsg_SetView.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView} message CSVCMsg_SetView message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetView.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity_index != null && Object.hasOwnProperty.call(message, "entity_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity_index);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SetView message, length delimited. Does not implicitly {@link CSVCMsg_SetView.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView} message CSVCMsg_SetView message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetView.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SetView message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SetView
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetView.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity_index = reader.int32();
                    break;
                case 2:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SetView message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SetView
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetView.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SetView message.
         * @function verify
         * @memberof CSVCMsg_SetView
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SetView.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                if (!$util.isInteger(message.entity_index))
                    return "entity_index: integer expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SetView message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SetView
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         */
        CSVCMsg_SetView.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SetView)
                return object;
            var message = new $root.CSVCMsg_SetView();
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SetView message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SetView
         * @static
         * @param {CSVCMsg_SetView} message CSVCMsg_SetView
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SetView.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity_index = 0;
                object.slot = 0;
            }
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SetView to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SetView
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SetView.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_SetView;
    })();
    
    $root.CSVCMsg_FixAngle = (function() {
    
        /**
         * Properties of a CSVCMsg_FixAngle.
         * @exports ICSVCMsg_FixAngle
         * @interface ICSVCMsg_FixAngle
         * @property {boolean|null} [relative] CSVCMsg_FixAngle relative
         * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle
         */
    
        /**
         * Constructs a new CSVCMsg_FixAngle.
         * @exports CSVCMsg_FixAngle
         * @classdesc Represents a CSVCMsg_FixAngle.
         * @implements ICSVCMsg_FixAngle
         * @constructor
         * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
         */
        function CSVCMsg_FixAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FixAngle relative.
         * @member {boolean} relative
         * @memberof CSVCMsg_FixAngle
         * @instance
         */
        CSVCMsg_FixAngle.prototype.relative = false;
    
        /**
         * CSVCMsg_FixAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CSVCMsg_FixAngle
         * @instance
         */
        CSVCMsg_FixAngle.prototype.angle = null;
    
        /**
         * Creates a new CSVCMsg_FixAngle instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle instance
         */
        CSVCMsg_FixAngle.create = function create(properties) {
            return new CSVCMsg_FixAngle(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FixAngle message. Does not implicitly {@link CSVCMsg_FixAngle.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle} message CSVCMsg_FixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FixAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relative != null && Object.hasOwnProperty.call(message, "relative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.relative);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FixAngle message, length delimited. Does not implicitly {@link CSVCMsg_FixAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle} message CSVCMsg_FixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FixAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FixAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.relative = reader.bool();
                    break;
                case 2:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FixAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FixAngle message.
         * @function verify
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FixAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.relative != null && message.hasOwnProperty("relative"))
                if (typeof message.relative !== "boolean")
                    return "relative: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FixAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         */
        CSVCMsg_FixAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FixAngle)
                return object;
            var message = new $root.CSVCMsg_FixAngle();
            if (object.relative != null)
                message.relative = Boolean(object.relative);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CSVCMsg_FixAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FixAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {CSVCMsg_FixAngle} message CSVCMsg_FixAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FixAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relative = false;
                object.angle = null;
            }
            if (message.relative != null && message.hasOwnProperty("relative"))
                object.relative = message.relative;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FixAngle to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FixAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FixAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_FixAngle;
    })();
    
    $root.CSVCMsg_CrosshairAngle = (function() {
    
        /**
         * Properties of a CSVCMsg_CrosshairAngle.
         * @exports ICSVCMsg_CrosshairAngle
         * @interface ICSVCMsg_CrosshairAngle
         * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle
         */
    
        /**
         * Constructs a new CSVCMsg_CrosshairAngle.
         * @exports CSVCMsg_CrosshairAngle
         * @classdesc Represents a CSVCMsg_CrosshairAngle.
         * @implements ICSVCMsg_CrosshairAngle
         * @constructor
         * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
         */
        function CSVCMsg_CrosshairAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CrosshairAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CSVCMsg_CrosshairAngle
         * @instance
         */
        CSVCMsg_CrosshairAngle.prototype.angle = null;
    
        /**
         * Creates a new CSVCMsg_CrosshairAngle instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle instance
         */
        CSVCMsg_CrosshairAngle.create = function create(properties) {
            return new CSVCMsg_CrosshairAngle(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CrosshairAngle message. Does not implicitly {@link CSVCMsg_CrosshairAngle.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CrosshairAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CrosshairAngle message, length delimited. Does not implicitly {@link CSVCMsg_CrosshairAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CrosshairAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CrosshairAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CrosshairAngle message.
         * @function verify
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CrosshairAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CrosshairAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         */
        CSVCMsg_CrosshairAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CrosshairAngle)
                return object;
            var message = new $root.CSVCMsg_CrosshairAngle();
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CSVCMsg_CrosshairAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CrosshairAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {CSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CrosshairAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.angle = null;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CrosshairAngle to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CrosshairAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CrosshairAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_CrosshairAngle;
    })();
    
    $root.CSVCMsg_BSPDecal = (function() {
    
        /**
         * Properties of a CSVCMsg_BSPDecal.
         * @exports ICSVCMsg_BSPDecal
         * @interface ICSVCMsg_BSPDecal
         * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos
         * @property {number|null} [decal_texture_index] CSVCMsg_BSPDecal decal_texture_index
         * @property {number|null} [entity_index] CSVCMsg_BSPDecal entity_index
         * @property {number|null} [model_index] CSVCMsg_BSPDecal model_index
         * @property {boolean|null} [low_priority] CSVCMsg_BSPDecal low_priority
         */
    
        /**
         * Constructs a new CSVCMsg_BSPDecal.
         * @exports CSVCMsg_BSPDecal
         * @classdesc Represents a CSVCMsg_BSPDecal.
         * @implements ICSVCMsg_BSPDecal
         * @constructor
         * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
         */
        function CSVCMsg_BSPDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_BSPDecal pos.
         * @member {ICMsgVector|null|undefined} pos
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.pos = null;
    
        /**
         * CSVCMsg_BSPDecal decal_texture_index.
         * @member {number} decal_texture_index
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.decal_texture_index = 0;
    
        /**
         * CSVCMsg_BSPDecal entity_index.
         * @member {number} entity_index
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.entity_index = 0;
    
        /**
         * CSVCMsg_BSPDecal model_index.
         * @member {number} model_index
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.model_index = 0;
    
        /**
         * CSVCMsg_BSPDecal low_priority.
         * @member {boolean} low_priority
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.low_priority = false;
    
        /**
         * Creates a new CSVCMsg_BSPDecal instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal instance
         */
        CSVCMsg_BSPDecal.create = function create(properties) {
            return new CSVCMsg_BSPDecal(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_BSPDecal message. Does not implicitly {@link CSVCMsg_BSPDecal.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal} message CSVCMsg_BSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_BSPDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.CMsgVector.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.decal_texture_index != null && Object.hasOwnProperty.call(message, "decal_texture_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decal_texture_index);
            if (message.entity_index != null && Object.hasOwnProperty.call(message, "entity_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entity_index);
            if (message.model_index != null && Object.hasOwnProperty.call(message, "model_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.model_index);
            if (message.low_priority != null && Object.hasOwnProperty.call(message, "low_priority"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.low_priority);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_BSPDecal message, length delimited. Does not implicitly {@link CSVCMsg_BSPDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal} message CSVCMsg_BSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_BSPDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_BSPDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.decal_texture_index = reader.int32();
                    break;
                case 3:
                    message.entity_index = reader.int32();
                    break;
                case 4:
                    message.model_index = reader.int32();
                    break;
                case 5:
                    message.low_priority = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_BSPDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_BSPDecal message.
         * @function verify
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_BSPDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.CMsgVector.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.decal_texture_index != null && message.hasOwnProperty("decal_texture_index"))
                if (!$util.isInteger(message.decal_texture_index))
                    return "decal_texture_index: integer expected";
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                if (!$util.isInteger(message.entity_index))
                    return "entity_index: integer expected";
            if (message.model_index != null && message.hasOwnProperty("model_index"))
                if (!$util.isInteger(message.model_index))
                    return "model_index: integer expected";
            if (message.low_priority != null && message.hasOwnProperty("low_priority"))
                if (typeof message.low_priority !== "boolean")
                    return "low_priority: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_BSPDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         */
        CSVCMsg_BSPDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_BSPDecal)
                return object;
            var message = new $root.CSVCMsg_BSPDecal();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".CSVCMsg_BSPDecal.pos: object expected");
                message.pos = $root.CMsgVector.fromObject(object.pos);
            }
            if (object.decal_texture_index != null)
                message.decal_texture_index = object.decal_texture_index | 0;
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            if (object.model_index != null)
                message.model_index = object.model_index | 0;
            if (object.low_priority != null)
                message.low_priority = Boolean(object.low_priority);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_BSPDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {CSVCMsg_BSPDecal} message CSVCMsg_BSPDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_BSPDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.decal_texture_index = 0;
                object.entity_index = 0;
                object.model_index = 0;
                object.low_priority = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.CMsgVector.toObject(message.pos, options);
            if (message.decal_texture_index != null && message.hasOwnProperty("decal_texture_index"))
                object.decal_texture_index = message.decal_texture_index;
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            if (message.model_index != null && message.hasOwnProperty("model_index"))
                object.model_index = message.model_index;
            if (message.low_priority != null && message.hasOwnProperty("low_priority"))
                object.low_priority = message.low_priority;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_BSPDecal to JSON.
         * @function toJSON
         * @memberof CSVCMsg_BSPDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_BSPDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_BSPDecal;
    })();
    
    $root.CSVCMsg_SplitScreen = (function() {
    
        /**
         * Properties of a CSVCMsg_SplitScreen.
         * @exports ICSVCMsg_SplitScreen
         * @interface ICSVCMsg_SplitScreen
         * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type
         * @property {number|null} [slot] CSVCMsg_SplitScreen slot
         * @property {number|null} [player_index] CSVCMsg_SplitScreen player_index
         */
    
        /**
         * Constructs a new CSVCMsg_SplitScreen.
         * @exports CSVCMsg_SplitScreen
         * @classdesc Represents a CSVCMsg_SplitScreen.
         * @implements ICSVCMsg_SplitScreen
         * @constructor
         * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
         */
        function CSVCMsg_SplitScreen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SplitScreen type.
         * @member {ESplitScreenMessageType} type
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.type = 0;
    
        /**
         * CSVCMsg_SplitScreen slot.
         * @member {number} slot
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.slot = 0;
    
        /**
         * CSVCMsg_SplitScreen player_index.
         * @member {number} player_index
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.player_index = 0;
    
        /**
         * Creates a new CSVCMsg_SplitScreen instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen instance
         */
        CSVCMsg_SplitScreen.create = function create(properties) {
            return new CSVCMsg_SplitScreen(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SplitScreen message. Does not implicitly {@link CSVCMsg_SplitScreen.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen} message CSVCMsg_SplitScreen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SplitScreen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot);
            if (message.player_index != null && Object.hasOwnProperty.call(message, "player_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.player_index);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SplitScreen message, length delimited. Does not implicitly {@link CSVCMsg_SplitScreen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen} message CSVCMsg_SplitScreen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SplitScreen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SplitScreen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.slot = reader.int32();
                    break;
                case 3:
                    message.player_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SplitScreen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SplitScreen message.
         * @function verify
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SplitScreen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            if (message.player_index != null && message.hasOwnProperty("player_index"))
                if (!$util.isInteger(message.player_index))
                    return "player_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SplitScreen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         */
        CSVCMsg_SplitScreen.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SplitScreen)
                return object;
            var message = new $root.CSVCMsg_SplitScreen();
            switch (object.type) {
            case "MSG_SPLITSCREEN_ADDUSER":
            case 0:
                message.type = 0;
                break;
            case "MSG_SPLITSCREEN_REMOVEUSER":
            case 1:
                message.type = 1;
                break;
            }
            if (object.slot != null)
                message.slot = object.slot | 0;
            if (object.player_index != null)
                message.player_index = object.player_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SplitScreen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {CSVCMsg_SplitScreen} message CSVCMsg_SplitScreen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SplitScreen.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "MSG_SPLITSCREEN_ADDUSER" : 0;
                object.slot = 0;
                object.player_index = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ESplitScreenMessageType[message.type] : message.type;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.player_index != null && message.hasOwnProperty("player_index"))
                object.player_index = message.player_index;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SplitScreen to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SplitScreen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SplitScreen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_SplitScreen;
    })();
    
    $root.CSVCMsg_GetCvarValue = (function() {
    
        /**
         * Properties of a CSVCMsg_GetCvarValue.
         * @exports ICSVCMsg_GetCvarValue
         * @interface ICSVCMsg_GetCvarValue
         * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie
         * @property {string|null} [cvar_name] CSVCMsg_GetCvarValue cvar_name
         */
    
        /**
         * Constructs a new CSVCMsg_GetCvarValue.
         * @exports CSVCMsg_GetCvarValue
         * @classdesc Represents a CSVCMsg_GetCvarValue.
         * @implements ICSVCMsg_GetCvarValue
         * @constructor
         * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
         */
        function CSVCMsg_GetCvarValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GetCvarValue cookie.
         * @member {number} cookie
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         */
        CSVCMsg_GetCvarValue.prototype.cookie = 0;
    
        /**
         * CSVCMsg_GetCvarValue cvar_name.
         * @member {string} cvar_name
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         */
        CSVCMsg_GetCvarValue.prototype.cvar_name = "";
    
        /**
         * Creates a new CSVCMsg_GetCvarValue instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue instance
         */
        CSVCMsg_GetCvarValue.create = function create(properties) {
            return new CSVCMsg_GetCvarValue(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GetCvarValue message. Does not implicitly {@link CSVCMsg_GetCvarValue.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GetCvarValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cookie);
            if (message.cvar_name != null && Object.hasOwnProperty.call(message, "cvar_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cvar_name);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GetCvarValue message, length delimited. Does not implicitly {@link CSVCMsg_GetCvarValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GetCvarValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GetCvarValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.cvar_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GetCvarValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GetCvarValue message.
         * @function verify
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GetCvarValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                if (!$util.isInteger(message.cookie))
                    return "cookie: integer expected";
            if (message.cvar_name != null && message.hasOwnProperty("cvar_name"))
                if (!$util.isString(message.cvar_name))
                    return "cvar_name: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GetCvarValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         */
        CSVCMsg_GetCvarValue.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GetCvarValue)
                return object;
            var message = new $root.CSVCMsg_GetCvarValue();
            if (object.cookie != null)
                message.cookie = object.cookie | 0;
            if (object.cvar_name != null)
                message.cvar_name = String(object.cvar_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GetCvarValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {CSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GetCvarValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cookie = 0;
                object.cvar_name = "";
            }
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                object.cookie = message.cookie;
            if (message.cvar_name != null && message.hasOwnProperty("cvar_name"))
                object.cvar_name = message.cvar_name;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GetCvarValue to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GetCvarValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GetCvarValue;
    })();
    
    $root.CSVCMsg_Menu = (function() {
    
        /**
         * Properties of a CSVCMsg_Menu.
         * @exports ICSVCMsg_Menu
         * @interface ICSVCMsg_Menu
         * @property {number|null} [dialog_type] CSVCMsg_Menu dialog_type
         * @property {Uint8Array|null} [menu_key_values] CSVCMsg_Menu menu_key_values
         */
    
        /**
         * Constructs a new CSVCMsg_Menu.
         * @exports CSVCMsg_Menu
         * @classdesc Represents a CSVCMsg_Menu.
         * @implements ICSVCMsg_Menu
         * @constructor
         * @param {ICSVCMsg_Menu=} [properties] Properties to set
         */
        function CSVCMsg_Menu(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Menu dialog_type.
         * @member {number} dialog_type
         * @memberof CSVCMsg_Menu
         * @instance
         */
        CSVCMsg_Menu.prototype.dialog_type = 0;
    
        /**
         * CSVCMsg_Menu menu_key_values.
         * @member {Uint8Array} menu_key_values
         * @memberof CSVCMsg_Menu
         * @instance
         */
        CSVCMsg_Menu.prototype.menu_key_values = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_Menu instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu=} [properties] Properties to set
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu instance
         */
        CSVCMsg_Menu.create = function create(properties) {
            return new CSVCMsg_Menu(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Menu message. Does not implicitly {@link CSVCMsg_Menu.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu} message CSVCMsg_Menu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Menu.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dialog_type != null && Object.hasOwnProperty.call(message, "dialog_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dialog_type);
            if (message.menu_key_values != null && Object.hasOwnProperty.call(message, "menu_key_values"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.menu_key_values);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Menu message, length delimited. Does not implicitly {@link CSVCMsg_Menu.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu} message CSVCMsg_Menu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Menu.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Menu message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Menu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Menu.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dialog_type = reader.int32();
                    break;
                case 2:
                    message.menu_key_values = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Menu message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Menu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Menu.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Menu message.
         * @function verify
         * @memberof CSVCMsg_Menu
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Menu.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dialog_type != null && message.hasOwnProperty("dialog_type"))
                if (!$util.isInteger(message.dialog_type))
                    return "dialog_type: integer expected";
            if (message.menu_key_values != null && message.hasOwnProperty("menu_key_values"))
                if (!(message.menu_key_values && typeof message.menu_key_values.length === "number" || $util.isString(message.menu_key_values)))
                    return "menu_key_values: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Menu message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Menu
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         */
        CSVCMsg_Menu.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Menu)
                return object;
            var message = new $root.CSVCMsg_Menu();
            if (object.dialog_type != null)
                message.dialog_type = object.dialog_type | 0;
            if (object.menu_key_values != null)
                if (typeof object.menu_key_values === "string")
                    $util.base64.decode(object.menu_key_values, message.menu_key_values = $util.newBuffer($util.base64.length(object.menu_key_values)), 0);
                else if (object.menu_key_values.length)
                    message.menu_key_values = object.menu_key_values;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Menu message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Menu
         * @static
         * @param {CSVCMsg_Menu} message CSVCMsg_Menu
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Menu.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dialog_type = 0;
                if (options.bytes === String)
                    object.menu_key_values = "";
                else {
                    object.menu_key_values = [];
                    if (options.bytes !== Array)
                        object.menu_key_values = $util.newBuffer(object.menu_key_values);
                }
            }
            if (message.dialog_type != null && message.hasOwnProperty("dialog_type"))
                object.dialog_type = message.dialog_type;
            if (message.menu_key_values != null && message.hasOwnProperty("menu_key_values"))
                object.menu_key_values = options.bytes === String ? $util.base64.encode(message.menu_key_values, 0, message.menu_key_values.length) : options.bytes === Array ? Array.prototype.slice.call(message.menu_key_values) : message.menu_key_values;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Menu to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Menu
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Menu.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Menu;
    })();
    
    $root.CSVCMsg_SendTable = (function() {
    
        /**
         * Properties of a CSVCMsg_SendTable.
         * @exports ICSVCMsg_SendTable
         * @interface ICSVCMsg_SendTable
         * @property {boolean|null} [is_end] CSVCMsg_SendTable is_end
         * @property {string|null} [net_table_name] CSVCMsg_SendTable net_table_name
         * @property {boolean|null} [needs_decoder] CSVCMsg_SendTable needs_decoder
         * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props
         */
    
        /**
         * Constructs a new CSVCMsg_SendTable.
         * @exports CSVCMsg_SendTable
         * @classdesc Represents a CSVCMsg_SendTable.
         * @implements ICSVCMsg_SendTable
         * @constructor
         * @param {ICSVCMsg_SendTable=} [properties] Properties to set
         */
        function CSVCMsg_SendTable(properties) {
            this.props = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SendTable is_end.
         * @member {boolean} is_end
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.is_end = false;
    
        /**
         * CSVCMsg_SendTable net_table_name.
         * @member {string} net_table_name
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.net_table_name = "";
    
        /**
         * CSVCMsg_SendTable needs_decoder.
         * @member {boolean} needs_decoder
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.needs_decoder = false;
    
        /**
         * CSVCMsg_SendTable props.
         * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.props = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_SendTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable=} [properties] Properties to set
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable instance
         */
        CSVCMsg_SendTable.create = function create(properties) {
            return new CSVCMsg_SendTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SendTable message. Does not implicitly {@link CSVCMsg_SendTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable} message CSVCMsg_SendTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SendTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_end != null && Object.hasOwnProperty.call(message, "is_end"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_end);
            if (message.net_table_name != null && Object.hasOwnProperty.call(message, "net_table_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.net_table_name);
            if (message.needs_decoder != null && Object.hasOwnProperty.call(message, "needs_decoder"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needs_decoder);
            if (message.props != null && message.props.length)
                for (var i = 0; i < message.props.length; ++i)
                    $root.CSVCMsg_SendTable.sendprop_t.encode(message.props[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SendTable message, length delimited. Does not implicitly {@link CSVCMsg_SendTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable} message CSVCMsg_SendTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SendTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SendTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_end = reader.bool();
                    break;
                case 2:
                    message.net_table_name = reader.string();
                    break;
                case 3:
                    message.needs_decoder = reader.bool();
                    break;
                case 4:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SendTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SendTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SendTable message.
         * @function verify
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SendTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_end != null && message.hasOwnProperty("is_end"))
                if (typeof message.is_end !== "boolean")
                    return "is_end: boolean expected";
            if (message.net_table_name != null && message.hasOwnProperty("net_table_name"))
                if (!$util.isString(message.net_table_name))
                    return "net_table_name: string expected";
            if (message.needs_decoder != null && message.hasOwnProperty("needs_decoder"))
                if (typeof message.needs_decoder !== "boolean")
                    return "needs_decoder: boolean expected";
            if (message.props != null && message.hasOwnProperty("props")) {
                if (!Array.isArray(message.props))
                    return "props: array expected";
                for (var i = 0; i < message.props.length; ++i) {
                    var error = $root.CSVCMsg_SendTable.sendprop_t.verify(message.props[i]);
                    if (error)
                        return "props." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SendTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         */
        CSVCMsg_SendTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SendTable)
                return object;
            var message = new $root.CSVCMsg_SendTable();
            if (object.is_end != null)
                message.is_end = Boolean(object.is_end);
            if (object.net_table_name != null)
                message.net_table_name = String(object.net_table_name);
            if (object.needs_decoder != null)
                message.needs_decoder = Boolean(object.needs_decoder);
            if (object.props) {
                if (!Array.isArray(object.props))
                    throw TypeError(".CSVCMsg_SendTable.props: array expected");
                message.props = [];
                for (var i = 0; i < object.props.length; ++i) {
                    if (typeof object.props[i] !== "object")
                        throw TypeError(".CSVCMsg_SendTable.props: object expected");
                    message.props[i] = $root.CSVCMsg_SendTable.sendprop_t.fromObject(object.props[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SendTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {CSVCMsg_SendTable} message CSVCMsg_SendTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SendTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.props = [];
            if (options.defaults) {
                object.is_end = false;
                object.net_table_name = "";
                object.needs_decoder = false;
            }
            if (message.is_end != null && message.hasOwnProperty("is_end"))
                object.is_end = message.is_end;
            if (message.net_table_name != null && message.hasOwnProperty("net_table_name"))
                object.net_table_name = message.net_table_name;
            if (message.needs_decoder != null && message.hasOwnProperty("needs_decoder"))
                object.needs_decoder = message.needs_decoder;
            if (message.props && message.props.length) {
                object.props = [];
                for (var j = 0; j < message.props.length; ++j)
                    object.props[j] = $root.CSVCMsg_SendTable.sendprop_t.toObject(message.props[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SendTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SendTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SendTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_SendTable.sendprop_t = (function() {
    
            /**
             * Properties of a sendprop_t.
             * @memberof CSVCMsg_SendTable
             * @interface Isendprop_t
             * @property {number|null} [type] sendprop_t type
             * @property {string|null} [var_name] sendprop_t var_name
             * @property {number|null} [flags] sendprop_t flags
             * @property {number|null} [priority] sendprop_t priority
             * @property {string|null} [dt_name] sendprop_t dt_name
             * @property {number|null} [num_elements] sendprop_t num_elements
             * @property {number|null} [low_value] sendprop_t low_value
             * @property {number|null} [high_value] sendprop_t high_value
             * @property {number|null} [num_bits] sendprop_t num_bits
             */
    
            /**
             * Constructs a new sendprop_t.
             * @memberof CSVCMsg_SendTable
             * @classdesc Represents a sendprop_t.
             * @implements Isendprop_t
             * @constructor
             * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
             */
            function sendprop_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * sendprop_t type.
             * @member {number} type
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.type = 0;
    
            /**
             * sendprop_t var_name.
             * @member {string} var_name
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.var_name = "";
    
            /**
             * sendprop_t flags.
             * @member {number} flags
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.flags = 0;
    
            /**
             * sendprop_t priority.
             * @member {number} priority
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.priority = 0;
    
            /**
             * sendprop_t dt_name.
             * @member {string} dt_name
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.dt_name = "";
    
            /**
             * sendprop_t num_elements.
             * @member {number} num_elements
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.num_elements = 0;
    
            /**
             * sendprop_t low_value.
             * @member {number} low_value
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.low_value = 0;
    
            /**
             * sendprop_t high_value.
             * @member {number} high_value
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.high_value = 0;
    
            /**
             * sendprop_t num_bits.
             * @member {number} num_bits
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.num_bits = 0;
    
            /**
             * Creates a new sendprop_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t instance
             */
            sendprop_t.create = function create(properties) {
                return new sendprop_t(properties);
            };
    
            /**
             * Encodes the specified sendprop_t message. Does not implicitly {@link CSVCMsg_SendTable.sendprop_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t} message sendprop_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sendprop_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.var_name != null && Object.hasOwnProperty.call(message, "var_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.var_name);
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flags);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.priority);
                if (message.dt_name != null && Object.hasOwnProperty.call(message, "dt_name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.dt_name);
                if (message.num_elements != null && Object.hasOwnProperty.call(message, "num_elements"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.num_elements);
                if (message.low_value != null && Object.hasOwnProperty.call(message, "low_value"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.low_value);
                if (message.high_value != null && Object.hasOwnProperty.call(message, "high_value"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.high_value);
                if (message.num_bits != null && Object.hasOwnProperty.call(message, "num_bits"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.num_bits);
                return writer;
            };
    
            /**
             * Encodes the specified sendprop_t message, length delimited. Does not implicitly {@link CSVCMsg_SendTable.sendprop_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t} message sendprop_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sendprop_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a sendprop_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sendprop_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.var_name = reader.string();
                        break;
                    case 3:
                        message.flags = reader.int32();
                        break;
                    case 4:
                        message.priority = reader.int32();
                        break;
                    case 5:
                        message.dt_name = reader.string();
                        break;
                    case 6:
                        message.num_elements = reader.int32();
                        break;
                    case 7:
                        message.low_value = reader.float();
                        break;
                    case 8:
                        message.high_value = reader.float();
                        break;
                    case 9:
                        message.num_bits = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a sendprop_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sendprop_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a sendprop_t message.
             * @function verify
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sendprop_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.var_name != null && message.hasOwnProperty("var_name"))
                    if (!$util.isString(message.var_name))
                        return "var_name: string expected";
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.dt_name != null && message.hasOwnProperty("dt_name"))
                    if (!$util.isString(message.dt_name))
                        return "dt_name: string expected";
                if (message.num_elements != null && message.hasOwnProperty("num_elements"))
                    if (!$util.isInteger(message.num_elements))
                        return "num_elements: integer expected";
                if (message.low_value != null && message.hasOwnProperty("low_value"))
                    if (typeof message.low_value !== "number")
                        return "low_value: number expected";
                if (message.high_value != null && message.hasOwnProperty("high_value"))
                    if (typeof message.high_value !== "number")
                        return "high_value: number expected";
                if (message.num_bits != null && message.hasOwnProperty("num_bits"))
                    if (!$util.isInteger(message.num_bits))
                        return "num_bits: integer expected";
                return null;
            };
    
            /**
             * Creates a sendprop_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             */
            sendprop_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_SendTable.sendprop_t)
                    return object;
                var message = new $root.CSVCMsg_SendTable.sendprop_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.var_name != null)
                    message.var_name = String(object.var_name);
                if (object.flags != null)
                    message.flags = object.flags | 0;
                if (object.priority != null)
                    message.priority = object.priority | 0;
                if (object.dt_name != null)
                    message.dt_name = String(object.dt_name);
                if (object.num_elements != null)
                    message.num_elements = object.num_elements | 0;
                if (object.low_value != null)
                    message.low_value = Number(object.low_value);
                if (object.high_value != null)
                    message.high_value = Number(object.high_value);
                if (object.num_bits != null)
                    message.num_bits = object.num_bits | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a sendprop_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.sendprop_t} message sendprop_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            sendprop_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.var_name = "";
                    object.flags = 0;
                    object.priority = 0;
                    object.dt_name = "";
                    object.num_elements = 0;
                    object.low_value = 0;
                    object.high_value = 0;
                    object.num_bits = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.var_name != null && message.hasOwnProperty("var_name"))
                    object.var_name = message.var_name;
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.dt_name != null && message.hasOwnProperty("dt_name"))
                    object.dt_name = message.dt_name;
                if (message.num_elements != null && message.hasOwnProperty("num_elements"))
                    object.num_elements = message.num_elements;
                if (message.low_value != null && message.hasOwnProperty("low_value"))
                    object.low_value = options.json && !isFinite(message.low_value) ? String(message.low_value) : message.low_value;
                if (message.high_value != null && message.hasOwnProperty("high_value"))
                    object.high_value = options.json && !isFinite(message.high_value) ? String(message.high_value) : message.high_value;
                if (message.num_bits != null && message.hasOwnProperty("num_bits"))
                    object.num_bits = message.num_bits;
                return object;
            };
    
            /**
             * Converts this sendprop_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            sendprop_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return sendprop_t;
        })();
    
        return CSVCMsg_SendTable;
    })();
    
    $root.CSVCMsg_GameEventList = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEventList.
         * @exports ICSVCMsg_GameEventList
         * @interface ICSVCMsg_GameEventList
         * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors
         */
    
        /**
         * Constructs a new CSVCMsg_GameEventList.
         * @exports CSVCMsg_GameEventList
         * @classdesc Represents a CSVCMsg_GameEventList.
         * @implements ICSVCMsg_GameEventList
         * @constructor
         * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
         */
        function CSVCMsg_GameEventList(properties) {
            this.descriptors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEventList descriptors.
         * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors
         * @memberof CSVCMsg_GameEventList
         * @instance
         */
        CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEventList instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList instance
         */
        CSVCMsg_GameEventList.create = function create(properties) {
            return new CSVCMsg_GameEventList(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEventList message. Does not implicitly {@link CSVCMsg_GameEventList.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList} message CSVCMsg_GameEventList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEventList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.descriptors != null && message.descriptors.length)
                for (var i = 0; i < message.descriptors.length; ++i)
                    $root.CSVCMsg_GameEventList.descriptor_t.encode(message.descriptors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEventList message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList} message CSVCMsg_GameEventList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEventList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEventList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.descriptors && message.descriptors.length))
                        message.descriptors = [];
                    message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEventList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEventList message.
         * @function verify
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEventList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.descriptors != null && message.hasOwnProperty("descriptors")) {
                if (!Array.isArray(message.descriptors))
                    return "descriptors: array expected";
                for (var i = 0; i < message.descriptors.length; ++i) {
                    var error = $root.CSVCMsg_GameEventList.descriptor_t.verify(message.descriptors[i]);
                    if (error)
                        return "descriptors." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEventList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         */
        CSVCMsg_GameEventList.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEventList)
                return object;
            var message = new $root.CSVCMsg_GameEventList();
            if (object.descriptors) {
                if (!Array.isArray(object.descriptors))
                    throw TypeError(".CSVCMsg_GameEventList.descriptors: array expected");
                message.descriptors = [];
                for (var i = 0; i < object.descriptors.length; ++i) {
                    if (typeof object.descriptors[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEventList.descriptors: object expected");
                    message.descriptors[i] = $root.CSVCMsg_GameEventList.descriptor_t.fromObject(object.descriptors[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEventList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {CSVCMsg_GameEventList} message CSVCMsg_GameEventList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEventList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.descriptors = [];
            if (message.descriptors && message.descriptors.length) {
                object.descriptors = [];
                for (var j = 0; j < message.descriptors.length; ++j)
                    object.descriptors[j] = $root.CSVCMsg_GameEventList.descriptor_t.toObject(message.descriptors[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEventList to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEventList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEventList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEventList.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEventList
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [name] key_t name
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEventList
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t name.
             * @member {string} name
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             */
            key_t.prototype.name = "";
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEventList.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEventList.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEventList.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEventList.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.name = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        CSVCMsg_GameEventList.descriptor_t = (function() {
    
            /**
             * Properties of a descriptor_t.
             * @memberof CSVCMsg_GameEventList
             * @interface Idescriptor_t
             * @property {number|null} [eventid] descriptor_t eventid
             * @property {string|null} [name] descriptor_t name
             * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys
             */
    
            /**
             * Constructs a new descriptor_t.
             * @memberof CSVCMsg_GameEventList
             * @classdesc Represents a descriptor_t.
             * @implements Idescriptor_t
             * @constructor
             * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
             */
            function descriptor_t(properties) {
                this.keys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * descriptor_t eventid.
             * @member {number} eventid
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.eventid = 0;
    
            /**
             * descriptor_t name.
             * @member {string} name
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.name = "";
    
            /**
             * descriptor_t keys.
             * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.keys = $util.emptyArray;
    
            /**
             * Creates a new descriptor_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t instance
             */
            descriptor_t.create = function create(properties) {
                return new descriptor_t(properties);
            };
    
            /**
             * Encodes the specified descriptor_t message. Does not implicitly {@link CSVCMsg_GameEventList.descriptor_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t} message descriptor_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            descriptor_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventid);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.keys != null && message.keys.length)
                    for (var i = 0; i < message.keys.length; ++i)
                        $root.CSVCMsg_GameEventList.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified descriptor_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.descriptor_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t} message descriptor_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            descriptor_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a descriptor_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            descriptor_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eventid = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a descriptor_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            descriptor_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a descriptor_t message.
             * @function verify
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            descriptor_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    if (!$util.isInteger(message.eventid))
                        return "eventid: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (var i = 0; i < message.keys.length; ++i) {
                        var error = $root.CSVCMsg_GameEventList.key_t.verify(message.keys[i]);
                        if (error)
                            return "keys." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a descriptor_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             */
            descriptor_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEventList.descriptor_t)
                    return object;
                var message = new $root.CSVCMsg_GameEventList.descriptor_t();
                if (object.eventid != null)
                    message.eventid = object.eventid | 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".CSVCMsg_GameEventList.descriptor_t.keys: array expected");
                    message.keys = [];
                    for (var i = 0; i < object.keys.length; ++i) {
                        if (typeof object.keys[i] !== "object")
                            throw TypeError(".CSVCMsg_GameEventList.descriptor_t.keys: object expected");
                        message.keys[i] = $root.CSVCMsg_GameEventList.key_t.fromObject(object.keys[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a descriptor_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.descriptor_t} message descriptor_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            descriptor_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (options.defaults) {
                    object.eventid = 0;
                    object.name = "";
                }
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    object.eventid = message.eventid;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (var j = 0; j < message.keys.length; ++j)
                        object.keys[j] = $root.CSVCMsg_GameEventList.key_t.toObject(message.keys[j], options);
                }
                return object;
            };
    
            /**
             * Converts this descriptor_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            descriptor_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return descriptor_t;
        })();
    
        return CSVCMsg_GameEventList;
    })();
    
    $root.CSVCMsg_PacketEntities = (function() {
    
        /**
         * Properties of a CSVCMsg_PacketEntities.
         * @exports ICSVCMsg_PacketEntities
         * @interface ICSVCMsg_PacketEntities
         * @property {number|null} [max_entries] CSVCMsg_PacketEntities max_entries
         * @property {number|null} [updated_entries] CSVCMsg_PacketEntities updated_entries
         * @property {boolean|null} [is_delta] CSVCMsg_PacketEntities is_delta
         * @property {boolean|null} [update_baseline] CSVCMsg_PacketEntities update_baseline
         * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline
         * @property {number|null} [delta_from] CSVCMsg_PacketEntities delta_from
         * @property {Uint8Array|null} [entity_data] CSVCMsg_PacketEntities entity_data
         * @property {boolean|null} [pending_full_frame] CSVCMsg_PacketEntities pending_full_frame
         * @property {number|null} [active_spawngroup_handle] CSVCMsg_PacketEntities active_spawngroup_handle
         * @property {number|null} [max_spawngroup_creationsequence] CSVCMsg_PacketEntities max_spawngroup_creationsequence
         * @property {number|null} [last_cmd_number] CSVCMsg_PacketEntities last_cmd_number
         * @property {number|null} [server_tick] CSVCMsg_PacketEntities server_tick
         * @property {Uint8Array|null} [serialized_entities] CSVCMsg_PacketEntities serialized_entities
         * @property {CSVCMsg_PacketEntities.Icommand_queue_info_t|null} [command_queue_info] CSVCMsg_PacketEntities command_queue_info
         */
    
        /**
         * Constructs a new CSVCMsg_PacketEntities.
         * @exports CSVCMsg_PacketEntities
         * @classdesc Represents a CSVCMsg_PacketEntities.
         * @implements ICSVCMsg_PacketEntities
         * @constructor
         * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
         */
        function CSVCMsg_PacketEntities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PacketEntities max_entries.
         * @member {number} max_entries
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.max_entries = 0;
    
        /**
         * CSVCMsg_PacketEntities updated_entries.
         * @member {number} updated_entries
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.updated_entries = 0;
    
        /**
         * CSVCMsg_PacketEntities is_delta.
         * @member {boolean} is_delta
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.is_delta = false;
    
        /**
         * CSVCMsg_PacketEntities update_baseline.
         * @member {boolean} update_baseline
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.update_baseline = false;
    
        /**
         * CSVCMsg_PacketEntities baseline.
         * @member {number} baseline
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.baseline = 0;
    
        /**
         * CSVCMsg_PacketEntities delta_from.
         * @member {number} delta_from
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.delta_from = 0;
    
        /**
         * CSVCMsg_PacketEntities entity_data.
         * @member {Uint8Array} entity_data
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.entity_data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_PacketEntities pending_full_frame.
         * @member {boolean} pending_full_frame
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.pending_full_frame = false;
    
        /**
         * CSVCMsg_PacketEntities active_spawngroup_handle.
         * @member {number} active_spawngroup_handle
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.active_spawngroup_handle = 0;
    
        /**
         * CSVCMsg_PacketEntities max_spawngroup_creationsequence.
         * @member {number} max_spawngroup_creationsequence
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.max_spawngroup_creationsequence = 0;
    
        /**
         * CSVCMsg_PacketEntities last_cmd_number.
         * @member {number} last_cmd_number
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.last_cmd_number = 0;
    
        /**
         * CSVCMsg_PacketEntities server_tick.
         * @member {number} server_tick
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.server_tick = 0;
    
        /**
         * CSVCMsg_PacketEntities serialized_entities.
         * @member {Uint8Array} serialized_entities
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.serialized_entities = $util.newBuffer([]);
    
        /**
         * CSVCMsg_PacketEntities command_queue_info.
         * @member {CSVCMsg_PacketEntities.Icommand_queue_info_t|null|undefined} command_queue_info
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.command_queue_info = null;
    
        /**
         * Creates a new CSVCMsg_PacketEntities instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities instance
         */
        CSVCMsg_PacketEntities.create = function create(properties) {
            return new CSVCMsg_PacketEntities(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketEntities message. Does not implicitly {@link CSVCMsg_PacketEntities.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities} message CSVCMsg_PacketEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketEntities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.max_entries != null && Object.hasOwnProperty.call(message, "max_entries"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.max_entries);
            if (message.updated_entries != null && Object.hasOwnProperty.call(message, "updated_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.updated_entries);
            if (message.is_delta != null && Object.hasOwnProperty.call(message, "is_delta"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_delta);
            if (message.update_baseline != null && Object.hasOwnProperty.call(message, "update_baseline"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.update_baseline);
            if (message.baseline != null && Object.hasOwnProperty.call(message, "baseline"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.baseline);
            if (message.delta_from != null && Object.hasOwnProperty.call(message, "delta_from"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.delta_from);
            if (message.entity_data != null && Object.hasOwnProperty.call(message, "entity_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.entity_data);
            if (message.pending_full_frame != null && Object.hasOwnProperty.call(message, "pending_full_frame"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.pending_full_frame);
            if (message.active_spawngroup_handle != null && Object.hasOwnProperty.call(message, "active_spawngroup_handle"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.active_spawngroup_handle);
            if (message.max_spawngroup_creationsequence != null && Object.hasOwnProperty.call(message, "max_spawngroup_creationsequence"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.max_spawngroup_creationsequence);
            if (message.last_cmd_number != null && Object.hasOwnProperty.call(message, "last_cmd_number"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.last_cmd_number);
            if (message.server_tick != null && Object.hasOwnProperty.call(message, "server_tick"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.server_tick);
            if (message.serialized_entities != null && Object.hasOwnProperty.call(message, "serialized_entities"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.serialized_entities);
            if (message.command_queue_info != null && Object.hasOwnProperty.call(message, "command_queue_info"))
                $root.CSVCMsg_PacketEntities.command_queue_info_t.encode(message.command_queue_info, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketEntities message, length delimited. Does not implicitly {@link CSVCMsg_PacketEntities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities} message CSVCMsg_PacketEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketEntities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketEntities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.max_entries = reader.int32();
                    break;
                case 2:
                    message.updated_entries = reader.int32();
                    break;
                case 3:
                    message.is_delta = reader.bool();
                    break;
                case 4:
                    message.update_baseline = reader.bool();
                    break;
                case 5:
                    message.baseline = reader.int32();
                    break;
                case 6:
                    message.delta_from = reader.int32();
                    break;
                case 7:
                    message.entity_data = reader.bytes();
                    break;
                case 8:
                    message.pending_full_frame = reader.bool();
                    break;
                case 9:
                    message.active_spawngroup_handle = reader.uint32();
                    break;
                case 10:
                    message.max_spawngroup_creationsequence = reader.uint32();
                    break;
                case 11:
                    message.last_cmd_number = reader.uint32();
                    break;
                case 12:
                    message.server_tick = reader.uint32();
                    break;
                case 13:
                    message.serialized_entities = reader.bytes();
                    break;
                case 14:
                    message.command_queue_info = $root.CSVCMsg_PacketEntities.command_queue_info_t.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketEntities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PacketEntities message.
         * @function verify
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PacketEntities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                if (!$util.isInteger(message.max_entries))
                    return "max_entries: integer expected";
            if (message.updated_entries != null && message.hasOwnProperty("updated_entries"))
                if (!$util.isInteger(message.updated_entries))
                    return "updated_entries: integer expected";
            if (message.is_delta != null && message.hasOwnProperty("is_delta"))
                if (typeof message.is_delta !== "boolean")
                    return "is_delta: boolean expected";
            if (message.update_baseline != null && message.hasOwnProperty("update_baseline"))
                if (typeof message.update_baseline !== "boolean")
                    return "update_baseline: boolean expected";
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                if (!$util.isInteger(message.baseline))
                    return "baseline: integer expected";
            if (message.delta_from != null && message.hasOwnProperty("delta_from"))
                if (!$util.isInteger(message.delta_from))
                    return "delta_from: integer expected";
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                if (!(message.entity_data && typeof message.entity_data.length === "number" || $util.isString(message.entity_data)))
                    return "entity_data: buffer expected";
            if (message.pending_full_frame != null && message.hasOwnProperty("pending_full_frame"))
                if (typeof message.pending_full_frame !== "boolean")
                    return "pending_full_frame: boolean expected";
            if (message.active_spawngroup_handle != null && message.hasOwnProperty("active_spawngroup_handle"))
                if (!$util.isInteger(message.active_spawngroup_handle))
                    return "active_spawngroup_handle: integer expected";
            if (message.max_spawngroup_creationsequence != null && message.hasOwnProperty("max_spawngroup_creationsequence"))
                if (!$util.isInteger(message.max_spawngroup_creationsequence))
                    return "max_spawngroup_creationsequence: integer expected";
            if (message.last_cmd_number != null && message.hasOwnProperty("last_cmd_number"))
                if (!$util.isInteger(message.last_cmd_number))
                    return "last_cmd_number: integer expected";
            if (message.server_tick != null && message.hasOwnProperty("server_tick"))
                if (!$util.isInteger(message.server_tick))
                    return "server_tick: integer expected";
            if (message.serialized_entities != null && message.hasOwnProperty("serialized_entities"))
                if (!(message.serialized_entities && typeof message.serialized_entities.length === "number" || $util.isString(message.serialized_entities)))
                    return "serialized_entities: buffer expected";
            if (message.command_queue_info != null && message.hasOwnProperty("command_queue_info")) {
                var error = $root.CSVCMsg_PacketEntities.command_queue_info_t.verify(message.command_queue_info);
                if (error)
                    return "command_queue_info." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PacketEntities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         */
        CSVCMsg_PacketEntities.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PacketEntities)
                return object;
            var message = new $root.CSVCMsg_PacketEntities();
            if (object.max_entries != null)
                message.max_entries = object.max_entries | 0;
            if (object.updated_entries != null)
                message.updated_entries = object.updated_entries | 0;
            if (object.is_delta != null)
                message.is_delta = Boolean(object.is_delta);
            if (object.update_baseline != null)
                message.update_baseline = Boolean(object.update_baseline);
            if (object.baseline != null)
                message.baseline = object.baseline | 0;
            if (object.delta_from != null)
                message.delta_from = object.delta_from | 0;
            if (object.entity_data != null)
                if (typeof object.entity_data === "string")
                    $util.base64.decode(object.entity_data, message.entity_data = $util.newBuffer($util.base64.length(object.entity_data)), 0);
                else if (object.entity_data.length)
                    message.entity_data = object.entity_data;
            if (object.pending_full_frame != null)
                message.pending_full_frame = Boolean(object.pending_full_frame);
            if (object.active_spawngroup_handle != null)
                message.active_spawngroup_handle = object.active_spawngroup_handle >>> 0;
            if (object.max_spawngroup_creationsequence != null)
                message.max_spawngroup_creationsequence = object.max_spawngroup_creationsequence >>> 0;
            if (object.last_cmd_number != null)
                message.last_cmd_number = object.last_cmd_number >>> 0;
            if (object.server_tick != null)
                message.server_tick = object.server_tick >>> 0;
            if (object.serialized_entities != null)
                if (typeof object.serialized_entities === "string")
                    $util.base64.decode(object.serialized_entities, message.serialized_entities = $util.newBuffer($util.base64.length(object.serialized_entities)), 0);
                else if (object.serialized_entities.length)
                    message.serialized_entities = object.serialized_entities;
            if (object.command_queue_info != null) {
                if (typeof object.command_queue_info !== "object")
                    throw TypeError(".CSVCMsg_PacketEntities.command_queue_info: object expected");
                message.command_queue_info = $root.CSVCMsg_PacketEntities.command_queue_info_t.fromObject(object.command_queue_info);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PacketEntities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {CSVCMsg_PacketEntities} message CSVCMsg_PacketEntities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PacketEntities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.max_entries = 0;
                object.updated_entries = 0;
                object.is_delta = false;
                object.update_baseline = false;
                object.baseline = 0;
                object.delta_from = 0;
                if (options.bytes === String)
                    object.entity_data = "";
                else {
                    object.entity_data = [];
                    if (options.bytes !== Array)
                        object.entity_data = $util.newBuffer(object.entity_data);
                }
                object.pending_full_frame = false;
                object.active_spawngroup_handle = 0;
                object.max_spawngroup_creationsequence = 0;
                object.last_cmd_number = 0;
                object.server_tick = 0;
                if (options.bytes === String)
                    object.serialized_entities = "";
                else {
                    object.serialized_entities = [];
                    if (options.bytes !== Array)
                        object.serialized_entities = $util.newBuffer(object.serialized_entities);
                }
                object.command_queue_info = null;
            }
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                object.max_entries = message.max_entries;
            if (message.updated_entries != null && message.hasOwnProperty("updated_entries"))
                object.updated_entries = message.updated_entries;
            if (message.is_delta != null && message.hasOwnProperty("is_delta"))
                object.is_delta = message.is_delta;
            if (message.update_baseline != null && message.hasOwnProperty("update_baseline"))
                object.update_baseline = message.update_baseline;
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                object.baseline = message.baseline;
            if (message.delta_from != null && message.hasOwnProperty("delta_from"))
                object.delta_from = message.delta_from;
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                object.entity_data = options.bytes === String ? $util.base64.encode(message.entity_data, 0, message.entity_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.entity_data) : message.entity_data;
            if (message.pending_full_frame != null && message.hasOwnProperty("pending_full_frame"))
                object.pending_full_frame = message.pending_full_frame;
            if (message.active_spawngroup_handle != null && message.hasOwnProperty("active_spawngroup_handle"))
                object.active_spawngroup_handle = message.active_spawngroup_handle;
            if (message.max_spawngroup_creationsequence != null && message.hasOwnProperty("max_spawngroup_creationsequence"))
                object.max_spawngroup_creationsequence = message.max_spawngroup_creationsequence;
            if (message.last_cmd_number != null && message.hasOwnProperty("last_cmd_number"))
                object.last_cmd_number = message.last_cmd_number;
            if (message.server_tick != null && message.hasOwnProperty("server_tick"))
                object.server_tick = message.server_tick;
            if (message.serialized_entities != null && message.hasOwnProperty("serialized_entities"))
                object.serialized_entities = options.bytes === String ? $util.base64.encode(message.serialized_entities, 0, message.serialized_entities.length) : options.bytes === Array ? Array.prototype.slice.call(message.serialized_entities) : message.serialized_entities;
            if (message.command_queue_info != null && message.hasOwnProperty("command_queue_info"))
                object.command_queue_info = $root.CSVCMsg_PacketEntities.command_queue_info_t.toObject(message.command_queue_info, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PacketEntities to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PacketEntities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PacketEntities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_PacketEntities.command_queue_info_t = (function() {
    
            /**
             * Properties of a command_queue_info_t.
             * @memberof CSVCMsg_PacketEntities
             * @interface Icommand_queue_info_t
             * @property {number|null} [commands_queued] command_queue_info_t commands_queued
             * @property {number|null} [command_queue_desired_size] command_queue_info_t command_queue_desired_size
             * @property {number|null} [starved_command_ticks] command_queue_info_t starved_command_ticks
             * @property {number|null} [time_dilation_percent] command_queue_info_t time_dilation_percent
             */
    
            /**
             * Constructs a new command_queue_info_t.
             * @memberof CSVCMsg_PacketEntities
             * @classdesc Represents a command_queue_info_t.
             * @implements Icommand_queue_info_t
             * @constructor
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t=} [properties] Properties to set
             */
            function command_queue_info_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * command_queue_info_t commands_queued.
             * @member {number} commands_queued
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.commands_queued = 0;
    
            /**
             * command_queue_info_t command_queue_desired_size.
             * @member {number} command_queue_desired_size
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.command_queue_desired_size = 0;
    
            /**
             * command_queue_info_t starved_command_ticks.
             * @member {number} starved_command_ticks
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.starved_command_ticks = 0;
    
            /**
             * command_queue_info_t time_dilation_percent.
             * @member {number} time_dilation_percent
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.time_dilation_percent = 0;
    
            /**
             * Creates a new command_queue_info_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t=} [properties] Properties to set
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t instance
             */
            command_queue_info_t.create = function create(properties) {
                return new command_queue_info_t(properties);
            };
    
            /**
             * Encodes the specified command_queue_info_t message. Does not implicitly {@link CSVCMsg_PacketEntities.command_queue_info_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t} message command_queue_info_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            command_queue_info_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commands_queued != null && Object.hasOwnProperty.call(message, "commands_queued"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.commands_queued);
                if (message.command_queue_desired_size != null && Object.hasOwnProperty.call(message, "command_queue_desired_size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.command_queue_desired_size);
                if (message.starved_command_ticks != null && Object.hasOwnProperty.call(message, "starved_command_ticks"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.starved_command_ticks);
                if (message.time_dilation_percent != null && Object.hasOwnProperty.call(message, "time_dilation_percent"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.time_dilation_percent);
                return writer;
            };
    
            /**
             * Encodes the specified command_queue_info_t message, length delimited. Does not implicitly {@link CSVCMsg_PacketEntities.command_queue_info_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t} message command_queue_info_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            command_queue_info_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a command_queue_info_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            command_queue_info_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities.command_queue_info_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.commands_queued = reader.uint32();
                        break;
                    case 2:
                        message.command_queue_desired_size = reader.uint32();
                        break;
                    case 3:
                        message.starved_command_ticks = reader.uint32();
                        break;
                    case 4:
                        message.time_dilation_percent = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a command_queue_info_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            command_queue_info_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a command_queue_info_t message.
             * @function verify
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            command_queue_info_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commands_queued != null && message.hasOwnProperty("commands_queued"))
                    if (!$util.isInteger(message.commands_queued))
                        return "commands_queued: integer expected";
                if (message.command_queue_desired_size != null && message.hasOwnProperty("command_queue_desired_size"))
                    if (!$util.isInteger(message.command_queue_desired_size))
                        return "command_queue_desired_size: integer expected";
                if (message.starved_command_ticks != null && message.hasOwnProperty("starved_command_ticks"))
                    if (!$util.isInteger(message.starved_command_ticks))
                        return "starved_command_ticks: integer expected";
                if (message.time_dilation_percent != null && message.hasOwnProperty("time_dilation_percent"))
                    if (typeof message.time_dilation_percent !== "number")
                        return "time_dilation_percent: number expected";
                return null;
            };
    
            /**
             * Creates a command_queue_info_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t
             */
            command_queue_info_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_PacketEntities.command_queue_info_t)
                    return object;
                var message = new $root.CSVCMsg_PacketEntities.command_queue_info_t();
                if (object.commands_queued != null)
                    message.commands_queued = object.commands_queued >>> 0;
                if (object.command_queue_desired_size != null)
                    message.command_queue_desired_size = object.command_queue_desired_size >>> 0;
                if (object.starved_command_ticks != null)
                    message.starved_command_ticks = object.starved_command_ticks >>> 0;
                if (object.time_dilation_percent != null)
                    message.time_dilation_percent = Number(object.time_dilation_percent);
                return message;
            };
    
            /**
             * Creates a plain object from a command_queue_info_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.command_queue_info_t} message command_queue_info_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            command_queue_info_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.commands_queued = 0;
                    object.command_queue_desired_size = 0;
                    object.starved_command_ticks = 0;
                    object.time_dilation_percent = 0;
                }
                if (message.commands_queued != null && message.hasOwnProperty("commands_queued"))
                    object.commands_queued = message.commands_queued;
                if (message.command_queue_desired_size != null && message.hasOwnProperty("command_queue_desired_size"))
                    object.command_queue_desired_size = message.command_queue_desired_size;
                if (message.starved_command_ticks != null && message.hasOwnProperty("starved_command_ticks"))
                    object.starved_command_ticks = message.starved_command_ticks;
                if (message.time_dilation_percent != null && message.hasOwnProperty("time_dilation_percent"))
                    object.time_dilation_percent = options.json && !isFinite(message.time_dilation_percent) ? String(message.time_dilation_percent) : message.time_dilation_percent;
                return object;
            };
    
            /**
             * Converts this command_queue_info_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            command_queue_info_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return command_queue_info_t;
        })();
    
        return CSVCMsg_PacketEntities;
    })();
    
    $root.CSVCMsg_TempEntities = (function() {
    
        /**
         * Properties of a CSVCMsg_TempEntities.
         * @exports ICSVCMsg_TempEntities
         * @interface ICSVCMsg_TempEntities
         * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable
         * @property {number|null} [num_entries] CSVCMsg_TempEntities num_entries
         * @property {Uint8Array|null} [entity_data] CSVCMsg_TempEntities entity_data
         */
    
        /**
         * Constructs a new CSVCMsg_TempEntities.
         * @exports CSVCMsg_TempEntities
         * @classdesc Represents a CSVCMsg_TempEntities.
         * @implements ICSVCMsg_TempEntities
         * @constructor
         * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
         */
        function CSVCMsg_TempEntities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_TempEntities reliable.
         * @member {boolean} reliable
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.reliable = false;
    
        /**
         * CSVCMsg_TempEntities num_entries.
         * @member {number} num_entries
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.num_entries = 0;
    
        /**
         * CSVCMsg_TempEntities entity_data.
         * @member {Uint8Array} entity_data
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.entity_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_TempEntities instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities instance
         */
        CSVCMsg_TempEntities.create = function create(properties) {
            return new CSVCMsg_TempEntities(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_TempEntities message. Does not implicitly {@link CSVCMsg_TempEntities.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities} message CSVCMsg_TempEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_TempEntities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliable != null && Object.hasOwnProperty.call(message, "reliable"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reliable);
            if (message.num_entries != null && Object.hasOwnProperty.call(message, "num_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num_entries);
            if (message.entity_data != null && Object.hasOwnProperty.call(message, "entity_data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.entity_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_TempEntities message, length delimited. Does not implicitly {@link CSVCMsg_TempEntities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities} message CSVCMsg_TempEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_TempEntities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_TempEntities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reliable = reader.bool();
                    break;
                case 2:
                    message.num_entries = reader.int32();
                    break;
                case 3:
                    message.entity_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_TempEntities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_TempEntities message.
         * @function verify
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_TempEntities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                if (typeof message.reliable !== "boolean")
                    return "reliable: boolean expected";
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                if (!$util.isInteger(message.num_entries))
                    return "num_entries: integer expected";
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                if (!(message.entity_data && typeof message.entity_data.length === "number" || $util.isString(message.entity_data)))
                    return "entity_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_TempEntities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         */
        CSVCMsg_TempEntities.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_TempEntities)
                return object;
            var message = new $root.CSVCMsg_TempEntities();
            if (object.reliable != null)
                message.reliable = Boolean(object.reliable);
            if (object.num_entries != null)
                message.num_entries = object.num_entries | 0;
            if (object.entity_data != null)
                if (typeof object.entity_data === "string")
                    $util.base64.decode(object.entity_data, message.entity_data = $util.newBuffer($util.base64.length(object.entity_data)), 0);
                else if (object.entity_data.length)
                    message.entity_data = object.entity_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_TempEntities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {CSVCMsg_TempEntities} message CSVCMsg_TempEntities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_TempEntities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reliable = false;
                object.num_entries = 0;
                if (options.bytes === String)
                    object.entity_data = "";
                else {
                    object.entity_data = [];
                    if (options.bytes !== Array)
                        object.entity_data = $util.newBuffer(object.entity_data);
                }
            }
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                object.reliable = message.reliable;
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                object.num_entries = message.num_entries;
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                object.entity_data = options.bytes === String ? $util.base64.encode(message.entity_data, 0, message.entity_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.entity_data) : message.entity_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_TempEntities to JSON.
         * @function toJSON
         * @memberof CSVCMsg_TempEntities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_TempEntities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_TempEntities;
    })();
    
    $root.CSVCMsg_CreateStringTable = (function() {
    
        /**
         * Properties of a CSVCMsg_CreateStringTable.
         * @exports ICSVCMsg_CreateStringTable
         * @interface ICSVCMsg_CreateStringTable
         * @property {string|null} [name] CSVCMsg_CreateStringTable name
         * @property {number|null} [num_entries] CSVCMsg_CreateStringTable num_entries
         * @property {boolean|null} [user_data_fixed_size] CSVCMsg_CreateStringTable user_data_fixed_size
         * @property {number|null} [user_data_size] CSVCMsg_CreateStringTable user_data_size
         * @property {number|null} [user_data_size_bits] CSVCMsg_CreateStringTable user_data_size_bits
         * @property {number|null} [flags] CSVCMsg_CreateStringTable flags
         * @property {Uint8Array|null} [string_data] CSVCMsg_CreateStringTable string_data
         * @property {number|null} [uncompressed_size] CSVCMsg_CreateStringTable uncompressed_size
         * @property {boolean|null} [data_compressed] CSVCMsg_CreateStringTable data_compressed
         */
    
        /**
         * Constructs a new CSVCMsg_CreateStringTable.
         * @exports CSVCMsg_CreateStringTable
         * @classdesc Represents a CSVCMsg_CreateStringTable.
         * @implements ICSVCMsg_CreateStringTable
         * @constructor
         * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
         */
        function CSVCMsg_CreateStringTable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CreateStringTable name.
         * @member {string} name
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.name = "";
    
        /**
         * CSVCMsg_CreateStringTable num_entries.
         * @member {number} num_entries
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.num_entries = 0;
    
        /**
         * CSVCMsg_CreateStringTable user_data_fixed_size.
         * @member {boolean} user_data_fixed_size
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.user_data_fixed_size = false;
    
        /**
         * CSVCMsg_CreateStringTable user_data_size.
         * @member {number} user_data_size
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.user_data_size = 0;
    
        /**
         * CSVCMsg_CreateStringTable user_data_size_bits.
         * @member {number} user_data_size_bits
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.user_data_size_bits = 0;
    
        /**
         * CSVCMsg_CreateStringTable flags.
         * @member {number} flags
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.flags = 0;
    
        /**
         * CSVCMsg_CreateStringTable string_data.
         * @member {Uint8Array} string_data
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.string_data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_CreateStringTable uncompressed_size.
         * @member {number} uncompressed_size
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.uncompressed_size = 0;
    
        /**
         * CSVCMsg_CreateStringTable data_compressed.
         * @member {boolean} data_compressed
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.data_compressed = false;
    
        /**
         * Creates a new CSVCMsg_CreateStringTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable instance
         */
        CSVCMsg_CreateStringTable.create = function create(properties) {
            return new CSVCMsg_CreateStringTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CreateStringTable message. Does not implicitly {@link CSVCMsg_CreateStringTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CreateStringTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.num_entries != null && Object.hasOwnProperty.call(message, "num_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num_entries);
            if (message.user_data_fixed_size != null && Object.hasOwnProperty.call(message, "user_data_fixed_size"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.user_data_fixed_size);
            if (message.user_data_size != null && Object.hasOwnProperty.call(message, "user_data_size"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.user_data_size);
            if (message.user_data_size_bits != null && Object.hasOwnProperty.call(message, "user_data_size_bits"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.user_data_size_bits);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.flags);
            if (message.string_data != null && Object.hasOwnProperty.call(message, "string_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_data);
            if (message.uncompressed_size != null && Object.hasOwnProperty.call(message, "uncompressed_size"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.uncompressed_size);
            if (message.data_compressed != null && Object.hasOwnProperty.call(message, "data_compressed"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.data_compressed);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CreateStringTable message, length delimited. Does not implicitly {@link CSVCMsg_CreateStringTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CreateStringTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CreateStringTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.num_entries = reader.int32();
                    break;
                case 3:
                    message.user_data_fixed_size = reader.bool();
                    break;
                case 4:
                    message.user_data_size = reader.int32();
                    break;
                case 5:
                    message.user_data_size_bits = reader.int32();
                    break;
                case 6:
                    message.flags = reader.int32();
                    break;
                case 7:
                    message.string_data = reader.bytes();
                    break;
                case 8:
                    message.uncompressed_size = reader.int32();
                    break;
                case 9:
                    message.data_compressed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CreateStringTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CreateStringTable message.
         * @function verify
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CreateStringTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                if (!$util.isInteger(message.num_entries))
                    return "num_entries: integer expected";
            if (message.user_data_fixed_size != null && message.hasOwnProperty("user_data_fixed_size"))
                if (typeof message.user_data_fixed_size !== "boolean")
                    return "user_data_fixed_size: boolean expected";
            if (message.user_data_size != null && message.hasOwnProperty("user_data_size"))
                if (!$util.isInteger(message.user_data_size))
                    return "user_data_size: integer expected";
            if (message.user_data_size_bits != null && message.hasOwnProperty("user_data_size_bits"))
                if (!$util.isInteger(message.user_data_size_bits))
                    return "user_data_size_bits: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                if (!(message.string_data && typeof message.string_data.length === "number" || $util.isString(message.string_data)))
                    return "string_data: buffer expected";
            if (message.uncompressed_size != null && message.hasOwnProperty("uncompressed_size"))
                if (!$util.isInteger(message.uncompressed_size))
                    return "uncompressed_size: integer expected";
            if (message.data_compressed != null && message.hasOwnProperty("data_compressed"))
                if (typeof message.data_compressed !== "boolean")
                    return "data_compressed: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CreateStringTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         */
        CSVCMsg_CreateStringTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CreateStringTable)
                return object;
            var message = new $root.CSVCMsg_CreateStringTable();
            if (object.name != null)
                message.name = String(object.name);
            if (object.num_entries != null)
                message.num_entries = object.num_entries | 0;
            if (object.user_data_fixed_size != null)
                message.user_data_fixed_size = Boolean(object.user_data_fixed_size);
            if (object.user_data_size != null)
                message.user_data_size = object.user_data_size | 0;
            if (object.user_data_size_bits != null)
                message.user_data_size_bits = object.user_data_size_bits | 0;
            if (object.flags != null)
                message.flags = object.flags | 0;
            if (object.string_data != null)
                if (typeof object.string_data === "string")
                    $util.base64.decode(object.string_data, message.string_data = $util.newBuffer($util.base64.length(object.string_data)), 0);
                else if (object.string_data.length)
                    message.string_data = object.string_data;
            if (object.uncompressed_size != null)
                message.uncompressed_size = object.uncompressed_size | 0;
            if (object.data_compressed != null)
                message.data_compressed = Boolean(object.data_compressed);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CreateStringTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {CSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CreateStringTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.num_entries = 0;
                object.user_data_fixed_size = false;
                object.user_data_size = 0;
                object.user_data_size_bits = 0;
                object.flags = 0;
                if (options.bytes === String)
                    object.string_data = "";
                else {
                    object.string_data = [];
                    if (options.bytes !== Array)
                        object.string_data = $util.newBuffer(object.string_data);
                }
                object.uncompressed_size = 0;
                object.data_compressed = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                object.num_entries = message.num_entries;
            if (message.user_data_fixed_size != null && message.hasOwnProperty("user_data_fixed_size"))
                object.user_data_fixed_size = message.user_data_fixed_size;
            if (message.user_data_size != null && message.hasOwnProperty("user_data_size"))
                object.user_data_size = message.user_data_size;
            if (message.user_data_size_bits != null && message.hasOwnProperty("user_data_size_bits"))
                object.user_data_size_bits = message.user_data_size_bits;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                object.string_data = options.bytes === String ? $util.base64.encode(message.string_data, 0, message.string_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_data) : message.string_data;
            if (message.uncompressed_size != null && message.hasOwnProperty("uncompressed_size"))
                object.uncompressed_size = message.uncompressed_size;
            if (message.data_compressed != null && message.hasOwnProperty("data_compressed"))
                object.data_compressed = message.data_compressed;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CreateStringTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CreateStringTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_CreateStringTable;
    })();
    
    $root.CSVCMsg_UpdateStringTable = (function() {
    
        /**
         * Properties of a CSVCMsg_UpdateStringTable.
         * @exports ICSVCMsg_UpdateStringTable
         * @interface ICSVCMsg_UpdateStringTable
         * @property {number|null} [table_id] CSVCMsg_UpdateStringTable table_id
         * @property {number|null} [num_changed_entries] CSVCMsg_UpdateStringTable num_changed_entries
         * @property {Uint8Array|null} [string_data] CSVCMsg_UpdateStringTable string_data
         */
    
        /**
         * Constructs a new CSVCMsg_UpdateStringTable.
         * @exports CSVCMsg_UpdateStringTable
         * @classdesc Represents a CSVCMsg_UpdateStringTable.
         * @implements ICSVCMsg_UpdateStringTable
         * @constructor
         * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
         */
        function CSVCMsg_UpdateStringTable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UpdateStringTable table_id.
         * @member {number} table_id
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.table_id = 0;
    
        /**
         * CSVCMsg_UpdateStringTable num_changed_entries.
         * @member {number} num_changed_entries
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.num_changed_entries = 0;
    
        /**
         * CSVCMsg_UpdateStringTable string_data.
         * @member {Uint8Array} string_data
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.string_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UpdateStringTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable instance
         */
        CSVCMsg_UpdateStringTable.create = function create(properties) {
            return new CSVCMsg_UpdateStringTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UpdateStringTable message. Does not implicitly {@link CSVCMsg_UpdateStringTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UpdateStringTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table_id != null && Object.hasOwnProperty.call(message, "table_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.table_id);
            if (message.num_changed_entries != null && Object.hasOwnProperty.call(message, "num_changed_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num_changed_entries);
            if (message.string_data != null && Object.hasOwnProperty.call(message, "string_data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.string_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UpdateStringTable message, length delimited. Does not implicitly {@link CSVCMsg_UpdateStringTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UpdateStringTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table_id = reader.int32();
                    break;
                case 2:
                    message.num_changed_entries = reader.int32();
                    break;
                case 3:
                    message.string_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UpdateStringTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UpdateStringTable message.
         * @function verify
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UpdateStringTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table_id != null && message.hasOwnProperty("table_id"))
                if (!$util.isInteger(message.table_id))
                    return "table_id: integer expected";
            if (message.num_changed_entries != null && message.hasOwnProperty("num_changed_entries"))
                if (!$util.isInteger(message.num_changed_entries))
                    return "num_changed_entries: integer expected";
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                if (!(message.string_data && typeof message.string_data.length === "number" || $util.isString(message.string_data)))
                    return "string_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UpdateStringTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         */
        CSVCMsg_UpdateStringTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UpdateStringTable)
                return object;
            var message = new $root.CSVCMsg_UpdateStringTable();
            if (object.table_id != null)
                message.table_id = object.table_id | 0;
            if (object.num_changed_entries != null)
                message.num_changed_entries = object.num_changed_entries | 0;
            if (object.string_data != null)
                if (typeof object.string_data === "string")
                    $util.base64.decode(object.string_data, message.string_data = $util.newBuffer($util.base64.length(object.string_data)), 0);
                else if (object.string_data.length)
                    message.string_data = object.string_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UpdateStringTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {CSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UpdateStringTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.table_id = 0;
                object.num_changed_entries = 0;
                if (options.bytes === String)
                    object.string_data = "";
                else {
                    object.string_data = [];
                    if (options.bytes !== Array)
                        object.string_data = $util.newBuffer(object.string_data);
                }
            }
            if (message.table_id != null && message.hasOwnProperty("table_id"))
                object.table_id = message.table_id;
            if (message.num_changed_entries != null && message.hasOwnProperty("num_changed_entries"))
                object.num_changed_entries = message.num_changed_entries;
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                object.string_data = options.bytes === String ? $util.base64.encode(message.string_data, 0, message.string_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_data) : message.string_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UpdateStringTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UpdateStringTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UpdateStringTable;
    })();
    
    $root.CSVCMsg_VoiceData = (function() {
    
        /**
         * Properties of a CSVCMsg_VoiceData.
         * @exports ICSVCMsg_VoiceData
         * @interface ICSVCMsg_VoiceData
         * @property {ICMsgVoiceAudio|null} [audio] CSVCMsg_VoiceData audio
         * @property {number|null} [client] CSVCMsg_VoiceData client
         * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity
         * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid
         * @property {number|null} [audible_mask] CSVCMsg_VoiceData audible_mask
         * @property {number|null} [tick] CSVCMsg_VoiceData tick
         */
    
        /**
         * Constructs a new CSVCMsg_VoiceData.
         * @exports CSVCMsg_VoiceData
         * @classdesc Represents a CSVCMsg_VoiceData.
         * @implements ICSVCMsg_VoiceData
         * @constructor
         * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
         */
        function CSVCMsg_VoiceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_VoiceData audio.
         * @member {ICMsgVoiceAudio|null|undefined} audio
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.audio = null;
    
        /**
         * CSVCMsg_VoiceData client.
         * @member {number} client
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.client = 0;
    
        /**
         * CSVCMsg_VoiceData proximity.
         * @member {boolean} proximity
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.proximity = false;
    
        /**
         * CSVCMsg_VoiceData xuid.
         * @member {number|Long} xuid
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CSVCMsg_VoiceData audible_mask.
         * @member {number} audible_mask
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.audible_mask = 0;
    
        /**
         * CSVCMsg_VoiceData tick.
         * @member {number} tick
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.tick = 0;
    
        /**
         * Creates a new CSVCMsg_VoiceData instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData instance
         */
        CSVCMsg_VoiceData.create = function create(properties) {
            return new CSVCMsg_VoiceData(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceData message. Does not implicitly {@link CSVCMsg_VoiceData.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData} message CSVCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.CMsgVoiceAudio.encode(message.audio, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.client != null && Object.hasOwnProperty.call(message, "client"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.client);
            if (message.proximity != null && Object.hasOwnProperty.call(message, "proximity"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.proximity);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.xuid);
            if (message.audible_mask != null && Object.hasOwnProperty.call(message, "audible_mask"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.audible_mask);
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.tick);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceData message, length delimited. Does not implicitly {@link CSVCMsg_VoiceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData} message CSVCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio = $root.CMsgVoiceAudio.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.client = reader.int32();
                    break;
                case 3:
                    message.proximity = reader.bool();
                    break;
                case 4:
                    message.xuid = reader.fixed64();
                    break;
                case 5:
                    message.audible_mask = reader.int32();
                    break;
                case 6:
                    message.tick = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_VoiceData message.
         * @function verify
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_VoiceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio != null && message.hasOwnProperty("audio")) {
                var error = $root.CMsgVoiceAudio.verify(message.audio);
                if (error)
                    return "audio." + error;
            }
            if (message.client != null && message.hasOwnProperty("client"))
                if (!$util.isInteger(message.client))
                    return "client: integer expected";
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                if (typeof message.proximity !== "boolean")
                    return "proximity: boolean expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.audible_mask != null && message.hasOwnProperty("audible_mask"))
                if (!$util.isInteger(message.audible_mask))
                    return "audible_mask: integer expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_VoiceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         */
        CSVCMsg_VoiceData.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_VoiceData)
                return object;
            var message = new $root.CSVCMsg_VoiceData();
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".CSVCMsg_VoiceData.audio: object expected");
                message.audio = $root.CMsgVoiceAudio.fromObject(object.audio);
            }
            if (object.client != null)
                message.client = object.client | 0;
            if (object.proximity != null)
                message.proximity = Boolean(object.proximity);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.audible_mask != null)
                message.audible_mask = object.audible_mask | 0;
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_VoiceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {CSVCMsg_VoiceData} message CSVCMsg_VoiceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_VoiceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio = null;
                object.client = 0;
                object.proximity = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.audible_mask = 0;
                object.tick = 0;
            }
            if (message.audio != null && message.hasOwnProperty("audio"))
                object.audio = $root.CMsgVoiceAudio.toObject(message.audio, options);
            if (message.client != null && message.hasOwnProperty("client"))
                object.client = message.client;
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                object.proximity = message.proximity;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.audible_mask != null && message.hasOwnProperty("audible_mask"))
                object.audible_mask = message.audible_mask;
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_VoiceData to JSON.
         * @function toJSON
         * @memberof CSVCMsg_VoiceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_VoiceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_VoiceData;
    })();
    
    $root.CSVCMsg_PacketReliable = (function() {
    
        /**
         * Properties of a CSVCMsg_PacketReliable.
         * @exports ICSVCMsg_PacketReliable
         * @interface ICSVCMsg_PacketReliable
         * @property {number|null} [tick] CSVCMsg_PacketReliable tick
         * @property {number|null} [messagessize] CSVCMsg_PacketReliable messagessize
         * @property {boolean|null} [state] CSVCMsg_PacketReliable state
         */
    
        /**
         * Constructs a new CSVCMsg_PacketReliable.
         * @exports CSVCMsg_PacketReliable
         * @classdesc Represents a CSVCMsg_PacketReliable.
         * @implements ICSVCMsg_PacketReliable
         * @constructor
         * @param {ICSVCMsg_PacketReliable=} [properties] Properties to set
         */
        function CSVCMsg_PacketReliable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PacketReliable tick.
         * @member {number} tick
         * @memberof CSVCMsg_PacketReliable
         * @instance
         */
        CSVCMsg_PacketReliable.prototype.tick = 0;
    
        /**
         * CSVCMsg_PacketReliable messagessize.
         * @member {number} messagessize
         * @memberof CSVCMsg_PacketReliable
         * @instance
         */
        CSVCMsg_PacketReliable.prototype.messagessize = 0;
    
        /**
         * CSVCMsg_PacketReliable state.
         * @member {boolean} state
         * @memberof CSVCMsg_PacketReliable
         * @instance
         */
        CSVCMsg_PacketReliable.prototype.state = false;
    
        /**
         * Creates a new CSVCMsg_PacketReliable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {ICSVCMsg_PacketReliable=} [properties] Properties to set
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable instance
         */
        CSVCMsg_PacketReliable.create = function create(properties) {
            return new CSVCMsg_PacketReliable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketReliable message. Does not implicitly {@link CSVCMsg_PacketReliable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {ICSVCMsg_PacketReliable} message CSVCMsg_PacketReliable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketReliable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
            if (message.messagessize != null && Object.hasOwnProperty.call(message, "messagessize"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.messagessize);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.state);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketReliable message, length delimited. Does not implicitly {@link CSVCMsg_PacketReliable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {ICSVCMsg_PacketReliable} message CSVCMsg_PacketReliable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketReliable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PacketReliable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketReliable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketReliable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.int32();
                    break;
                case 2:
                    message.messagessize = reader.int32();
                    break;
                case 3:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PacketReliable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketReliable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PacketReliable message.
         * @function verify
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PacketReliable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.messagessize != null && message.hasOwnProperty("messagessize"))
                if (!$util.isInteger(message.messagessize))
                    return "messagessize: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PacketReliable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable
         */
        CSVCMsg_PacketReliable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PacketReliable)
                return object;
            var message = new $root.CSVCMsg_PacketReliable();
            if (object.tick != null)
                message.tick = object.tick | 0;
            if (object.messagessize != null)
                message.messagessize = object.messagessize | 0;
            if (object.state != null)
                message.state = Boolean(object.state);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PacketReliable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {CSVCMsg_PacketReliable} message CSVCMsg_PacketReliable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PacketReliable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.messagessize = 0;
                object.state = false;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.messagessize != null && message.hasOwnProperty("messagessize"))
                object.messagessize = message.messagessize;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PacketReliable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PacketReliable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PacketReliable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_PacketReliable;
    })();
    
    $root.CSVCMsg_FullFrameSplit = (function() {
    
        /**
         * Properties of a CSVCMsg_FullFrameSplit.
         * @exports ICSVCMsg_FullFrameSplit
         * @interface ICSVCMsg_FullFrameSplit
         * @property {number|null} [tick] CSVCMsg_FullFrameSplit tick
         * @property {number|null} [section] CSVCMsg_FullFrameSplit section
         * @property {number|null} [total] CSVCMsg_FullFrameSplit total
         * @property {Uint8Array|null} [data] CSVCMsg_FullFrameSplit data
         */
    
        /**
         * Constructs a new CSVCMsg_FullFrameSplit.
         * @exports CSVCMsg_FullFrameSplit
         * @classdesc Represents a CSVCMsg_FullFrameSplit.
         * @implements ICSVCMsg_FullFrameSplit
         * @constructor
         * @param {ICSVCMsg_FullFrameSplit=} [properties] Properties to set
         */
        function CSVCMsg_FullFrameSplit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FullFrameSplit tick.
         * @member {number} tick
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.tick = 0;
    
        /**
         * CSVCMsg_FullFrameSplit section.
         * @member {number} section
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.section = 0;
    
        /**
         * CSVCMsg_FullFrameSplit total.
         * @member {number} total
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.total = 0;
    
        /**
         * CSVCMsg_FullFrameSplit data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_FullFrameSplit instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {ICSVCMsg_FullFrameSplit=} [properties] Properties to set
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit instance
         */
        CSVCMsg_FullFrameSplit.create = function create(properties) {
            return new CSVCMsg_FullFrameSplit(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FullFrameSplit message. Does not implicitly {@link CSVCMsg_FullFrameSplit.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {ICSVCMsg_FullFrameSplit} message CSVCMsg_FullFrameSplit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FullFrameSplit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
            if (message.section != null && Object.hasOwnProperty.call(message, "section"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.section);
            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.total);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FullFrameSplit message, length delimited. Does not implicitly {@link CSVCMsg_FullFrameSplit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {ICSVCMsg_FullFrameSplit} message CSVCMsg_FullFrameSplit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FullFrameSplit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FullFrameSplit message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FullFrameSplit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FullFrameSplit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.int32();
                    break;
                case 2:
                    message.section = reader.int32();
                    break;
                case 3:
                    message.total = reader.int32();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FullFrameSplit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FullFrameSplit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FullFrameSplit message.
         * @function verify
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FullFrameSplit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.section != null && message.hasOwnProperty("section"))
                if (!$util.isInteger(message.section))
                    return "section: integer expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total))
                    return "total: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FullFrameSplit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit
         */
        CSVCMsg_FullFrameSplit.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FullFrameSplit)
                return object;
            var message = new $root.CSVCMsg_FullFrameSplit();
            if (object.tick != null)
                message.tick = object.tick | 0;
            if (object.section != null)
                message.section = object.section | 0;
            if (object.total != null)
                message.total = object.total | 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FullFrameSplit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {CSVCMsg_FullFrameSplit} message CSVCMsg_FullFrameSplit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FullFrameSplit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.section = 0;
                object.total = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.section != null && message.hasOwnProperty("section"))
                object.section = message.section;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FullFrameSplit to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FullFrameSplit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_FullFrameSplit;
    })();
    
    $root.CSVCMsg_HLTVStatus = (function() {
    
        /**
         * Properties of a CSVCMsg_HLTVStatus.
         * @exports ICSVCMsg_HLTVStatus
         * @interface ICSVCMsg_HLTVStatus
         * @property {string|null} [master] CSVCMsg_HLTVStatus master
         * @property {number|null} [clients] CSVCMsg_HLTVStatus clients
         * @property {number|null} [slots] CSVCMsg_HLTVStatus slots
         * @property {number|null} [proxies] CSVCMsg_HLTVStatus proxies
         */
    
        /**
         * Constructs a new CSVCMsg_HLTVStatus.
         * @exports CSVCMsg_HLTVStatus
         * @classdesc Represents a CSVCMsg_HLTVStatus.
         * @implements ICSVCMsg_HLTVStatus
         * @constructor
         * @param {ICSVCMsg_HLTVStatus=} [properties] Properties to set
         */
        function CSVCMsg_HLTVStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_HLTVStatus master.
         * @member {string} master
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.master = "";
    
        /**
         * CSVCMsg_HLTVStatus clients.
         * @member {number} clients
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.clients = 0;
    
        /**
         * CSVCMsg_HLTVStatus slots.
         * @member {number} slots
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.slots = 0;
    
        /**
         * CSVCMsg_HLTVStatus proxies.
         * @member {number} proxies
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.proxies = 0;
    
        /**
         * Creates a new CSVCMsg_HLTVStatus instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {ICSVCMsg_HLTVStatus=} [properties] Properties to set
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus instance
         */
        CSVCMsg_HLTVStatus.create = function create(properties) {
            return new CSVCMsg_HLTVStatus(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_HLTVStatus message. Does not implicitly {@link CSVCMsg_HLTVStatus.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {ICSVCMsg_HLTVStatus} message CSVCMsg_HLTVStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HLTVStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.master != null && Object.hasOwnProperty.call(message, "master"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.master);
            if (message.clients != null && Object.hasOwnProperty.call(message, "clients"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.clients);
            if (message.slots != null && Object.hasOwnProperty.call(message, "slots"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.slots);
            if (message.proxies != null && Object.hasOwnProperty.call(message, "proxies"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.proxies);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_HLTVStatus message, length delimited. Does not implicitly {@link CSVCMsg_HLTVStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {ICSVCMsg_HLTVStatus} message CSVCMsg_HLTVStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HLTVStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_HLTVStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HLTVStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HLTVStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.master = reader.string();
                    break;
                case 2:
                    message.clients = reader.int32();
                    break;
                case 3:
                    message.slots = reader.int32();
                    break;
                case 4:
                    message.proxies = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_HLTVStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HLTVStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_HLTVStatus message.
         * @function verify
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_HLTVStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.master != null && message.hasOwnProperty("master"))
                if (!$util.isString(message.master))
                    return "master: string expected";
            if (message.clients != null && message.hasOwnProperty("clients"))
                if (!$util.isInteger(message.clients))
                    return "clients: integer expected";
            if (message.slots != null && message.hasOwnProperty("slots"))
                if (!$util.isInteger(message.slots))
                    return "slots: integer expected";
            if (message.proxies != null && message.hasOwnProperty("proxies"))
                if (!$util.isInteger(message.proxies))
                    return "proxies: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_HLTVStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus
         */
        CSVCMsg_HLTVStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_HLTVStatus)
                return object;
            var message = new $root.CSVCMsg_HLTVStatus();
            if (object.master != null)
                message.master = String(object.master);
            if (object.clients != null)
                message.clients = object.clients | 0;
            if (object.slots != null)
                message.slots = object.slots | 0;
            if (object.proxies != null)
                message.proxies = object.proxies | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_HLTVStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {CSVCMsg_HLTVStatus} message CSVCMsg_HLTVStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_HLTVStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.master = "";
                object.clients = 0;
                object.slots = 0;
                object.proxies = 0;
            }
            if (message.master != null && message.hasOwnProperty("master"))
                object.master = message.master;
            if (message.clients != null && message.hasOwnProperty("clients"))
                object.clients = message.clients;
            if (message.slots != null && message.hasOwnProperty("slots"))
                object.slots = message.slots;
            if (message.proxies != null && message.hasOwnProperty("proxies"))
                object.proxies = message.proxies;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_HLTVStatus to JSON.
         * @function toJSON
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_HLTVStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_HLTVStatus;
    })();
    
    $root.CSVCMsg_ServerSteamID = (function() {
    
        /**
         * Properties of a CSVCMsg_ServerSteamID.
         * @exports ICSVCMsg_ServerSteamID
         * @interface ICSVCMsg_ServerSteamID
         * @property {number|Long|null} [steam_id] CSVCMsg_ServerSteamID steam_id
         */
    
        /**
         * Constructs a new CSVCMsg_ServerSteamID.
         * @exports CSVCMsg_ServerSteamID
         * @classdesc Represents a CSVCMsg_ServerSteamID.
         * @implements ICSVCMsg_ServerSteamID
         * @constructor
         * @param {ICSVCMsg_ServerSteamID=} [properties] Properties to set
         */
        function CSVCMsg_ServerSteamID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ServerSteamID steam_id.
         * @member {number|Long} steam_id
         * @memberof CSVCMsg_ServerSteamID
         * @instance
         */
        CSVCMsg_ServerSteamID.prototype.steam_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CSVCMsg_ServerSteamID instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {ICSVCMsg_ServerSteamID=} [properties] Properties to set
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID instance
         */
        CSVCMsg_ServerSteamID.create = function create(properties) {
            return new CSVCMsg_ServerSteamID(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerSteamID message. Does not implicitly {@link CSVCMsg_ServerSteamID.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {ICSVCMsg_ServerSteamID} message CSVCMsg_ServerSteamID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerSteamID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.steam_id != null && Object.hasOwnProperty.call(message, "steam_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.steam_id);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerSteamID message, length delimited. Does not implicitly {@link CSVCMsg_ServerSteamID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {ICSVCMsg_ServerSteamID} message CSVCMsg_ServerSteamID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerSteamID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ServerSteamID message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerSteamID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerSteamID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.steam_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ServerSteamID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerSteamID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ServerSteamID message.
         * @function verify
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ServerSteamID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.steam_id != null && message.hasOwnProperty("steam_id"))
                if (!$util.isInteger(message.steam_id) && !(message.steam_id && $util.isInteger(message.steam_id.low) && $util.isInteger(message.steam_id.high)))
                    return "steam_id: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ServerSteamID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID
         */
        CSVCMsg_ServerSteamID.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ServerSteamID)
                return object;
            var message = new $root.CSVCMsg_ServerSteamID();
            if (object.steam_id != null)
                if ($util.Long)
                    (message.steam_id = $util.Long.fromValue(object.steam_id)).unsigned = true;
                else if (typeof object.steam_id === "string")
                    message.steam_id = parseInt(object.steam_id, 10);
                else if (typeof object.steam_id === "number")
                    message.steam_id = object.steam_id;
                else if (typeof object.steam_id === "object")
                    message.steam_id = new $util.LongBits(object.steam_id.low >>> 0, object.steam_id.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ServerSteamID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {CSVCMsg_ServerSteamID} message CSVCMsg_ServerSteamID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ServerSteamID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.steam_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steam_id = options.longs === String ? "0" : 0;
            if (message.steam_id != null && message.hasOwnProperty("steam_id"))
                if (typeof message.steam_id === "number")
                    object.steam_id = options.longs === String ? String(message.steam_id) : message.steam_id;
                else
                    object.steam_id = options.longs === String ? $util.Long.prototype.toString.call(message.steam_id) : options.longs === Number ? new $util.LongBits(message.steam_id.low >>> 0, message.steam_id.high >>> 0).toNumber(true) : message.steam_id;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ServerSteamID to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ServerSteamID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ServerSteamID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_ServerSteamID;
    })();
    
    $root.CSVCMsg_CmdKeyValues = (function() {
    
        /**
         * Properties of a CSVCMsg_CmdKeyValues.
         * @exports ICSVCMsg_CmdKeyValues
         * @interface ICSVCMsg_CmdKeyValues
         * @property {Uint8Array|null} [data] CSVCMsg_CmdKeyValues data
         */
    
        /**
         * Constructs a new CSVCMsg_CmdKeyValues.
         * @exports CSVCMsg_CmdKeyValues
         * @classdesc Represents a CSVCMsg_CmdKeyValues.
         * @implements ICSVCMsg_CmdKeyValues
         * @constructor
         * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
         */
        function CSVCMsg_CmdKeyValues(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CmdKeyValues data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_CmdKeyValues
         * @instance
         */
        CSVCMsg_CmdKeyValues.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_CmdKeyValues instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues instance
         */
        CSVCMsg_CmdKeyValues.create = function create(properties) {
            return new CSVCMsg_CmdKeyValues(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CmdKeyValues message. Does not implicitly {@link CSVCMsg_CmdKeyValues.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CmdKeyValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CmdKeyValues message, length delimited. Does not implicitly {@link CSVCMsg_CmdKeyValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CmdKeyValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CmdKeyValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CmdKeyValues message.
         * @function verify
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CmdKeyValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CmdKeyValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         */
        CSVCMsg_CmdKeyValues.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CmdKeyValues)
                return object;
            var message = new $root.CSVCMsg_CmdKeyValues();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CmdKeyValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {CSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CmdKeyValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CmdKeyValues to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CmdKeyValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CmdKeyValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_CmdKeyValues;
    })();
    
    $root.CMsgIPCAddress = (function() {
    
        /**
         * Properties of a CMsgIPCAddress.
         * @exports ICMsgIPCAddress
         * @interface ICMsgIPCAddress
         * @property {number|Long|null} [computer_guid] CMsgIPCAddress computer_guid
         * @property {number|null} [process_id] CMsgIPCAddress process_id
         */
    
        /**
         * Constructs a new CMsgIPCAddress.
         * @exports CMsgIPCAddress
         * @classdesc Represents a CMsgIPCAddress.
         * @implements ICMsgIPCAddress
         * @constructor
         * @param {ICMsgIPCAddress=} [properties] Properties to set
         */
        function CMsgIPCAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgIPCAddress computer_guid.
         * @member {number|Long} computer_guid
         * @memberof CMsgIPCAddress
         * @instance
         */
        CMsgIPCAddress.prototype.computer_guid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgIPCAddress process_id.
         * @member {number} process_id
         * @memberof CMsgIPCAddress
         * @instance
         */
        CMsgIPCAddress.prototype.process_id = 0;
    
        /**
         * Creates a new CMsgIPCAddress instance using the specified properties.
         * @function create
         * @memberof CMsgIPCAddress
         * @static
         * @param {ICMsgIPCAddress=} [properties] Properties to set
         * @returns {CMsgIPCAddress} CMsgIPCAddress instance
         */
        CMsgIPCAddress.create = function create(properties) {
            return new CMsgIPCAddress(properties);
        };
    
        /**
         * Encodes the specified CMsgIPCAddress message. Does not implicitly {@link CMsgIPCAddress.verify|verify} messages.
         * @function encode
         * @memberof CMsgIPCAddress
         * @static
         * @param {ICMsgIPCAddress} message CMsgIPCAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgIPCAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.computer_guid != null && Object.hasOwnProperty.call(message, "computer_guid"))
                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.computer_guid);
            if (message.process_id != null && Object.hasOwnProperty.call(message, "process_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.process_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgIPCAddress message, length delimited. Does not implicitly {@link CMsgIPCAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgIPCAddress
         * @static
         * @param {ICMsgIPCAddress} message CMsgIPCAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgIPCAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgIPCAddress message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgIPCAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgIPCAddress} CMsgIPCAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgIPCAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgIPCAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.computer_guid = reader.fixed64();
                    break;
                case 2:
                    message.process_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgIPCAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgIPCAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgIPCAddress} CMsgIPCAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgIPCAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgIPCAddress message.
         * @function verify
         * @memberof CMsgIPCAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgIPCAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.computer_guid != null && message.hasOwnProperty("computer_guid"))
                if (!$util.isInteger(message.computer_guid) && !(message.computer_guid && $util.isInteger(message.computer_guid.low) && $util.isInteger(message.computer_guid.high)))
                    return "computer_guid: integer|Long expected";
            if (message.process_id != null && message.hasOwnProperty("process_id"))
                if (!$util.isInteger(message.process_id))
                    return "process_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgIPCAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgIPCAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgIPCAddress} CMsgIPCAddress
         */
        CMsgIPCAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgIPCAddress)
                return object;
            var message = new $root.CMsgIPCAddress();
            if (object.computer_guid != null)
                if ($util.Long)
                    (message.computer_guid = $util.Long.fromValue(object.computer_guid)).unsigned = false;
                else if (typeof object.computer_guid === "string")
                    message.computer_guid = parseInt(object.computer_guid, 10);
                else if (typeof object.computer_guid === "number")
                    message.computer_guid = object.computer_guid;
                else if (typeof object.computer_guid === "object")
                    message.computer_guid = new $util.LongBits(object.computer_guid.low >>> 0, object.computer_guid.high >>> 0).toNumber();
            if (object.process_id != null)
                message.process_id = object.process_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgIPCAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgIPCAddress
         * @static
         * @param {CMsgIPCAddress} message CMsgIPCAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgIPCAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.computer_guid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.computer_guid = options.longs === String ? "0" : 0;
                object.process_id = 0;
            }
            if (message.computer_guid != null && message.hasOwnProperty("computer_guid"))
                if (typeof message.computer_guid === "number")
                    object.computer_guid = options.longs === String ? String(message.computer_guid) : message.computer_guid;
                else
                    object.computer_guid = options.longs === String ? $util.Long.prototype.toString.call(message.computer_guid) : options.longs === Number ? new $util.LongBits(message.computer_guid.low >>> 0, message.computer_guid.high >>> 0).toNumber() : message.computer_guid;
            if (message.process_id != null && message.hasOwnProperty("process_id"))
                object.process_id = message.process_id;
            return object;
        };
    
        /**
         * Converts this CMsgIPCAddress to JSON.
         * @function toJSON
         * @memberof CMsgIPCAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgIPCAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgIPCAddress;
    })();
    
    $root.CMsgServerPeer = (function() {
    
        /**
         * Properties of a CMsgServerPeer.
         * @exports ICMsgServerPeer
         * @interface ICMsgServerPeer
         * @property {number|null} [player_slot] CMsgServerPeer player_slot
         * @property {number|Long|null} [steamid] CMsgServerPeer steamid
         * @property {ICMsgIPCAddress|null} [ipc] CMsgServerPeer ipc
         * @property {boolean|null} [they_hear_you] CMsgServerPeer they_hear_you
         * @property {boolean|null} [you_hear_them] CMsgServerPeer you_hear_them
         * @property {boolean|null} [is_listenserver_host] CMsgServerPeer is_listenserver_host
         */
    
        /**
         * Constructs a new CMsgServerPeer.
         * @exports CMsgServerPeer
         * @classdesc Represents a CMsgServerPeer.
         * @implements ICMsgServerPeer
         * @constructor
         * @param {ICMsgServerPeer=} [properties] Properties to set
         */
        function CMsgServerPeer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgServerPeer player_slot.
         * @member {number} player_slot
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.player_slot = 0;
    
        /**
         * CMsgServerPeer steamid.
         * @member {number|Long} steamid
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgServerPeer ipc.
         * @member {ICMsgIPCAddress|null|undefined} ipc
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.ipc = null;
    
        /**
         * CMsgServerPeer they_hear_you.
         * @member {boolean} they_hear_you
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.they_hear_you = false;
    
        /**
         * CMsgServerPeer you_hear_them.
         * @member {boolean} you_hear_them
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.you_hear_them = false;
    
        /**
         * CMsgServerPeer is_listenserver_host.
         * @member {boolean} is_listenserver_host
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.is_listenserver_host = false;
    
        /**
         * Creates a new CMsgServerPeer instance using the specified properties.
         * @function create
         * @memberof CMsgServerPeer
         * @static
         * @param {ICMsgServerPeer=} [properties] Properties to set
         * @returns {CMsgServerPeer} CMsgServerPeer instance
         */
        CMsgServerPeer.create = function create(properties) {
            return new CMsgServerPeer(properties);
        };
    
        /**
         * Encodes the specified CMsgServerPeer message. Does not implicitly {@link CMsgServerPeer.verify|verify} messages.
         * @function encode
         * @memberof CMsgServerPeer
         * @static
         * @param {ICMsgServerPeer} message CMsgServerPeer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerPeer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_slot != null && Object.hasOwnProperty.call(message, "player_slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player_slot);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.steamid);
            if (message.ipc != null && Object.hasOwnProperty.call(message, "ipc"))
                $root.CMsgIPCAddress.encode(message.ipc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.they_hear_you != null && Object.hasOwnProperty.call(message, "they_hear_you"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.they_hear_you);
            if (message.you_hear_them != null && Object.hasOwnProperty.call(message, "you_hear_them"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.you_hear_them);
            if (message.is_listenserver_host != null && Object.hasOwnProperty.call(message, "is_listenserver_host"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.is_listenserver_host);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgServerPeer message, length delimited. Does not implicitly {@link CMsgServerPeer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgServerPeer
         * @static
         * @param {ICMsgServerPeer} message CMsgServerPeer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerPeer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgServerPeer message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgServerPeer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgServerPeer} CMsgServerPeer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerPeer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerPeer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_slot = reader.int32();
                    break;
                case 2:
                    message.steamid = reader.fixed64();
                    break;
                case 3:
                    message.ipc = $root.CMsgIPCAddress.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.they_hear_you = reader.bool();
                    break;
                case 5:
                    message.you_hear_them = reader.bool();
                    break;
                case 6:
                    message.is_listenserver_host = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgServerPeer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgServerPeer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgServerPeer} CMsgServerPeer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerPeer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgServerPeer message.
         * @function verify
         * @memberof CMsgServerPeer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgServerPeer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                if (!$util.isInteger(message.player_slot))
                    return "player_slot: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.ipc != null && message.hasOwnProperty("ipc")) {
                var error = $root.CMsgIPCAddress.verify(message.ipc);
                if (error)
                    return "ipc." + error;
            }
            if (message.they_hear_you != null && message.hasOwnProperty("they_hear_you"))
                if (typeof message.they_hear_you !== "boolean")
                    return "they_hear_you: boolean expected";
            if (message.you_hear_them != null && message.hasOwnProperty("you_hear_them"))
                if (typeof message.you_hear_them !== "boolean")
                    return "you_hear_them: boolean expected";
            if (message.is_listenserver_host != null && message.hasOwnProperty("is_listenserver_host"))
                if (typeof message.is_listenserver_host !== "boolean")
                    return "is_listenserver_host: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgServerPeer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgServerPeer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgServerPeer} CMsgServerPeer
         */
        CMsgServerPeer.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgServerPeer)
                return object;
            var message = new $root.CMsgServerPeer();
            if (object.player_slot != null)
                message.player_slot = object.player_slot | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.ipc != null) {
                if (typeof object.ipc !== "object")
                    throw TypeError(".CMsgServerPeer.ipc: object expected");
                message.ipc = $root.CMsgIPCAddress.fromObject(object.ipc);
            }
            if (object.they_hear_you != null)
                message.they_hear_you = Boolean(object.they_hear_you);
            if (object.you_hear_them != null)
                message.you_hear_them = Boolean(object.you_hear_them);
            if (object.is_listenserver_host != null)
                message.is_listenserver_host = Boolean(object.is_listenserver_host);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgServerPeer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgServerPeer
         * @static
         * @param {CMsgServerPeer} message CMsgServerPeer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgServerPeer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player_slot = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.ipc = null;
                object.they_hear_you = false;
                object.you_hear_them = false;
                object.is_listenserver_host = false;
            }
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                object.player_slot = message.player_slot;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.ipc != null && message.hasOwnProperty("ipc"))
                object.ipc = $root.CMsgIPCAddress.toObject(message.ipc, options);
            if (message.they_hear_you != null && message.hasOwnProperty("they_hear_you"))
                object.they_hear_you = message.they_hear_you;
            if (message.you_hear_them != null && message.hasOwnProperty("you_hear_them"))
                object.you_hear_them = message.you_hear_them;
            if (message.is_listenserver_host != null && message.hasOwnProperty("is_listenserver_host"))
                object.is_listenserver_host = message.is_listenserver_host;
            return object;
        };
    
        /**
         * Converts this CMsgServerPeer to JSON.
         * @function toJSON
         * @memberof CMsgServerPeer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgServerPeer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgServerPeer;
    })();
    
    $root.CSVCMsg_PeerList = (function() {
    
        /**
         * Properties of a CSVCMsg_PeerList.
         * @exports ICSVCMsg_PeerList
         * @interface ICSVCMsg_PeerList
         * @property {Array.<ICMsgServerPeer>|null} [peer] CSVCMsg_PeerList peer
         */
    
        /**
         * Constructs a new CSVCMsg_PeerList.
         * @exports CSVCMsg_PeerList
         * @classdesc Represents a CSVCMsg_PeerList.
         * @implements ICSVCMsg_PeerList
         * @constructor
         * @param {ICSVCMsg_PeerList=} [properties] Properties to set
         */
        function CSVCMsg_PeerList(properties) {
            this.peer = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PeerList peer.
         * @member {Array.<ICMsgServerPeer>} peer
         * @memberof CSVCMsg_PeerList
         * @instance
         */
        CSVCMsg_PeerList.prototype.peer = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_PeerList instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {ICSVCMsg_PeerList=} [properties] Properties to set
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList instance
         */
        CSVCMsg_PeerList.create = function create(properties) {
            return new CSVCMsg_PeerList(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PeerList message. Does not implicitly {@link CSVCMsg_PeerList.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {ICSVCMsg_PeerList} message CSVCMsg_PeerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PeerList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peer != null && message.peer.length)
                for (var i = 0; i < message.peer.length; ++i)
                    $root.CMsgServerPeer.encode(message.peer[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PeerList message, length delimited. Does not implicitly {@link CSVCMsg_PeerList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {ICSVCMsg_PeerList} message CSVCMsg_PeerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PeerList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PeerList message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PeerList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PeerList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.peer && message.peer.length))
                        message.peer = [];
                    message.peer.push($root.CMsgServerPeer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PeerList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PeerList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PeerList message.
         * @function verify
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PeerList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peer != null && message.hasOwnProperty("peer")) {
                if (!Array.isArray(message.peer))
                    return "peer: array expected";
                for (var i = 0; i < message.peer.length; ++i) {
                    var error = $root.CMsgServerPeer.verify(message.peer[i]);
                    if (error)
                        return "peer." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PeerList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList
         */
        CSVCMsg_PeerList.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PeerList)
                return object;
            var message = new $root.CSVCMsg_PeerList();
            if (object.peer) {
                if (!Array.isArray(object.peer))
                    throw TypeError(".CSVCMsg_PeerList.peer: array expected");
                message.peer = [];
                for (var i = 0; i < object.peer.length; ++i) {
                    if (typeof object.peer[i] !== "object")
                        throw TypeError(".CSVCMsg_PeerList.peer: object expected");
                    message.peer[i] = $root.CMsgServerPeer.fromObject(object.peer[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PeerList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {CSVCMsg_PeerList} message CSVCMsg_PeerList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PeerList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peer = [];
            if (message.peer && message.peer.length) {
                object.peer = [];
                for (var j = 0; j < message.peer.length; ++j)
                    object.peer[j] = $root.CMsgServerPeer.toObject(message.peer[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PeerList to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PeerList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PeerList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_PeerList;
    })();
    
    $root.CSVCMsg_ClearAllStringTables = (function() {
    
        /**
         * Properties of a CSVCMsg_ClearAllStringTables.
         * @exports ICSVCMsg_ClearAllStringTables
         * @interface ICSVCMsg_ClearAllStringTables
         * @property {string|null} [mapname] CSVCMsg_ClearAllStringTables mapname
         */
    
        /**
         * Constructs a new CSVCMsg_ClearAllStringTables.
         * @exports CSVCMsg_ClearAllStringTables
         * @classdesc Represents a CSVCMsg_ClearAllStringTables.
         * @implements ICSVCMsg_ClearAllStringTables
         * @constructor
         * @param {ICSVCMsg_ClearAllStringTables=} [properties] Properties to set
         */
        function CSVCMsg_ClearAllStringTables(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ClearAllStringTables mapname.
         * @member {string} mapname
         * @memberof CSVCMsg_ClearAllStringTables
         * @instance
         */
        CSVCMsg_ClearAllStringTables.prototype.mapname = "";
    
        /**
         * Creates a new CSVCMsg_ClearAllStringTables instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {ICSVCMsg_ClearAllStringTables=} [properties] Properties to set
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables instance
         */
        CSVCMsg_ClearAllStringTables.create = function create(properties) {
            return new CSVCMsg_ClearAllStringTables(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ClearAllStringTables message. Does not implicitly {@link CSVCMsg_ClearAllStringTables.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {ICSVCMsg_ClearAllStringTables} message CSVCMsg_ClearAllStringTables message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClearAllStringTables.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapname != null && Object.hasOwnProperty.call(message, "mapname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mapname);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ClearAllStringTables message, length delimited. Does not implicitly {@link CSVCMsg_ClearAllStringTables.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {ICSVCMsg_ClearAllStringTables} message CSVCMsg_ClearAllStringTables message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClearAllStringTables.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ClearAllStringTables message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClearAllStringTables.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClearAllStringTables();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mapname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ClearAllStringTables message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClearAllStringTables.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ClearAllStringTables message.
         * @function verify
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ClearAllStringTables.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapname != null && message.hasOwnProperty("mapname"))
                if (!$util.isString(message.mapname))
                    return "mapname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ClearAllStringTables message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables
         */
        CSVCMsg_ClearAllStringTables.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ClearAllStringTables)
                return object;
            var message = new $root.CSVCMsg_ClearAllStringTables();
            if (object.mapname != null)
                message.mapname = String(object.mapname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ClearAllStringTables message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {CSVCMsg_ClearAllStringTables} message CSVCMsg_ClearAllStringTables
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ClearAllStringTables.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mapname = "";
            if (message.mapname != null && message.hasOwnProperty("mapname"))
                object.mapname = message.mapname;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ClearAllStringTables to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ClearAllStringTables
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ClearAllStringTables.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_ClearAllStringTables;
    })();
    
    $root.ProtoFlattenedSerializerField_t = (function() {
    
        /**
         * Properties of a ProtoFlattenedSerializerField_t.
         * @exports IProtoFlattenedSerializerField_t
         * @interface IProtoFlattenedSerializerField_t
         * @property {number|null} [var_type_sym] ProtoFlattenedSerializerField_t var_type_sym
         * @property {number|null} [var_name_sym] ProtoFlattenedSerializerField_t var_name_sym
         * @property {number|null} [bit_count] ProtoFlattenedSerializerField_t bit_count
         * @property {number|null} [low_value] ProtoFlattenedSerializerField_t low_value
         * @property {number|null} [high_value] ProtoFlattenedSerializerField_t high_value
         * @property {number|null} [encode_flags] ProtoFlattenedSerializerField_t encode_flags
         * @property {number|null} [field_serializer_name_sym] ProtoFlattenedSerializerField_t field_serializer_name_sym
         * @property {number|null} [field_serializer_version] ProtoFlattenedSerializerField_t field_serializer_version
         * @property {number|null} [send_node_sym] ProtoFlattenedSerializerField_t send_node_sym
         * @property {number|null} [var_encoder_sym] ProtoFlattenedSerializerField_t var_encoder_sym
         */
    
        /**
         * Constructs a new ProtoFlattenedSerializerField_t.
         * @exports ProtoFlattenedSerializerField_t
         * @classdesc Represents a ProtoFlattenedSerializerField_t.
         * @implements IProtoFlattenedSerializerField_t
         * @constructor
         * @param {IProtoFlattenedSerializerField_t=} [properties] Properties to set
         */
        function ProtoFlattenedSerializerField_t(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ProtoFlattenedSerializerField_t var_type_sym.
         * @member {number} var_type_sym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.var_type_sym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t var_name_sym.
         * @member {number} var_name_sym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.var_name_sym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t bit_count.
         * @member {number} bit_count
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.bit_count = 0;
    
        /**
         * ProtoFlattenedSerializerField_t low_value.
         * @member {number} low_value
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.low_value = 0;
    
        /**
         * ProtoFlattenedSerializerField_t high_value.
         * @member {number} high_value
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.high_value = 0;
    
        /**
         * ProtoFlattenedSerializerField_t encode_flags.
         * @member {number} encode_flags
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.encode_flags = 0;
    
        /**
         * ProtoFlattenedSerializerField_t field_serializer_name_sym.
         * @member {number} field_serializer_name_sym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.field_serializer_name_sym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t field_serializer_version.
         * @member {number} field_serializer_version
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.field_serializer_version = 0;
    
        /**
         * ProtoFlattenedSerializerField_t send_node_sym.
         * @member {number} send_node_sym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.send_node_sym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t var_encoder_sym.
         * @member {number} var_encoder_sym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.var_encoder_sym = 0;
    
        /**
         * Creates a new ProtoFlattenedSerializerField_t instance using the specified properties.
         * @function create
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {IProtoFlattenedSerializerField_t=} [properties] Properties to set
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t instance
         */
        ProtoFlattenedSerializerField_t.create = function create(properties) {
            return new ProtoFlattenedSerializerField_t(properties);
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializerField_t message. Does not implicitly {@link ProtoFlattenedSerializerField_t.verify|verify} messages.
         * @function encode
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {IProtoFlattenedSerializerField_t} message ProtoFlattenedSerializerField_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializerField_t.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.var_type_sym != null && Object.hasOwnProperty.call(message, "var_type_sym"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.var_type_sym);
            if (message.var_name_sym != null && Object.hasOwnProperty.call(message, "var_name_sym"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.var_name_sym);
            if (message.bit_count != null && Object.hasOwnProperty.call(message, "bit_count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bit_count);
            if (message.low_value != null && Object.hasOwnProperty.call(message, "low_value"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.low_value);
            if (message.high_value != null && Object.hasOwnProperty.call(message, "high_value"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.high_value);
            if (message.encode_flags != null && Object.hasOwnProperty.call(message, "encode_flags"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.encode_flags);
            if (message.field_serializer_name_sym != null && Object.hasOwnProperty.call(message, "field_serializer_name_sym"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.field_serializer_name_sym);
            if (message.field_serializer_version != null && Object.hasOwnProperty.call(message, "field_serializer_version"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.field_serializer_version);
            if (message.send_node_sym != null && Object.hasOwnProperty.call(message, "send_node_sym"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.send_node_sym);
            if (message.var_encoder_sym != null && Object.hasOwnProperty.call(message, "var_encoder_sym"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.var_encoder_sym);
            return writer;
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializerField_t message, length delimited. Does not implicitly {@link ProtoFlattenedSerializerField_t.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {IProtoFlattenedSerializerField_t} message ProtoFlattenedSerializerField_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializerField_t.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ProtoFlattenedSerializerField_t message from the specified reader or buffer.
         * @function decode
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializerField_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtoFlattenedSerializerField_t();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.var_type_sym = reader.int32();
                    break;
                case 2:
                    message.var_name_sym = reader.int32();
                    break;
                case 3:
                    message.bit_count = reader.int32();
                    break;
                case 4:
                    message.low_value = reader.float();
                    break;
                case 5:
                    message.high_value = reader.float();
                    break;
                case 6:
                    message.encode_flags = reader.int32();
                    break;
                case 7:
                    message.field_serializer_name_sym = reader.int32();
                    break;
                case 8:
                    message.field_serializer_version = reader.int32();
                    break;
                case 9:
                    message.send_node_sym = reader.int32();
                    break;
                case 10:
                    message.var_encoder_sym = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ProtoFlattenedSerializerField_t message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializerField_t.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ProtoFlattenedSerializerField_t message.
         * @function verify
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFlattenedSerializerField_t.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.var_type_sym != null && message.hasOwnProperty("var_type_sym"))
                if (!$util.isInteger(message.var_type_sym))
                    return "var_type_sym: integer expected";
            if (message.var_name_sym != null && message.hasOwnProperty("var_name_sym"))
                if (!$util.isInteger(message.var_name_sym))
                    return "var_name_sym: integer expected";
            if (message.bit_count != null && message.hasOwnProperty("bit_count"))
                if (!$util.isInteger(message.bit_count))
                    return "bit_count: integer expected";
            if (message.low_value != null && message.hasOwnProperty("low_value"))
                if (typeof message.low_value !== "number")
                    return "low_value: number expected";
            if (message.high_value != null && message.hasOwnProperty("high_value"))
                if (typeof message.high_value !== "number")
                    return "high_value: number expected";
            if (message.encode_flags != null && message.hasOwnProperty("encode_flags"))
                if (!$util.isInteger(message.encode_flags))
                    return "encode_flags: integer expected";
            if (message.field_serializer_name_sym != null && message.hasOwnProperty("field_serializer_name_sym"))
                if (!$util.isInteger(message.field_serializer_name_sym))
                    return "field_serializer_name_sym: integer expected";
            if (message.field_serializer_version != null && message.hasOwnProperty("field_serializer_version"))
                if (!$util.isInteger(message.field_serializer_version))
                    return "field_serializer_version: integer expected";
            if (message.send_node_sym != null && message.hasOwnProperty("send_node_sym"))
                if (!$util.isInteger(message.send_node_sym))
                    return "send_node_sym: integer expected";
            if (message.var_encoder_sym != null && message.hasOwnProperty("var_encoder_sym"))
                if (!$util.isInteger(message.var_encoder_sym))
                    return "var_encoder_sym: integer expected";
            return null;
        };
    
        /**
         * Creates a ProtoFlattenedSerializerField_t message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t
         */
        ProtoFlattenedSerializerField_t.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtoFlattenedSerializerField_t)
                return object;
            var message = new $root.ProtoFlattenedSerializerField_t();
            if (object.var_type_sym != null)
                message.var_type_sym = object.var_type_sym | 0;
            if (object.var_name_sym != null)
                message.var_name_sym = object.var_name_sym | 0;
            if (object.bit_count != null)
                message.bit_count = object.bit_count | 0;
            if (object.low_value != null)
                message.low_value = Number(object.low_value);
            if (object.high_value != null)
                message.high_value = Number(object.high_value);
            if (object.encode_flags != null)
                message.encode_flags = object.encode_flags | 0;
            if (object.field_serializer_name_sym != null)
                message.field_serializer_name_sym = object.field_serializer_name_sym | 0;
            if (object.field_serializer_version != null)
                message.field_serializer_version = object.field_serializer_version | 0;
            if (object.send_node_sym != null)
                message.send_node_sym = object.send_node_sym | 0;
            if (object.var_encoder_sym != null)
                message.var_encoder_sym = object.var_encoder_sym | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ProtoFlattenedSerializerField_t message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {ProtoFlattenedSerializerField_t} message ProtoFlattenedSerializerField_t
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFlattenedSerializerField_t.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.var_type_sym = 0;
                object.var_name_sym = 0;
                object.bit_count = 0;
                object.low_value = 0;
                object.high_value = 0;
                object.encode_flags = 0;
                object.field_serializer_name_sym = 0;
                object.field_serializer_version = 0;
                object.send_node_sym = 0;
                object.var_encoder_sym = 0;
            }
            if (message.var_type_sym != null && message.hasOwnProperty("var_type_sym"))
                object.var_type_sym = message.var_type_sym;
            if (message.var_name_sym != null && message.hasOwnProperty("var_name_sym"))
                object.var_name_sym = message.var_name_sym;
            if (message.bit_count != null && message.hasOwnProperty("bit_count"))
                object.bit_count = message.bit_count;
            if (message.low_value != null && message.hasOwnProperty("low_value"))
                object.low_value = options.json && !isFinite(message.low_value) ? String(message.low_value) : message.low_value;
            if (message.high_value != null && message.hasOwnProperty("high_value"))
                object.high_value = options.json && !isFinite(message.high_value) ? String(message.high_value) : message.high_value;
            if (message.encode_flags != null && message.hasOwnProperty("encode_flags"))
                object.encode_flags = message.encode_flags;
            if (message.field_serializer_name_sym != null && message.hasOwnProperty("field_serializer_name_sym"))
                object.field_serializer_name_sym = message.field_serializer_name_sym;
            if (message.field_serializer_version != null && message.hasOwnProperty("field_serializer_version"))
                object.field_serializer_version = message.field_serializer_version;
            if (message.send_node_sym != null && message.hasOwnProperty("send_node_sym"))
                object.send_node_sym = message.send_node_sym;
            if (message.var_encoder_sym != null && message.hasOwnProperty("var_encoder_sym"))
                object.var_encoder_sym = message.var_encoder_sym;
            return object;
        };
    
        /**
         * Converts this ProtoFlattenedSerializerField_t to JSON.
         * @function toJSON
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFlattenedSerializerField_t.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ProtoFlattenedSerializerField_t;
    })();
    
    $root.ProtoFlattenedSerializer_t = (function() {
    
        /**
         * Properties of a ProtoFlattenedSerializer_t.
         * @exports IProtoFlattenedSerializer_t
         * @interface IProtoFlattenedSerializer_t
         * @property {number|null} [serializer_name_sym] ProtoFlattenedSerializer_t serializer_name_sym
         * @property {number|null} [serializer_version] ProtoFlattenedSerializer_t serializer_version
         * @property {Array.<number>|null} [fields_index] ProtoFlattenedSerializer_t fields_index
         */
    
        /**
         * Constructs a new ProtoFlattenedSerializer_t.
         * @exports ProtoFlattenedSerializer_t
         * @classdesc Represents a ProtoFlattenedSerializer_t.
         * @implements IProtoFlattenedSerializer_t
         * @constructor
         * @param {IProtoFlattenedSerializer_t=} [properties] Properties to set
         */
        function ProtoFlattenedSerializer_t(properties) {
            this.fields_index = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ProtoFlattenedSerializer_t serializer_name_sym.
         * @member {number} serializer_name_sym
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         */
        ProtoFlattenedSerializer_t.prototype.serializer_name_sym = 0;
    
        /**
         * ProtoFlattenedSerializer_t serializer_version.
         * @member {number} serializer_version
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         */
        ProtoFlattenedSerializer_t.prototype.serializer_version = 0;
    
        /**
         * ProtoFlattenedSerializer_t fields_index.
         * @member {Array.<number>} fields_index
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         */
        ProtoFlattenedSerializer_t.prototype.fields_index = $util.emptyArray;
    
        /**
         * Creates a new ProtoFlattenedSerializer_t instance using the specified properties.
         * @function create
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {IProtoFlattenedSerializer_t=} [properties] Properties to set
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t instance
         */
        ProtoFlattenedSerializer_t.create = function create(properties) {
            return new ProtoFlattenedSerializer_t(properties);
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializer_t message. Does not implicitly {@link ProtoFlattenedSerializer_t.verify|verify} messages.
         * @function encode
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {IProtoFlattenedSerializer_t} message ProtoFlattenedSerializer_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializer_t.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serializer_name_sym != null && Object.hasOwnProperty.call(message, "serializer_name_sym"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serializer_name_sym);
            if (message.serializer_version != null && Object.hasOwnProperty.call(message, "serializer_version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serializer_version);
            if (message.fields_index != null && message.fields_index.length)
                for (var i = 0; i < message.fields_index.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fields_index[i]);
            return writer;
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializer_t message, length delimited. Does not implicitly {@link ProtoFlattenedSerializer_t.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {IProtoFlattenedSerializer_t} message ProtoFlattenedSerializer_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializer_t.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ProtoFlattenedSerializer_t message from the specified reader or buffer.
         * @function decode
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializer_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtoFlattenedSerializer_t();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serializer_name_sym = reader.int32();
                    break;
                case 2:
                    message.serializer_version = reader.int32();
                    break;
                case 3:
                    if (!(message.fields_index && message.fields_index.length))
                        message.fields_index = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fields_index.push(reader.int32());
                    } else
                        message.fields_index.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ProtoFlattenedSerializer_t message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializer_t.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ProtoFlattenedSerializer_t message.
         * @function verify
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFlattenedSerializer_t.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serializer_name_sym != null && message.hasOwnProperty("serializer_name_sym"))
                if (!$util.isInteger(message.serializer_name_sym))
                    return "serializer_name_sym: integer expected";
            if (message.serializer_version != null && message.hasOwnProperty("serializer_version"))
                if (!$util.isInteger(message.serializer_version))
                    return "serializer_version: integer expected";
            if (message.fields_index != null && message.hasOwnProperty("fields_index")) {
                if (!Array.isArray(message.fields_index))
                    return "fields_index: array expected";
                for (var i = 0; i < message.fields_index.length; ++i)
                    if (!$util.isInteger(message.fields_index[i]))
                        return "fields_index: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a ProtoFlattenedSerializer_t message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t
         */
        ProtoFlattenedSerializer_t.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtoFlattenedSerializer_t)
                return object;
            var message = new $root.ProtoFlattenedSerializer_t();
            if (object.serializer_name_sym != null)
                message.serializer_name_sym = object.serializer_name_sym | 0;
            if (object.serializer_version != null)
                message.serializer_version = object.serializer_version | 0;
            if (object.fields_index) {
                if (!Array.isArray(object.fields_index))
                    throw TypeError(".ProtoFlattenedSerializer_t.fields_index: array expected");
                message.fields_index = [];
                for (var i = 0; i < object.fields_index.length; ++i)
                    message.fields_index[i] = object.fields_index[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ProtoFlattenedSerializer_t message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {ProtoFlattenedSerializer_t} message ProtoFlattenedSerializer_t
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFlattenedSerializer_t.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fields_index = [];
            if (options.defaults) {
                object.serializer_name_sym = 0;
                object.serializer_version = 0;
            }
            if (message.serializer_name_sym != null && message.hasOwnProperty("serializer_name_sym"))
                object.serializer_name_sym = message.serializer_name_sym;
            if (message.serializer_version != null && message.hasOwnProperty("serializer_version"))
                object.serializer_version = message.serializer_version;
            if (message.fields_index && message.fields_index.length) {
                object.fields_index = [];
                for (var j = 0; j < message.fields_index.length; ++j)
                    object.fields_index[j] = message.fields_index[j];
            }
            return object;
        };
    
        /**
         * Converts this ProtoFlattenedSerializer_t to JSON.
         * @function toJSON
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFlattenedSerializer_t.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ProtoFlattenedSerializer_t;
    })();
    
    $root.CSVCMsg_FlattenedSerializer = (function() {
    
        /**
         * Properties of a CSVCMsg_FlattenedSerializer.
         * @exports ICSVCMsg_FlattenedSerializer
         * @interface ICSVCMsg_FlattenedSerializer
         * @property {Array.<IProtoFlattenedSerializer_t>|null} [serializers] CSVCMsg_FlattenedSerializer serializers
         * @property {Array.<string>|null} [symbols] CSVCMsg_FlattenedSerializer symbols
         * @property {Array.<IProtoFlattenedSerializerField_t>|null} [fields] CSVCMsg_FlattenedSerializer fields
         */
    
        /**
         * Constructs a new CSVCMsg_FlattenedSerializer.
         * @exports CSVCMsg_FlattenedSerializer
         * @classdesc Represents a CSVCMsg_FlattenedSerializer.
         * @implements ICSVCMsg_FlattenedSerializer
         * @constructor
         * @param {ICSVCMsg_FlattenedSerializer=} [properties] Properties to set
         */
        function CSVCMsg_FlattenedSerializer(properties) {
            this.serializers = [];
            this.symbols = [];
            this.fields = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FlattenedSerializer serializers.
         * @member {Array.<IProtoFlattenedSerializer_t>} serializers
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         */
        CSVCMsg_FlattenedSerializer.prototype.serializers = $util.emptyArray;
    
        /**
         * CSVCMsg_FlattenedSerializer symbols.
         * @member {Array.<string>} symbols
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         */
        CSVCMsg_FlattenedSerializer.prototype.symbols = $util.emptyArray;
    
        /**
         * CSVCMsg_FlattenedSerializer fields.
         * @member {Array.<IProtoFlattenedSerializerField_t>} fields
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         */
        CSVCMsg_FlattenedSerializer.prototype.fields = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_FlattenedSerializer instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {ICSVCMsg_FlattenedSerializer=} [properties] Properties to set
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer instance
         */
        CSVCMsg_FlattenedSerializer.create = function create(properties) {
            return new CSVCMsg_FlattenedSerializer(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FlattenedSerializer message. Does not implicitly {@link CSVCMsg_FlattenedSerializer.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {ICSVCMsg_FlattenedSerializer} message CSVCMsg_FlattenedSerializer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FlattenedSerializer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serializers != null && message.serializers.length)
                for (var i = 0; i < message.serializers.length; ++i)
                    $root.ProtoFlattenedSerializer_t.encode(message.serializers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.symbols != null && message.symbols.length)
                for (var i = 0; i < message.symbols.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbols[i]);
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.ProtoFlattenedSerializerField_t.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FlattenedSerializer message, length delimited. Does not implicitly {@link CSVCMsg_FlattenedSerializer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {ICSVCMsg_FlattenedSerializer} message CSVCMsg_FlattenedSerializer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FlattenedSerializer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FlattenedSerializer message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FlattenedSerializer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FlattenedSerializer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serializers && message.serializers.length))
                        message.serializers = [];
                    message.serializers.push($root.ProtoFlattenedSerializer_t.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.symbols && message.symbols.length))
                        message.symbols = [];
                    message.symbols.push(reader.string());
                    break;
                case 3:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.ProtoFlattenedSerializerField_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FlattenedSerializer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FlattenedSerializer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FlattenedSerializer message.
         * @function verify
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FlattenedSerializer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serializers != null && message.hasOwnProperty("serializers")) {
                if (!Array.isArray(message.serializers))
                    return "serializers: array expected";
                for (var i = 0; i < message.serializers.length; ++i) {
                    var error = $root.ProtoFlattenedSerializer_t.verify(message.serializers[i]);
                    if (error)
                        return "serializers." + error;
                }
            }
            if (message.symbols != null && message.hasOwnProperty("symbols")) {
                if (!Array.isArray(message.symbols))
                    return "symbols: array expected";
                for (var i = 0; i < message.symbols.length; ++i)
                    if (!$util.isString(message.symbols[i]))
                        return "symbols: string[] expected";
            }
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.ProtoFlattenedSerializerField_t.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FlattenedSerializer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer
         */
        CSVCMsg_FlattenedSerializer.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FlattenedSerializer)
                return object;
            var message = new $root.CSVCMsg_FlattenedSerializer();
            if (object.serializers) {
                if (!Array.isArray(object.serializers))
                    throw TypeError(".CSVCMsg_FlattenedSerializer.serializers: array expected");
                message.serializers = [];
                for (var i = 0; i < object.serializers.length; ++i) {
                    if (typeof object.serializers[i] !== "object")
                        throw TypeError(".CSVCMsg_FlattenedSerializer.serializers: object expected");
                    message.serializers[i] = $root.ProtoFlattenedSerializer_t.fromObject(object.serializers[i]);
                }
            }
            if (object.symbols) {
                if (!Array.isArray(object.symbols))
                    throw TypeError(".CSVCMsg_FlattenedSerializer.symbols: array expected");
                message.symbols = [];
                for (var i = 0; i < object.symbols.length; ++i)
                    message.symbols[i] = String(object.symbols[i]);
            }
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".CSVCMsg_FlattenedSerializer.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".CSVCMsg_FlattenedSerializer.fields: object expected");
                    message.fields[i] = $root.ProtoFlattenedSerializerField_t.fromObject(object.fields[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FlattenedSerializer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {CSVCMsg_FlattenedSerializer} message CSVCMsg_FlattenedSerializer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FlattenedSerializer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.serializers = [];
                object.symbols = [];
                object.fields = [];
            }
            if (message.serializers && message.serializers.length) {
                object.serializers = [];
                for (var j = 0; j < message.serializers.length; ++j)
                    object.serializers[j] = $root.ProtoFlattenedSerializer_t.toObject(message.serializers[j], options);
            }
            if (message.symbols && message.symbols.length) {
                object.symbols = [];
                for (var j = 0; j < message.symbols.length; ++j)
                    object.symbols[j] = message.symbols[j];
            }
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.ProtoFlattenedSerializerField_t.toObject(message.fields[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FlattenedSerializer to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FlattenedSerializer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_FlattenedSerializer;
    })();
    
    $root.CSVCMsg_StopSound = (function() {
    
        /**
         * Properties of a CSVCMsg_StopSound.
         * @exports ICSVCMsg_StopSound
         * @interface ICSVCMsg_StopSound
         * @property {number|null} [guid] CSVCMsg_StopSound guid
         */
    
        /**
         * Constructs a new CSVCMsg_StopSound.
         * @exports CSVCMsg_StopSound
         * @classdesc Represents a CSVCMsg_StopSound.
         * @implements ICSVCMsg_StopSound
         * @constructor
         * @param {ICSVCMsg_StopSound=} [properties] Properties to set
         */
        function CSVCMsg_StopSound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_StopSound guid.
         * @member {number} guid
         * @memberof CSVCMsg_StopSound
         * @instance
         */
        CSVCMsg_StopSound.prototype.guid = 0;
    
        /**
         * Creates a new CSVCMsg_StopSound instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {ICSVCMsg_StopSound=} [properties] Properties to set
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound instance
         */
        CSVCMsg_StopSound.create = function create(properties) {
            return new CSVCMsg_StopSound(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_StopSound message. Does not implicitly {@link CSVCMsg_StopSound.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {ICSVCMsg_StopSound} message CSVCMsg_StopSound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_StopSound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guid != null && Object.hasOwnProperty.call(message, "guid"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.guid);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_StopSound message, length delimited. Does not implicitly {@link CSVCMsg_StopSound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {ICSVCMsg_StopSound} message CSVCMsg_StopSound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_StopSound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_StopSound message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_StopSound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_StopSound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guid = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_StopSound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_StopSound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_StopSound message.
         * @function verify
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_StopSound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guid != null && message.hasOwnProperty("guid"))
                if (!$util.isInteger(message.guid))
                    return "guid: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_StopSound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound
         */
        CSVCMsg_StopSound.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_StopSound)
                return object;
            var message = new $root.CSVCMsg_StopSound();
            if (object.guid != null)
                message.guid = object.guid >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_StopSound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {CSVCMsg_StopSound} message CSVCMsg_StopSound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_StopSound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guid = 0;
            if (message.guid != null && message.hasOwnProperty("guid"))
                object.guid = message.guid;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_StopSound to JSON.
         * @function toJSON
         * @memberof CSVCMsg_StopSound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_StopSound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_StopSound;
    })();
    
    $root.CBidirMsg_RebroadcastGameEvent = (function() {
    
        /**
         * Properties of a CBidirMsg_RebroadcastGameEvent.
         * @exports ICBidirMsg_RebroadcastGameEvent
         * @interface ICBidirMsg_RebroadcastGameEvent
         * @property {boolean|null} [posttoserver] CBidirMsg_RebroadcastGameEvent posttoserver
         * @property {number|null} [buftype] CBidirMsg_RebroadcastGameEvent buftype
         * @property {number|null} [clientbitcount] CBidirMsg_RebroadcastGameEvent clientbitcount
         * @property {number|Long|null} [receivingclients] CBidirMsg_RebroadcastGameEvent receivingclients
         */
    
        /**
         * Constructs a new CBidirMsg_RebroadcastGameEvent.
         * @exports CBidirMsg_RebroadcastGameEvent
         * @classdesc Represents a CBidirMsg_RebroadcastGameEvent.
         * @implements ICBidirMsg_RebroadcastGameEvent
         * @constructor
         * @param {ICBidirMsg_RebroadcastGameEvent=} [properties] Properties to set
         */
        function CBidirMsg_RebroadcastGameEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CBidirMsg_RebroadcastGameEvent posttoserver.
         * @member {boolean} posttoserver
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.posttoserver = false;
    
        /**
         * CBidirMsg_RebroadcastGameEvent buftype.
         * @member {number} buftype
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.buftype = 0;
    
        /**
         * CBidirMsg_RebroadcastGameEvent clientbitcount.
         * @member {number} clientbitcount
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.clientbitcount = 0;
    
        /**
         * CBidirMsg_RebroadcastGameEvent receivingclients.
         * @member {number|Long} receivingclients
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.receivingclients = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CBidirMsg_RebroadcastGameEvent instance using the specified properties.
         * @function create
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {ICBidirMsg_RebroadcastGameEvent=} [properties] Properties to set
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent instance
         */
        CBidirMsg_RebroadcastGameEvent.create = function create(properties) {
            return new CBidirMsg_RebroadcastGameEvent(properties);
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastGameEvent message. Does not implicitly {@link CBidirMsg_RebroadcastGameEvent.verify|verify} messages.
         * @function encode
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {ICBidirMsg_RebroadcastGameEvent} message CBidirMsg_RebroadcastGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastGameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.posttoserver != null && Object.hasOwnProperty.call(message, "posttoserver"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.posttoserver);
            if (message.buftype != null && Object.hasOwnProperty.call(message, "buftype"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buftype);
            if (message.clientbitcount != null && Object.hasOwnProperty.call(message, "clientbitcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.clientbitcount);
            if (message.receivingclients != null && Object.hasOwnProperty.call(message, "receivingclients"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.receivingclients);
            return writer;
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastGameEvent message, length delimited. Does not implicitly {@link CBidirMsg_RebroadcastGameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {ICBidirMsg_RebroadcastGameEvent} message CBidirMsg_RebroadcastGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastGameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastGameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastGameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RebroadcastGameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.posttoserver = reader.bool();
                    break;
                case 2:
                    message.buftype = reader.int32();
                    break;
                case 3:
                    message.clientbitcount = reader.uint32();
                    break;
                case 4:
                    message.receivingclients = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastGameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastGameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CBidirMsg_RebroadcastGameEvent message.
         * @function verify
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CBidirMsg_RebroadcastGameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.posttoserver != null && message.hasOwnProperty("posttoserver"))
                if (typeof message.posttoserver !== "boolean")
                    return "posttoserver: boolean expected";
            if (message.buftype != null && message.hasOwnProperty("buftype"))
                if (!$util.isInteger(message.buftype))
                    return "buftype: integer expected";
            if (message.clientbitcount != null && message.hasOwnProperty("clientbitcount"))
                if (!$util.isInteger(message.clientbitcount))
                    return "clientbitcount: integer expected";
            if (message.receivingclients != null && message.hasOwnProperty("receivingclients"))
                if (!$util.isInteger(message.receivingclients) && !(message.receivingclients && $util.isInteger(message.receivingclients.low) && $util.isInteger(message.receivingclients.high)))
                    return "receivingclients: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CBidirMsg_RebroadcastGameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent
         */
        CBidirMsg_RebroadcastGameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CBidirMsg_RebroadcastGameEvent)
                return object;
            var message = new $root.CBidirMsg_RebroadcastGameEvent();
            if (object.posttoserver != null)
                message.posttoserver = Boolean(object.posttoserver);
            if (object.buftype != null)
                message.buftype = object.buftype | 0;
            if (object.clientbitcount != null)
                message.clientbitcount = object.clientbitcount >>> 0;
            if (object.receivingclients != null)
                if ($util.Long)
                    (message.receivingclients = $util.Long.fromValue(object.receivingclients)).unsigned = true;
                else if (typeof object.receivingclients === "string")
                    message.receivingclients = parseInt(object.receivingclients, 10);
                else if (typeof object.receivingclients === "number")
                    message.receivingclients = object.receivingclients;
                else if (typeof object.receivingclients === "object")
                    message.receivingclients = new $util.LongBits(object.receivingclients.low >>> 0, object.receivingclients.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CBidirMsg_RebroadcastGameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {CBidirMsg_RebroadcastGameEvent} message CBidirMsg_RebroadcastGameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CBidirMsg_RebroadcastGameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.posttoserver = false;
                object.buftype = 0;
                object.clientbitcount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.receivingclients = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.receivingclients = options.longs === String ? "0" : 0;
            }
            if (message.posttoserver != null && message.hasOwnProperty("posttoserver"))
                object.posttoserver = message.posttoserver;
            if (message.buftype != null && message.hasOwnProperty("buftype"))
                object.buftype = message.buftype;
            if (message.clientbitcount != null && message.hasOwnProperty("clientbitcount"))
                object.clientbitcount = message.clientbitcount;
            if (message.receivingclients != null && message.hasOwnProperty("receivingclients"))
                if (typeof message.receivingclients === "number")
                    object.receivingclients = options.longs === String ? String(message.receivingclients) : message.receivingclients;
                else
                    object.receivingclients = options.longs === String ? $util.Long.prototype.toString.call(message.receivingclients) : options.longs === Number ? new $util.LongBits(message.receivingclients.low >>> 0, message.receivingclients.high >>> 0).toNumber(true) : message.receivingclients;
            return object;
        };
    
        /**
         * Converts this CBidirMsg_RebroadcastGameEvent to JSON.
         * @function toJSON
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CBidirMsg_RebroadcastGameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CBidirMsg_RebroadcastGameEvent;
    })();
    
    $root.CBidirMsg_RebroadcastSource = (function() {
    
        /**
         * Properties of a CBidirMsg_RebroadcastSource.
         * @exports ICBidirMsg_RebroadcastSource
         * @interface ICBidirMsg_RebroadcastSource
         * @property {number|null} [eventsource] CBidirMsg_RebroadcastSource eventsource
         */
    
        /**
         * Constructs a new CBidirMsg_RebroadcastSource.
         * @exports CBidirMsg_RebroadcastSource
         * @classdesc Represents a CBidirMsg_RebroadcastSource.
         * @implements ICBidirMsg_RebroadcastSource
         * @constructor
         * @param {ICBidirMsg_RebroadcastSource=} [properties] Properties to set
         */
        function CBidirMsg_RebroadcastSource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CBidirMsg_RebroadcastSource eventsource.
         * @member {number} eventsource
         * @memberof CBidirMsg_RebroadcastSource
         * @instance
         */
        CBidirMsg_RebroadcastSource.prototype.eventsource = 0;
    
        /**
         * Creates a new CBidirMsg_RebroadcastSource instance using the specified properties.
         * @function create
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {ICBidirMsg_RebroadcastSource=} [properties] Properties to set
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource instance
         */
        CBidirMsg_RebroadcastSource.create = function create(properties) {
            return new CBidirMsg_RebroadcastSource(properties);
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastSource message. Does not implicitly {@link CBidirMsg_RebroadcastSource.verify|verify} messages.
         * @function encode
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {ICBidirMsg_RebroadcastSource} message CBidirMsg_RebroadcastSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastSource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventsource != null && Object.hasOwnProperty.call(message, "eventsource"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventsource);
            return writer;
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastSource message, length delimited. Does not implicitly {@link CBidirMsg_RebroadcastSource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {ICBidirMsg_RebroadcastSource} message CBidirMsg_RebroadcastSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastSource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastSource message from the specified reader or buffer.
         * @function decode
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastSource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RebroadcastSource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eventsource = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastSource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastSource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CBidirMsg_RebroadcastSource message.
         * @function verify
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CBidirMsg_RebroadcastSource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventsource != null && message.hasOwnProperty("eventsource"))
                if (!$util.isInteger(message.eventsource))
                    return "eventsource: integer expected";
            return null;
        };
    
        /**
         * Creates a CBidirMsg_RebroadcastSource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource
         */
        CBidirMsg_RebroadcastSource.fromObject = function fromObject(object) {
            if (object instanceof $root.CBidirMsg_RebroadcastSource)
                return object;
            var message = new $root.CBidirMsg_RebroadcastSource();
            if (object.eventsource != null)
                message.eventsource = object.eventsource | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CBidirMsg_RebroadcastSource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {CBidirMsg_RebroadcastSource} message CBidirMsg_RebroadcastSource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CBidirMsg_RebroadcastSource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eventsource = 0;
            if (message.eventsource != null && message.hasOwnProperty("eventsource"))
                object.eventsource = message.eventsource;
            return object;
        };
    
        /**
         * Converts this CBidirMsg_RebroadcastSource to JSON.
         * @function toJSON
         * @memberof CBidirMsg_RebroadcastSource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CBidirMsg_RebroadcastSource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CBidirMsg_RebroadcastSource;
    })();
    
    $root.SerializedNetAddress_t = (function() {
    
        /**
         * Properties of a SerializedNetAddress_t.
         * @exports ISerializedNetAddress_t
         * @interface ISerializedNetAddress_t
         * @property {Uint8Array} serializedAddress SerializedNetAddress_t serializedAddress
         */
    
        /**
         * Constructs a new SerializedNetAddress_t.
         * @exports SerializedNetAddress_t
         * @classdesc Represents a SerializedNetAddress_t.
         * @implements ISerializedNetAddress_t
         * @constructor
         * @param {ISerializedNetAddress_t=} [properties] Properties to set
         */
        function SerializedNetAddress_t(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SerializedNetAddress_t serializedAddress.
         * @member {Uint8Array} serializedAddress
         * @memberof SerializedNetAddress_t
         * @instance
         */
        SerializedNetAddress_t.prototype.serializedAddress = $util.newBuffer([]);
    
        /**
         * Creates a new SerializedNetAddress_t instance using the specified properties.
         * @function create
         * @memberof SerializedNetAddress_t
         * @static
         * @param {ISerializedNetAddress_t=} [properties] Properties to set
         * @returns {SerializedNetAddress_t} SerializedNetAddress_t instance
         */
        SerializedNetAddress_t.create = function create(properties) {
            return new SerializedNetAddress_t(properties);
        };
    
        /**
         * Encodes the specified SerializedNetAddress_t message. Does not implicitly {@link SerializedNetAddress_t.verify|verify} messages.
         * @function encode
         * @memberof SerializedNetAddress_t
         * @static
         * @param {ISerializedNetAddress_t} message SerializedNetAddress_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SerializedNetAddress_t.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.serializedAddress);
            return writer;
        };
    
        /**
         * Encodes the specified SerializedNetAddress_t message, length delimited. Does not implicitly {@link SerializedNetAddress_t.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SerializedNetAddress_t
         * @static
         * @param {ISerializedNetAddress_t} message SerializedNetAddress_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SerializedNetAddress_t.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SerializedNetAddress_t message from the specified reader or buffer.
         * @function decode
         * @memberof SerializedNetAddress_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SerializedNetAddress_t} SerializedNetAddress_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SerializedNetAddress_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SerializedNetAddress_t();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serializedAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("serializedAddress"))
                throw $util.ProtocolError("missing required 'serializedAddress'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SerializedNetAddress_t message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SerializedNetAddress_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SerializedNetAddress_t} SerializedNetAddress_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SerializedNetAddress_t.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SerializedNetAddress_t message.
         * @function verify
         * @memberof SerializedNetAddress_t
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SerializedNetAddress_t.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.serializedAddress && typeof message.serializedAddress.length === "number" || $util.isString(message.serializedAddress)))
                return "serializedAddress: buffer expected";
            return null;
        };
    
        /**
         * Creates a SerializedNetAddress_t message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SerializedNetAddress_t
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SerializedNetAddress_t} SerializedNetAddress_t
         */
        SerializedNetAddress_t.fromObject = function fromObject(object) {
            if (object instanceof $root.SerializedNetAddress_t)
                return object;
            var message = new $root.SerializedNetAddress_t();
            if (object.serializedAddress != null)
                if (typeof object.serializedAddress === "string")
                    $util.base64.decode(object.serializedAddress, message.serializedAddress = $util.newBuffer($util.base64.length(object.serializedAddress)), 0);
                else if (object.serializedAddress.length)
                    message.serializedAddress = object.serializedAddress;
            return message;
        };
    
        /**
         * Creates a plain object from a SerializedNetAddress_t message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SerializedNetAddress_t
         * @static
         * @param {SerializedNetAddress_t} message SerializedNetAddress_t
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SerializedNetAddress_t.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.serializedAddress = "";
                else {
                    object.serializedAddress = [];
                    if (options.bytes !== Array)
                        object.serializedAddress = $util.newBuffer(object.serializedAddress);
                }
            if (message.serializedAddress != null && message.hasOwnProperty("serializedAddress"))
                object.serializedAddress = options.bytes === String ? $util.base64.encode(message.serializedAddress, 0, message.serializedAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedAddress) : message.serializedAddress;
            return object;
        };
    
        /**
         * Converts this SerializedNetAddress_t to JSON.
         * @function toJSON
         * @memberof SerializedNetAddress_t
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SerializedNetAddress_t.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SerializedNetAddress_t;
    })();
    
    $root.CBidirMsg_RelayInfo = (function() {
    
        /**
         * Properties of a CBidirMsg_RelayInfo.
         * @exports ICBidirMsg_RelayInfo
         * @interface ICBidirMsg_RelayInfo
         * @property {CBidirMsg_RelayInfo.Operation_t} operation CBidirMsg_RelayInfo operation
         * @property {ISerializedNetAddress_t|null} [serializedTargetAddress] CBidirMsg_RelayInfo serializedTargetAddress
         * @property {number|null} [additionalHops] CBidirMsg_RelayInfo additionalHops
         */
    
        /**
         * Constructs a new CBidirMsg_RelayInfo.
         * @exports CBidirMsg_RelayInfo
         * @classdesc Represents a CBidirMsg_RelayInfo.
         * @implements ICBidirMsg_RelayInfo
         * @constructor
         * @param {ICBidirMsg_RelayInfo=} [properties] Properties to set
         */
        function CBidirMsg_RelayInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CBidirMsg_RelayInfo operation.
         * @member {CBidirMsg_RelayInfo.Operation_t} operation
         * @memberof CBidirMsg_RelayInfo
         * @instance
         */
        CBidirMsg_RelayInfo.prototype.operation = 0;
    
        /**
         * CBidirMsg_RelayInfo serializedTargetAddress.
         * @member {ISerializedNetAddress_t|null|undefined} serializedTargetAddress
         * @memberof CBidirMsg_RelayInfo
         * @instance
         */
        CBidirMsg_RelayInfo.prototype.serializedTargetAddress = null;
    
        /**
         * CBidirMsg_RelayInfo additionalHops.
         * @member {number} additionalHops
         * @memberof CBidirMsg_RelayInfo
         * @instance
         */
        CBidirMsg_RelayInfo.prototype.additionalHops = 0;
    
        /**
         * Creates a new CBidirMsg_RelayInfo instance using the specified properties.
         * @function create
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {ICBidirMsg_RelayInfo=} [properties] Properties to set
         * @returns {CBidirMsg_RelayInfo} CBidirMsg_RelayInfo instance
         */
        CBidirMsg_RelayInfo.create = function create(properties) {
            return new CBidirMsg_RelayInfo(properties);
        };
    
        /**
         * Encodes the specified CBidirMsg_RelayInfo message. Does not implicitly {@link CBidirMsg_RelayInfo.verify|verify} messages.
         * @function encode
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {ICBidirMsg_RelayInfo} message CBidirMsg_RelayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RelayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operation);
            if (message.serializedTargetAddress != null && Object.hasOwnProperty.call(message, "serializedTargetAddress"))
                $root.SerializedNetAddress_t.encode(message.serializedTargetAddress, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.additionalHops != null && Object.hasOwnProperty.call(message, "additionalHops"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.additionalHops);
            return writer;
        };
    
        /**
         * Encodes the specified CBidirMsg_RelayInfo message, length delimited. Does not implicitly {@link CBidirMsg_RelayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {ICBidirMsg_RelayInfo} message CBidirMsg_RelayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RelayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CBidirMsg_RelayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CBidirMsg_RelayInfo} CBidirMsg_RelayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RelayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RelayInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.operation = reader.int32();
                    break;
                case 2:
                    message.serializedTargetAddress = $root.SerializedNetAddress_t.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.additionalHops = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("operation"))
                throw $util.ProtocolError("missing required 'operation'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CBidirMsg_RelayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CBidirMsg_RelayInfo} CBidirMsg_RelayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RelayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CBidirMsg_RelayInfo message.
         * @function verify
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CBidirMsg_RelayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.operation) {
            default:
                return "operation: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (message.serializedTargetAddress != null && message.hasOwnProperty("serializedTargetAddress")) {
                var error = $root.SerializedNetAddress_t.verify(message.serializedTargetAddress);
                if (error)
                    return "serializedTargetAddress." + error;
            }
            if (message.additionalHops != null && message.hasOwnProperty("additionalHops"))
                if (!$util.isInteger(message.additionalHops))
                    return "additionalHops: integer expected";
            return null;
        };
    
        /**
         * Creates a CBidirMsg_RelayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CBidirMsg_RelayInfo} CBidirMsg_RelayInfo
         */
        CBidirMsg_RelayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CBidirMsg_RelayInfo)
                return object;
            var message = new $root.CBidirMsg_RelayInfo();
            switch (object.operation) {
            case "RIO_REQUEST_RELAY":
            case 0:
                message.operation = 0;
                break;
            case "RIO_WILL_RELAY":
            case 1:
                message.operation = 1;
                break;
            case "RIO_NO_ROUTE":
            case 2:
                message.operation = 2;
                break;
            case "RIO_REJECT_RELAY":
            case 3:
                message.operation = 3;
                break;
            case "RIO_ESTABLISH_CONNECTION":
            case 4:
                message.operation = 4;
                break;
            }
            if (object.serializedTargetAddress != null) {
                if (typeof object.serializedTargetAddress !== "object")
                    throw TypeError(".CBidirMsg_RelayInfo.serializedTargetAddress: object expected");
                message.serializedTargetAddress = $root.SerializedNetAddress_t.fromObject(object.serializedTargetAddress);
            }
            if (object.additionalHops != null)
                message.additionalHops = object.additionalHops >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CBidirMsg_RelayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CBidirMsg_RelayInfo
         * @static
         * @param {CBidirMsg_RelayInfo} message CBidirMsg_RelayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CBidirMsg_RelayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.operation = options.enums === String ? "RIO_REQUEST_RELAY" : 0;
                object.serializedTargetAddress = null;
                object.additionalHops = 0;
            }
            if (message.operation != null && message.hasOwnProperty("operation"))
                object.operation = options.enums === String ? $root.CBidirMsg_RelayInfo.Operation_t[message.operation] : message.operation;
            if (message.serializedTargetAddress != null && message.hasOwnProperty("serializedTargetAddress"))
                object.serializedTargetAddress = $root.SerializedNetAddress_t.toObject(message.serializedTargetAddress, options);
            if (message.additionalHops != null && message.hasOwnProperty("additionalHops"))
                object.additionalHops = message.additionalHops;
            return object;
        };
    
        /**
         * Converts this CBidirMsg_RelayInfo to JSON.
         * @function toJSON
         * @memberof CBidirMsg_RelayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CBidirMsg_RelayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Operation_t enum.
         * @name CBidirMsg_RelayInfo.Operation_t
         * @enum {number}
         * @property {number} RIO_REQUEST_RELAY=0 RIO_REQUEST_RELAY value
         * @property {number} RIO_WILL_RELAY=1 RIO_WILL_RELAY value
         * @property {number} RIO_NO_ROUTE=2 RIO_NO_ROUTE value
         * @property {number} RIO_REJECT_RELAY=3 RIO_REJECT_RELAY value
         * @property {number} RIO_ESTABLISH_CONNECTION=4 RIO_ESTABLISH_CONNECTION value
         */
        CBidirMsg_RelayInfo.Operation_t = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RIO_REQUEST_RELAY"] = 0;
            values[valuesById[1] = "RIO_WILL_RELAY"] = 1;
            values[valuesById[2] = "RIO_NO_ROUTE"] = 2;
            values[valuesById[3] = "RIO_REJECT_RELAY"] = 3;
            values[valuesById[4] = "RIO_ESTABLISH_CONNECTION"] = 4;
            return values;
        })();
    
        return CBidirMsg_RelayInfo;
    })();
    
    $root.SignedPayload_t = (function() {
    
        /**
         * Properties of a SignedPayload_t.
         * @exports ISignedPayload_t
         * @interface ISignedPayload_t
         * @property {Uint8Array} payloadData SignedPayload_t payloadData
         * @property {number} signature SignedPayload_t signature
         * @property {boolean} bPayloadEncrypted SignedPayload_t bPayloadEncrypted
         */
    
        /**
         * Constructs a new SignedPayload_t.
         * @exports SignedPayload_t
         * @classdesc Represents a SignedPayload_t.
         * @implements ISignedPayload_t
         * @constructor
         * @param {ISignedPayload_t=} [properties] Properties to set
         */
        function SignedPayload_t(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SignedPayload_t payloadData.
         * @member {Uint8Array} payloadData
         * @memberof SignedPayload_t
         * @instance
         */
        SignedPayload_t.prototype.payloadData = $util.newBuffer([]);
    
        /**
         * SignedPayload_t signature.
         * @member {number} signature
         * @memberof SignedPayload_t
         * @instance
         */
        SignedPayload_t.prototype.signature = 0;
    
        /**
         * SignedPayload_t bPayloadEncrypted.
         * @member {boolean} bPayloadEncrypted
         * @memberof SignedPayload_t
         * @instance
         */
        SignedPayload_t.prototype.bPayloadEncrypted = false;
    
        /**
         * Creates a new SignedPayload_t instance using the specified properties.
         * @function create
         * @memberof SignedPayload_t
         * @static
         * @param {ISignedPayload_t=} [properties] Properties to set
         * @returns {SignedPayload_t} SignedPayload_t instance
         */
        SignedPayload_t.create = function create(properties) {
            return new SignedPayload_t(properties);
        };
    
        /**
         * Encodes the specified SignedPayload_t message. Does not implicitly {@link SignedPayload_t.verify|verify} messages.
         * @function encode
         * @memberof SignedPayload_t
         * @static
         * @param {ISignedPayload_t} message SignedPayload_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedPayload_t.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payloadData);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.signature);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bPayloadEncrypted);
            return writer;
        };
    
        /**
         * Encodes the specified SignedPayload_t message, length delimited. Does not implicitly {@link SignedPayload_t.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SignedPayload_t
         * @static
         * @param {ISignedPayload_t} message SignedPayload_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedPayload_t.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SignedPayload_t message from the specified reader or buffer.
         * @function decode
         * @memberof SignedPayload_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SignedPayload_t} SignedPayload_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedPayload_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignedPayload_t();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payloadData = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.uint32();
                    break;
                case 3:
                    message.bPayloadEncrypted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("payloadData"))
                throw $util.ProtocolError("missing required 'payloadData'", { instance: message });
            if (!message.hasOwnProperty("signature"))
                throw $util.ProtocolError("missing required 'signature'", { instance: message });
            if (!message.hasOwnProperty("bPayloadEncrypted"))
                throw $util.ProtocolError("missing required 'bPayloadEncrypted'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SignedPayload_t message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SignedPayload_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SignedPayload_t} SignedPayload_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedPayload_t.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SignedPayload_t message.
         * @function verify
         * @memberof SignedPayload_t
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignedPayload_t.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.payloadData && typeof message.payloadData.length === "number" || $util.isString(message.payloadData)))
                return "payloadData: buffer expected";
            if (!$util.isInteger(message.signature))
                return "signature: integer expected";
            if (typeof message.bPayloadEncrypted !== "boolean")
                return "bPayloadEncrypted: boolean expected";
            return null;
        };
    
        /**
         * Creates a SignedPayload_t message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SignedPayload_t
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SignedPayload_t} SignedPayload_t
         */
        SignedPayload_t.fromObject = function fromObject(object) {
            if (object instanceof $root.SignedPayload_t)
                return object;
            var message = new $root.SignedPayload_t();
            if (object.payloadData != null)
                if (typeof object.payloadData === "string")
                    $util.base64.decode(object.payloadData, message.payloadData = $util.newBuffer($util.base64.length(object.payloadData)), 0);
                else if (object.payloadData.length)
                    message.payloadData = object.payloadData;
            if (object.signature != null)
                message.signature = object.signature >>> 0;
            if (object.bPayloadEncrypted != null)
                message.bPayloadEncrypted = Boolean(object.bPayloadEncrypted);
            return message;
        };
    
        /**
         * Creates a plain object from a SignedPayload_t message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SignedPayload_t
         * @static
         * @param {SignedPayload_t} message SignedPayload_t
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignedPayload_t.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.payloadData = "";
                else {
                    object.payloadData = [];
                    if (options.bytes !== Array)
                        object.payloadData = $util.newBuffer(object.payloadData);
                }
                object.signature = 0;
                object.bPayloadEncrypted = false;
            }
            if (message.payloadData != null && message.hasOwnProperty("payloadData"))
                object.payloadData = options.bytes === String ? $util.base64.encode(message.payloadData, 0, message.payloadData.length) : options.bytes === Array ? Array.prototype.slice.call(message.payloadData) : message.payloadData;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            if (message.bPayloadEncrypted != null && message.hasOwnProperty("bPayloadEncrypted"))
                object.bPayloadEncrypted = message.bPayloadEncrypted;
            return object;
        };
    
        /**
         * Converts this SignedPayload_t to JSON.
         * @function toJSON
         * @memberof SignedPayload_t
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignedPayload_t.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SignedPayload_t;
    })();
    
    $root.CBidirMsg_RelayPacket = (function() {
    
        /**
         * Properties of a CBidirMsg_RelayPacket.
         * @exports ICBidirMsg_RelayPacket
         * @interface ICBidirMsg_RelayPacket
         * @property {number} prevhopcount CBidirMsg_RelayPacket prevhopcount
         * @property {ISerializedNetAddress_t} originalSender CBidirMsg_RelayPacket originalSender
         * @property {ISignedPayload_t} signedPayload CBidirMsg_RelayPacket signedPayload
         * @property {Array.<CBidirMsg_RelayPacket.ISignedDestinationAddress_t>|null} [recipientList] CBidirMsg_RelayPacket recipientList
         */
    
        /**
         * Constructs a new CBidirMsg_RelayPacket.
         * @exports CBidirMsg_RelayPacket
         * @classdesc Represents a CBidirMsg_RelayPacket.
         * @implements ICBidirMsg_RelayPacket
         * @constructor
         * @param {ICBidirMsg_RelayPacket=} [properties] Properties to set
         */
        function CBidirMsg_RelayPacket(properties) {
            this.recipientList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CBidirMsg_RelayPacket prevhopcount.
         * @member {number} prevhopcount
         * @memberof CBidirMsg_RelayPacket
         * @instance
         */
        CBidirMsg_RelayPacket.prototype.prevhopcount = 0;
    
        /**
         * CBidirMsg_RelayPacket originalSender.
         * @member {ISerializedNetAddress_t} originalSender
         * @memberof CBidirMsg_RelayPacket
         * @instance
         */
        CBidirMsg_RelayPacket.prototype.originalSender = null;
    
        /**
         * CBidirMsg_RelayPacket signedPayload.
         * @member {ISignedPayload_t} signedPayload
         * @memberof CBidirMsg_RelayPacket
         * @instance
         */
        CBidirMsg_RelayPacket.prototype.signedPayload = null;
    
        /**
         * CBidirMsg_RelayPacket recipientList.
         * @member {Array.<CBidirMsg_RelayPacket.ISignedDestinationAddress_t>} recipientList
         * @memberof CBidirMsg_RelayPacket
         * @instance
         */
        CBidirMsg_RelayPacket.prototype.recipientList = $util.emptyArray;
    
        /**
         * Creates a new CBidirMsg_RelayPacket instance using the specified properties.
         * @function create
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {ICBidirMsg_RelayPacket=} [properties] Properties to set
         * @returns {CBidirMsg_RelayPacket} CBidirMsg_RelayPacket instance
         */
        CBidirMsg_RelayPacket.create = function create(properties) {
            return new CBidirMsg_RelayPacket(properties);
        };
    
        /**
         * Encodes the specified CBidirMsg_RelayPacket message. Does not implicitly {@link CBidirMsg_RelayPacket.verify|verify} messages.
         * @function encode
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {ICBidirMsg_RelayPacket} message CBidirMsg_RelayPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RelayPacket.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.prevhopcount);
            $root.SerializedNetAddress_t.encode(message.originalSender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.SignedPayload_t.encode(message.signedPayload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.recipientList != null && message.recipientList.length)
                for (var i = 0; i < message.recipientList.length; ++i)
                    $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t.encode(message.recipientList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CBidirMsg_RelayPacket message, length delimited. Does not implicitly {@link CBidirMsg_RelayPacket.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {ICBidirMsg_RelayPacket} message CBidirMsg_RelayPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RelayPacket.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CBidirMsg_RelayPacket message from the specified reader or buffer.
         * @function decode
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CBidirMsg_RelayPacket} CBidirMsg_RelayPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RelayPacket.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RelayPacket();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.prevhopcount = reader.uint32();
                    break;
                case 2:
                    message.originalSender = $root.SerializedNetAddress_t.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signedPayload = $root.SignedPayload_t.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.recipientList && message.recipientList.length))
                        message.recipientList = [];
                    message.recipientList.push($root.CBidirMsg_RelayPacket.SignedDestinationAddress_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("prevhopcount"))
                throw $util.ProtocolError("missing required 'prevhopcount'", { instance: message });
            if (!message.hasOwnProperty("originalSender"))
                throw $util.ProtocolError("missing required 'originalSender'", { instance: message });
            if (!message.hasOwnProperty("signedPayload"))
                throw $util.ProtocolError("missing required 'signedPayload'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CBidirMsg_RelayPacket message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CBidirMsg_RelayPacket} CBidirMsg_RelayPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RelayPacket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CBidirMsg_RelayPacket message.
         * @function verify
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CBidirMsg_RelayPacket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.prevhopcount))
                return "prevhopcount: integer expected";
            {
                var error = $root.SerializedNetAddress_t.verify(message.originalSender);
                if (error)
                    return "originalSender." + error;
            }
            {
                var error = $root.SignedPayload_t.verify(message.signedPayload);
                if (error)
                    return "signedPayload." + error;
            }
            if (message.recipientList != null && message.hasOwnProperty("recipientList")) {
                if (!Array.isArray(message.recipientList))
                    return "recipientList: array expected";
                for (var i = 0; i < message.recipientList.length; ++i) {
                    var error = $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t.verify(message.recipientList[i]);
                    if (error)
                        return "recipientList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CBidirMsg_RelayPacket message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CBidirMsg_RelayPacket} CBidirMsg_RelayPacket
         */
        CBidirMsg_RelayPacket.fromObject = function fromObject(object) {
            if (object instanceof $root.CBidirMsg_RelayPacket)
                return object;
            var message = new $root.CBidirMsg_RelayPacket();
            if (object.prevhopcount != null)
                message.prevhopcount = object.prevhopcount >>> 0;
            if (object.originalSender != null) {
                if (typeof object.originalSender !== "object")
                    throw TypeError(".CBidirMsg_RelayPacket.originalSender: object expected");
                message.originalSender = $root.SerializedNetAddress_t.fromObject(object.originalSender);
            }
            if (object.signedPayload != null) {
                if (typeof object.signedPayload !== "object")
                    throw TypeError(".CBidirMsg_RelayPacket.signedPayload: object expected");
                message.signedPayload = $root.SignedPayload_t.fromObject(object.signedPayload);
            }
            if (object.recipientList) {
                if (!Array.isArray(object.recipientList))
                    throw TypeError(".CBidirMsg_RelayPacket.recipientList: array expected");
                message.recipientList = [];
                for (var i = 0; i < object.recipientList.length; ++i) {
                    if (typeof object.recipientList[i] !== "object")
                        throw TypeError(".CBidirMsg_RelayPacket.recipientList: object expected");
                    message.recipientList[i] = $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t.fromObject(object.recipientList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CBidirMsg_RelayPacket message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CBidirMsg_RelayPacket
         * @static
         * @param {CBidirMsg_RelayPacket} message CBidirMsg_RelayPacket
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CBidirMsg_RelayPacket.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recipientList = [];
            if (options.defaults) {
                object.prevhopcount = 0;
                object.originalSender = null;
                object.signedPayload = null;
            }
            if (message.prevhopcount != null && message.hasOwnProperty("prevhopcount"))
                object.prevhopcount = message.prevhopcount;
            if (message.originalSender != null && message.hasOwnProperty("originalSender"))
                object.originalSender = $root.SerializedNetAddress_t.toObject(message.originalSender, options);
            if (message.signedPayload != null && message.hasOwnProperty("signedPayload"))
                object.signedPayload = $root.SignedPayload_t.toObject(message.signedPayload, options);
            if (message.recipientList && message.recipientList.length) {
                object.recipientList = [];
                for (var j = 0; j < message.recipientList.length; ++j)
                    object.recipientList[j] = $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t.toObject(message.recipientList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CBidirMsg_RelayPacket to JSON.
         * @function toJSON
         * @memberof CBidirMsg_RelayPacket
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CBidirMsg_RelayPacket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CBidirMsg_RelayPacket.SignedDestinationAddress_t = (function() {
    
            /**
             * Properties of a SignedDestinationAddress_t.
             * @memberof CBidirMsg_RelayPacket
             * @interface ISignedDestinationAddress_t
             * @property {ISerializedNetAddress_t} serializedAddr SignedDestinationAddress_t serializedAddr
             * @property {number} signature SignedDestinationAddress_t signature
             * @property {Uint8Array|null} [encryptedPayloadKey] SignedDestinationAddress_t encryptedPayloadKey
             */
    
            /**
             * Constructs a new SignedDestinationAddress_t.
             * @memberof CBidirMsg_RelayPacket
             * @classdesc Represents a SignedDestinationAddress_t.
             * @implements ISignedDestinationAddress_t
             * @constructor
             * @param {CBidirMsg_RelayPacket.ISignedDestinationAddress_t=} [properties] Properties to set
             */
            function SignedDestinationAddress_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedDestinationAddress_t serializedAddr.
             * @member {ISerializedNetAddress_t} serializedAddr
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @instance
             */
            SignedDestinationAddress_t.prototype.serializedAddr = null;
    
            /**
             * SignedDestinationAddress_t signature.
             * @member {number} signature
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @instance
             */
            SignedDestinationAddress_t.prototype.signature = 0;
    
            /**
             * SignedDestinationAddress_t encryptedPayloadKey.
             * @member {Uint8Array} encryptedPayloadKey
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @instance
             */
            SignedDestinationAddress_t.prototype.encryptedPayloadKey = $util.newBuffer([]);
    
            /**
             * Creates a new SignedDestinationAddress_t instance using the specified properties.
             * @function create
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {CBidirMsg_RelayPacket.ISignedDestinationAddress_t=} [properties] Properties to set
             * @returns {CBidirMsg_RelayPacket.SignedDestinationAddress_t} SignedDestinationAddress_t instance
             */
            SignedDestinationAddress_t.create = function create(properties) {
                return new SignedDestinationAddress_t(properties);
            };
    
            /**
             * Encodes the specified SignedDestinationAddress_t message. Does not implicitly {@link CBidirMsg_RelayPacket.SignedDestinationAddress_t.verify|verify} messages.
             * @function encode
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {CBidirMsg_RelayPacket.ISignedDestinationAddress_t} message SignedDestinationAddress_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedDestinationAddress_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.SerializedNetAddress_t.encode(message.serializedAddr, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.signature);
                if (message.encryptedPayloadKey != null && Object.hasOwnProperty.call(message, "encryptedPayloadKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedPayloadKey);
                return writer;
            };
    
            /**
             * Encodes the specified SignedDestinationAddress_t message, length delimited. Does not implicitly {@link CBidirMsg_RelayPacket.SignedDestinationAddress_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {CBidirMsg_RelayPacket.ISignedDestinationAddress_t} message SignedDestinationAddress_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedDestinationAddress_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedDestinationAddress_t message from the specified reader or buffer.
             * @function decode
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CBidirMsg_RelayPacket.SignedDestinationAddress_t} SignedDestinationAddress_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedDestinationAddress_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serializedAddr = $root.SerializedNetAddress_t.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.signature = reader.uint32();
                        break;
                    case 3:
                        message.encryptedPayloadKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("serializedAddr"))
                    throw $util.ProtocolError("missing required 'serializedAddr'", { instance: message });
                if (!message.hasOwnProperty("signature"))
                    throw $util.ProtocolError("missing required 'signature'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a SignedDestinationAddress_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CBidirMsg_RelayPacket.SignedDestinationAddress_t} SignedDestinationAddress_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedDestinationAddress_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedDestinationAddress_t message.
             * @function verify
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedDestinationAddress_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.SerializedNetAddress_t.verify(message.serializedAddr);
                    if (error)
                        return "serializedAddr." + error;
                }
                if (!$util.isInteger(message.signature))
                    return "signature: integer expected";
                if (message.encryptedPayloadKey != null && message.hasOwnProperty("encryptedPayloadKey"))
                    if (!(message.encryptedPayloadKey && typeof message.encryptedPayloadKey.length === "number" || $util.isString(message.encryptedPayloadKey)))
                        return "encryptedPayloadKey: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignedDestinationAddress_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CBidirMsg_RelayPacket.SignedDestinationAddress_t} SignedDestinationAddress_t
             */
            SignedDestinationAddress_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t)
                    return object;
                var message = new $root.CBidirMsg_RelayPacket.SignedDestinationAddress_t();
                if (object.serializedAddr != null) {
                    if (typeof object.serializedAddr !== "object")
                        throw TypeError(".CBidirMsg_RelayPacket.SignedDestinationAddress_t.serializedAddr: object expected");
                    message.serializedAddr = $root.SerializedNetAddress_t.fromObject(object.serializedAddr);
                }
                if (object.signature != null)
                    message.signature = object.signature >>> 0;
                if (object.encryptedPayloadKey != null)
                    if (typeof object.encryptedPayloadKey === "string")
                        $util.base64.decode(object.encryptedPayloadKey, message.encryptedPayloadKey = $util.newBuffer($util.base64.length(object.encryptedPayloadKey)), 0);
                    else if (object.encryptedPayloadKey.length)
                        message.encryptedPayloadKey = object.encryptedPayloadKey;
                return message;
            };
    
            /**
             * Creates a plain object from a SignedDestinationAddress_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @static
             * @param {CBidirMsg_RelayPacket.SignedDestinationAddress_t} message SignedDestinationAddress_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedDestinationAddress_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.serializedAddr = null;
                    object.signature = 0;
                    if (options.bytes === String)
                        object.encryptedPayloadKey = "";
                    else {
                        object.encryptedPayloadKey = [];
                        if (options.bytes !== Array)
                            object.encryptedPayloadKey = $util.newBuffer(object.encryptedPayloadKey);
                    }
                }
                if (message.serializedAddr != null && message.hasOwnProperty("serializedAddr"))
                    object.serializedAddr = $root.SerializedNetAddress_t.toObject(message.serializedAddr, options);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = message.signature;
                if (message.encryptedPayloadKey != null && message.hasOwnProperty("encryptedPayloadKey"))
                    object.encryptedPayloadKey = options.bytes === String ? $util.base64.encode(message.encryptedPayloadKey, 0, message.encryptedPayloadKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPayloadKey) : message.encryptedPayloadKey;
                return object;
            };
    
            /**
             * Converts this SignedDestinationAddress_t to JSON.
             * @function toJSON
             * @memberof CBidirMsg_RelayPacket.SignedDestinationAddress_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedDestinationAddress_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedDestinationAddress_t;
        })();
    
        return CBidirMsg_RelayPacket;
    })();
    
    $root.CMsgServerNetworkStats = (function() {
    
        /**
         * Properties of a CMsgServerNetworkStats.
         * @exports ICMsgServerNetworkStats
         * @interface ICMsgServerNetworkStats
         * @property {boolean|null} [dedicated] CMsgServerNetworkStats dedicated
         * @property {number|null} [cpu_usage] CMsgServerNetworkStats cpu_usage
         * @property {number|null} [memory_used_mb] CMsgServerNetworkStats memory_used_mb
         * @property {number|null} [memory_free_mb] CMsgServerNetworkStats memory_free_mb
         * @property {number|null} [uptime] CMsgServerNetworkStats uptime
         * @property {number|null} [spawn_count] CMsgServerNetworkStats spawn_count
         * @property {number|null} [num_clients] CMsgServerNetworkStats num_clients
         * @property {number|null} [num_bots] CMsgServerNetworkStats num_bots
         * @property {number|null} [num_spectators] CMsgServerNetworkStats num_spectators
         * @property {number|null} [num_tv_relays] CMsgServerNetworkStats num_tv_relays
         * @property {number|null} [fps] CMsgServerNetworkStats fps
         * @property {Array.<CMsgServerNetworkStats.IPort>|null} [ports] CMsgServerNetworkStats ports
         * @property {number|null} [avg_latency_out] CMsgServerNetworkStats avg_latency_out
         * @property {number|null} [avg_latency_in] CMsgServerNetworkStats avg_latency_in
         * @property {number|null} [avg_packets_out] CMsgServerNetworkStats avg_packets_out
         * @property {number|null} [avg_packets_in] CMsgServerNetworkStats avg_packets_in
         * @property {number|null} [avg_loss_out] CMsgServerNetworkStats avg_loss_out
         * @property {number|null} [avg_loss_in] CMsgServerNetworkStats avg_loss_in
         * @property {number|null} [avg_data_out] CMsgServerNetworkStats avg_data_out
         * @property {number|null} [avg_data_in] CMsgServerNetworkStats avg_data_in
         * @property {number|Long|null} [total_data_in] CMsgServerNetworkStats total_data_in
         * @property {number|Long|null} [total_packets_in] CMsgServerNetworkStats total_packets_in
         * @property {number|Long|null} [total_data_out] CMsgServerNetworkStats total_data_out
         * @property {number|Long|null} [total_packets_out] CMsgServerNetworkStats total_packets_out
         * @property {Array.<CMsgServerNetworkStats.IPlayer>|null} [players] CMsgServerNetworkStats players
         */
    
        /**
         * Constructs a new CMsgServerNetworkStats.
         * @exports CMsgServerNetworkStats
         * @classdesc Represents a CMsgServerNetworkStats.
         * @implements ICMsgServerNetworkStats
         * @constructor
         * @param {ICMsgServerNetworkStats=} [properties] Properties to set
         */
        function CMsgServerNetworkStats(properties) {
            this.ports = [];
            this.players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgServerNetworkStats dedicated.
         * @member {boolean} dedicated
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.dedicated = false;
    
        /**
         * CMsgServerNetworkStats cpu_usage.
         * @member {number} cpu_usage
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.cpu_usage = 0;
    
        /**
         * CMsgServerNetworkStats memory_used_mb.
         * @member {number} memory_used_mb
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.memory_used_mb = 0;
    
        /**
         * CMsgServerNetworkStats memory_free_mb.
         * @member {number} memory_free_mb
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.memory_free_mb = 0;
    
        /**
         * CMsgServerNetworkStats uptime.
         * @member {number} uptime
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.uptime = 0;
    
        /**
         * CMsgServerNetworkStats spawn_count.
         * @member {number} spawn_count
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.spawn_count = 0;
    
        /**
         * CMsgServerNetworkStats num_clients.
         * @member {number} num_clients
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.num_clients = 0;
    
        /**
         * CMsgServerNetworkStats num_bots.
         * @member {number} num_bots
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.num_bots = 0;
    
        /**
         * CMsgServerNetworkStats num_spectators.
         * @member {number} num_spectators
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.num_spectators = 0;
    
        /**
         * CMsgServerNetworkStats num_tv_relays.
         * @member {number} num_tv_relays
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.num_tv_relays = 0;
    
        /**
         * CMsgServerNetworkStats fps.
         * @member {number} fps
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.fps = 0;
    
        /**
         * CMsgServerNetworkStats ports.
         * @member {Array.<CMsgServerNetworkStats.IPort>} ports
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.ports = $util.emptyArray;
    
        /**
         * CMsgServerNetworkStats avg_latency_out.
         * @member {number} avg_latency_out
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_latency_out = 0;
    
        /**
         * CMsgServerNetworkStats avg_latency_in.
         * @member {number} avg_latency_in
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_latency_in = 0;
    
        /**
         * CMsgServerNetworkStats avg_packets_out.
         * @member {number} avg_packets_out
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_packets_out = 0;
    
        /**
         * CMsgServerNetworkStats avg_packets_in.
         * @member {number} avg_packets_in
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_packets_in = 0;
    
        /**
         * CMsgServerNetworkStats avg_loss_out.
         * @member {number} avg_loss_out
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_loss_out = 0;
    
        /**
         * CMsgServerNetworkStats avg_loss_in.
         * @member {number} avg_loss_in
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_loss_in = 0;
    
        /**
         * CMsgServerNetworkStats avg_data_out.
         * @member {number} avg_data_out
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_data_out = 0;
    
        /**
         * CMsgServerNetworkStats avg_data_in.
         * @member {number} avg_data_in
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avg_data_in = 0;
    
        /**
         * CMsgServerNetworkStats total_data_in.
         * @member {number|Long} total_data_in
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.total_data_in = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats total_packets_in.
         * @member {number|Long} total_packets_in
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.total_packets_in = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats total_data_out.
         * @member {number|Long} total_data_out
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.total_data_out = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats total_packets_out.
         * @member {number|Long} total_packets_out
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.total_packets_out = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats players.
         * @member {Array.<CMsgServerNetworkStats.IPlayer>} players
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.players = $util.emptyArray;
    
        /**
         * Creates a new CMsgServerNetworkStats instance using the specified properties.
         * @function create
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {ICMsgServerNetworkStats=} [properties] Properties to set
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats instance
         */
        CMsgServerNetworkStats.create = function create(properties) {
            return new CMsgServerNetworkStats(properties);
        };
    
        /**
         * Encodes the specified CMsgServerNetworkStats message. Does not implicitly {@link CMsgServerNetworkStats.verify|verify} messages.
         * @function encode
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {ICMsgServerNetworkStats} message CMsgServerNetworkStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerNetworkStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dedicated != null && Object.hasOwnProperty.call(message, "dedicated"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.dedicated);
            if (message.cpu_usage != null && Object.hasOwnProperty.call(message, "cpu_usage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cpu_usage);
            if (message.memory_used_mb != null && Object.hasOwnProperty.call(message, "memory_used_mb"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.memory_used_mb);
            if (message.memory_free_mb != null && Object.hasOwnProperty.call(message, "memory_free_mb"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.memory_free_mb);
            if (message.uptime != null && Object.hasOwnProperty.call(message, "uptime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.uptime);
            if (message.spawn_count != null && Object.hasOwnProperty.call(message, "spawn_count"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.spawn_count);
            if (message.num_clients != null && Object.hasOwnProperty.call(message, "num_clients"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.num_clients);
            if (message.num_bots != null && Object.hasOwnProperty.call(message, "num_bots"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.num_bots);
            if (message.num_spectators != null && Object.hasOwnProperty.call(message, "num_spectators"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.num_spectators);
            if (message.num_tv_relays != null && Object.hasOwnProperty.call(message, "num_tv_relays"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.num_tv_relays);
            if (message.fps != null && Object.hasOwnProperty.call(message, "fps"))
                writer.uint32(/* id 12, wireType 5 =*/101).float(message.fps);
            if (message.ports != null && message.ports.length)
                for (var i = 0; i < message.ports.length; ++i)
                    $root.CMsgServerNetworkStats.Port.encode(message.ports[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.avg_latency_out != null && Object.hasOwnProperty.call(message, "avg_latency_out"))
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.avg_latency_out);
            if (message.avg_latency_in != null && Object.hasOwnProperty.call(message, "avg_latency_in"))
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.avg_latency_in);
            if (message.avg_packets_out != null && Object.hasOwnProperty.call(message, "avg_packets_out"))
                writer.uint32(/* id 20, wireType 5 =*/165).float(message.avg_packets_out);
            if (message.avg_packets_in != null && Object.hasOwnProperty.call(message, "avg_packets_in"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.avg_packets_in);
            if (message.avg_loss_out != null && Object.hasOwnProperty.call(message, "avg_loss_out"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.avg_loss_out);
            if (message.avg_loss_in != null && Object.hasOwnProperty.call(message, "avg_loss_in"))
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.avg_loss_in);
            if (message.avg_data_out != null && Object.hasOwnProperty.call(message, "avg_data_out"))
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.avg_data_out);
            if (message.avg_data_in != null && Object.hasOwnProperty.call(message, "avg_data_in"))
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.avg_data_in);
            if (message.total_data_in != null && Object.hasOwnProperty.call(message, "total_data_in"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint64(message.total_data_in);
            if (message.total_packets_in != null && Object.hasOwnProperty.call(message, "total_packets_in"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint64(message.total_packets_in);
            if (message.total_data_out != null && Object.hasOwnProperty.call(message, "total_data_out"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint64(message.total_data_out);
            if (message.total_packets_out != null && Object.hasOwnProperty.call(message, "total_packets_out"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint64(message.total_packets_out);
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    $root.CMsgServerNetworkStats.Player.encode(message.players[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgServerNetworkStats message, length delimited. Does not implicitly {@link CMsgServerNetworkStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {ICMsgServerNetworkStats} message CMsgServerNetworkStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerNetworkStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgServerNetworkStats message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerNetworkStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerNetworkStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dedicated = reader.bool();
                    break;
                case 2:
                    message.cpu_usage = reader.int32();
                    break;
                case 3:
                    message.memory_used_mb = reader.int32();
                    break;
                case 4:
                    message.memory_free_mb = reader.int32();
                    break;
                case 5:
                    message.uptime = reader.int32();
                    break;
                case 6:
                    message.spawn_count = reader.int32();
                    break;
                case 8:
                    message.num_clients = reader.int32();
                    break;
                case 9:
                    message.num_bots = reader.int32();
                    break;
                case 10:
                    message.num_spectators = reader.int32();
                    break;
                case 11:
                    message.num_tv_relays = reader.int32();
                    break;
                case 12:
                    message.fps = reader.float();
                    break;
                case 17:
                    if (!(message.ports && message.ports.length))
                        message.ports = [];
                    message.ports.push($root.CMsgServerNetworkStats.Port.decode(reader, reader.uint32()));
                    break;
                case 18:
                    message.avg_latency_out = reader.float();
                    break;
                case 19:
                    message.avg_latency_in = reader.float();
                    break;
                case 20:
                    message.avg_packets_out = reader.float();
                    break;
                case 21:
                    message.avg_packets_in = reader.float();
                    break;
                case 22:
                    message.avg_loss_out = reader.float();
                    break;
                case 23:
                    message.avg_loss_in = reader.float();
                    break;
                case 24:
                    message.avg_data_out = reader.float();
                    break;
                case 25:
                    message.avg_data_in = reader.float();
                    break;
                case 26:
                    message.total_data_in = reader.uint64();
                    break;
                case 27:
                    message.total_packets_in = reader.uint64();
                    break;
                case 28:
                    message.total_data_out = reader.uint64();
                    break;
                case 29:
                    message.total_packets_out = reader.uint64();
                    break;
                case 30:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.CMsgServerNetworkStats.Player.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgServerNetworkStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerNetworkStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgServerNetworkStats message.
         * @function verify
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgServerNetworkStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dedicated != null && message.hasOwnProperty("dedicated"))
                if (typeof message.dedicated !== "boolean")
                    return "dedicated: boolean expected";
            if (message.cpu_usage != null && message.hasOwnProperty("cpu_usage"))
                if (!$util.isInteger(message.cpu_usage))
                    return "cpu_usage: integer expected";
            if (message.memory_used_mb != null && message.hasOwnProperty("memory_used_mb"))
                if (!$util.isInteger(message.memory_used_mb))
                    return "memory_used_mb: integer expected";
            if (message.memory_free_mb != null && message.hasOwnProperty("memory_free_mb"))
                if (!$util.isInteger(message.memory_free_mb))
                    return "memory_free_mb: integer expected";
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                if (!$util.isInteger(message.uptime))
                    return "uptime: integer expected";
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_clients != null && message.hasOwnProperty("num_clients"))
                if (!$util.isInteger(message.num_clients))
                    return "num_clients: integer expected";
            if (message.num_bots != null && message.hasOwnProperty("num_bots"))
                if (!$util.isInteger(message.num_bots))
                    return "num_bots: integer expected";
            if (message.num_spectators != null && message.hasOwnProperty("num_spectators"))
                if (!$util.isInteger(message.num_spectators))
                    return "num_spectators: integer expected";
            if (message.num_tv_relays != null && message.hasOwnProperty("num_tv_relays"))
                if (!$util.isInteger(message.num_tv_relays))
                    return "num_tv_relays: integer expected";
            if (message.fps != null && message.hasOwnProperty("fps"))
                if (typeof message.fps !== "number")
                    return "fps: number expected";
            if (message.ports != null && message.hasOwnProperty("ports")) {
                if (!Array.isArray(message.ports))
                    return "ports: array expected";
                for (var i = 0; i < message.ports.length; ++i) {
                    var error = $root.CMsgServerNetworkStats.Port.verify(message.ports[i]);
                    if (error)
                        return "ports." + error;
                }
            }
            if (message.avg_latency_out != null && message.hasOwnProperty("avg_latency_out"))
                if (typeof message.avg_latency_out !== "number")
                    return "avg_latency_out: number expected";
            if (message.avg_latency_in != null && message.hasOwnProperty("avg_latency_in"))
                if (typeof message.avg_latency_in !== "number")
                    return "avg_latency_in: number expected";
            if (message.avg_packets_out != null && message.hasOwnProperty("avg_packets_out"))
                if (typeof message.avg_packets_out !== "number")
                    return "avg_packets_out: number expected";
            if (message.avg_packets_in != null && message.hasOwnProperty("avg_packets_in"))
                if (typeof message.avg_packets_in !== "number")
                    return "avg_packets_in: number expected";
            if (message.avg_loss_out != null && message.hasOwnProperty("avg_loss_out"))
                if (typeof message.avg_loss_out !== "number")
                    return "avg_loss_out: number expected";
            if (message.avg_loss_in != null && message.hasOwnProperty("avg_loss_in"))
                if (typeof message.avg_loss_in !== "number")
                    return "avg_loss_in: number expected";
            if (message.avg_data_out != null && message.hasOwnProperty("avg_data_out"))
                if (typeof message.avg_data_out !== "number")
                    return "avg_data_out: number expected";
            if (message.avg_data_in != null && message.hasOwnProperty("avg_data_in"))
                if (typeof message.avg_data_in !== "number")
                    return "avg_data_in: number expected";
            if (message.total_data_in != null && message.hasOwnProperty("total_data_in"))
                if (!$util.isInteger(message.total_data_in) && !(message.total_data_in && $util.isInteger(message.total_data_in.low) && $util.isInteger(message.total_data_in.high)))
                    return "total_data_in: integer|Long expected";
            if (message.total_packets_in != null && message.hasOwnProperty("total_packets_in"))
                if (!$util.isInteger(message.total_packets_in) && !(message.total_packets_in && $util.isInteger(message.total_packets_in.low) && $util.isInteger(message.total_packets_in.high)))
                    return "total_packets_in: integer|Long expected";
            if (message.total_data_out != null && message.hasOwnProperty("total_data_out"))
                if (!$util.isInteger(message.total_data_out) && !(message.total_data_out && $util.isInteger(message.total_data_out.low) && $util.isInteger(message.total_data_out.high)))
                    return "total_data_out: integer|Long expected";
            if (message.total_packets_out != null && message.hasOwnProperty("total_packets_out"))
                if (!$util.isInteger(message.total_packets_out) && !(message.total_packets_out && $util.isInteger(message.total_packets_out.low) && $util.isInteger(message.total_packets_out.high)))
                    return "total_packets_out: integer|Long expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i) {
                    var error = $root.CMsgServerNetworkStats.Player.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgServerNetworkStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats
         */
        CMsgServerNetworkStats.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgServerNetworkStats)
                return object;
            var message = new $root.CMsgServerNetworkStats();
            if (object.dedicated != null)
                message.dedicated = Boolean(object.dedicated);
            if (object.cpu_usage != null)
                message.cpu_usage = object.cpu_usage | 0;
            if (object.memory_used_mb != null)
                message.memory_used_mb = object.memory_used_mb | 0;
            if (object.memory_free_mb != null)
                message.memory_free_mb = object.memory_free_mb | 0;
            if (object.uptime != null)
                message.uptime = object.uptime | 0;
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count | 0;
            if (object.num_clients != null)
                message.num_clients = object.num_clients | 0;
            if (object.num_bots != null)
                message.num_bots = object.num_bots | 0;
            if (object.num_spectators != null)
                message.num_spectators = object.num_spectators | 0;
            if (object.num_tv_relays != null)
                message.num_tv_relays = object.num_tv_relays | 0;
            if (object.fps != null)
                message.fps = Number(object.fps);
            if (object.ports) {
                if (!Array.isArray(object.ports))
                    throw TypeError(".CMsgServerNetworkStats.ports: array expected");
                message.ports = [];
                for (var i = 0; i < object.ports.length; ++i) {
                    if (typeof object.ports[i] !== "object")
                        throw TypeError(".CMsgServerNetworkStats.ports: object expected");
                    message.ports[i] = $root.CMsgServerNetworkStats.Port.fromObject(object.ports[i]);
                }
            }
            if (object.avg_latency_out != null)
                message.avg_latency_out = Number(object.avg_latency_out);
            if (object.avg_latency_in != null)
                message.avg_latency_in = Number(object.avg_latency_in);
            if (object.avg_packets_out != null)
                message.avg_packets_out = Number(object.avg_packets_out);
            if (object.avg_packets_in != null)
                message.avg_packets_in = Number(object.avg_packets_in);
            if (object.avg_loss_out != null)
                message.avg_loss_out = Number(object.avg_loss_out);
            if (object.avg_loss_in != null)
                message.avg_loss_in = Number(object.avg_loss_in);
            if (object.avg_data_out != null)
                message.avg_data_out = Number(object.avg_data_out);
            if (object.avg_data_in != null)
                message.avg_data_in = Number(object.avg_data_in);
            if (object.total_data_in != null)
                if ($util.Long)
                    (message.total_data_in = $util.Long.fromValue(object.total_data_in)).unsigned = true;
                else if (typeof object.total_data_in === "string")
                    message.total_data_in = parseInt(object.total_data_in, 10);
                else if (typeof object.total_data_in === "number")
                    message.total_data_in = object.total_data_in;
                else if (typeof object.total_data_in === "object")
                    message.total_data_in = new $util.LongBits(object.total_data_in.low >>> 0, object.total_data_in.high >>> 0).toNumber(true);
            if (object.total_packets_in != null)
                if ($util.Long)
                    (message.total_packets_in = $util.Long.fromValue(object.total_packets_in)).unsigned = true;
                else if (typeof object.total_packets_in === "string")
                    message.total_packets_in = parseInt(object.total_packets_in, 10);
                else if (typeof object.total_packets_in === "number")
                    message.total_packets_in = object.total_packets_in;
                else if (typeof object.total_packets_in === "object")
                    message.total_packets_in = new $util.LongBits(object.total_packets_in.low >>> 0, object.total_packets_in.high >>> 0).toNumber(true);
            if (object.total_data_out != null)
                if ($util.Long)
                    (message.total_data_out = $util.Long.fromValue(object.total_data_out)).unsigned = true;
                else if (typeof object.total_data_out === "string")
                    message.total_data_out = parseInt(object.total_data_out, 10);
                else if (typeof object.total_data_out === "number")
                    message.total_data_out = object.total_data_out;
                else if (typeof object.total_data_out === "object")
                    message.total_data_out = new $util.LongBits(object.total_data_out.low >>> 0, object.total_data_out.high >>> 0).toNumber(true);
            if (object.total_packets_out != null)
                if ($util.Long)
                    (message.total_packets_out = $util.Long.fromValue(object.total_packets_out)).unsigned = true;
                else if (typeof object.total_packets_out === "string")
                    message.total_packets_out = parseInt(object.total_packets_out, 10);
                else if (typeof object.total_packets_out === "number")
                    message.total_packets_out = object.total_packets_out;
                else if (typeof object.total_packets_out === "object")
                    message.total_packets_out = new $util.LongBits(object.total_packets_out.low >>> 0, object.total_packets_out.high >>> 0).toNumber(true);
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".CMsgServerNetworkStats.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".CMsgServerNetworkStats.players: object expected");
                    message.players[i] = $root.CMsgServerNetworkStats.Player.fromObject(object.players[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgServerNetworkStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {CMsgServerNetworkStats} message CMsgServerNetworkStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgServerNetworkStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.ports = [];
                object.players = [];
            }
            if (options.defaults) {
                object.dedicated = false;
                object.cpu_usage = 0;
                object.memory_used_mb = 0;
                object.memory_free_mb = 0;
                object.uptime = 0;
                object.spawn_count = 0;
                object.num_clients = 0;
                object.num_bots = 0;
                object.num_spectators = 0;
                object.num_tv_relays = 0;
                object.fps = 0;
                object.avg_latency_out = 0;
                object.avg_latency_in = 0;
                object.avg_packets_out = 0;
                object.avg_packets_in = 0;
                object.avg_loss_out = 0;
                object.avg_loss_in = 0;
                object.avg_data_out = 0;
                object.avg_data_in = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.total_data_in = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_data_in = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.total_packets_in = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_packets_in = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.total_data_out = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_data_out = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.total_packets_out = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_packets_out = options.longs === String ? "0" : 0;
            }
            if (message.dedicated != null && message.hasOwnProperty("dedicated"))
                object.dedicated = message.dedicated;
            if (message.cpu_usage != null && message.hasOwnProperty("cpu_usage"))
                object.cpu_usage = message.cpu_usage;
            if (message.memory_used_mb != null && message.hasOwnProperty("memory_used_mb"))
                object.memory_used_mb = message.memory_used_mb;
            if (message.memory_free_mb != null && message.hasOwnProperty("memory_free_mb"))
                object.memory_free_mb = message.memory_free_mb;
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                object.uptime = message.uptime;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_clients != null && message.hasOwnProperty("num_clients"))
                object.num_clients = message.num_clients;
            if (message.num_bots != null && message.hasOwnProperty("num_bots"))
                object.num_bots = message.num_bots;
            if (message.num_spectators != null && message.hasOwnProperty("num_spectators"))
                object.num_spectators = message.num_spectators;
            if (message.num_tv_relays != null && message.hasOwnProperty("num_tv_relays"))
                object.num_tv_relays = message.num_tv_relays;
            if (message.fps != null && message.hasOwnProperty("fps"))
                object.fps = options.json && !isFinite(message.fps) ? String(message.fps) : message.fps;
            if (message.ports && message.ports.length) {
                object.ports = [];
                for (var j = 0; j < message.ports.length; ++j)
                    object.ports[j] = $root.CMsgServerNetworkStats.Port.toObject(message.ports[j], options);
            }
            if (message.avg_latency_out != null && message.hasOwnProperty("avg_latency_out"))
                object.avg_latency_out = options.json && !isFinite(message.avg_latency_out) ? String(message.avg_latency_out) : message.avg_latency_out;
            if (message.avg_latency_in != null && message.hasOwnProperty("avg_latency_in"))
                object.avg_latency_in = options.json && !isFinite(message.avg_latency_in) ? String(message.avg_latency_in) : message.avg_latency_in;
            if (message.avg_packets_out != null && message.hasOwnProperty("avg_packets_out"))
                object.avg_packets_out = options.json && !isFinite(message.avg_packets_out) ? String(message.avg_packets_out) : message.avg_packets_out;
            if (message.avg_packets_in != null && message.hasOwnProperty("avg_packets_in"))
                object.avg_packets_in = options.json && !isFinite(message.avg_packets_in) ? String(message.avg_packets_in) : message.avg_packets_in;
            if (message.avg_loss_out != null && message.hasOwnProperty("avg_loss_out"))
                object.avg_loss_out = options.json && !isFinite(message.avg_loss_out) ? String(message.avg_loss_out) : message.avg_loss_out;
            if (message.avg_loss_in != null && message.hasOwnProperty("avg_loss_in"))
                object.avg_loss_in = options.json && !isFinite(message.avg_loss_in) ? String(message.avg_loss_in) : message.avg_loss_in;
            if (message.avg_data_out != null && message.hasOwnProperty("avg_data_out"))
                object.avg_data_out = options.json && !isFinite(message.avg_data_out) ? String(message.avg_data_out) : message.avg_data_out;
            if (message.avg_data_in != null && message.hasOwnProperty("avg_data_in"))
                object.avg_data_in = options.json && !isFinite(message.avg_data_in) ? String(message.avg_data_in) : message.avg_data_in;
            if (message.total_data_in != null && message.hasOwnProperty("total_data_in"))
                if (typeof message.total_data_in === "number")
                    object.total_data_in = options.longs === String ? String(message.total_data_in) : message.total_data_in;
                else
                    object.total_data_in = options.longs === String ? $util.Long.prototype.toString.call(message.total_data_in) : options.longs === Number ? new $util.LongBits(message.total_data_in.low >>> 0, message.total_data_in.high >>> 0).toNumber(true) : message.total_data_in;
            if (message.total_packets_in != null && message.hasOwnProperty("total_packets_in"))
                if (typeof message.total_packets_in === "number")
                    object.total_packets_in = options.longs === String ? String(message.total_packets_in) : message.total_packets_in;
                else
                    object.total_packets_in = options.longs === String ? $util.Long.prototype.toString.call(message.total_packets_in) : options.longs === Number ? new $util.LongBits(message.total_packets_in.low >>> 0, message.total_packets_in.high >>> 0).toNumber(true) : message.total_packets_in;
            if (message.total_data_out != null && message.hasOwnProperty("total_data_out"))
                if (typeof message.total_data_out === "number")
                    object.total_data_out = options.longs === String ? String(message.total_data_out) : message.total_data_out;
                else
                    object.total_data_out = options.longs === String ? $util.Long.prototype.toString.call(message.total_data_out) : options.longs === Number ? new $util.LongBits(message.total_data_out.low >>> 0, message.total_data_out.high >>> 0).toNumber(true) : message.total_data_out;
            if (message.total_packets_out != null && message.hasOwnProperty("total_packets_out"))
                if (typeof message.total_packets_out === "number")
                    object.total_packets_out = options.longs === String ? String(message.total_packets_out) : message.total_packets_out;
                else
                    object.total_packets_out = options.longs === String ? $util.Long.prototype.toString.call(message.total_packets_out) : options.longs === Number ? new $util.LongBits(message.total_packets_out.low >>> 0, message.total_packets_out.high >>> 0).toNumber(true) : message.total_packets_out;
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.CMsgServerNetworkStats.Player.toObject(message.players[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgServerNetworkStats to JSON.
         * @function toJSON
         * @memberof CMsgServerNetworkStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgServerNetworkStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgServerNetworkStats.Port = (function() {
    
            /**
             * Properties of a Port.
             * @memberof CMsgServerNetworkStats
             * @interface IPort
             * @property {number|null} [port] Port port
             * @property {string|null} [name] Port name
             */
    
            /**
             * Constructs a new Port.
             * @memberof CMsgServerNetworkStats
             * @classdesc Represents a Port.
             * @implements IPort
             * @constructor
             * @param {CMsgServerNetworkStats.IPort=} [properties] Properties to set
             */
            function Port(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Port port.
             * @member {number} port
             * @memberof CMsgServerNetworkStats.Port
             * @instance
             */
            Port.prototype.port = 0;
    
            /**
             * Port name.
             * @member {string} name
             * @memberof CMsgServerNetworkStats.Port
             * @instance
             */
            Port.prototype.name = "";
    
            /**
             * Creates a new Port instance using the specified properties.
             * @function create
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.IPort=} [properties] Properties to set
             * @returns {CMsgServerNetworkStats.Port} Port instance
             */
            Port.create = function create(properties) {
                return new Port(properties);
            };
    
            /**
             * Encodes the specified Port message. Does not implicitly {@link CMsgServerNetworkStats.Port.verify|verify} messages.
             * @function encode
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.IPort} message Port message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Port.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.port);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified Port message, length delimited. Does not implicitly {@link CMsgServerNetworkStats.Port.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.IPort} message Port message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Port.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Port message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgServerNetworkStats.Port} Port
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Port.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerNetworkStats.Port();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.port = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Port message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgServerNetworkStats.Port} Port
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Port.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Port message.
             * @function verify
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Port.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a Port message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgServerNetworkStats.Port} Port
             */
            Port.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgServerNetworkStats.Port)
                    return object;
                var message = new $root.CMsgServerNetworkStats.Port();
                if (object.port != null)
                    message.port = object.port | 0;
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a Port message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.Port} message Port
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Port.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.port = 0;
                    object.name = "";
                }
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this Port to JSON.
             * @function toJSON
             * @memberof CMsgServerNetworkStats.Port
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Port.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Port;
        })();
    
        CMsgServerNetworkStats.Player = (function() {
    
            /**
             * Properties of a Player.
             * @memberof CMsgServerNetworkStats
             * @interface IPlayer
             * @property {number|Long|null} [steamid] Player steamid
             * @property {string|null} [remote_addr] Player remote_addr
             * @property {number|null} [ping_stddev_ms] Player ping_stddev_ms
             * @property {number|null} [ping_avg_ms] Player ping_avg_ms
             * @property {number|null} [packet_loss_pct] Player packet_loss_pct
             * @property {boolean|null} [is_bot] Player is_bot
             */
    
            /**
             * Constructs a new Player.
             * @memberof CMsgServerNetworkStats
             * @classdesc Represents a Player.
             * @implements IPlayer
             * @constructor
             * @param {CMsgServerNetworkStats.IPlayer=} [properties] Properties to set
             */
            function Player(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Player steamid.
             * @member {number|Long} steamid
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Player remote_addr.
             * @member {string} remote_addr
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.remote_addr = "";
    
            /**
             * Player ping_stddev_ms.
             * @member {number} ping_stddev_ms
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.ping_stddev_ms = 0;
    
            /**
             * Player ping_avg_ms.
             * @member {number} ping_avg_ms
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.ping_avg_ms = 0;
    
            /**
             * Player packet_loss_pct.
             * @member {number} packet_loss_pct
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.packet_loss_pct = 0;
    
            /**
             * Player is_bot.
             * @member {boolean} is_bot
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.is_bot = false;
    
            /**
             * Creates a new Player instance using the specified properties.
             * @function create
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.IPlayer=} [properties] Properties to set
             * @returns {CMsgServerNetworkStats.Player} Player instance
             */
            Player.create = function create(properties) {
                return new Player(properties);
            };
    
            /**
             * Encodes the specified Player message. Does not implicitly {@link CMsgServerNetworkStats.Player.verify|verify} messages.
             * @function encode
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.steamid);
                if (message.remote_addr != null && Object.hasOwnProperty.call(message, "remote_addr"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remote_addr);
                if (message.ping_stddev_ms != null && Object.hasOwnProperty.call(message, "ping_stddev_ms"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ping_stddev_ms);
                if (message.ping_avg_ms != null && Object.hasOwnProperty.call(message, "ping_avg_ms"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ping_avg_ms);
                if (message.packet_loss_pct != null && Object.hasOwnProperty.call(message, "packet_loss_pct"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.packet_loss_pct);
                if (message.is_bot != null && Object.hasOwnProperty.call(message, "is_bot"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.is_bot);
                return writer;
            };
    
            /**
             * Encodes the specified Player message, length delimited. Does not implicitly {@link CMsgServerNetworkStats.Player.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgServerNetworkStats.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerNetworkStats.Player();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.steamid = reader.uint64();
                        break;
                    case 2:
                        message.remote_addr = reader.string();
                        break;
                    case 3:
                        message.ping_stddev_ms = reader.int32();
                        break;
                    case 4:
                        message.ping_avg_ms = reader.int32();
                        break;
                    case 5:
                        message.packet_loss_pct = reader.float();
                        break;
                    case 6:
                        message.is_bot = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgServerNetworkStats.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Player message.
             * @function verify
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Player.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.steamid != null && message.hasOwnProperty("steamid"))
                    if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                        return "steamid: integer|Long expected";
                if (message.remote_addr != null && message.hasOwnProperty("remote_addr"))
                    if (!$util.isString(message.remote_addr))
                        return "remote_addr: string expected";
                if (message.ping_stddev_ms != null && message.hasOwnProperty("ping_stddev_ms"))
                    if (!$util.isInteger(message.ping_stddev_ms))
                        return "ping_stddev_ms: integer expected";
                if (message.ping_avg_ms != null && message.hasOwnProperty("ping_avg_ms"))
                    if (!$util.isInteger(message.ping_avg_ms))
                        return "ping_avg_ms: integer expected";
                if (message.packet_loss_pct != null && message.hasOwnProperty("packet_loss_pct"))
                    if (typeof message.packet_loss_pct !== "number")
                        return "packet_loss_pct: number expected";
                if (message.is_bot != null && message.hasOwnProperty("is_bot"))
                    if (typeof message.is_bot !== "boolean")
                        return "is_bot: boolean expected";
                return null;
            };
    
            /**
             * Creates a Player message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgServerNetworkStats.Player} Player
             */
            Player.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgServerNetworkStats.Player)
                    return object;
                var message = new $root.CMsgServerNetworkStats.Player();
                if (object.steamid != null)
                    if ($util.Long)
                        (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = true;
                    else if (typeof object.steamid === "string")
                        message.steamid = parseInt(object.steamid, 10);
                    else if (typeof object.steamid === "number")
                        message.steamid = object.steamid;
                    else if (typeof object.steamid === "object")
                        message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber(true);
                if (object.remote_addr != null)
                    message.remote_addr = String(object.remote_addr);
                if (object.ping_stddev_ms != null)
                    message.ping_stddev_ms = object.ping_stddev_ms | 0;
                if (object.ping_avg_ms != null)
                    message.ping_avg_ms = object.ping_avg_ms | 0;
                if (object.packet_loss_pct != null)
                    message.packet_loss_pct = Number(object.packet_loss_pct);
                if (object.is_bot != null)
                    message.is_bot = Boolean(object.is_bot);
                return message;
            };
    
            /**
             * Creates a plain object from a Player message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.Player} message Player
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Player.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.steamid = options.longs === String ? "0" : 0;
                    object.remote_addr = "";
                    object.ping_stddev_ms = 0;
                    object.ping_avg_ms = 0;
                    object.packet_loss_pct = 0;
                    object.is_bot = false;
                }
                if (message.steamid != null && message.hasOwnProperty("steamid"))
                    if (typeof message.steamid === "number")
                        object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                    else
                        object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber(true) : message.steamid;
                if (message.remote_addr != null && message.hasOwnProperty("remote_addr"))
                    object.remote_addr = message.remote_addr;
                if (message.ping_stddev_ms != null && message.hasOwnProperty("ping_stddev_ms"))
                    object.ping_stddev_ms = message.ping_stddev_ms;
                if (message.ping_avg_ms != null && message.hasOwnProperty("ping_avg_ms"))
                    object.ping_avg_ms = message.ping_avg_ms;
                if (message.packet_loss_pct != null && message.hasOwnProperty("packet_loss_pct"))
                    object.packet_loss_pct = options.json && !isFinite(message.packet_loss_pct) ? String(message.packet_loss_pct) : message.packet_loss_pct;
                if (message.is_bot != null && message.hasOwnProperty("is_bot"))
                    object.is_bot = message.is_bot;
                return object;
            };
    
            /**
             * Converts this Player to JSON.
             * @function toJSON
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Player.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Player;
        })();
    
        return CMsgServerNetworkStats;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.userid = reader.int32();
                    break;
                case 4:
                    message.steamid = reader.fixed64();
                    break;
                case 5:
                    message.fakeplayer = reader.bool();
                    break;
                case 6:
                    message.ishltv = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [target_entity] CEntityMsg target_entity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg target_entity.
         * @member {number} target_entity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.target_entity = 0;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entity != null && Object.hasOwnProperty.call(message, "target_entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                if (!$util.isInteger(message.target_entity))
                    return "target_entity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.target_entity != null)
                message.target_entity = object.target_entity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.target_entity = 0;
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                object.target_entity = message.target_entity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW":
            case 70:
                message.reason = 70;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [host_frametime] CNETMsg_Tick host_frametime
         * @property {number|null} [host_frametime_std_deviation] CNETMsg_Tick host_frametime_std_deviation
         * @property {number|null} [host_computationtime] CNETMsg_Tick host_computationtime
         * @property {number|null} [host_computationtime_std_deviation] CNETMsg_Tick host_computationtime_std_deviation
         * @property {number|null} [host_framestarttime_std_deviation] CNETMsg_Tick host_framestarttime_std_deviation
         * @property {number|null} [host_loss] CNETMsg_Tick host_loss
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick host_frametime.
         * @member {number} host_frametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime = 0;
    
        /**
         * CNETMsg_Tick host_frametime_std_deviation.
         * @member {number} host_frametime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_computationtime.
         * @member {number} host_computationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime = 0;
    
        /**
         * CNETMsg_Tick host_computationtime_std_deviation.
         * @member {number} host_computationtime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_framestarttime_std_deviation.
         * @member {number} host_framestarttime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_framestarttime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_loss.
         * @member {number} host_loss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_loss = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.host_frametime != null && Object.hasOwnProperty.call(message, "host_frametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.host_frametime);
            if (message.host_frametime_std_deviation != null && Object.hasOwnProperty.call(message, "host_frametime_std_deviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.host_frametime_std_deviation);
            if (message.host_computationtime != null && Object.hasOwnProperty.call(message, "host_computationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.host_computationtime);
            if (message.host_computationtime_std_deviation != null && Object.hasOwnProperty.call(message, "host_computationtime_std_deviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.host_computationtime_std_deviation);
            if (message.host_framestarttime_std_deviation != null && Object.hasOwnProperty.call(message, "host_framestarttime_std_deviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.host_framestarttime_std_deviation);
            if (message.host_loss != null && Object.hasOwnProperty.call(message, "host_loss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.host_loss);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 2:
                    message.host_frametime = reader.uint32();
                    break;
                case 3:
                    message.host_frametime_std_deviation = reader.uint32();
                    break;
                case 4:
                    message.host_computationtime = reader.uint32();
                    break;
                case 5:
                    message.host_computationtime_std_deviation = reader.uint32();
                    break;
                case 6:
                    message.host_framestarttime_std_deviation = reader.uint32();
                    break;
                case 7:
                    message.host_loss = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                if (!$util.isInteger(message.host_frametime))
                    return "host_frametime: integer expected";
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                if (!$util.isInteger(message.host_frametime_std_deviation))
                    return "host_frametime_std_deviation: integer expected";
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                if (!$util.isInteger(message.host_computationtime))
                    return "host_computationtime: integer expected";
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                if (!$util.isInteger(message.host_computationtime_std_deviation))
                    return "host_computationtime_std_deviation: integer expected";
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                if (!$util.isInteger(message.host_framestarttime_std_deviation))
                    return "host_framestarttime_std_deviation: integer expected";
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                if (!$util.isInteger(message.host_loss))
                    return "host_loss: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.host_frametime != null)
                message.host_frametime = object.host_frametime >>> 0;
            if (object.host_frametime_std_deviation != null)
                message.host_frametime_std_deviation = object.host_frametime_std_deviation >>> 0;
            if (object.host_computationtime != null)
                message.host_computationtime = object.host_computationtime >>> 0;
            if (object.host_computationtime_std_deviation != null)
                message.host_computationtime_std_deviation = object.host_computationtime_std_deviation >>> 0;
            if (object.host_framestarttime_std_deviation != null)
                message.host_framestarttime_std_deviation = object.host_framestarttime_std_deviation >>> 0;
            if (object.host_loss != null)
                message.host_loss = object.host_loss >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.host_frametime = 0;
                object.host_frametime_std_deviation = 0;
                object.host_computationtime = 0;
                object.host_computationtime_std_deviation = 0;
                object.host_framestarttime_std_deviation = 0;
                object.host_loss = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                object.host_frametime = message.host_frametime;
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                object.host_frametime_std_deviation = message.host_frametime_std_deviation;
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                object.host_computationtime = message.host_computationtime;
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                object.host_computationtime_std_deviation = message.host_computationtime_std_deviation;
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                object.host_framestarttime_std_deviation = message.host_framestarttime_std_deviation;
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                object.host_loss = message.host_loss;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signon_state] CNETMsg_SignonState signon_state
         * @property {number|null} [spawn_count] CNETMsg_SignonState spawn_count
         * @property {number|null} [num_server_players] CNETMsg_SignonState num_server_players
         * @property {Array.<string>|null} [players_networkids] CNETMsg_SignonState players_networkids
         * @property {string|null} [map_name] CNETMsg_SignonState map_name
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.players_networkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signon_state.
         * @member {SignonState_t} signon_state
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signon_state = 0;
    
        /**
         * CNETMsg_SignonState spawn_count.
         * @member {number} spawn_count
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawn_count = 0;
    
        /**
         * CNETMsg_SignonState num_server_players.
         * @member {number} num_server_players
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.num_server_players = 0;
    
        /**
         * CNETMsg_SignonState players_networkids.
         * @member {Array.<string>} players_networkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.players_networkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState map_name.
         * @member {string} map_name
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.map_name = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signon_state != null && Object.hasOwnProperty.call(message, "signon_state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signon_state);
            if (message.spawn_count != null && Object.hasOwnProperty.call(message, "spawn_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawn_count);
            if (message.num_server_players != null && Object.hasOwnProperty.call(message, "num_server_players"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_server_players);
            if (message.players_networkids != null && message.players_networkids.length)
                for (var i = 0; i < message.players_networkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.players_networkids[i]);
            if (message.map_name != null && Object.hasOwnProperty.call(message, "map_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.map_name);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signon_state = reader.int32();
                    break;
                case 2:
                    message.spawn_count = reader.uint32();
                    break;
                case 3:
                    message.num_server_players = reader.uint32();
                    break;
                case 4:
                    if (!(message.players_networkids && message.players_networkids.length))
                        message.players_networkids = [];
                    message.players_networkids.push(reader.string());
                    break;
                case 5:
                    message.map_name = reader.string();
                    break;
                case 6:
                    message.addons = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                switch (message.signon_state) {
                default:
                    return "signon_state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                if (!$util.isInteger(message.num_server_players))
                    return "num_server_players: integer expected";
            if (message.players_networkids != null && message.hasOwnProperty("players_networkids")) {
                if (!Array.isArray(message.players_networkids))
                    return "players_networkids: array expected";
                for (var i = 0; i < message.players_networkids.length; ++i)
                    if (!$util.isString(message.players_networkids[i]))
                        return "players_networkids: string[] expected";
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signon_state) {
            case "SIGNONSTATE_NONE":
            case 0:
                message.signon_state = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signon_state = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signon_state = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signon_state = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signon_state = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signon_state = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signon_state = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signon_state = 7;
                break;
            }
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count >>> 0;
            if (object.num_server_players != null)
                message.num_server_players = object.num_server_players >>> 0;
            if (object.players_networkids) {
                if (!Array.isArray(object.players_networkids))
                    throw TypeError(".CNETMsg_SignonState.players_networkids: array expected");
                message.players_networkids = [];
                for (var i = 0; i < object.players_networkids.length; ++i)
                    message.players_networkids[i] = String(object.players_networkids[i]);
            }
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.players_networkids = [];
            if (options.defaults) {
                object.signon_state = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawn_count = 0;
                object.num_server_players = 0;
                object.map_name = "";
                object.addons = "";
            }
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                object.signon_state = options.enums === String ? $root.SignonState_t[message.signon_state] : message.signon_state;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                object.num_server_players = message.num_server_players;
            if (message.players_networkids && message.players_networkids.length) {
                object.players_networkids = [];
                for (var j = 0; j < message.players_networkids.length; ++j)
                    object.players_networkids[j] = message.players_networkids[j];
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [event_name] CSVCMsg_GameEvent event_name
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent event_name.
         * @member {string} event_name
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.event_name = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.event_name = "";
                object.eventid = 0;
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [val_string] key_t val_string
             * @property {number|null} [val_float] key_t val_float
             * @property {number|null} [val_long] key_t val_long
             * @property {number|null} [val_short] key_t val_short
             * @property {number|null} [val_byte] key_t val_byte
             * @property {boolean|null} [val_bool] key_t val_bool
             * @property {number|Long|null} [val_uint64] key_t val_uint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t val_string.
             * @member {string} val_string
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_string = "";
    
            /**
             * key_t val_float.
             * @member {number} val_float
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_float = 0;
    
            /**
             * key_t val_long.
             * @member {number} val_long
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_long = 0;
    
            /**
             * key_t val_short.
             * @member {number} val_short
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_short = 0;
    
            /**
             * key_t val_byte.
             * @member {number} val_byte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_byte = 0;
    
            /**
             * key_t val_bool.
             * @member {boolean} val_bool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_bool = false;
    
            /**
             * key_t val_uint64.
             * @member {number|Long} val_uint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_uint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.val_string != null && Object.hasOwnProperty.call(message, "val_string"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.val_string);
                if (message.val_float != null && Object.hasOwnProperty.call(message, "val_float"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_float);
                if (message.val_long != null && Object.hasOwnProperty.call(message, "val_long"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.val_long);
                if (message.val_short != null && Object.hasOwnProperty.call(message, "val_short"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_short);
                if (message.val_byte != null && Object.hasOwnProperty.call(message, "val_byte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.val_byte);
                if (message.val_bool != null && Object.hasOwnProperty.call(message, "val_bool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.val_bool);
                if (message.val_uint64 != null && Object.hasOwnProperty.call(message, "val_uint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.val_uint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.val_string = reader.string();
                        break;
                    case 3:
                        message.val_float = reader.float();
                        break;
                    case 4:
                        message.val_long = reader.int32();
                        break;
                    case 5:
                        message.val_short = reader.int32();
                        break;
                    case 6:
                        message.val_byte = reader.int32();
                        break;
                    case 7:
                        message.val_bool = reader.bool();
                        break;
                    case 8:
                        message.val_uint64 = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    if (typeof message.val_float !== "number")
                        return "val_float: number expected";
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    if (!$util.isInteger(message.val_long))
                        return "val_long: integer expected";
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    if (!$util.isInteger(message.val_short))
                        return "val_short: integer expected";
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    if (!$util.isInteger(message.val_byte))
                        return "val_byte: integer expected";
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    if (typeof message.val_bool !== "boolean")
                        return "val_bool: boolean expected";
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (!$util.isInteger(message.val_uint64) && !(message.val_uint64 && $util.isInteger(message.val_uint64.low) && $util.isInteger(message.val_uint64.high)))
                        return "val_uint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_float != null)
                    message.val_float = Number(object.val_float);
                if (object.val_long != null)
                    message.val_long = object.val_long | 0;
                if (object.val_short != null)
                    message.val_short = object.val_short | 0;
                if (object.val_byte != null)
                    message.val_byte = object.val_byte | 0;
                if (object.val_bool != null)
                    message.val_bool = Boolean(object.val_bool);
                if (object.val_uint64 != null)
                    if ($util.Long)
                        (message.val_uint64 = $util.Long.fromValue(object.val_uint64)).unsigned = true;
                    else if (typeof object.val_uint64 === "string")
                        message.val_uint64 = parseInt(object.val_uint64, 10);
                    else if (typeof object.val_uint64 === "number")
                        message.val_uint64 = object.val_uint64;
                    else if (typeof object.val_uint64 === "object")
                        message.val_uint64 = new $util.LongBits(object.val_uint64.low >>> 0, object.val_uint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.val_string = "";
                    object.val_float = 0;
                    object.val_long = 0;
                    object.val_short = 0;
                    object.val_byte = 0;
                    object.val_bool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.val_uint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val_uint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    object.val_float = options.json && !isFinite(message.val_float) ? String(message.val_float) : message.val_float;
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    object.val_long = message.val_long;
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    object.val_short = message.val_short;
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    object.val_byte = message.val_byte;
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    object.val_bool = message.val_bool;
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (typeof message.val_uint64 === "number")
                        object.val_uint64 = options.longs === String ? String(message.val_uint64) : message.val_uint64;
                    else
                        object.val_uint64 = options.longs === String ? $util.Long.prototype.toString.call(message.val_uint64) : options.longs === Number ? new $util.LongBits(message.val_uint64.low >>> 0, message.val_uint64.high >>> 0).toNumber(true) : message.val_uint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msg_type] CSVCMsg_UserMessage msg_type
         * @property {Uint8Array|null} [msg_data] CSVCMsg_UserMessage msg_data
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msg_type.
         * @member {number} msg_type
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_type = 0;
    
        /**
         * CSVCMsg_UserMessage msg_data.
         * @member {Uint8Array} msg_data
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.msg_data != null && Object.hasOwnProperty.call(message, "msg_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.msg_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                if (!(message.msg_data && typeof message.msg_data.length === "number" || $util.isString(message.msg_data)))
                    return "msg_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.msg_data != null)
                if (typeof object.msg_data === "string")
                    $util.base64.decode(object.msg_data, message.msg_data = $util.newBuffer($util.base64.length(object.msg_data)), 0);
                else if (object.msg_data.length)
                    message.msg_data = object.msg_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.msg_data = "";
                else {
                    object.msg_data = [];
                    if (options.bytes !== Array)
                        object.msg_data = $util.newBuffer(object.msg_data);
                }
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                object.msg_data = options.bytes === String ? $util.base64.encode(message.msg_data, 0, message.msg_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg_data) : message.msg_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsgList_UserMessages = (function() {
    
        /**
         * Properties of a CSVCMsgList_UserMessages.
         * @exports ICSVCMsgList_UserMessages
         * @interface ICSVCMsgList_UserMessages
         * @property {Array.<CSVCMsgList_UserMessages.Iusermsg_t>|null} [usermsgs] CSVCMsgList_UserMessages usermsgs
         */
    
        /**
         * Constructs a new CSVCMsgList_UserMessages.
         * @exports CSVCMsgList_UserMessages
         * @classdesc Represents a CSVCMsgList_UserMessages.
         * @implements ICSVCMsgList_UserMessages
         * @constructor
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         */
        function CSVCMsgList_UserMessages(properties) {
            this.usermsgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_UserMessages usermsgs.
         * @member {Array.<CSVCMsgList_UserMessages.Iusermsg_t>} usermsgs
         * @memberof CSVCMsgList_UserMessages
         * @instance
         */
        CSVCMsgList_UserMessages.prototype.usermsgs = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_UserMessages instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages instance
         */
        CSVCMsgList_UserMessages.create = function create(properties) {
            return new CSVCMsgList_UserMessages(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usermsgs != null && message.usermsgs.length)
                for (var i = 0; i < message.usermsgs.length; ++i)
                    $root.CSVCMsgList_UserMessages.usermsg_t.encode(message.usermsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.usermsgs && message.usermsgs.length))
                        message.usermsgs = [];
                    message.usermsgs.push($root.CSVCMsgList_UserMessages.usermsg_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_UserMessages message.
         * @function verify
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_UserMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usermsgs != null && message.hasOwnProperty("usermsgs")) {
                if (!Array.isArray(message.usermsgs))
                    return "usermsgs: array expected";
                for (var i = 0; i < message.usermsgs.length; ++i) {
                    var error = $root.CSVCMsgList_UserMessages.usermsg_t.verify(message.usermsgs[i]);
                    if (error)
                        return "usermsgs." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_UserMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         */
        CSVCMsgList_UserMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_UserMessages)
                return object;
            var message = new $root.CSVCMsgList_UserMessages();
            if (object.usermsgs) {
                if (!Array.isArray(object.usermsgs))
                    throw TypeError(".CSVCMsgList_UserMessages.usermsgs: array expected");
                message.usermsgs = [];
                for (var i = 0; i < object.usermsgs.length; ++i) {
                    if (typeof object.usermsgs[i] !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsgs: object expected");
                    message.usermsgs[i] = $root.CSVCMsgList_UserMessages.usermsg_t.fromObject(object.usermsgs[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_UserMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {CSVCMsgList_UserMessages} message CSVCMsgList_UserMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_UserMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.usermsgs = [];
            if (message.usermsgs && message.usermsgs.length) {
                object.usermsgs = [];
                for (var j = 0; j < message.usermsgs.length; ++j)
                    object.usermsgs[j] = $root.CSVCMsgList_UserMessages.usermsg_t.toObject(message.usermsgs[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_UserMessages to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_UserMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_UserMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_UserMessages.usermsg_t = (function() {
    
            /**
             * Properties of a usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @interface Iusermsg_t
             * @property {number|null} [tick] usermsg_t tick
             * @property {ICSVCMsg_UserMessage|null} [msg] usermsg_t msg
             */
    
            /**
             * Constructs a new usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @classdesc Represents a usermsg_t.
             * @implements Iusermsg_t
             * @constructor
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             */
            function usermsg_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * usermsg_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.tick = 0;
    
            /**
             * usermsg_t msg.
             * @member {ICSVCMsg_UserMessage|null|undefined} msg
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.msg = null;
    
            /**
             * Creates a new usermsg_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t instance
             */
            usermsg_t.create = function create(properties) {
                return new usermsg_t(properties);
            };
    
            /**
             * Encodes the specified usermsg_t message. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.CSVCMsg_UserMessage.encode(message.msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified usermsg_t message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.msg = $root.CSVCMsg_UserMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a usermsg_t message.
             * @function verify
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            usermsg_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    var error = $root.CSVCMsg_UserMessage.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                return null;
            };
    
            /**
             * Creates a usermsg_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             */
            usermsg_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_UserMessages.usermsg_t)
                    return object;
                var message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsg_t.msg: object expected");
                    message.msg = $root.CSVCMsg_UserMessage.fromObject(object.msg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a usermsg_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.usermsg_t} message usermsg_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            usermsg_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.msg = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.CSVCMsg_UserMessage.toObject(message.msg, options);
                return object;
            };
    
            /**
             * Converts this usermsg_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            usermsg_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return usermsg_t;
        })();
    
        return CSVCMsgList_UserMessages;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [world_offset_pos] CNETMsg_SpawnGroup_Load world_offset_pos
         * @property {ICMsgQAngle|null} [world_offset_angle] CNETMsg_SpawnGroup_Load world_offset_angle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_pos.
         * @member {ICMsgVector|null|undefined} world_offset_pos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_pos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_angle.
         * @member {ICMsgQAngle|null|undefined} world_offset_angle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_angle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.world_offset_pos != null && Object.hasOwnProperty.call(message, "world_offset_pos"))
                $root.CMsgVector.encode(message.world_offset_pos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.world_offset_angle != null && Object.hasOwnProperty.call(message, "world_offset_angle"))
                $root.CMsgQAngle.encode(message.world_offset_angle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldname = reader.string();
                    break;
                case 2:
                    message.entitylumpname = reader.string();
                    break;
                case 3:
                    message.entityfiltername = reader.string();
                    break;
                case 4:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 5:
                    message.spawngroupownerhandle = reader.uint32();
                    break;
                case 6:
                    message.world_offset_pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.world_offset_angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                case 10:
                    message.tickcount = reader.int32();
                    break;
                case 11:
                    message.manifestincomplete = reader.bool();
                    break;
                case 12:
                    message.localnamefixup = reader.string();
                    break;
                case 13:
                    message.parentnamefixup = reader.string();
                    break;
                case 14:
                    message.manifestloadpriority = reader.int32();
                    break;
                case 15:
                    message.worldgroupid = reader.uint32();
                    break;
                case 16:
                    message.creationsequence = reader.uint32();
                    break;
                case 17:
                    message.savegamefilename = reader.string();
                    break;
                case 18:
                    message.spawngroupparenthandle = reader.uint32();
                    break;
                case 19:
                    message.leveltransition = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos")) {
                var error = $root.CMsgVector.verify(message.world_offset_pos);
                if (error)
                    return "world_offset_pos." + error;
            }
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle")) {
                var error = $root.CMsgQAngle.verify(message.world_offset_angle);
                if (error)
                    return "world_offset_angle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.world_offset_pos != null) {
                if (typeof object.world_offset_pos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_pos: object expected");
                message.world_offset_pos = $root.CMsgVector.fromObject(object.world_offset_pos);
            }
            if (object.world_offset_angle != null) {
                if (typeof object.world_offset_angle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_angle: object expected");
                message.world_offset_angle = $root.CMsgQAngle.fromObject(object.world_offset_angle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.world_offset_pos = null;
                object.world_offset_angle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos"))
                object.world_offset_pos = $root.CMsgVector.toObject(message.world_offset_pos, options);
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle"))
                object.world_offset_angle = $root.CMsgQAngle.toObject(message.world_offset_angle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 3:
                    message.manifestincomplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.tickcount = reader.int32();
                    break;
                case 3:
                    message.creationsequence = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.flags = reader.uint32();
                    break;
                case 3:
                    message.tickcount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [is_multiplayer] CSVCMsg_GameSessionConfiguration is_multiplayer
         * @property {boolean|null} [is_loadsavegame] CSVCMsg_GameSessionConfiguration is_loadsavegame
         * @property {boolean|null} [is_background_map] CSVCMsg_GameSessionConfiguration is_background_map
         * @property {boolean|null} [is_headless] CSVCMsg_GameSessionConfiguration is_headless
         * @property {number|null} [min_client_limit] CSVCMsg_GameSessionConfiguration min_client_limit
         * @property {number|null} [max_client_limit] CSVCMsg_GameSessionConfiguration max_client_limit
         * @property {number|null} [max_clients] CSVCMsg_GameSessionConfiguration max_clients
         * @property {number|null} [tick_interval] CSVCMsg_GameSessionConfiguration tick_interval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1_mapname] CSVCMsg_GameSessionConfiguration s1_mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [server_ip_address] CSVCMsg_GameSessionConfiguration server_ip_address
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [is_localonly] CSVCMsg_GameSessionConfiguration is_localonly
         * @property {boolean|null} [no_steam_server] CSVCMsg_GameSessionConfiguration no_steam_server
         * @property {boolean|null} [is_transition] CSVCMsg_GameSessionConfiguration is_transition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration is_multiplayer.
         * @member {boolean} is_multiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_multiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_loadsavegame.
         * @member {boolean} is_loadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_loadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_background_map.
         * @member {boolean} is_background_map
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_background_map = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_headless.
         * @member {boolean} is_headless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_headless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration min_client_limit.
         * @member {number} min_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.min_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_client_limit.
         * @member {number} max_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1_mapname.
         * @member {string} s1_mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1_mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration server_ip_address.
         * @member {string} server_ip_address
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.server_ip_address = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration is_localonly.
         * @member {boolean} is_localonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_localonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration no_steam_server.
         * @member {boolean} no_steam_server
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.no_steam_server = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_transition.
         * @member {boolean} is_transition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_transition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_multiplayer != null && Object.hasOwnProperty.call(message, "is_multiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_multiplayer);
            if (message.is_loadsavegame != null && Object.hasOwnProperty.call(message, "is_loadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_loadsavegame);
            if (message.is_background_map != null && Object.hasOwnProperty.call(message, "is_background_map"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_background_map);
            if (message.is_headless != null && Object.hasOwnProperty.call(message, "is_headless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_headless);
            if (message.min_client_limit != null && Object.hasOwnProperty.call(message, "min_client_limit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.min_client_limit);
            if (message.max_client_limit != null && Object.hasOwnProperty.call(message, "max_client_limit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.max_client_limit);
            if (message.max_clients != null && Object.hasOwnProperty.call(message, "max_clients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.max_clients);
            if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tick_interval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1_mapname != null && Object.hasOwnProperty.call(message, "s1_mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1_mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.server_ip_address != null && Object.hasOwnProperty.call(message, "server_ip_address"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.server_ip_address);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.is_localonly != null && Object.hasOwnProperty.call(message, "is_localonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.is_localonly);
            if (message.is_transition != null && Object.hasOwnProperty.call(message, "is_transition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_transition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.no_steam_server != null && Object.hasOwnProperty.call(message, "no_steam_server"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.no_steam_server);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_multiplayer = reader.bool();
                    break;
                case 2:
                    message.is_loadsavegame = reader.bool();
                    break;
                case 3:
                    message.is_background_map = reader.bool();
                    break;
                case 4:
                    message.is_headless = reader.bool();
                    break;
                case 5:
                    message.min_client_limit = reader.uint32();
                    break;
                case 6:
                    message.max_client_limit = reader.uint32();
                    break;
                case 7:
                    message.max_clients = reader.uint32();
                    break;
                case 8:
                    message.tick_interval = reader.fixed32();
                    break;
                case 9:
                    message.hostname = reader.string();
                    break;
                case 10:
                    message.savegamename = reader.string();
                    break;
                case 11:
                    message.s1_mapname = reader.string();
                    break;
                case 12:
                    message.gamemode = reader.string();
                    break;
                case 13:
                    message.server_ip_address = reader.string();
                    break;
                case 14:
                    message.data = reader.bytes();
                    break;
                case 15:
                    message.is_localonly = reader.bool();
                    break;
                case 19:
                    message.no_steam_server = reader.bool();
                    break;
                case 16:
                    message.is_transition = reader.bool();
                    break;
                case 17:
                    message.previouslevel = reader.string();
                    break;
                case 18:
                    message.landmarkname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                if (typeof message.is_multiplayer !== "boolean")
                    return "is_multiplayer: boolean expected";
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                if (typeof message.is_loadsavegame !== "boolean")
                    return "is_loadsavegame: boolean expected";
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                if (typeof message.is_background_map !== "boolean")
                    return "is_background_map: boolean expected";
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                if (typeof message.is_headless !== "boolean")
                    return "is_headless: boolean expected";
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                if (!$util.isInteger(message.min_client_limit))
                    return "min_client_limit: integer expected";
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                if (!$util.isInteger(message.max_client_limit))
                    return "max_client_limit: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (!$util.isInteger(message.tick_interval))
                    return "tick_interval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                if (!$util.isString(message.s1_mapname))
                    return "s1_mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                if (!$util.isString(message.server_ip_address))
                    return "server_ip_address: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                if (typeof message.is_localonly !== "boolean")
                    return "is_localonly: boolean expected";
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                if (typeof message.no_steam_server !== "boolean")
                    return "no_steam_server: boolean expected";
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                if (typeof message.is_transition !== "boolean")
                    return "is_transition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.is_multiplayer != null)
                message.is_multiplayer = Boolean(object.is_multiplayer);
            if (object.is_loadsavegame != null)
                message.is_loadsavegame = Boolean(object.is_loadsavegame);
            if (object.is_background_map != null)
                message.is_background_map = Boolean(object.is_background_map);
            if (object.is_headless != null)
                message.is_headless = Boolean(object.is_headless);
            if (object.min_client_limit != null)
                message.min_client_limit = object.min_client_limit >>> 0;
            if (object.max_client_limit != null)
                message.max_client_limit = object.max_client_limit >>> 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients >>> 0;
            if (object.tick_interval != null)
                message.tick_interval = object.tick_interval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1_mapname != null)
                message.s1_mapname = String(object.s1_mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.server_ip_address != null)
                message.server_ip_address = String(object.server_ip_address);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.is_localonly != null)
                message.is_localonly = Boolean(object.is_localonly);
            if (object.no_steam_server != null)
                message.no_steam_server = Boolean(object.no_steam_server);
            if (object.is_transition != null)
                message.is_transition = Boolean(object.is_transition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.is_multiplayer = false;
                object.is_loadsavegame = false;
                object.is_background_map = false;
                object.is_headless = false;
                object.min_client_limit = 0;
                object.max_client_limit = 0;
                object.max_clients = 0;
                object.tick_interval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1_mapname = "";
                object.gamemode = "";
                object.server_ip_address = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.is_localonly = false;
                object.is_transition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.no_steam_server = false;
            }
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                object.is_multiplayer = message.is_multiplayer;
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                object.is_loadsavegame = message.is_loadsavegame;
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                object.is_background_map = message.is_background_map;
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                object.is_headless = message.is_headless;
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                object.min_client_limit = message.min_client_limit;
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                object.max_client_limit = message.max_client_limit;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = message.tick_interval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                object.s1_mapname = message.s1_mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                object.server_ip_address = message.server_ip_address;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                object.is_localonly = message.is_localonly;
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                object.is_transition = message.is_transition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                object.no_steam_server = message.no_steam_server;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW=70 NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[70] = "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW"] = 70;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {string|null} [experimental_map_key] FieldOptions experimental_map_key
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions experimental_map_key.
                 * @member {string} experimental_map_key
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.experimental_map_key = "";
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.experimental_map_key != null && Object.hasOwnProperty.call(message, "experimental_map_key"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.experimental_map_key);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 9:
                            message.experimental_map_key = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        if (!$util.isString(message.experimental_map_key))
                            return "experimental_map_key: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.experimental_map_key != null)
                        message.experimental_map_key = String(object.experimental_map_key);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.experimental_map_key = "";
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        object.experimental_map_key = message.experimental_map_key;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 * @property {string|null} [".network_connection_token"] EnumValueOptions .network_connection_token
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * EnumValueOptions .network_connection_token.
                 * @member {string} .network_connection_token
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".network_connection_token"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".network_connection_token"] != null && Object.hasOwnProperty.call(message, ".network_connection_token"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".network_connection_token"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50500:
                            message[".network_connection_token"] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        if (!$util.isString(message[".network_connection_token"]))
                            return ".network_connection_token: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".network_connection_token"] != null)
                        message[".network_connection_token"] = String(object[".network_connection_token"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object[".network_connection_token"] = "";
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        object[".network_connection_token"] = message[".network_connection_token"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
