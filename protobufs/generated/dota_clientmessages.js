/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * EDotaClientMessages enum.
     * @exports EDotaClientMessages
     * @enum {number}
     * @property {number} DOTA_CM_MapLine=301 DOTA_CM_MapLine value
     * @property {number} DOTA_CM_AspectRatio=302 DOTA_CM_AspectRatio value
     * @property {number} DOTA_CM_MapPing=303 DOTA_CM_MapPing value
     * @property {number} DOTA_CM_UnitsAutoAttack=304 DOTA_CM_UnitsAutoAttack value
     * @property {number} DOTA_CM_SearchString=307 DOTA_CM_SearchString value
     * @property {number} DOTA_CM_Pause=308 DOTA_CM_Pause value
     * @property {number} DOTA_CM_ShopViewMode=309 DOTA_CM_ShopViewMode value
     * @property {number} DOTA_CM_SetUnitShareFlag=310 DOTA_CM_SetUnitShareFlag value
     * @property {number} DOTA_CM_SwapRequest=311 DOTA_CM_SwapRequest value
     * @property {number} DOTA_CM_SwapAccept=312 DOTA_CM_SwapAccept value
     * @property {number} DOTA_CM_WorldLine=313 DOTA_CM_WorldLine value
     * @property {number} DOTA_CM_RequestGraphUpdate=314 DOTA_CM_RequestGraphUpdate value
     * @property {number} DOTA_CM_ItemAlert=315 DOTA_CM_ItemAlert value
     * @property {number} DOTA_CM_ChatWheel=316 DOTA_CM_ChatWheel value
     * @property {number} DOTA_CM_SendStatPopup=317 DOTA_CM_SendStatPopup value
     * @property {number} DOTA_CM_BeginLastHitChallenge=318 DOTA_CM_BeginLastHitChallenge value
     * @property {number} DOTA_CM_UpdateQuickBuy=319 DOTA_CM_UpdateQuickBuy value
     * @property {number} DOTA_CM_UpdateCoachListen=320 DOTA_CM_UpdateCoachListen value
     * @property {number} DOTA_CM_CoachHUDPing=321 DOTA_CM_CoachHUDPing value
     * @property {number} DOTA_CM_RecordVote=322 DOTA_CM_RecordVote value
     * @property {number} DOTA_CM_UnitsAutoAttackAfterSpell=323 DOTA_CM_UnitsAutoAttackAfterSpell value
     * @property {number} DOTA_CM_WillPurchaseAlert=324 DOTA_CM_WillPurchaseAlert value
     * @property {number} DOTA_CM_PlayerShowCase=325 DOTA_CM_PlayerShowCase value
     * @property {number} DOTA_CM_TeleportRequiresHalt=326 DOTA_CM_TeleportRequiresHalt value
     * @property {number} DOTA_CM_CameraZoomAmount=327 DOTA_CM_CameraZoomAmount value
     * @property {number} DOTA_CM_BroadcasterUsingCamerman=328 DOTA_CM_BroadcasterUsingCamerman value
     * @property {number} DOTA_CM_BroadcasterUsingAssistedCameraOperator=329 DOTA_CM_BroadcasterUsingAssistedCameraOperator value
     * @property {number} DOTA_CM_EnemyItemAlert=330 DOTA_CM_EnemyItemAlert value
     * @property {number} DOTA_CM_FreeInventory=331 DOTA_CM_FreeInventory value
     * @property {number} DOTA_CM_BuyBackStateAlert=332 DOTA_CM_BuyBackStateAlert value
     * @property {number} DOTA_CM_QuickBuyAlert=333 DOTA_CM_QuickBuyAlert value
     * @property {number} DOTA_CM_HeroStatueLike=334 DOTA_CM_HeroStatueLike value
     * @property {number} DOTA_CM_ModifierAlert=335 DOTA_CM_ModifierAlert value
     * @property {number} DOTA_CM_TeamShowcaseEditor=336 DOTA_CM_TeamShowcaseEditor value
     * @property {number} DOTA_CM_HPManaAlert=337 DOTA_CM_HPManaAlert value
     * @property {number} DOTA_CM_GlyphAlert=338 DOTA_CM_GlyphAlert value
     * @property {number} DOTA_CM_TeamShowcaseClientData=339 DOTA_CM_TeamShowcaseClientData value
     * @property {number} DOTA_CM_PlayTeamShowcase=340 DOTA_CM_PlayTeamShowcase value
     * @property {number} DOTA_CM_EventCNY2015Cmd=341 DOTA_CM_EventCNY2015Cmd value
     * @property {number} DOTA_CM_FillEmptySlotsWithBots=342 DOTA_CM_FillEmptySlotsWithBots value
     * @property {number} DOTA_CM_DemoHero=343 DOTA_CM_DemoHero value
     * @property {number} DOTA_CM_AbilityLearnModeToggled=344 DOTA_CM_AbilityLearnModeToggled value
     * @property {number} DOTA_CM_AbilityStartUse=345 DOTA_CM_AbilityStartUse value
     * @property {number} DOTA_CM_ChallengeSelect=346 DOTA_CM_ChallengeSelect value
     * @property {number} DOTA_CM_ChallengeReroll=347 DOTA_CM_ChallengeReroll value
     * @property {number} DOTA_CM_ClickedBuff=348 DOTA_CM_ClickedBuff value
     * @property {number} DOTA_CM_CoinWager=349 DOTA_CM_CoinWager value
     * @property {number} DOTA_CM_ExecuteOrders=350 DOTA_CM_ExecuteOrders value
     * @property {number} DOTA_CM_XPAlert=351 DOTA_CM_XPAlert value
     * @property {number} DOTA_CM_EventPointsTip=353 DOTA_CM_EventPointsTip value
     * @property {number} DOTA_CM_MatchMetadata=354 DOTA_CM_MatchMetadata value
     * @property {number} DOTA_CM_KillMyHero=355 DOTA_CM_KillMyHero value
     * @property {number} DOTA_CM_QuestStatus=356 DOTA_CM_QuestStatus value
     * @property {number} DOTA_CM_ToggleAutoattack=357 DOTA_CM_ToggleAutoattack value
     * @property {number} DOTA_CM_SpecialAbility=358 DOTA_CM_SpecialAbility value
     * @property {number} DOTA_CM_KillcamDamageTaken=359 DOTA_CM_KillcamDamageTaken value
     * @property {number} DOTA_CM_SetEnemyStartingPosition=360 DOTA_CM_SetEnemyStartingPosition value
     * @property {number} DOTA_CM_SetDesiredWardPlacement=361 DOTA_CM_SetDesiredWardPlacement value
     * @property {number} DOTA_CM_RollDice=362 DOTA_CM_RollDice value
     * @property {number} DOTA_CM_FlipCoin=363 DOTA_CM_FlipCoin value
     * @property {number} DOTA_CM_RequestItemSuggestions=364 DOTA_CM_RequestItemSuggestions value
     * @property {number} DOTA_CM_MakeTeamCaptain=365 DOTA_CM_MakeTeamCaptain value
     * @property {number} DOTA_CM_CoinWagerToken=366 DOTA_CM_CoinWagerToken value
     * @property {number} DOTA_CM_RankWager=367 DOTA_CM_RankWager value
     * @property {number} DOTA_CM_DismissAllStatPopups=368 DOTA_CM_DismissAllStatPopups value
     * @property {number} DOTA_CM_HelpTipSystemStateChanged=369 DOTA_CM_HelpTipSystemStateChanged value
     * @property {number} DOTA_CM_ChannelRequiresHalt=370 DOTA_CM_ChannelRequiresHalt value
     * @property {number} DOTA_CM_RequestBulkCombatLog=371 DOTA_CM_RequestBulkCombatLog value
     * @property {number} DOTA_CM_AbilityDraftRequestAbility=372 DOTA_CM_AbilityDraftRequestAbility value
     * @property {number} DOTA_CM_GuideSelectOption=373 DOTA_CM_GuideSelectOption value
     * @property {number} DOTA_CM_GuideSelected=374 DOTA_CM_GuideSelected value
     * @property {number} DOTA_CM_DamageReport=375 DOTA_CM_DamageReport value
     * @property {number} DOTA_CM_SalutePlayer=376 DOTA_CM_SalutePlayer value
     * @property {number} DOTA_CM_SprayWheel=377 DOTA_CM_SprayWheel value
     * @property {number} DOTA_CM_TipAlert=378 DOTA_CM_TipAlert value
     * @property {number} DOTA_CM_EmptyTeleportAlert=379 DOTA_CM_EmptyTeleportAlert value
     * @property {number} DOTA_CM_RadarAlert=380 DOTA_CM_RadarAlert value
     * @property {number} DOTA_CM_TalentTreeAlert=381 DOTA_CM_TalentTreeAlert value
     * @property {number} DOTA_CM_SetCavernMapVariant=382 DOTA_CM_SetCavernMapVariant value
     * @property {number} DOTA_CM_PauseGameOrder=383 DOTA_CM_PauseGameOrder value
     * @property {number} DOTA_CM_VersusScene_PlayerBehavior=384 DOTA_CM_VersusScene_PlayerBehavior value
     * @property {number} DOTA_CM_PlayerBounty=385 DOTA_CM_PlayerBounty value
     * @property {number} DOTA_CM_PlayerBountyCancel=386 DOTA_CM_PlayerBountyCancel value
     * @property {number} DOTA_CM_PingConfirm=387 DOTA_CM_PingConfirm value
     * @property {number} DOTA_CM_EmptyItemSlotAlert=388 DOTA_CM_EmptyItemSlotAlert value
     * @property {number} DOTA_CM_AddMarker=389 DOTA_CM_AddMarker value
     */
    $root.EDotaClientMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[301] = "DOTA_CM_MapLine"] = 301;
        values[valuesById[302] = "DOTA_CM_AspectRatio"] = 302;
        values[valuesById[303] = "DOTA_CM_MapPing"] = 303;
        values[valuesById[304] = "DOTA_CM_UnitsAutoAttack"] = 304;
        values[valuesById[307] = "DOTA_CM_SearchString"] = 307;
        values[valuesById[308] = "DOTA_CM_Pause"] = 308;
        values[valuesById[309] = "DOTA_CM_ShopViewMode"] = 309;
        values[valuesById[310] = "DOTA_CM_SetUnitShareFlag"] = 310;
        values[valuesById[311] = "DOTA_CM_SwapRequest"] = 311;
        values[valuesById[312] = "DOTA_CM_SwapAccept"] = 312;
        values[valuesById[313] = "DOTA_CM_WorldLine"] = 313;
        values[valuesById[314] = "DOTA_CM_RequestGraphUpdate"] = 314;
        values[valuesById[315] = "DOTA_CM_ItemAlert"] = 315;
        values[valuesById[316] = "DOTA_CM_ChatWheel"] = 316;
        values[valuesById[317] = "DOTA_CM_SendStatPopup"] = 317;
        values[valuesById[318] = "DOTA_CM_BeginLastHitChallenge"] = 318;
        values[valuesById[319] = "DOTA_CM_UpdateQuickBuy"] = 319;
        values[valuesById[320] = "DOTA_CM_UpdateCoachListen"] = 320;
        values[valuesById[321] = "DOTA_CM_CoachHUDPing"] = 321;
        values[valuesById[322] = "DOTA_CM_RecordVote"] = 322;
        values[valuesById[323] = "DOTA_CM_UnitsAutoAttackAfterSpell"] = 323;
        values[valuesById[324] = "DOTA_CM_WillPurchaseAlert"] = 324;
        values[valuesById[325] = "DOTA_CM_PlayerShowCase"] = 325;
        values[valuesById[326] = "DOTA_CM_TeleportRequiresHalt"] = 326;
        values[valuesById[327] = "DOTA_CM_CameraZoomAmount"] = 327;
        values[valuesById[328] = "DOTA_CM_BroadcasterUsingCamerman"] = 328;
        values[valuesById[329] = "DOTA_CM_BroadcasterUsingAssistedCameraOperator"] = 329;
        values[valuesById[330] = "DOTA_CM_EnemyItemAlert"] = 330;
        values[valuesById[331] = "DOTA_CM_FreeInventory"] = 331;
        values[valuesById[332] = "DOTA_CM_BuyBackStateAlert"] = 332;
        values[valuesById[333] = "DOTA_CM_QuickBuyAlert"] = 333;
        values[valuesById[334] = "DOTA_CM_HeroStatueLike"] = 334;
        values[valuesById[335] = "DOTA_CM_ModifierAlert"] = 335;
        values[valuesById[336] = "DOTA_CM_TeamShowcaseEditor"] = 336;
        values[valuesById[337] = "DOTA_CM_HPManaAlert"] = 337;
        values[valuesById[338] = "DOTA_CM_GlyphAlert"] = 338;
        values[valuesById[339] = "DOTA_CM_TeamShowcaseClientData"] = 339;
        values[valuesById[340] = "DOTA_CM_PlayTeamShowcase"] = 340;
        values[valuesById[341] = "DOTA_CM_EventCNY2015Cmd"] = 341;
        values[valuesById[342] = "DOTA_CM_FillEmptySlotsWithBots"] = 342;
        values[valuesById[343] = "DOTA_CM_DemoHero"] = 343;
        values[valuesById[344] = "DOTA_CM_AbilityLearnModeToggled"] = 344;
        values[valuesById[345] = "DOTA_CM_AbilityStartUse"] = 345;
        values[valuesById[346] = "DOTA_CM_ChallengeSelect"] = 346;
        values[valuesById[347] = "DOTA_CM_ChallengeReroll"] = 347;
        values[valuesById[348] = "DOTA_CM_ClickedBuff"] = 348;
        values[valuesById[349] = "DOTA_CM_CoinWager"] = 349;
        values[valuesById[350] = "DOTA_CM_ExecuteOrders"] = 350;
        values[valuesById[351] = "DOTA_CM_XPAlert"] = 351;
        values[valuesById[353] = "DOTA_CM_EventPointsTip"] = 353;
        values[valuesById[354] = "DOTA_CM_MatchMetadata"] = 354;
        values[valuesById[355] = "DOTA_CM_KillMyHero"] = 355;
        values[valuesById[356] = "DOTA_CM_QuestStatus"] = 356;
        values[valuesById[357] = "DOTA_CM_ToggleAutoattack"] = 357;
        values[valuesById[358] = "DOTA_CM_SpecialAbility"] = 358;
        values[valuesById[359] = "DOTA_CM_KillcamDamageTaken"] = 359;
        values[valuesById[360] = "DOTA_CM_SetEnemyStartingPosition"] = 360;
        values[valuesById[361] = "DOTA_CM_SetDesiredWardPlacement"] = 361;
        values[valuesById[362] = "DOTA_CM_RollDice"] = 362;
        values[valuesById[363] = "DOTA_CM_FlipCoin"] = 363;
        values[valuesById[364] = "DOTA_CM_RequestItemSuggestions"] = 364;
        values[valuesById[365] = "DOTA_CM_MakeTeamCaptain"] = 365;
        values[valuesById[366] = "DOTA_CM_CoinWagerToken"] = 366;
        values[valuesById[367] = "DOTA_CM_RankWager"] = 367;
        values[valuesById[368] = "DOTA_CM_DismissAllStatPopups"] = 368;
        values[valuesById[369] = "DOTA_CM_HelpTipSystemStateChanged"] = 369;
        values[valuesById[370] = "DOTA_CM_ChannelRequiresHalt"] = 370;
        values[valuesById[371] = "DOTA_CM_RequestBulkCombatLog"] = 371;
        values[valuesById[372] = "DOTA_CM_AbilityDraftRequestAbility"] = 372;
        values[valuesById[373] = "DOTA_CM_GuideSelectOption"] = 373;
        values[valuesById[374] = "DOTA_CM_GuideSelected"] = 374;
        values[valuesById[375] = "DOTA_CM_DamageReport"] = 375;
        values[valuesById[376] = "DOTA_CM_SalutePlayer"] = 376;
        values[valuesById[377] = "DOTA_CM_SprayWheel"] = 377;
        values[valuesById[378] = "DOTA_CM_TipAlert"] = 378;
        values[valuesById[379] = "DOTA_CM_EmptyTeleportAlert"] = 379;
        values[valuesById[380] = "DOTA_CM_RadarAlert"] = 380;
        values[valuesById[381] = "DOTA_CM_TalentTreeAlert"] = 381;
        values[valuesById[382] = "DOTA_CM_SetCavernMapVariant"] = 382;
        values[valuesById[383] = "DOTA_CM_PauseGameOrder"] = 383;
        values[valuesById[384] = "DOTA_CM_VersusScene_PlayerBehavior"] = 384;
        values[valuesById[385] = "DOTA_CM_PlayerBounty"] = 385;
        values[valuesById[386] = "DOTA_CM_PlayerBountyCancel"] = 386;
        values[valuesById[387] = "DOTA_CM_PingConfirm"] = 387;
        values[valuesById[388] = "DOTA_CM_EmptyItemSlotAlert"] = 388;
        values[valuesById[389] = "DOTA_CM_AddMarker"] = 389;
        return values;
    })();
    
    $root.CDOTAClientMsg_MapPing = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_MapPing.
         * @exports ICDOTAClientMsg_MapPing
         * @interface ICDOTAClientMsg_MapPing
         * @property {ICDOTAMsg_LocationPing|null} [location_ping] CDOTAClientMsg_MapPing location_ping
         */
    
        /**
         * Constructs a new CDOTAClientMsg_MapPing.
         * @exports CDOTAClientMsg_MapPing
         * @classdesc Represents a CDOTAClientMsg_MapPing.
         * @implements ICDOTAClientMsg_MapPing
         * @constructor
         * @param {ICDOTAClientMsg_MapPing=} [properties] Properties to set
         */
        function CDOTAClientMsg_MapPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_MapPing location_ping.
         * @member {ICDOTAMsg_LocationPing|null|undefined} location_ping
         * @memberof CDOTAClientMsg_MapPing
         * @instance
         */
        CDOTAClientMsg_MapPing.prototype.location_ping = null;
    
        /**
         * Creates a new CDOTAClientMsg_MapPing instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {ICDOTAClientMsg_MapPing=} [properties] Properties to set
         * @returns {CDOTAClientMsg_MapPing} CDOTAClientMsg_MapPing instance
         */
        CDOTAClientMsg_MapPing.create = function create(properties) {
            return new CDOTAClientMsg_MapPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MapPing message. Does not implicitly {@link CDOTAClientMsg_MapPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {ICDOTAClientMsg_MapPing} message CDOTAClientMsg_MapPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MapPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.location_ping != null && Object.hasOwnProperty.call(message, "location_ping"))
                $root.CDOTAMsg_LocationPing.encode(message.location_ping, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MapPing message, length delimited. Does not implicitly {@link CDOTAClientMsg_MapPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {ICDOTAClientMsg_MapPing} message CDOTAClientMsg_MapPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MapPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_MapPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_MapPing} CDOTAClientMsg_MapPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MapPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_MapPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.location_ping = $root.CDOTAMsg_LocationPing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_MapPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_MapPing} CDOTAClientMsg_MapPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MapPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_MapPing message.
         * @function verify
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_MapPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.location_ping != null && message.hasOwnProperty("location_ping")) {
                var error = $root.CDOTAMsg_LocationPing.verify(message.location_ping);
                if (error)
                    return "location_ping." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_MapPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_MapPing} CDOTAClientMsg_MapPing
         */
        CDOTAClientMsg_MapPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_MapPing)
                return object;
            var message = new $root.CDOTAClientMsg_MapPing();
            if (object.location_ping != null) {
                if (typeof object.location_ping !== "object")
                    throw TypeError(".CDOTAClientMsg_MapPing.location_ping: object expected");
                message.location_ping = $root.CDOTAMsg_LocationPing.fromObject(object.location_ping);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_MapPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_MapPing
         * @static
         * @param {CDOTAClientMsg_MapPing} message CDOTAClientMsg_MapPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_MapPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.location_ping = null;
            if (message.location_ping != null && message.hasOwnProperty("location_ping"))
                object.location_ping = $root.CDOTAMsg_LocationPing.toObject(message.location_ping, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_MapPing to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_MapPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_MapPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_MapPing;
    })();
    
    $root.CDOTAClientMsg_ItemAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ItemAlert.
         * @exports ICDOTAClientMsg_ItemAlert
         * @interface ICDOTAClientMsg_ItemAlert
         * @property {ICDOTAMsg_ItemAlert|null} [item_alert] CDOTAClientMsg_ItemAlert item_alert
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ItemAlert.
         * @exports CDOTAClientMsg_ItemAlert
         * @classdesc Represents a CDOTAClientMsg_ItemAlert.
         * @implements ICDOTAClientMsg_ItemAlert
         * @constructor
         * @param {ICDOTAClientMsg_ItemAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_ItemAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ItemAlert item_alert.
         * @member {ICDOTAMsg_ItemAlert|null|undefined} item_alert
         * @memberof CDOTAClientMsg_ItemAlert
         * @instance
         */
        CDOTAClientMsg_ItemAlert.prototype.item_alert = null;
    
        /**
         * Creates a new CDOTAClientMsg_ItemAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {ICDOTAClientMsg_ItemAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ItemAlert} CDOTAClientMsg_ItemAlert instance
         */
        CDOTAClientMsg_ItemAlert.create = function create(properties) {
            return new CDOTAClientMsg_ItemAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ItemAlert message. Does not implicitly {@link CDOTAClientMsg_ItemAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {ICDOTAClientMsg_ItemAlert} message CDOTAClientMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ItemAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_alert != null && Object.hasOwnProperty.call(message, "item_alert"))
                $root.CDOTAMsg_ItemAlert.encode(message.item_alert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ItemAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_ItemAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {ICDOTAClientMsg_ItemAlert} message CDOTAClientMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ItemAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ItemAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ItemAlert} CDOTAClientMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ItemAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ItemAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_alert = $root.CDOTAMsg_ItemAlert.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ItemAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ItemAlert} CDOTAClientMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ItemAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ItemAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ItemAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_alert != null && message.hasOwnProperty("item_alert")) {
                var error = $root.CDOTAMsg_ItemAlert.verify(message.item_alert);
                if (error)
                    return "item_alert." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ItemAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ItemAlert} CDOTAClientMsg_ItemAlert
         */
        CDOTAClientMsg_ItemAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ItemAlert)
                return object;
            var message = new $root.CDOTAClientMsg_ItemAlert();
            if (object.item_alert != null) {
                if (typeof object.item_alert !== "object")
                    throw TypeError(".CDOTAClientMsg_ItemAlert.item_alert: object expected");
                message.item_alert = $root.CDOTAMsg_ItemAlert.fromObject(object.item_alert);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ItemAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ItemAlert
         * @static
         * @param {CDOTAClientMsg_ItemAlert} message CDOTAClientMsg_ItemAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ItemAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item_alert = null;
            if (message.item_alert != null && message.hasOwnProperty("item_alert"))
                object.item_alert = $root.CDOTAMsg_ItemAlert.toObject(message.item_alert, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ItemAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ItemAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ItemAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ItemAlert;
    })();
    
    $root.CDOTAClientMsg_EnemyItemAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_EnemyItemAlert.
         * @exports ICDOTAClientMsg_EnemyItemAlert
         * @interface ICDOTAClientMsg_EnemyItemAlert
         * @property {number|null} [item_entindex] CDOTAClientMsg_EnemyItemAlert item_entindex
         * @property {number|null} [rune_type] CDOTAClientMsg_EnemyItemAlert rune_type
         * @property {number|null} [item_level] CDOTAClientMsg_EnemyItemAlert item_level
         * @property {number|null} [primary_charges] CDOTAClientMsg_EnemyItemAlert primary_charges
         * @property {number|null} [secondary_charges] CDOTAClientMsg_EnemyItemAlert secondary_charges
         */
    
        /**
         * Constructs a new CDOTAClientMsg_EnemyItemAlert.
         * @exports CDOTAClientMsg_EnemyItemAlert
         * @classdesc Represents a CDOTAClientMsg_EnemyItemAlert.
         * @implements ICDOTAClientMsg_EnemyItemAlert
         * @constructor
         * @param {ICDOTAClientMsg_EnemyItemAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_EnemyItemAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_EnemyItemAlert item_entindex.
         * @member {number} item_entindex
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @instance
         */
        CDOTAClientMsg_EnemyItemAlert.prototype.item_entindex = 0;
    
        /**
         * CDOTAClientMsg_EnemyItemAlert rune_type.
         * @member {number} rune_type
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @instance
         */
        CDOTAClientMsg_EnemyItemAlert.prototype.rune_type = -1;
    
        /**
         * CDOTAClientMsg_EnemyItemAlert item_level.
         * @member {number} item_level
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @instance
         */
        CDOTAClientMsg_EnemyItemAlert.prototype.item_level = -1;
    
        /**
         * CDOTAClientMsg_EnemyItemAlert primary_charges.
         * @member {number} primary_charges
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @instance
         */
        CDOTAClientMsg_EnemyItemAlert.prototype.primary_charges = -1;
    
        /**
         * CDOTAClientMsg_EnemyItemAlert secondary_charges.
         * @member {number} secondary_charges
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @instance
         */
        CDOTAClientMsg_EnemyItemAlert.prototype.secondary_charges = -1;
    
        /**
         * Creates a new CDOTAClientMsg_EnemyItemAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {ICDOTAClientMsg_EnemyItemAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_EnemyItemAlert} CDOTAClientMsg_EnemyItemAlert instance
         */
        CDOTAClientMsg_EnemyItemAlert.create = function create(properties) {
            return new CDOTAClientMsg_EnemyItemAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EnemyItemAlert message. Does not implicitly {@link CDOTAClientMsg_EnemyItemAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {ICDOTAClientMsg_EnemyItemAlert} message CDOTAClientMsg_EnemyItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EnemyItemAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_entindex != null && Object.hasOwnProperty.call(message, "item_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.item_entindex);
            if (message.rune_type != null && Object.hasOwnProperty.call(message, "rune_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rune_type);
            if (message.item_level != null && Object.hasOwnProperty.call(message, "item_level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.item_level);
            if (message.primary_charges != null && Object.hasOwnProperty.call(message, "primary_charges"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.primary_charges);
            if (message.secondary_charges != null && Object.hasOwnProperty.call(message, "secondary_charges"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.secondary_charges);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EnemyItemAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_EnemyItemAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {ICDOTAClientMsg_EnemyItemAlert} message CDOTAClientMsg_EnemyItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EnemyItemAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_EnemyItemAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_EnemyItemAlert} CDOTAClientMsg_EnemyItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EnemyItemAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_EnemyItemAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_entindex = reader.uint32();
                    break;
                case 2:
                    message.rune_type = reader.int32();
                    break;
                case 3:
                    message.item_level = reader.int32();
                    break;
                case 4:
                    message.primary_charges = reader.int32();
                    break;
                case 5:
                    message.secondary_charges = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_EnemyItemAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_EnemyItemAlert} CDOTAClientMsg_EnemyItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EnemyItemAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_EnemyItemAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_EnemyItemAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_entindex != null && message.hasOwnProperty("item_entindex"))
                if (!$util.isInteger(message.item_entindex))
                    return "item_entindex: integer expected";
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                if (!$util.isInteger(message.rune_type))
                    return "rune_type: integer expected";
            if (message.item_level != null && message.hasOwnProperty("item_level"))
                if (!$util.isInteger(message.item_level))
                    return "item_level: integer expected";
            if (message.primary_charges != null && message.hasOwnProperty("primary_charges"))
                if (!$util.isInteger(message.primary_charges))
                    return "primary_charges: integer expected";
            if (message.secondary_charges != null && message.hasOwnProperty("secondary_charges"))
                if (!$util.isInteger(message.secondary_charges))
                    return "secondary_charges: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_EnemyItemAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_EnemyItemAlert} CDOTAClientMsg_EnemyItemAlert
         */
        CDOTAClientMsg_EnemyItemAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_EnemyItemAlert)
                return object;
            var message = new $root.CDOTAClientMsg_EnemyItemAlert();
            if (object.item_entindex != null)
                message.item_entindex = object.item_entindex >>> 0;
            if (object.rune_type != null)
                message.rune_type = object.rune_type | 0;
            if (object.item_level != null)
                message.item_level = object.item_level | 0;
            if (object.primary_charges != null)
                message.primary_charges = object.primary_charges | 0;
            if (object.secondary_charges != null)
                message.secondary_charges = object.secondary_charges | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_EnemyItemAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @static
         * @param {CDOTAClientMsg_EnemyItemAlert} message CDOTAClientMsg_EnemyItemAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_EnemyItemAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item_entindex = 0;
                object.rune_type = -1;
                object.item_level = -1;
                object.primary_charges = -1;
                object.secondary_charges = -1;
            }
            if (message.item_entindex != null && message.hasOwnProperty("item_entindex"))
                object.item_entindex = message.item_entindex;
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                object.rune_type = message.rune_type;
            if (message.item_level != null && message.hasOwnProperty("item_level"))
                object.item_level = message.item_level;
            if (message.primary_charges != null && message.hasOwnProperty("primary_charges"))
                object.primary_charges = message.primary_charges;
            if (message.secondary_charges != null && message.hasOwnProperty("secondary_charges"))
                object.secondary_charges = message.secondary_charges;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_EnemyItemAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_EnemyItemAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_EnemyItemAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_EnemyItemAlert;
    })();
    
    $root.CDOTAClientMsg_ModifierAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ModifierAlert.
         * @exports ICDOTAClientMsg_ModifierAlert
         * @interface ICDOTAClientMsg_ModifierAlert
         * @property {number|null} [buff_internal_index] CDOTAClientMsg_ModifierAlert buff_internal_index
         * @property {number|null} [target_entindex] CDOTAClientMsg_ModifierAlert target_entindex
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ModifierAlert.
         * @exports CDOTAClientMsg_ModifierAlert
         * @classdesc Represents a CDOTAClientMsg_ModifierAlert.
         * @implements ICDOTAClientMsg_ModifierAlert
         * @constructor
         * @param {ICDOTAClientMsg_ModifierAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_ModifierAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ModifierAlert buff_internal_index.
         * @member {number} buff_internal_index
         * @memberof CDOTAClientMsg_ModifierAlert
         * @instance
         */
        CDOTAClientMsg_ModifierAlert.prototype.buff_internal_index = 0;
    
        /**
         * CDOTAClientMsg_ModifierAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_ModifierAlert
         * @instance
         */
        CDOTAClientMsg_ModifierAlert.prototype.target_entindex = 0;
    
        /**
         * Creates a new CDOTAClientMsg_ModifierAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {ICDOTAClientMsg_ModifierAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ModifierAlert} CDOTAClientMsg_ModifierAlert instance
         */
        CDOTAClientMsg_ModifierAlert.create = function create(properties) {
            return new CDOTAClientMsg_ModifierAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ModifierAlert message. Does not implicitly {@link CDOTAClientMsg_ModifierAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {ICDOTAClientMsg_ModifierAlert} message CDOTAClientMsg_ModifierAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ModifierAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buff_internal_index != null && Object.hasOwnProperty.call(message, "buff_internal_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buff_internal_index);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ModifierAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_ModifierAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {ICDOTAClientMsg_ModifierAlert} message CDOTAClientMsg_ModifierAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ModifierAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ModifierAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ModifierAlert} CDOTAClientMsg_ModifierAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ModifierAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ModifierAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buff_internal_index = reader.int32();
                    break;
                case 2:
                    message.target_entindex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ModifierAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ModifierAlert} CDOTAClientMsg_ModifierAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ModifierAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ModifierAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ModifierAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buff_internal_index != null && message.hasOwnProperty("buff_internal_index"))
                if (!$util.isInteger(message.buff_internal_index))
                    return "buff_internal_index: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ModifierAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ModifierAlert} CDOTAClientMsg_ModifierAlert
         */
        CDOTAClientMsg_ModifierAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ModifierAlert)
                return object;
            var message = new $root.CDOTAClientMsg_ModifierAlert();
            if (object.buff_internal_index != null)
                message.buff_internal_index = object.buff_internal_index | 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ModifierAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ModifierAlert
         * @static
         * @param {CDOTAClientMsg_ModifierAlert} message CDOTAClientMsg_ModifierAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ModifierAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buff_internal_index = 0;
                object.target_entindex = 0;
            }
            if (message.buff_internal_index != null && message.hasOwnProperty("buff_internal_index"))
                object.buff_internal_index = message.buff_internal_index;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ModifierAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ModifierAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ModifierAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ModifierAlert;
    })();
    
    $root.CDOTAClientMsg_ClickedBuff = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ClickedBuff.
         * @exports ICDOTAClientMsg_ClickedBuff
         * @interface ICDOTAClientMsg_ClickedBuff
         * @property {number|null} [buff_internal_index] CDOTAClientMsg_ClickedBuff buff_internal_index
         * @property {number|null} [target_entindex] CDOTAClientMsg_ClickedBuff target_entindex
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ClickedBuff.
         * @exports CDOTAClientMsg_ClickedBuff
         * @classdesc Represents a CDOTAClientMsg_ClickedBuff.
         * @implements ICDOTAClientMsg_ClickedBuff
         * @constructor
         * @param {ICDOTAClientMsg_ClickedBuff=} [properties] Properties to set
         */
        function CDOTAClientMsg_ClickedBuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ClickedBuff buff_internal_index.
         * @member {number} buff_internal_index
         * @memberof CDOTAClientMsg_ClickedBuff
         * @instance
         */
        CDOTAClientMsg_ClickedBuff.prototype.buff_internal_index = 0;
    
        /**
         * CDOTAClientMsg_ClickedBuff target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_ClickedBuff
         * @instance
         */
        CDOTAClientMsg_ClickedBuff.prototype.target_entindex = 0;
    
        /**
         * Creates a new CDOTAClientMsg_ClickedBuff instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {ICDOTAClientMsg_ClickedBuff=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ClickedBuff} CDOTAClientMsg_ClickedBuff instance
         */
        CDOTAClientMsg_ClickedBuff.create = function create(properties) {
            return new CDOTAClientMsg_ClickedBuff(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ClickedBuff message. Does not implicitly {@link CDOTAClientMsg_ClickedBuff.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {ICDOTAClientMsg_ClickedBuff} message CDOTAClientMsg_ClickedBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ClickedBuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buff_internal_index != null && Object.hasOwnProperty.call(message, "buff_internal_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buff_internal_index);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ClickedBuff message, length delimited. Does not implicitly {@link CDOTAClientMsg_ClickedBuff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {ICDOTAClientMsg_ClickedBuff} message CDOTAClientMsg_ClickedBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ClickedBuff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ClickedBuff message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ClickedBuff} CDOTAClientMsg_ClickedBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ClickedBuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ClickedBuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buff_internal_index = reader.int32();
                    break;
                case 2:
                    message.target_entindex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ClickedBuff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ClickedBuff} CDOTAClientMsg_ClickedBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ClickedBuff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ClickedBuff message.
         * @function verify
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ClickedBuff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buff_internal_index != null && message.hasOwnProperty("buff_internal_index"))
                if (!$util.isInteger(message.buff_internal_index))
                    return "buff_internal_index: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ClickedBuff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ClickedBuff} CDOTAClientMsg_ClickedBuff
         */
        CDOTAClientMsg_ClickedBuff.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ClickedBuff)
                return object;
            var message = new $root.CDOTAClientMsg_ClickedBuff();
            if (object.buff_internal_index != null)
                message.buff_internal_index = object.buff_internal_index | 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ClickedBuff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ClickedBuff
         * @static
         * @param {CDOTAClientMsg_ClickedBuff} message CDOTAClientMsg_ClickedBuff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ClickedBuff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buff_internal_index = 0;
                object.target_entindex = 0;
            }
            if (message.buff_internal_index != null && message.hasOwnProperty("buff_internal_index"))
                object.buff_internal_index = message.buff_internal_index;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ClickedBuff to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ClickedBuff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ClickedBuff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ClickedBuff;
    })();
    
    $root.CDOTAClientMsg_HPManaAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_HPManaAlert.
         * @exports ICDOTAClientMsg_HPManaAlert
         * @interface ICDOTAClientMsg_HPManaAlert
         * @property {number|null} [target_entindex] CDOTAClientMsg_HPManaAlert target_entindex
         * @property {boolean|null} [show_raw_values] CDOTAClientMsg_HPManaAlert show_raw_values
         */
    
        /**
         * Constructs a new CDOTAClientMsg_HPManaAlert.
         * @exports CDOTAClientMsg_HPManaAlert
         * @classdesc Represents a CDOTAClientMsg_HPManaAlert.
         * @implements ICDOTAClientMsg_HPManaAlert
         * @constructor
         * @param {ICDOTAClientMsg_HPManaAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_HPManaAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_HPManaAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_HPManaAlert
         * @instance
         */
        CDOTAClientMsg_HPManaAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAClientMsg_HPManaAlert show_raw_values.
         * @member {boolean} show_raw_values
         * @memberof CDOTAClientMsg_HPManaAlert
         * @instance
         */
        CDOTAClientMsg_HPManaAlert.prototype.show_raw_values = false;
    
        /**
         * Creates a new CDOTAClientMsg_HPManaAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {ICDOTAClientMsg_HPManaAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_HPManaAlert} CDOTAClientMsg_HPManaAlert instance
         */
        CDOTAClientMsg_HPManaAlert.create = function create(properties) {
            return new CDOTAClientMsg_HPManaAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_HPManaAlert message. Does not implicitly {@link CDOTAClientMsg_HPManaAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {ICDOTAClientMsg_HPManaAlert} message CDOTAClientMsg_HPManaAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_HPManaAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entindex);
            if (message.show_raw_values != null && Object.hasOwnProperty.call(message, "show_raw_values"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.show_raw_values);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_HPManaAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_HPManaAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {ICDOTAClientMsg_HPManaAlert} message CDOTAClientMsg_HPManaAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_HPManaAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_HPManaAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_HPManaAlert} CDOTAClientMsg_HPManaAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_HPManaAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_HPManaAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entindex = reader.uint32();
                    break;
                case 2:
                    message.show_raw_values = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_HPManaAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_HPManaAlert} CDOTAClientMsg_HPManaAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_HPManaAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_HPManaAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_HPManaAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.show_raw_values != null && message.hasOwnProperty("show_raw_values"))
                if (typeof message.show_raw_values !== "boolean")
                    return "show_raw_values: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_HPManaAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_HPManaAlert} CDOTAClientMsg_HPManaAlert
         */
        CDOTAClientMsg_HPManaAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_HPManaAlert)
                return object;
            var message = new $root.CDOTAClientMsg_HPManaAlert();
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.show_raw_values != null)
                message.show_raw_values = Boolean(object.show_raw_values);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_HPManaAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_HPManaAlert
         * @static
         * @param {CDOTAClientMsg_HPManaAlert} message CDOTAClientMsg_HPManaAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_HPManaAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_entindex = 0;
                object.show_raw_values = false;
            }
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.show_raw_values != null && message.hasOwnProperty("show_raw_values"))
                object.show_raw_values = message.show_raw_values;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_HPManaAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_HPManaAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_HPManaAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_HPManaAlert;
    })();
    
    $root.CDOTAClientMsg_GlyphAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_GlyphAlert.
         * @exports ICDOTAClientMsg_GlyphAlert
         * @interface ICDOTAClientMsg_GlyphAlert
         * @property {boolean|null} [negative] CDOTAClientMsg_GlyphAlert negative
         */
    
        /**
         * Constructs a new CDOTAClientMsg_GlyphAlert.
         * @exports CDOTAClientMsg_GlyphAlert
         * @classdesc Represents a CDOTAClientMsg_GlyphAlert.
         * @implements ICDOTAClientMsg_GlyphAlert
         * @constructor
         * @param {ICDOTAClientMsg_GlyphAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_GlyphAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_GlyphAlert negative.
         * @member {boolean} negative
         * @memberof CDOTAClientMsg_GlyphAlert
         * @instance
         */
        CDOTAClientMsg_GlyphAlert.prototype.negative = false;
    
        /**
         * Creates a new CDOTAClientMsg_GlyphAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {ICDOTAClientMsg_GlyphAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_GlyphAlert} CDOTAClientMsg_GlyphAlert instance
         */
        CDOTAClientMsg_GlyphAlert.create = function create(properties) {
            return new CDOTAClientMsg_GlyphAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_GlyphAlert message. Does not implicitly {@link CDOTAClientMsg_GlyphAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {ICDOTAClientMsg_GlyphAlert} message CDOTAClientMsg_GlyphAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_GlyphAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.negative);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_GlyphAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_GlyphAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {ICDOTAClientMsg_GlyphAlert} message CDOTAClientMsg_GlyphAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_GlyphAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_GlyphAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_GlyphAlert} CDOTAClientMsg_GlyphAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_GlyphAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_GlyphAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.negative = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_GlyphAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_GlyphAlert} CDOTAClientMsg_GlyphAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_GlyphAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_GlyphAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_GlyphAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.negative != null && message.hasOwnProperty("negative"))
                if (typeof message.negative !== "boolean")
                    return "negative: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_GlyphAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_GlyphAlert} CDOTAClientMsg_GlyphAlert
         */
        CDOTAClientMsg_GlyphAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_GlyphAlert)
                return object;
            var message = new $root.CDOTAClientMsg_GlyphAlert();
            if (object.negative != null)
                message.negative = Boolean(object.negative);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_GlyphAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_GlyphAlert
         * @static
         * @param {CDOTAClientMsg_GlyphAlert} message CDOTAClientMsg_GlyphAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_GlyphAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.negative = false;
            if (message.negative != null && message.hasOwnProperty("negative"))
                object.negative = message.negative;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_GlyphAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_GlyphAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_GlyphAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_GlyphAlert;
    })();
    
    $root.CDOTAClientMsg_RadarAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RadarAlert.
         * @exports ICDOTAClientMsg_RadarAlert
         * @interface ICDOTAClientMsg_RadarAlert
         * @property {boolean|null} [negative] CDOTAClientMsg_RadarAlert negative
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RadarAlert.
         * @exports CDOTAClientMsg_RadarAlert
         * @classdesc Represents a CDOTAClientMsg_RadarAlert.
         * @implements ICDOTAClientMsg_RadarAlert
         * @constructor
         * @param {ICDOTAClientMsg_RadarAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_RadarAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_RadarAlert negative.
         * @member {boolean} negative
         * @memberof CDOTAClientMsg_RadarAlert
         * @instance
         */
        CDOTAClientMsg_RadarAlert.prototype.negative = false;
    
        /**
         * Creates a new CDOTAClientMsg_RadarAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {ICDOTAClientMsg_RadarAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RadarAlert} CDOTAClientMsg_RadarAlert instance
         */
        CDOTAClientMsg_RadarAlert.create = function create(properties) {
            return new CDOTAClientMsg_RadarAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RadarAlert message. Does not implicitly {@link CDOTAClientMsg_RadarAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {ICDOTAClientMsg_RadarAlert} message CDOTAClientMsg_RadarAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RadarAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.negative);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RadarAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_RadarAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {ICDOTAClientMsg_RadarAlert} message CDOTAClientMsg_RadarAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RadarAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RadarAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RadarAlert} CDOTAClientMsg_RadarAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RadarAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RadarAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.negative = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RadarAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RadarAlert} CDOTAClientMsg_RadarAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RadarAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RadarAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RadarAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.negative != null && message.hasOwnProperty("negative"))
                if (typeof message.negative !== "boolean")
                    return "negative: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RadarAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RadarAlert} CDOTAClientMsg_RadarAlert
         */
        CDOTAClientMsg_RadarAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RadarAlert)
                return object;
            var message = new $root.CDOTAClientMsg_RadarAlert();
            if (object.negative != null)
                message.negative = Boolean(object.negative);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RadarAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RadarAlert
         * @static
         * @param {CDOTAClientMsg_RadarAlert} message CDOTAClientMsg_RadarAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RadarAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.negative = false;
            if (message.negative != null && message.hasOwnProperty("negative"))
                object.negative = message.negative;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_RadarAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RadarAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RadarAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RadarAlert;
    })();
    
    $root.CDOTAClientMsg_MapLine = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_MapLine.
         * @exports ICDOTAClientMsg_MapLine
         * @interface ICDOTAClientMsg_MapLine
         * @property {ICDOTAMsg_MapLine|null} [mapline] CDOTAClientMsg_MapLine mapline
         */
    
        /**
         * Constructs a new CDOTAClientMsg_MapLine.
         * @exports CDOTAClientMsg_MapLine
         * @classdesc Represents a CDOTAClientMsg_MapLine.
         * @implements ICDOTAClientMsg_MapLine
         * @constructor
         * @param {ICDOTAClientMsg_MapLine=} [properties] Properties to set
         */
        function CDOTAClientMsg_MapLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_MapLine mapline.
         * @member {ICDOTAMsg_MapLine|null|undefined} mapline
         * @memberof CDOTAClientMsg_MapLine
         * @instance
         */
        CDOTAClientMsg_MapLine.prototype.mapline = null;
    
        /**
         * Creates a new CDOTAClientMsg_MapLine instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {ICDOTAClientMsg_MapLine=} [properties] Properties to set
         * @returns {CDOTAClientMsg_MapLine} CDOTAClientMsg_MapLine instance
         */
        CDOTAClientMsg_MapLine.create = function create(properties) {
            return new CDOTAClientMsg_MapLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MapLine message. Does not implicitly {@link CDOTAClientMsg_MapLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {ICDOTAClientMsg_MapLine} message CDOTAClientMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MapLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapline != null && Object.hasOwnProperty.call(message, "mapline"))
                $root.CDOTAMsg_MapLine.encode(message.mapline, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MapLine message, length delimited. Does not implicitly {@link CDOTAClientMsg_MapLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {ICDOTAClientMsg_MapLine} message CDOTAClientMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MapLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_MapLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_MapLine} CDOTAClientMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MapLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_MapLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mapline = $root.CDOTAMsg_MapLine.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_MapLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_MapLine} CDOTAClientMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MapLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_MapLine message.
         * @function verify
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_MapLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapline != null && message.hasOwnProperty("mapline")) {
                var error = $root.CDOTAMsg_MapLine.verify(message.mapline);
                if (error)
                    return "mapline." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_MapLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_MapLine} CDOTAClientMsg_MapLine
         */
        CDOTAClientMsg_MapLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_MapLine)
                return object;
            var message = new $root.CDOTAClientMsg_MapLine();
            if (object.mapline != null) {
                if (typeof object.mapline !== "object")
                    throw TypeError(".CDOTAClientMsg_MapLine.mapline: object expected");
                message.mapline = $root.CDOTAMsg_MapLine.fromObject(object.mapline);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_MapLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_MapLine
         * @static
         * @param {CDOTAClientMsg_MapLine} message CDOTAClientMsg_MapLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_MapLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mapline = null;
            if (message.mapline != null && message.hasOwnProperty("mapline"))
                object.mapline = $root.CDOTAMsg_MapLine.toObject(message.mapline, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_MapLine to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_MapLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_MapLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_MapLine;
    })();
    
    $root.CDOTAClientMsg_AspectRatio = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_AspectRatio.
         * @exports ICDOTAClientMsg_AspectRatio
         * @interface ICDOTAClientMsg_AspectRatio
         * @property {number|null} [ratio] CDOTAClientMsg_AspectRatio ratio
         */
    
        /**
         * Constructs a new CDOTAClientMsg_AspectRatio.
         * @exports CDOTAClientMsg_AspectRatio
         * @classdesc Represents a CDOTAClientMsg_AspectRatio.
         * @implements ICDOTAClientMsg_AspectRatio
         * @constructor
         * @param {ICDOTAClientMsg_AspectRatio=} [properties] Properties to set
         */
        function CDOTAClientMsg_AspectRatio(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_AspectRatio ratio.
         * @member {number} ratio
         * @memberof CDOTAClientMsg_AspectRatio
         * @instance
         */
        CDOTAClientMsg_AspectRatio.prototype.ratio = 0;
    
        /**
         * Creates a new CDOTAClientMsg_AspectRatio instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {ICDOTAClientMsg_AspectRatio=} [properties] Properties to set
         * @returns {CDOTAClientMsg_AspectRatio} CDOTAClientMsg_AspectRatio instance
         */
        CDOTAClientMsg_AspectRatio.create = function create(properties) {
            return new CDOTAClientMsg_AspectRatio(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_AspectRatio message. Does not implicitly {@link CDOTAClientMsg_AspectRatio.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {ICDOTAClientMsg_AspectRatio} message CDOTAClientMsg_AspectRatio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_AspectRatio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.ratio);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_AspectRatio message, length delimited. Does not implicitly {@link CDOTAClientMsg_AspectRatio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {ICDOTAClientMsg_AspectRatio} message CDOTAClientMsg_AspectRatio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_AspectRatio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_AspectRatio message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_AspectRatio} CDOTAClientMsg_AspectRatio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_AspectRatio.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_AspectRatio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ratio = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_AspectRatio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_AspectRatio} CDOTAClientMsg_AspectRatio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_AspectRatio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_AspectRatio message.
         * @function verify
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_AspectRatio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ratio != null && message.hasOwnProperty("ratio"))
                if (typeof message.ratio !== "number")
                    return "ratio: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_AspectRatio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_AspectRatio} CDOTAClientMsg_AspectRatio
         */
        CDOTAClientMsg_AspectRatio.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_AspectRatio)
                return object;
            var message = new $root.CDOTAClientMsg_AspectRatio();
            if (object.ratio != null)
                message.ratio = Number(object.ratio);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_AspectRatio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_AspectRatio
         * @static
         * @param {CDOTAClientMsg_AspectRatio} message CDOTAClientMsg_AspectRatio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_AspectRatio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.ratio = 0;
            if (message.ratio != null && message.hasOwnProperty("ratio"))
                object.ratio = options.json && !isFinite(message.ratio) ? String(message.ratio) : message.ratio;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_AspectRatio to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_AspectRatio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_AspectRatio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_AspectRatio;
    })();
    
    $root.CDOTAClientMsg_UnitsAutoAttackMode = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_UnitsAutoAttackMode.
         * @exports ICDOTAClientMsg_UnitsAutoAttackMode
         * @interface ICDOTAClientMsg_UnitsAutoAttackMode
         * @property {CDOTAClientMsg_UnitsAutoAttackMode.EMode|null} [mode] CDOTAClientMsg_UnitsAutoAttackMode mode
         * @property {CDOTAClientMsg_UnitsAutoAttackMode.EUnitType|null} [unit_type] CDOTAClientMsg_UnitsAutoAttackMode unit_type
         */
    
        /**
         * Constructs a new CDOTAClientMsg_UnitsAutoAttackMode.
         * @exports CDOTAClientMsg_UnitsAutoAttackMode
         * @classdesc Represents a CDOTAClientMsg_UnitsAutoAttackMode.
         * @implements ICDOTAClientMsg_UnitsAutoAttackMode
         * @constructor
         * @param {ICDOTAClientMsg_UnitsAutoAttackMode=} [properties] Properties to set
         */
        function CDOTAClientMsg_UnitsAutoAttackMode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_UnitsAutoAttackMode mode.
         * @member {CDOTAClientMsg_UnitsAutoAttackMode.EMode} mode
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @instance
         */
        CDOTAClientMsg_UnitsAutoAttackMode.prototype.mode = -1;
    
        /**
         * CDOTAClientMsg_UnitsAutoAttackMode unit_type.
         * @member {CDOTAClientMsg_UnitsAutoAttackMode.EUnitType} unit_type
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @instance
         */
        CDOTAClientMsg_UnitsAutoAttackMode.prototype.unit_type = 0;
    
        /**
         * Creates a new CDOTAClientMsg_UnitsAutoAttackMode instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {ICDOTAClientMsg_UnitsAutoAttackMode=} [properties] Properties to set
         * @returns {CDOTAClientMsg_UnitsAutoAttackMode} CDOTAClientMsg_UnitsAutoAttackMode instance
         */
        CDOTAClientMsg_UnitsAutoAttackMode.create = function create(properties) {
            return new CDOTAClientMsg_UnitsAutoAttackMode(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UnitsAutoAttackMode message. Does not implicitly {@link CDOTAClientMsg_UnitsAutoAttackMode.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {ICDOTAClientMsg_UnitsAutoAttackMode} message CDOTAClientMsg_UnitsAutoAttackMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UnitsAutoAttackMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            if (message.unit_type != null && Object.hasOwnProperty.call(message, "unit_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unit_type);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UnitsAutoAttackMode message, length delimited. Does not implicitly {@link CDOTAClientMsg_UnitsAutoAttackMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {ICDOTAClientMsg_UnitsAutoAttackMode} message CDOTAClientMsg_UnitsAutoAttackMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UnitsAutoAttackMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_UnitsAutoAttackMode message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_UnitsAutoAttackMode} CDOTAClientMsg_UnitsAutoAttackMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UnitsAutoAttackMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_UnitsAutoAttackMode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.unit_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_UnitsAutoAttackMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_UnitsAutoAttackMode} CDOTAClientMsg_UnitsAutoAttackMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UnitsAutoAttackMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_UnitsAutoAttackMode message.
         * @function verify
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_UnitsAutoAttackMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.unit_type != null && message.hasOwnProperty("unit_type"))
                switch (message.unit_type) {
                default:
                    return "unit_type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_UnitsAutoAttackMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_UnitsAutoAttackMode} CDOTAClientMsg_UnitsAutoAttackMode
         */
        CDOTAClientMsg_UnitsAutoAttackMode.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_UnitsAutoAttackMode)
                return object;
            var message = new $root.CDOTAClientMsg_UnitsAutoAttackMode();
            switch (object.mode) {
            case "INVALID":
            case -1:
                message.mode = -1;
                break;
            case "NEVER":
            case 0:
                message.mode = 0;
                break;
            case "AFTER_SPELLCAST":
            case 1:
                message.mode = 1;
                break;
            case "ALWAYS":
            case 2:
                message.mode = 2;
                break;
            }
            switch (object.unit_type) {
            case "NORMAL":
            case 0:
                message.unit_type = 0;
                break;
            case "SUMMONED":
            case 1:
                message.unit_type = 1;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_UnitsAutoAttackMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @static
         * @param {CDOTAClientMsg_UnitsAutoAttackMode} message CDOTAClientMsg_UnitsAutoAttackMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_UnitsAutoAttackMode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mode = options.enums === String ? "INVALID" : -1;
                object.unit_type = options.enums === String ? "NORMAL" : 0;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.CDOTAClientMsg_UnitsAutoAttackMode.EMode[message.mode] : message.mode;
            if (message.unit_type != null && message.hasOwnProperty("unit_type"))
                object.unit_type = options.enums === String ? $root.CDOTAClientMsg_UnitsAutoAttackMode.EUnitType[message.unit_type] : message.unit_type;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_UnitsAutoAttackMode to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_UnitsAutoAttackMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_UnitsAutoAttackMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EMode enum.
         * @name CDOTAClientMsg_UnitsAutoAttackMode.EMode
         * @enum {number}
         * @property {number} INVALID=-1 INVALID value
         * @property {number} NEVER=0 NEVER value
         * @property {number} AFTER_SPELLCAST=1 AFTER_SPELLCAST value
         * @property {number} ALWAYS=2 ALWAYS value
         */
        CDOTAClientMsg_UnitsAutoAttackMode.EMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[-1] = "INVALID"] = -1;
            values[valuesById[0] = "NEVER"] = 0;
            values[valuesById[1] = "AFTER_SPELLCAST"] = 1;
            values[valuesById[2] = "ALWAYS"] = 2;
            return values;
        })();
    
        /**
         * EUnitType enum.
         * @name CDOTAClientMsg_UnitsAutoAttackMode.EUnitType
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} SUMMONED=1 SUMMONED value
         */
        CDOTAClientMsg_UnitsAutoAttackMode.EUnitType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "SUMMONED"] = 1;
            return values;
        })();
    
        return CDOTAClientMsg_UnitsAutoAttackMode;
    })();
    
    $root.CDOTAClientMsg_UnitsAutoAttackAfterSpell = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_UnitsAutoAttackAfterSpell.
         * @exports ICDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @interface ICDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @property {boolean|null} [enabled] CDOTAClientMsg_UnitsAutoAttackAfterSpell enabled
         */
    
        /**
         * Constructs a new CDOTAClientMsg_UnitsAutoAttackAfterSpell.
         * @exports CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @classdesc Represents a CDOTAClientMsg_UnitsAutoAttackAfterSpell.
         * @implements ICDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @constructor
         * @param {ICDOTAClientMsg_UnitsAutoAttackAfterSpell=} [properties] Properties to set
         */
        function CDOTAClientMsg_UnitsAutoAttackAfterSpell(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_UnitsAutoAttackAfterSpell enabled.
         * @member {boolean} enabled
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @instance
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.prototype.enabled = false;
    
        /**
         * Creates a new CDOTAClientMsg_UnitsAutoAttackAfterSpell instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {ICDOTAClientMsg_UnitsAutoAttackAfterSpell=} [properties] Properties to set
         * @returns {CDOTAClientMsg_UnitsAutoAttackAfterSpell} CDOTAClientMsg_UnitsAutoAttackAfterSpell instance
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.create = function create(properties) {
            return new CDOTAClientMsg_UnitsAutoAttackAfterSpell(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UnitsAutoAttackAfterSpell message. Does not implicitly {@link CDOTAClientMsg_UnitsAutoAttackAfterSpell.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {ICDOTAClientMsg_UnitsAutoAttackAfterSpell} message CDOTAClientMsg_UnitsAutoAttackAfterSpell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UnitsAutoAttackAfterSpell message, length delimited. Does not implicitly {@link CDOTAClientMsg_UnitsAutoAttackAfterSpell.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {ICDOTAClientMsg_UnitsAutoAttackAfterSpell} message CDOTAClientMsg_UnitsAutoAttackAfterSpell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_UnitsAutoAttackAfterSpell message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_UnitsAutoAttackAfterSpell} CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_UnitsAutoAttackAfterSpell();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_UnitsAutoAttackAfterSpell message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_UnitsAutoAttackAfterSpell} CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_UnitsAutoAttackAfterSpell message.
         * @function verify
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_UnitsAutoAttackAfterSpell message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_UnitsAutoAttackAfterSpell} CDOTAClientMsg_UnitsAutoAttackAfterSpell
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_UnitsAutoAttackAfterSpell)
                return object;
            var message = new $root.CDOTAClientMsg_UnitsAutoAttackAfterSpell();
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_UnitsAutoAttackAfterSpell message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @static
         * @param {CDOTAClientMsg_UnitsAutoAttackAfterSpell} message CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enabled = false;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_UnitsAutoAttackAfterSpell to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_UnitsAutoAttackAfterSpell
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_UnitsAutoAttackAfterSpell.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_UnitsAutoAttackAfterSpell;
    })();
    
    $root.CDOTAClientMsg_TeleportRequiresHalt = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_TeleportRequiresHalt.
         * @exports ICDOTAClientMsg_TeleportRequiresHalt
         * @interface ICDOTAClientMsg_TeleportRequiresHalt
         * @property {boolean|null} [enabled] CDOTAClientMsg_TeleportRequiresHalt enabled
         */
    
        /**
         * Constructs a new CDOTAClientMsg_TeleportRequiresHalt.
         * @exports CDOTAClientMsg_TeleportRequiresHalt
         * @classdesc Represents a CDOTAClientMsg_TeleportRequiresHalt.
         * @implements ICDOTAClientMsg_TeleportRequiresHalt
         * @constructor
         * @param {ICDOTAClientMsg_TeleportRequiresHalt=} [properties] Properties to set
         */
        function CDOTAClientMsg_TeleportRequiresHalt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_TeleportRequiresHalt enabled.
         * @member {boolean} enabled
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @instance
         */
        CDOTAClientMsg_TeleportRequiresHalt.prototype.enabled = false;
    
        /**
         * Creates a new CDOTAClientMsg_TeleportRequiresHalt instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {ICDOTAClientMsg_TeleportRequiresHalt=} [properties] Properties to set
         * @returns {CDOTAClientMsg_TeleportRequiresHalt} CDOTAClientMsg_TeleportRequiresHalt instance
         */
        CDOTAClientMsg_TeleportRequiresHalt.create = function create(properties) {
            return new CDOTAClientMsg_TeleportRequiresHalt(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_TeleportRequiresHalt message. Does not implicitly {@link CDOTAClientMsg_TeleportRequiresHalt.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {ICDOTAClientMsg_TeleportRequiresHalt} message CDOTAClientMsg_TeleportRequiresHalt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_TeleportRequiresHalt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_TeleportRequiresHalt message, length delimited. Does not implicitly {@link CDOTAClientMsg_TeleportRequiresHalt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {ICDOTAClientMsg_TeleportRequiresHalt} message CDOTAClientMsg_TeleportRequiresHalt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_TeleportRequiresHalt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_TeleportRequiresHalt message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_TeleportRequiresHalt} CDOTAClientMsg_TeleportRequiresHalt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_TeleportRequiresHalt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_TeleportRequiresHalt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_TeleportRequiresHalt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_TeleportRequiresHalt} CDOTAClientMsg_TeleportRequiresHalt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_TeleportRequiresHalt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_TeleportRequiresHalt message.
         * @function verify
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_TeleportRequiresHalt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_TeleportRequiresHalt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_TeleportRequiresHalt} CDOTAClientMsg_TeleportRequiresHalt
         */
        CDOTAClientMsg_TeleportRequiresHalt.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_TeleportRequiresHalt)
                return object;
            var message = new $root.CDOTAClientMsg_TeleportRequiresHalt();
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_TeleportRequiresHalt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @static
         * @param {CDOTAClientMsg_TeleportRequiresHalt} message CDOTAClientMsg_TeleportRequiresHalt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_TeleportRequiresHalt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enabled = false;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_TeleportRequiresHalt to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_TeleportRequiresHalt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_TeleportRequiresHalt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_TeleportRequiresHalt;
    })();
    
    $root.CDOTAClientMsg_ChannelRequiresHalt = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ChannelRequiresHalt.
         * @exports ICDOTAClientMsg_ChannelRequiresHalt
         * @interface ICDOTAClientMsg_ChannelRequiresHalt
         * @property {boolean|null} [enabled] CDOTAClientMsg_ChannelRequiresHalt enabled
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ChannelRequiresHalt.
         * @exports CDOTAClientMsg_ChannelRequiresHalt
         * @classdesc Represents a CDOTAClientMsg_ChannelRequiresHalt.
         * @implements ICDOTAClientMsg_ChannelRequiresHalt
         * @constructor
         * @param {ICDOTAClientMsg_ChannelRequiresHalt=} [properties] Properties to set
         */
        function CDOTAClientMsg_ChannelRequiresHalt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ChannelRequiresHalt enabled.
         * @member {boolean} enabled
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @instance
         */
        CDOTAClientMsg_ChannelRequiresHalt.prototype.enabled = false;
    
        /**
         * Creates a new CDOTAClientMsg_ChannelRequiresHalt instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {ICDOTAClientMsg_ChannelRequiresHalt=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ChannelRequiresHalt} CDOTAClientMsg_ChannelRequiresHalt instance
         */
        CDOTAClientMsg_ChannelRequiresHalt.create = function create(properties) {
            return new CDOTAClientMsg_ChannelRequiresHalt(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChannelRequiresHalt message. Does not implicitly {@link CDOTAClientMsg_ChannelRequiresHalt.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {ICDOTAClientMsg_ChannelRequiresHalt} message CDOTAClientMsg_ChannelRequiresHalt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChannelRequiresHalt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChannelRequiresHalt message, length delimited. Does not implicitly {@link CDOTAClientMsg_ChannelRequiresHalt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {ICDOTAClientMsg_ChannelRequiresHalt} message CDOTAClientMsg_ChannelRequiresHalt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChannelRequiresHalt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChannelRequiresHalt message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ChannelRequiresHalt} CDOTAClientMsg_ChannelRequiresHalt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChannelRequiresHalt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ChannelRequiresHalt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChannelRequiresHalt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ChannelRequiresHalt} CDOTAClientMsg_ChannelRequiresHalt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChannelRequiresHalt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ChannelRequiresHalt message.
         * @function verify
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ChannelRequiresHalt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ChannelRequiresHalt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ChannelRequiresHalt} CDOTAClientMsg_ChannelRequiresHalt
         */
        CDOTAClientMsg_ChannelRequiresHalt.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ChannelRequiresHalt)
                return object;
            var message = new $root.CDOTAClientMsg_ChannelRequiresHalt();
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ChannelRequiresHalt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @static
         * @param {CDOTAClientMsg_ChannelRequiresHalt} message CDOTAClientMsg_ChannelRequiresHalt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ChannelRequiresHalt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enabled = false;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ChannelRequiresHalt to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ChannelRequiresHalt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ChannelRequiresHalt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ChannelRequiresHalt;
    })();
    
    $root.CDOTAClientMsg_SearchString = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SearchString.
         * @exports ICDOTAClientMsg_SearchString
         * @interface ICDOTAClientMsg_SearchString
         * @property {string|null} [search] CDOTAClientMsg_SearchString search
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SearchString.
         * @exports CDOTAClientMsg_SearchString
         * @classdesc Represents a CDOTAClientMsg_SearchString.
         * @implements ICDOTAClientMsg_SearchString
         * @constructor
         * @param {ICDOTAClientMsg_SearchString=} [properties] Properties to set
         */
        function CDOTAClientMsg_SearchString(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SearchString search.
         * @member {string} search
         * @memberof CDOTAClientMsg_SearchString
         * @instance
         */
        CDOTAClientMsg_SearchString.prototype.search = "";
    
        /**
         * Creates a new CDOTAClientMsg_SearchString instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {ICDOTAClientMsg_SearchString=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SearchString} CDOTAClientMsg_SearchString instance
         */
        CDOTAClientMsg_SearchString.create = function create(properties) {
            return new CDOTAClientMsg_SearchString(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SearchString message. Does not implicitly {@link CDOTAClientMsg_SearchString.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {ICDOTAClientMsg_SearchString} message CDOTAClientMsg_SearchString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SearchString.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.search != null && Object.hasOwnProperty.call(message, "search"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.search);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SearchString message, length delimited. Does not implicitly {@link CDOTAClientMsg_SearchString.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {ICDOTAClientMsg_SearchString} message CDOTAClientMsg_SearchString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SearchString.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SearchString message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SearchString} CDOTAClientMsg_SearchString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SearchString.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SearchString();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.search = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SearchString message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SearchString} CDOTAClientMsg_SearchString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SearchString.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SearchString message.
         * @function verify
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SearchString.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.search != null && message.hasOwnProperty("search"))
                if (!$util.isString(message.search))
                    return "search: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SearchString message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SearchString} CDOTAClientMsg_SearchString
         */
        CDOTAClientMsg_SearchString.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SearchString)
                return object;
            var message = new $root.CDOTAClientMsg_SearchString();
            if (object.search != null)
                message.search = String(object.search);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SearchString message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SearchString
         * @static
         * @param {CDOTAClientMsg_SearchString} message CDOTAClientMsg_SearchString
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SearchString.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.search = "";
            if (message.search != null && message.hasOwnProperty("search"))
                object.search = message.search;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SearchString to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SearchString
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SearchString.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SearchString;
    })();
    
    $root.CDOTAClientMsg_Pause = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_Pause.
         * @exports ICDOTAClientMsg_Pause
         * @interface ICDOTAClientMsg_Pause
         */
    
        /**
         * Constructs a new CDOTAClientMsg_Pause.
         * @exports CDOTAClientMsg_Pause
         * @classdesc Represents a CDOTAClientMsg_Pause.
         * @implements ICDOTAClientMsg_Pause
         * @constructor
         * @param {ICDOTAClientMsg_Pause=} [properties] Properties to set
         */
        function CDOTAClientMsg_Pause(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAClientMsg_Pause instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {ICDOTAClientMsg_Pause=} [properties] Properties to set
         * @returns {CDOTAClientMsg_Pause} CDOTAClientMsg_Pause instance
         */
        CDOTAClientMsg_Pause.create = function create(properties) {
            return new CDOTAClientMsg_Pause(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_Pause message. Does not implicitly {@link CDOTAClientMsg_Pause.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {ICDOTAClientMsg_Pause} message CDOTAClientMsg_Pause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_Pause.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_Pause message, length delimited. Does not implicitly {@link CDOTAClientMsg_Pause.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {ICDOTAClientMsg_Pause} message CDOTAClientMsg_Pause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_Pause.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_Pause message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_Pause} CDOTAClientMsg_Pause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_Pause.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_Pause();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_Pause message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_Pause} CDOTAClientMsg_Pause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_Pause.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_Pause message.
         * @function verify
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_Pause.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_Pause message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_Pause} CDOTAClientMsg_Pause
         */
        CDOTAClientMsg_Pause.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_Pause)
                return object;
            return new $root.CDOTAClientMsg_Pause();
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_Pause message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_Pause
         * @static
         * @param {CDOTAClientMsg_Pause} message CDOTAClientMsg_Pause
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_Pause.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAClientMsg_Pause to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_Pause
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_Pause.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_Pause;
    })();
    
    $root.CDOTAClientMsg_ShopViewMode = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ShopViewMode.
         * @exports ICDOTAClientMsg_ShopViewMode
         * @interface ICDOTAClientMsg_ShopViewMode
         * @property {number|null} [mode] CDOTAClientMsg_ShopViewMode mode
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ShopViewMode.
         * @exports CDOTAClientMsg_ShopViewMode
         * @classdesc Represents a CDOTAClientMsg_ShopViewMode.
         * @implements ICDOTAClientMsg_ShopViewMode
         * @constructor
         * @param {ICDOTAClientMsg_ShopViewMode=} [properties] Properties to set
         */
        function CDOTAClientMsg_ShopViewMode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ShopViewMode mode.
         * @member {number} mode
         * @memberof CDOTAClientMsg_ShopViewMode
         * @instance
         */
        CDOTAClientMsg_ShopViewMode.prototype.mode = 0;
    
        /**
         * Creates a new CDOTAClientMsg_ShopViewMode instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {ICDOTAClientMsg_ShopViewMode=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ShopViewMode} CDOTAClientMsg_ShopViewMode instance
         */
        CDOTAClientMsg_ShopViewMode.create = function create(properties) {
            return new CDOTAClientMsg_ShopViewMode(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ShopViewMode message. Does not implicitly {@link CDOTAClientMsg_ShopViewMode.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {ICDOTAClientMsg_ShopViewMode} message CDOTAClientMsg_ShopViewMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ShopViewMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.mode);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ShopViewMode message, length delimited. Does not implicitly {@link CDOTAClientMsg_ShopViewMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {ICDOTAClientMsg_ShopViewMode} message CDOTAClientMsg_ShopViewMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ShopViewMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ShopViewMode message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ShopViewMode} CDOTAClientMsg_ShopViewMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ShopViewMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ShopViewMode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ShopViewMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ShopViewMode} CDOTAClientMsg_ShopViewMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ShopViewMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ShopViewMode message.
         * @function verify
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ShopViewMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                if (!$util.isInteger(message.mode))
                    return "mode: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ShopViewMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ShopViewMode} CDOTAClientMsg_ShopViewMode
         */
        CDOTAClientMsg_ShopViewMode.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ShopViewMode)
                return object;
            var message = new $root.CDOTAClientMsg_ShopViewMode();
            if (object.mode != null)
                message.mode = object.mode >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ShopViewMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ShopViewMode
         * @static
         * @param {CDOTAClientMsg_ShopViewMode} message CDOTAClientMsg_ShopViewMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ShopViewMode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mode = 0;
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = message.mode;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ShopViewMode to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ShopViewMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ShopViewMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ShopViewMode;
    })();
    
    $root.CDOTAClientMsg_SetUnitShareFlag = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SetUnitShareFlag.
         * @exports ICDOTAClientMsg_SetUnitShareFlag
         * @interface ICDOTAClientMsg_SetUnitShareFlag
         * @property {number|null} [playerID] CDOTAClientMsg_SetUnitShareFlag playerID
         * @property {number|null} [flag] CDOTAClientMsg_SetUnitShareFlag flag
         * @property {boolean|null} [state] CDOTAClientMsg_SetUnitShareFlag state
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SetUnitShareFlag.
         * @exports CDOTAClientMsg_SetUnitShareFlag
         * @classdesc Represents a CDOTAClientMsg_SetUnitShareFlag.
         * @implements ICDOTAClientMsg_SetUnitShareFlag
         * @constructor
         * @param {ICDOTAClientMsg_SetUnitShareFlag=} [properties] Properties to set
         */
        function CDOTAClientMsg_SetUnitShareFlag(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SetUnitShareFlag playerID.
         * @member {number} playerID
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @instance
         */
        CDOTAClientMsg_SetUnitShareFlag.prototype.playerID = 0;
    
        /**
         * CDOTAClientMsg_SetUnitShareFlag flag.
         * @member {number} flag
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @instance
         */
        CDOTAClientMsg_SetUnitShareFlag.prototype.flag = 0;
    
        /**
         * CDOTAClientMsg_SetUnitShareFlag state.
         * @member {boolean} state
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @instance
         */
        CDOTAClientMsg_SetUnitShareFlag.prototype.state = false;
    
        /**
         * Creates a new CDOTAClientMsg_SetUnitShareFlag instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {ICDOTAClientMsg_SetUnitShareFlag=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SetUnitShareFlag} CDOTAClientMsg_SetUnitShareFlag instance
         */
        CDOTAClientMsg_SetUnitShareFlag.create = function create(properties) {
            return new CDOTAClientMsg_SetUnitShareFlag(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetUnitShareFlag message. Does not implicitly {@link CDOTAClientMsg_SetUnitShareFlag.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {ICDOTAClientMsg_SetUnitShareFlag} message CDOTAClientMsg_SetUnitShareFlag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetUnitShareFlag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && Object.hasOwnProperty.call(message, "playerID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.playerID);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flag);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.state);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetUnitShareFlag message, length delimited. Does not implicitly {@link CDOTAClientMsg_SetUnitShareFlag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {ICDOTAClientMsg_SetUnitShareFlag} message CDOTAClientMsg_SetUnitShareFlag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetUnitShareFlag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetUnitShareFlag message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SetUnitShareFlag} CDOTAClientMsg_SetUnitShareFlag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetUnitShareFlag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SetUnitShareFlag();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.uint32();
                    break;
                case 2:
                    message.flag = reader.uint32();
                    break;
                case 3:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetUnitShareFlag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SetUnitShareFlag} CDOTAClientMsg_SetUnitShareFlag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetUnitShareFlag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SetUnitShareFlag message.
         * @function verify
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SetUnitShareFlag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isInteger(message.playerID))
                    return "playerID: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SetUnitShareFlag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SetUnitShareFlag} CDOTAClientMsg_SetUnitShareFlag
         */
        CDOTAClientMsg_SetUnitShareFlag.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SetUnitShareFlag)
                return object;
            var message = new $root.CDOTAClientMsg_SetUnitShareFlag();
            if (object.playerID != null)
                message.playerID = object.playerID >>> 0;
            if (object.flag != null)
                message.flag = object.flag >>> 0;
            if (object.state != null)
                message.state = Boolean(object.state);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SetUnitShareFlag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @static
         * @param {CDOTAClientMsg_SetUnitShareFlag} message CDOTAClientMsg_SetUnitShareFlag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SetUnitShareFlag.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = 0;
                object.flag = 0;
                object.state = false;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SetUnitShareFlag to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SetUnitShareFlag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SetUnitShareFlag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SetUnitShareFlag;
    })();
    
    $root.CDOTAClientMsg_SwapRequest = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SwapRequest.
         * @exports ICDOTAClientMsg_SwapRequest
         * @interface ICDOTAClientMsg_SwapRequest
         * @property {number|null} [player_id] CDOTAClientMsg_SwapRequest player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SwapRequest.
         * @exports CDOTAClientMsg_SwapRequest
         * @classdesc Represents a CDOTAClientMsg_SwapRequest.
         * @implements ICDOTAClientMsg_SwapRequest
         * @constructor
         * @param {ICDOTAClientMsg_SwapRequest=} [properties] Properties to set
         */
        function CDOTAClientMsg_SwapRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SwapRequest player_id.
         * @member {number} player_id
         * @memberof CDOTAClientMsg_SwapRequest
         * @instance
         */
        CDOTAClientMsg_SwapRequest.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SwapRequest instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {ICDOTAClientMsg_SwapRequest=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SwapRequest} CDOTAClientMsg_SwapRequest instance
         */
        CDOTAClientMsg_SwapRequest.create = function create(properties) {
            return new CDOTAClientMsg_SwapRequest(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SwapRequest message. Does not implicitly {@link CDOTAClientMsg_SwapRequest.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {ICDOTAClientMsg_SwapRequest} message CDOTAClientMsg_SwapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SwapRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SwapRequest message, length delimited. Does not implicitly {@link CDOTAClientMsg_SwapRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {ICDOTAClientMsg_SwapRequest} message CDOTAClientMsg_SwapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SwapRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SwapRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SwapRequest} CDOTAClientMsg_SwapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SwapRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SwapRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SwapRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SwapRequest} CDOTAClientMsg_SwapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SwapRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SwapRequest message.
         * @function verify
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SwapRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SwapRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SwapRequest} CDOTAClientMsg_SwapRequest
         */
        CDOTAClientMsg_SwapRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SwapRequest)
                return object;
            var message = new $root.CDOTAClientMsg_SwapRequest();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SwapRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SwapRequest
         * @static
         * @param {CDOTAClientMsg_SwapRequest} message CDOTAClientMsg_SwapRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SwapRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SwapRequest to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SwapRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SwapRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SwapRequest;
    })();
    
    $root.CDOTAClientMsg_SwapAccept = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SwapAccept.
         * @exports ICDOTAClientMsg_SwapAccept
         * @interface ICDOTAClientMsg_SwapAccept
         * @property {number|null} [player_id] CDOTAClientMsg_SwapAccept player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SwapAccept.
         * @exports CDOTAClientMsg_SwapAccept
         * @classdesc Represents a CDOTAClientMsg_SwapAccept.
         * @implements ICDOTAClientMsg_SwapAccept
         * @constructor
         * @param {ICDOTAClientMsg_SwapAccept=} [properties] Properties to set
         */
        function CDOTAClientMsg_SwapAccept(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SwapAccept player_id.
         * @member {number} player_id
         * @memberof CDOTAClientMsg_SwapAccept
         * @instance
         */
        CDOTAClientMsg_SwapAccept.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SwapAccept instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {ICDOTAClientMsg_SwapAccept=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SwapAccept} CDOTAClientMsg_SwapAccept instance
         */
        CDOTAClientMsg_SwapAccept.create = function create(properties) {
            return new CDOTAClientMsg_SwapAccept(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SwapAccept message. Does not implicitly {@link CDOTAClientMsg_SwapAccept.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {ICDOTAClientMsg_SwapAccept} message CDOTAClientMsg_SwapAccept message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SwapAccept.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SwapAccept message, length delimited. Does not implicitly {@link CDOTAClientMsg_SwapAccept.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {ICDOTAClientMsg_SwapAccept} message CDOTAClientMsg_SwapAccept message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SwapAccept.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SwapAccept message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SwapAccept} CDOTAClientMsg_SwapAccept
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SwapAccept.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SwapAccept();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SwapAccept message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SwapAccept} CDOTAClientMsg_SwapAccept
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SwapAccept.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SwapAccept message.
         * @function verify
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SwapAccept.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SwapAccept message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SwapAccept} CDOTAClientMsg_SwapAccept
         */
        CDOTAClientMsg_SwapAccept.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SwapAccept)
                return object;
            var message = new $root.CDOTAClientMsg_SwapAccept();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SwapAccept message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SwapAccept
         * @static
         * @param {CDOTAClientMsg_SwapAccept} message CDOTAClientMsg_SwapAccept
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SwapAccept.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SwapAccept to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SwapAccept
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SwapAccept.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SwapAccept;
    })();
    
    $root.CDOTAClientMsg_WorldLine = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_WorldLine.
         * @exports ICDOTAClientMsg_WorldLine
         * @interface ICDOTAClientMsg_WorldLine
         * @property {ICDOTAMsg_WorldLine|null} [worldline] CDOTAClientMsg_WorldLine worldline
         */
    
        /**
         * Constructs a new CDOTAClientMsg_WorldLine.
         * @exports CDOTAClientMsg_WorldLine
         * @classdesc Represents a CDOTAClientMsg_WorldLine.
         * @implements ICDOTAClientMsg_WorldLine
         * @constructor
         * @param {ICDOTAClientMsg_WorldLine=} [properties] Properties to set
         */
        function CDOTAClientMsg_WorldLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_WorldLine worldline.
         * @member {ICDOTAMsg_WorldLine|null|undefined} worldline
         * @memberof CDOTAClientMsg_WorldLine
         * @instance
         */
        CDOTAClientMsg_WorldLine.prototype.worldline = null;
    
        /**
         * Creates a new CDOTAClientMsg_WorldLine instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {ICDOTAClientMsg_WorldLine=} [properties] Properties to set
         * @returns {CDOTAClientMsg_WorldLine} CDOTAClientMsg_WorldLine instance
         */
        CDOTAClientMsg_WorldLine.create = function create(properties) {
            return new CDOTAClientMsg_WorldLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_WorldLine message. Does not implicitly {@link CDOTAClientMsg_WorldLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {ICDOTAClientMsg_WorldLine} message CDOTAClientMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_WorldLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldline != null && Object.hasOwnProperty.call(message, "worldline"))
                $root.CDOTAMsg_WorldLine.encode(message.worldline, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_WorldLine message, length delimited. Does not implicitly {@link CDOTAClientMsg_WorldLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {ICDOTAClientMsg_WorldLine} message CDOTAClientMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_WorldLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_WorldLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_WorldLine} CDOTAClientMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_WorldLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_WorldLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldline = $root.CDOTAMsg_WorldLine.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_WorldLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_WorldLine} CDOTAClientMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_WorldLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_WorldLine message.
         * @function verify
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_WorldLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldline != null && message.hasOwnProperty("worldline")) {
                var error = $root.CDOTAMsg_WorldLine.verify(message.worldline);
                if (error)
                    return "worldline." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_WorldLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_WorldLine} CDOTAClientMsg_WorldLine
         */
        CDOTAClientMsg_WorldLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_WorldLine)
                return object;
            var message = new $root.CDOTAClientMsg_WorldLine();
            if (object.worldline != null) {
                if (typeof object.worldline !== "object")
                    throw TypeError(".CDOTAClientMsg_WorldLine.worldline: object expected");
                message.worldline = $root.CDOTAMsg_WorldLine.fromObject(object.worldline);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_WorldLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_WorldLine
         * @static
         * @param {CDOTAClientMsg_WorldLine} message CDOTAClientMsg_WorldLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_WorldLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.worldline = null;
            if (message.worldline != null && message.hasOwnProperty("worldline"))
                object.worldline = $root.CDOTAMsg_WorldLine.toObject(message.worldline, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_WorldLine to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_WorldLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_WorldLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_WorldLine;
    })();
    
    $root.CDOTAClientMsg_RequestGraphUpdate = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RequestGraphUpdate.
         * @exports ICDOTAClientMsg_RequestGraphUpdate
         * @interface ICDOTAClientMsg_RequestGraphUpdate
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RequestGraphUpdate.
         * @exports CDOTAClientMsg_RequestGraphUpdate
         * @classdesc Represents a CDOTAClientMsg_RequestGraphUpdate.
         * @implements ICDOTAClientMsg_RequestGraphUpdate
         * @constructor
         * @param {ICDOTAClientMsg_RequestGraphUpdate=} [properties] Properties to set
         */
        function CDOTAClientMsg_RequestGraphUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAClientMsg_RequestGraphUpdate instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {ICDOTAClientMsg_RequestGraphUpdate=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RequestGraphUpdate} CDOTAClientMsg_RequestGraphUpdate instance
         */
        CDOTAClientMsg_RequestGraphUpdate.create = function create(properties) {
            return new CDOTAClientMsg_RequestGraphUpdate(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RequestGraphUpdate message. Does not implicitly {@link CDOTAClientMsg_RequestGraphUpdate.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {ICDOTAClientMsg_RequestGraphUpdate} message CDOTAClientMsg_RequestGraphUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RequestGraphUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RequestGraphUpdate message, length delimited. Does not implicitly {@link CDOTAClientMsg_RequestGraphUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {ICDOTAClientMsg_RequestGraphUpdate} message CDOTAClientMsg_RequestGraphUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RequestGraphUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RequestGraphUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RequestGraphUpdate} CDOTAClientMsg_RequestGraphUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RequestGraphUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RequestGraphUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RequestGraphUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RequestGraphUpdate} CDOTAClientMsg_RequestGraphUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RequestGraphUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RequestGraphUpdate message.
         * @function verify
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RequestGraphUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RequestGraphUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RequestGraphUpdate} CDOTAClientMsg_RequestGraphUpdate
         */
        CDOTAClientMsg_RequestGraphUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RequestGraphUpdate)
                return object;
            return new $root.CDOTAClientMsg_RequestGraphUpdate();
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RequestGraphUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @static
         * @param {CDOTAClientMsg_RequestGraphUpdate} message CDOTAClientMsg_RequestGraphUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RequestGraphUpdate.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAClientMsg_RequestGraphUpdate to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RequestGraphUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RequestGraphUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RequestGraphUpdate;
    })();
    
    $root.CDOTAClientMsg_ChatWheel = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ChatWheel.
         * @exports ICDOTAClientMsg_ChatWheel
         * @interface ICDOTAClientMsg_ChatWheel
         * @property {number|null} [chat_message_id] CDOTAClientMsg_ChatWheel chat_message_id
         * @property {number|null} [param_hero_id] CDOTAClientMsg_ChatWheel param_hero_id
         * @property {number|null} [emoticon_id] CDOTAClientMsg_ChatWheel emoticon_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ChatWheel.
         * @exports CDOTAClientMsg_ChatWheel
         * @classdesc Represents a CDOTAClientMsg_ChatWheel.
         * @implements ICDOTAClientMsg_ChatWheel
         * @constructor
         * @param {ICDOTAClientMsg_ChatWheel=} [properties] Properties to set
         */
        function CDOTAClientMsg_ChatWheel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ChatWheel chat_message_id.
         * @member {number} chat_message_id
         * @memberof CDOTAClientMsg_ChatWheel
         * @instance
         */
        CDOTAClientMsg_ChatWheel.prototype.chat_message_id = 0;
    
        /**
         * CDOTAClientMsg_ChatWheel param_hero_id.
         * @member {number} param_hero_id
         * @memberof CDOTAClientMsg_ChatWheel
         * @instance
         */
        CDOTAClientMsg_ChatWheel.prototype.param_hero_id = 0;
    
        /**
         * CDOTAClientMsg_ChatWheel emoticon_id.
         * @member {number} emoticon_id
         * @memberof CDOTAClientMsg_ChatWheel
         * @instance
         */
        CDOTAClientMsg_ChatWheel.prototype.emoticon_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_ChatWheel instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {ICDOTAClientMsg_ChatWheel=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ChatWheel} CDOTAClientMsg_ChatWheel instance
         */
        CDOTAClientMsg_ChatWheel.create = function create(properties) {
            return new CDOTAClientMsg_ChatWheel(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChatWheel message. Does not implicitly {@link CDOTAClientMsg_ChatWheel.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {ICDOTAClientMsg_ChatWheel} message CDOTAClientMsg_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChatWheel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chat_message_id != null && Object.hasOwnProperty.call(message, "chat_message_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chat_message_id);
            if (message.param_hero_id != null && Object.hasOwnProperty.call(message, "param_hero_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.param_hero_id);
            if (message.emoticon_id != null && Object.hasOwnProperty.call(message, "emoticon_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.emoticon_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChatWheel message, length delimited. Does not implicitly {@link CDOTAClientMsg_ChatWheel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {ICDOTAClientMsg_ChatWheel} message CDOTAClientMsg_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChatWheel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChatWheel message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ChatWheel} CDOTAClientMsg_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChatWheel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ChatWheel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chat_message_id = reader.uint32();
                    break;
                case 2:
                    message.param_hero_id = reader.uint32();
                    break;
                case 3:
                    message.emoticon_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChatWheel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ChatWheel} CDOTAClientMsg_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChatWheel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ChatWheel message.
         * @function verify
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ChatWheel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                if (!$util.isInteger(message.chat_message_id))
                    return "chat_message_id: integer expected";
            if (message.param_hero_id != null && message.hasOwnProperty("param_hero_id"))
                if (!$util.isInteger(message.param_hero_id))
                    return "param_hero_id: integer expected";
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                if (!$util.isInteger(message.emoticon_id))
                    return "emoticon_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ChatWheel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ChatWheel} CDOTAClientMsg_ChatWheel
         */
        CDOTAClientMsg_ChatWheel.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ChatWheel)
                return object;
            var message = new $root.CDOTAClientMsg_ChatWheel();
            if (object.chat_message_id != null)
                message.chat_message_id = object.chat_message_id >>> 0;
            if (object.param_hero_id != null)
                message.param_hero_id = object.param_hero_id >>> 0;
            if (object.emoticon_id != null)
                message.emoticon_id = object.emoticon_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ChatWheel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ChatWheel
         * @static
         * @param {CDOTAClientMsg_ChatWheel} message CDOTAClientMsg_ChatWheel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ChatWheel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chat_message_id = 0;
                object.param_hero_id = 0;
                object.emoticon_id = 0;
            }
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                object.chat_message_id = message.chat_message_id;
            if (message.param_hero_id != null && message.hasOwnProperty("param_hero_id"))
                object.param_hero_id = message.param_hero_id;
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                object.emoticon_id = message.emoticon_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ChatWheel to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ChatWheel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ChatWheel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ChatWheel;
    })();
    
    $root.CDOTAClientMsg_SendStatPopup = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SendStatPopup.
         * @exports ICDOTAClientMsg_SendStatPopup
         * @interface ICDOTAClientMsg_SendStatPopup
         * @property {ICDOTAMsg_SendStatPopup|null} [statpopup] CDOTAClientMsg_SendStatPopup statpopup
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SendStatPopup.
         * @exports CDOTAClientMsg_SendStatPopup
         * @classdesc Represents a CDOTAClientMsg_SendStatPopup.
         * @implements ICDOTAClientMsg_SendStatPopup
         * @constructor
         * @param {ICDOTAClientMsg_SendStatPopup=} [properties] Properties to set
         */
        function CDOTAClientMsg_SendStatPopup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SendStatPopup statpopup.
         * @member {ICDOTAMsg_SendStatPopup|null|undefined} statpopup
         * @memberof CDOTAClientMsg_SendStatPopup
         * @instance
         */
        CDOTAClientMsg_SendStatPopup.prototype.statpopup = null;
    
        /**
         * Creates a new CDOTAClientMsg_SendStatPopup instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {ICDOTAClientMsg_SendStatPopup=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SendStatPopup} CDOTAClientMsg_SendStatPopup instance
         */
        CDOTAClientMsg_SendStatPopup.create = function create(properties) {
            return new CDOTAClientMsg_SendStatPopup(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SendStatPopup message. Does not implicitly {@link CDOTAClientMsg_SendStatPopup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {ICDOTAClientMsg_SendStatPopup} message CDOTAClientMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SendStatPopup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.statpopup != null && Object.hasOwnProperty.call(message, "statpopup"))
                $root.CDOTAMsg_SendStatPopup.encode(message.statpopup, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SendStatPopup message, length delimited. Does not implicitly {@link CDOTAClientMsg_SendStatPopup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {ICDOTAClientMsg_SendStatPopup} message CDOTAClientMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SendStatPopup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SendStatPopup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SendStatPopup} CDOTAClientMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SendStatPopup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SendStatPopup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.statpopup = $root.CDOTAMsg_SendStatPopup.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SendStatPopup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SendStatPopup} CDOTAClientMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SendStatPopup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SendStatPopup message.
         * @function verify
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SendStatPopup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.statpopup != null && message.hasOwnProperty("statpopup")) {
                var error = $root.CDOTAMsg_SendStatPopup.verify(message.statpopup);
                if (error)
                    return "statpopup." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SendStatPopup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SendStatPopup} CDOTAClientMsg_SendStatPopup
         */
        CDOTAClientMsg_SendStatPopup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SendStatPopup)
                return object;
            var message = new $root.CDOTAClientMsg_SendStatPopup();
            if (object.statpopup != null) {
                if (typeof object.statpopup !== "object")
                    throw TypeError(".CDOTAClientMsg_SendStatPopup.statpopup: object expected");
                message.statpopup = $root.CDOTAMsg_SendStatPopup.fromObject(object.statpopup);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SendStatPopup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SendStatPopup
         * @static
         * @param {CDOTAClientMsg_SendStatPopup} message CDOTAClientMsg_SendStatPopup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SendStatPopup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.statpopup = null;
            if (message.statpopup != null && message.hasOwnProperty("statpopup"))
                object.statpopup = $root.CDOTAMsg_SendStatPopup.toObject(message.statpopup, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SendStatPopup to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SendStatPopup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SendStatPopup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SendStatPopup;
    })();
    
    $root.CDOTAClientMsg_DismissAllStatPopups = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_DismissAllStatPopups.
         * @exports ICDOTAClientMsg_DismissAllStatPopups
         * @interface ICDOTAClientMsg_DismissAllStatPopups
         * @property {ICDOTAMsg_DismissAllStatPopups|null} [dismissallmsg] CDOTAClientMsg_DismissAllStatPopups dismissallmsg
         */
    
        /**
         * Constructs a new CDOTAClientMsg_DismissAllStatPopups.
         * @exports CDOTAClientMsg_DismissAllStatPopups
         * @classdesc Represents a CDOTAClientMsg_DismissAllStatPopups.
         * @implements ICDOTAClientMsg_DismissAllStatPopups
         * @constructor
         * @param {ICDOTAClientMsg_DismissAllStatPopups=} [properties] Properties to set
         */
        function CDOTAClientMsg_DismissAllStatPopups(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_DismissAllStatPopups dismissallmsg.
         * @member {ICDOTAMsg_DismissAllStatPopups|null|undefined} dismissallmsg
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @instance
         */
        CDOTAClientMsg_DismissAllStatPopups.prototype.dismissallmsg = null;
    
        /**
         * Creates a new CDOTAClientMsg_DismissAllStatPopups instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAClientMsg_DismissAllStatPopups=} [properties] Properties to set
         * @returns {CDOTAClientMsg_DismissAllStatPopups} CDOTAClientMsg_DismissAllStatPopups instance
         */
        CDOTAClientMsg_DismissAllStatPopups.create = function create(properties) {
            return new CDOTAClientMsg_DismissAllStatPopups(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_DismissAllStatPopups message. Does not implicitly {@link CDOTAClientMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAClientMsg_DismissAllStatPopups} message CDOTAClientMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_DismissAllStatPopups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dismissallmsg != null && Object.hasOwnProperty.call(message, "dismissallmsg"))
                $root.CDOTAMsg_DismissAllStatPopups.encode(message.dismissallmsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_DismissAllStatPopups message, length delimited. Does not implicitly {@link CDOTAClientMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAClientMsg_DismissAllStatPopups} message CDOTAClientMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_DismissAllStatPopups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_DismissAllStatPopups message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_DismissAllStatPopups} CDOTAClientMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_DismissAllStatPopups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_DismissAllStatPopups();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dismissallmsg = $root.CDOTAMsg_DismissAllStatPopups.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_DismissAllStatPopups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_DismissAllStatPopups} CDOTAClientMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_DismissAllStatPopups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_DismissAllStatPopups message.
         * @function verify
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_DismissAllStatPopups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dismissallmsg != null && message.hasOwnProperty("dismissallmsg")) {
                var error = $root.CDOTAMsg_DismissAllStatPopups.verify(message.dismissallmsg);
                if (error)
                    return "dismissallmsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_DismissAllStatPopups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_DismissAllStatPopups} CDOTAClientMsg_DismissAllStatPopups
         */
        CDOTAClientMsg_DismissAllStatPopups.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_DismissAllStatPopups)
                return object;
            var message = new $root.CDOTAClientMsg_DismissAllStatPopups();
            if (object.dismissallmsg != null) {
                if (typeof object.dismissallmsg !== "object")
                    throw TypeError(".CDOTAClientMsg_DismissAllStatPopups.dismissallmsg: object expected");
                message.dismissallmsg = $root.CDOTAMsg_DismissAllStatPopups.fromObject(object.dismissallmsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_DismissAllStatPopups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @static
         * @param {CDOTAClientMsg_DismissAllStatPopups} message CDOTAClientMsg_DismissAllStatPopups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_DismissAllStatPopups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.dismissallmsg = null;
            if (message.dismissallmsg != null && message.hasOwnProperty("dismissallmsg"))
                object.dismissallmsg = $root.CDOTAMsg_DismissAllStatPopups.toObject(message.dismissallmsg, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_DismissAllStatPopups to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_DismissAllStatPopups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_DismissAllStatPopups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_DismissAllStatPopups;
    })();
    
    $root.CDOTAClientMsg_BeginLastHitChallenge = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_BeginLastHitChallenge.
         * @exports ICDOTAClientMsg_BeginLastHitChallenge
         * @interface ICDOTAClientMsg_BeginLastHitChallenge
         * @property {number|null} [chosen_lane] CDOTAClientMsg_BeginLastHitChallenge chosen_lane
         * @property {boolean|null} [helper_enabled] CDOTAClientMsg_BeginLastHitChallenge helper_enabled
         */
    
        /**
         * Constructs a new CDOTAClientMsg_BeginLastHitChallenge.
         * @exports CDOTAClientMsg_BeginLastHitChallenge
         * @classdesc Represents a CDOTAClientMsg_BeginLastHitChallenge.
         * @implements ICDOTAClientMsg_BeginLastHitChallenge
         * @constructor
         * @param {ICDOTAClientMsg_BeginLastHitChallenge=} [properties] Properties to set
         */
        function CDOTAClientMsg_BeginLastHitChallenge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_BeginLastHitChallenge chosen_lane.
         * @member {number} chosen_lane
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @instance
         */
        CDOTAClientMsg_BeginLastHitChallenge.prototype.chosen_lane = 0;
    
        /**
         * CDOTAClientMsg_BeginLastHitChallenge helper_enabled.
         * @member {boolean} helper_enabled
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @instance
         */
        CDOTAClientMsg_BeginLastHitChallenge.prototype.helper_enabled = false;
    
        /**
         * Creates a new CDOTAClientMsg_BeginLastHitChallenge instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {ICDOTAClientMsg_BeginLastHitChallenge=} [properties] Properties to set
         * @returns {CDOTAClientMsg_BeginLastHitChallenge} CDOTAClientMsg_BeginLastHitChallenge instance
         */
        CDOTAClientMsg_BeginLastHitChallenge.create = function create(properties) {
            return new CDOTAClientMsg_BeginLastHitChallenge(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BeginLastHitChallenge message. Does not implicitly {@link CDOTAClientMsg_BeginLastHitChallenge.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {ICDOTAClientMsg_BeginLastHitChallenge} message CDOTAClientMsg_BeginLastHitChallenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BeginLastHitChallenge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chosen_lane != null && Object.hasOwnProperty.call(message, "chosen_lane"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chosen_lane);
            if (message.helper_enabled != null && Object.hasOwnProperty.call(message, "helper_enabled"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.helper_enabled);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BeginLastHitChallenge message, length delimited. Does not implicitly {@link CDOTAClientMsg_BeginLastHitChallenge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {ICDOTAClientMsg_BeginLastHitChallenge} message CDOTAClientMsg_BeginLastHitChallenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BeginLastHitChallenge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_BeginLastHitChallenge message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_BeginLastHitChallenge} CDOTAClientMsg_BeginLastHitChallenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BeginLastHitChallenge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_BeginLastHitChallenge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chosen_lane = reader.uint32();
                    break;
                case 2:
                    message.helper_enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_BeginLastHitChallenge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_BeginLastHitChallenge} CDOTAClientMsg_BeginLastHitChallenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BeginLastHitChallenge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_BeginLastHitChallenge message.
         * @function verify
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_BeginLastHitChallenge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chosen_lane != null && message.hasOwnProperty("chosen_lane"))
                if (!$util.isInteger(message.chosen_lane))
                    return "chosen_lane: integer expected";
            if (message.helper_enabled != null && message.hasOwnProperty("helper_enabled"))
                if (typeof message.helper_enabled !== "boolean")
                    return "helper_enabled: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_BeginLastHitChallenge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_BeginLastHitChallenge} CDOTAClientMsg_BeginLastHitChallenge
         */
        CDOTAClientMsg_BeginLastHitChallenge.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_BeginLastHitChallenge)
                return object;
            var message = new $root.CDOTAClientMsg_BeginLastHitChallenge();
            if (object.chosen_lane != null)
                message.chosen_lane = object.chosen_lane >>> 0;
            if (object.helper_enabled != null)
                message.helper_enabled = Boolean(object.helper_enabled);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_BeginLastHitChallenge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @static
         * @param {CDOTAClientMsg_BeginLastHitChallenge} message CDOTAClientMsg_BeginLastHitChallenge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_BeginLastHitChallenge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chosen_lane = 0;
                object.helper_enabled = false;
            }
            if (message.chosen_lane != null && message.hasOwnProperty("chosen_lane"))
                object.chosen_lane = message.chosen_lane;
            if (message.helper_enabled != null && message.hasOwnProperty("helper_enabled"))
                object.helper_enabled = message.helper_enabled;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_BeginLastHitChallenge to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_BeginLastHitChallenge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_BeginLastHitChallenge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_BeginLastHitChallenge;
    })();
    
    $root.CDOTAClientMsg_UpdateQuickBuyItem = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_UpdateQuickBuyItem.
         * @exports ICDOTAClientMsg_UpdateQuickBuyItem
         * @interface ICDOTAClientMsg_UpdateQuickBuyItem
         * @property {number|null} [item_ability_id] CDOTAClientMsg_UpdateQuickBuyItem item_ability_id
         * @property {boolean|null} [purchasable] CDOTAClientMsg_UpdateQuickBuyItem purchasable
         */
    
        /**
         * Constructs a new CDOTAClientMsg_UpdateQuickBuyItem.
         * @exports CDOTAClientMsg_UpdateQuickBuyItem
         * @classdesc Represents a CDOTAClientMsg_UpdateQuickBuyItem.
         * @implements ICDOTAClientMsg_UpdateQuickBuyItem
         * @constructor
         * @param {ICDOTAClientMsg_UpdateQuickBuyItem=} [properties] Properties to set
         */
        function CDOTAClientMsg_UpdateQuickBuyItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_UpdateQuickBuyItem item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @instance
         */
        CDOTAClientMsg_UpdateQuickBuyItem.prototype.item_ability_id = -1;
    
        /**
         * CDOTAClientMsg_UpdateQuickBuyItem purchasable.
         * @member {boolean} purchasable
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @instance
         */
        CDOTAClientMsg_UpdateQuickBuyItem.prototype.purchasable = false;
    
        /**
         * Creates a new CDOTAClientMsg_UpdateQuickBuyItem instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {ICDOTAClientMsg_UpdateQuickBuyItem=} [properties] Properties to set
         * @returns {CDOTAClientMsg_UpdateQuickBuyItem} CDOTAClientMsg_UpdateQuickBuyItem instance
         */
        CDOTAClientMsg_UpdateQuickBuyItem.create = function create(properties) {
            return new CDOTAClientMsg_UpdateQuickBuyItem(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UpdateQuickBuyItem message. Does not implicitly {@link CDOTAClientMsg_UpdateQuickBuyItem.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {ICDOTAClientMsg_UpdateQuickBuyItem} message CDOTAClientMsg_UpdateQuickBuyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UpdateQuickBuyItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
            if (message.purchasable != null && Object.hasOwnProperty.call(message, "purchasable"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.purchasable);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UpdateQuickBuyItem message, length delimited. Does not implicitly {@link CDOTAClientMsg_UpdateQuickBuyItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {ICDOTAClientMsg_UpdateQuickBuyItem} message CDOTAClientMsg_UpdateQuickBuyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UpdateQuickBuyItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_UpdateQuickBuyItem message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_UpdateQuickBuyItem} CDOTAClientMsg_UpdateQuickBuyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UpdateQuickBuyItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_UpdateQuickBuyItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_ability_id = reader.int32();
                    break;
                case 2:
                    message.purchasable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_UpdateQuickBuyItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_UpdateQuickBuyItem} CDOTAClientMsg_UpdateQuickBuyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UpdateQuickBuyItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_UpdateQuickBuyItem message.
         * @function verify
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_UpdateQuickBuyItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.purchasable != null && message.hasOwnProperty("purchasable"))
                if (typeof message.purchasable !== "boolean")
                    return "purchasable: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_UpdateQuickBuyItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_UpdateQuickBuyItem} CDOTAClientMsg_UpdateQuickBuyItem
         */
        CDOTAClientMsg_UpdateQuickBuyItem.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_UpdateQuickBuyItem)
                return object;
            var message = new $root.CDOTAClientMsg_UpdateQuickBuyItem();
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            if (object.purchasable != null)
                message.purchasable = Boolean(object.purchasable);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_UpdateQuickBuyItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @static
         * @param {CDOTAClientMsg_UpdateQuickBuyItem} message CDOTAClientMsg_UpdateQuickBuyItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_UpdateQuickBuyItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item_ability_id = -1;
                object.purchasable = false;
            }
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.purchasable != null && message.hasOwnProperty("purchasable"))
                object.purchasable = message.purchasable;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_UpdateQuickBuyItem to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_UpdateQuickBuyItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_UpdateQuickBuyItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_UpdateQuickBuyItem;
    })();
    
    $root.CDOTAClientMsg_UpdateQuickBuy = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_UpdateQuickBuy.
         * @exports ICDOTAClientMsg_UpdateQuickBuy
         * @interface ICDOTAClientMsg_UpdateQuickBuy
         * @property {Array.<ICDOTAClientMsg_UpdateQuickBuyItem>|null} [items] CDOTAClientMsg_UpdateQuickBuy items
         */
    
        /**
         * Constructs a new CDOTAClientMsg_UpdateQuickBuy.
         * @exports CDOTAClientMsg_UpdateQuickBuy
         * @classdesc Represents a CDOTAClientMsg_UpdateQuickBuy.
         * @implements ICDOTAClientMsg_UpdateQuickBuy
         * @constructor
         * @param {ICDOTAClientMsg_UpdateQuickBuy=} [properties] Properties to set
         */
        function CDOTAClientMsg_UpdateQuickBuy(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_UpdateQuickBuy items.
         * @member {Array.<ICDOTAClientMsg_UpdateQuickBuyItem>} items
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @instance
         */
        CDOTAClientMsg_UpdateQuickBuy.prototype.items = $util.emptyArray;
    
        /**
         * Creates a new CDOTAClientMsg_UpdateQuickBuy instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {ICDOTAClientMsg_UpdateQuickBuy=} [properties] Properties to set
         * @returns {CDOTAClientMsg_UpdateQuickBuy} CDOTAClientMsg_UpdateQuickBuy instance
         */
        CDOTAClientMsg_UpdateQuickBuy.create = function create(properties) {
            return new CDOTAClientMsg_UpdateQuickBuy(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UpdateQuickBuy message. Does not implicitly {@link CDOTAClientMsg_UpdateQuickBuy.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {ICDOTAClientMsg_UpdateQuickBuy} message CDOTAClientMsg_UpdateQuickBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UpdateQuickBuy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.CDOTAClientMsg_UpdateQuickBuyItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_UpdateQuickBuy message, length delimited. Does not implicitly {@link CDOTAClientMsg_UpdateQuickBuy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {ICDOTAClientMsg_UpdateQuickBuy} message CDOTAClientMsg_UpdateQuickBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_UpdateQuickBuy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_UpdateQuickBuy message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_UpdateQuickBuy} CDOTAClientMsg_UpdateQuickBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UpdateQuickBuy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_UpdateQuickBuy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.CDOTAClientMsg_UpdateQuickBuyItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_UpdateQuickBuy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_UpdateQuickBuy} CDOTAClientMsg_UpdateQuickBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_UpdateQuickBuy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_UpdateQuickBuy message.
         * @function verify
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_UpdateQuickBuy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.CDOTAClientMsg_UpdateQuickBuyItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_UpdateQuickBuy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_UpdateQuickBuy} CDOTAClientMsg_UpdateQuickBuy
         */
        CDOTAClientMsg_UpdateQuickBuy.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_UpdateQuickBuy)
                return object;
            var message = new $root.CDOTAClientMsg_UpdateQuickBuy();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".CDOTAClientMsg_UpdateQuickBuy.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".CDOTAClientMsg_UpdateQuickBuy.items: object expected");
                    message.items[i] = $root.CDOTAClientMsg_UpdateQuickBuyItem.fromObject(object.items[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_UpdateQuickBuy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @static
         * @param {CDOTAClientMsg_UpdateQuickBuy} message CDOTAClientMsg_UpdateQuickBuy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_UpdateQuickBuy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.CDOTAClientMsg_UpdateQuickBuyItem.toObject(message.items[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_UpdateQuickBuy to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_UpdateQuickBuy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_UpdateQuickBuy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_UpdateQuickBuy;
    })();
    
    $root.CDOTAClientMsg_RecordVote = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RecordVote.
         * @exports ICDOTAClientMsg_RecordVote
         * @interface ICDOTAClientMsg_RecordVote
         * @property {number|null} [choice_index] CDOTAClientMsg_RecordVote choice_index
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RecordVote.
         * @exports CDOTAClientMsg_RecordVote
         * @classdesc Represents a CDOTAClientMsg_RecordVote.
         * @implements ICDOTAClientMsg_RecordVote
         * @constructor
         * @param {ICDOTAClientMsg_RecordVote=} [properties] Properties to set
         */
        function CDOTAClientMsg_RecordVote(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_RecordVote choice_index.
         * @member {number} choice_index
         * @memberof CDOTAClientMsg_RecordVote
         * @instance
         */
        CDOTAClientMsg_RecordVote.prototype.choice_index = 0;
    
        /**
         * Creates a new CDOTAClientMsg_RecordVote instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {ICDOTAClientMsg_RecordVote=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RecordVote} CDOTAClientMsg_RecordVote instance
         */
        CDOTAClientMsg_RecordVote.create = function create(properties) {
            return new CDOTAClientMsg_RecordVote(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RecordVote message. Does not implicitly {@link CDOTAClientMsg_RecordVote.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {ICDOTAClientMsg_RecordVote} message CDOTAClientMsg_RecordVote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RecordVote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.choice_index != null && Object.hasOwnProperty.call(message, "choice_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.choice_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RecordVote message, length delimited. Does not implicitly {@link CDOTAClientMsg_RecordVote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {ICDOTAClientMsg_RecordVote} message CDOTAClientMsg_RecordVote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RecordVote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RecordVote message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RecordVote} CDOTAClientMsg_RecordVote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RecordVote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RecordVote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.choice_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RecordVote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RecordVote} CDOTAClientMsg_RecordVote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RecordVote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RecordVote message.
         * @function verify
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RecordVote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.choice_index != null && message.hasOwnProperty("choice_index"))
                if (!$util.isInteger(message.choice_index))
                    return "choice_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RecordVote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RecordVote} CDOTAClientMsg_RecordVote
         */
        CDOTAClientMsg_RecordVote.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RecordVote)
                return object;
            var message = new $root.CDOTAClientMsg_RecordVote();
            if (object.choice_index != null)
                message.choice_index = object.choice_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RecordVote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RecordVote
         * @static
         * @param {CDOTAClientMsg_RecordVote} message CDOTAClientMsg_RecordVote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RecordVote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.choice_index = 0;
            if (message.choice_index != null && message.hasOwnProperty("choice_index"))
                object.choice_index = message.choice_index;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_RecordVote to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RecordVote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RecordVote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RecordVote;
    })();
    
    $root.CDOTAClientMsg_WillPurchaseAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_WillPurchaseAlert.
         * @exports ICDOTAClientMsg_WillPurchaseAlert
         * @interface ICDOTAClientMsg_WillPurchaseAlert
         * @property {number|null} [item_ability_id] CDOTAClientMsg_WillPurchaseAlert item_ability_id
         * @property {number|null} [gold_remaining] CDOTAClientMsg_WillPurchaseAlert gold_remaining
         * @property {number|null} [suggestion_player_id] CDOTAClientMsg_WillPurchaseAlert suggestion_player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_WillPurchaseAlert.
         * @exports CDOTAClientMsg_WillPurchaseAlert
         * @classdesc Represents a CDOTAClientMsg_WillPurchaseAlert.
         * @implements ICDOTAClientMsg_WillPurchaseAlert
         * @constructor
         * @param {ICDOTAClientMsg_WillPurchaseAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_WillPurchaseAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_WillPurchaseAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAClientMsg_WillPurchaseAlert.prototype.item_ability_id = 0;
    
        /**
         * CDOTAClientMsg_WillPurchaseAlert gold_remaining.
         * @member {number} gold_remaining
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAClientMsg_WillPurchaseAlert.prototype.gold_remaining = 0;
    
        /**
         * CDOTAClientMsg_WillPurchaseAlert suggestion_player_id.
         * @member {number} suggestion_player_id
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @instance
         */
        CDOTAClientMsg_WillPurchaseAlert.prototype.suggestion_player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_WillPurchaseAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {ICDOTAClientMsg_WillPurchaseAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_WillPurchaseAlert} CDOTAClientMsg_WillPurchaseAlert instance
         */
        CDOTAClientMsg_WillPurchaseAlert.create = function create(properties) {
            return new CDOTAClientMsg_WillPurchaseAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_WillPurchaseAlert message. Does not implicitly {@link CDOTAClientMsg_WillPurchaseAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {ICDOTAClientMsg_WillPurchaseAlert} message CDOTAClientMsg_WillPurchaseAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_WillPurchaseAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
            if (message.gold_remaining != null && Object.hasOwnProperty.call(message, "gold_remaining"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gold_remaining);
            if (message.suggestion_player_id != null && Object.hasOwnProperty.call(message, "suggestion_player_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.suggestion_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_WillPurchaseAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_WillPurchaseAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {ICDOTAClientMsg_WillPurchaseAlert} message CDOTAClientMsg_WillPurchaseAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_WillPurchaseAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_WillPurchaseAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_WillPurchaseAlert} CDOTAClientMsg_WillPurchaseAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_WillPurchaseAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_WillPurchaseAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_ability_id = reader.int32();
                    break;
                case 2:
                    message.gold_remaining = reader.uint32();
                    break;
                case 3:
                    message.suggestion_player_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_WillPurchaseAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_WillPurchaseAlert} CDOTAClientMsg_WillPurchaseAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_WillPurchaseAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_WillPurchaseAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_WillPurchaseAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.gold_remaining != null && message.hasOwnProperty("gold_remaining"))
                if (!$util.isInteger(message.gold_remaining))
                    return "gold_remaining: integer expected";
            if (message.suggestion_player_id != null && message.hasOwnProperty("suggestion_player_id"))
                if (!$util.isInteger(message.suggestion_player_id))
                    return "suggestion_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_WillPurchaseAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_WillPurchaseAlert} CDOTAClientMsg_WillPurchaseAlert
         */
        CDOTAClientMsg_WillPurchaseAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_WillPurchaseAlert)
                return object;
            var message = new $root.CDOTAClientMsg_WillPurchaseAlert();
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            if (object.gold_remaining != null)
                message.gold_remaining = object.gold_remaining >>> 0;
            if (object.suggestion_player_id != null)
                message.suggestion_player_id = object.suggestion_player_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_WillPurchaseAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @static
         * @param {CDOTAClientMsg_WillPurchaseAlert} message CDOTAClientMsg_WillPurchaseAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_WillPurchaseAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item_ability_id = 0;
                object.gold_remaining = 0;
                object.suggestion_player_id = 0;
            }
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.gold_remaining != null && message.hasOwnProperty("gold_remaining"))
                object.gold_remaining = message.gold_remaining;
            if (message.suggestion_player_id != null && message.hasOwnProperty("suggestion_player_id"))
                object.suggestion_player_id = message.suggestion_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_WillPurchaseAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_WillPurchaseAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_WillPurchaseAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_WillPurchaseAlert;
    })();
    
    $root.CDOTAClientMsg_BuyBackStateAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_BuyBackStateAlert.
         * @exports ICDOTAClientMsg_BuyBackStateAlert
         * @interface ICDOTAClientMsg_BuyBackStateAlert
         */
    
        /**
         * Constructs a new CDOTAClientMsg_BuyBackStateAlert.
         * @exports CDOTAClientMsg_BuyBackStateAlert
         * @classdesc Represents a CDOTAClientMsg_BuyBackStateAlert.
         * @implements ICDOTAClientMsg_BuyBackStateAlert
         * @constructor
         * @param {ICDOTAClientMsg_BuyBackStateAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_BuyBackStateAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAClientMsg_BuyBackStateAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {ICDOTAClientMsg_BuyBackStateAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_BuyBackStateAlert} CDOTAClientMsg_BuyBackStateAlert instance
         */
        CDOTAClientMsg_BuyBackStateAlert.create = function create(properties) {
            return new CDOTAClientMsg_BuyBackStateAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BuyBackStateAlert message. Does not implicitly {@link CDOTAClientMsg_BuyBackStateAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {ICDOTAClientMsg_BuyBackStateAlert} message CDOTAClientMsg_BuyBackStateAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BuyBackStateAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BuyBackStateAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_BuyBackStateAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {ICDOTAClientMsg_BuyBackStateAlert} message CDOTAClientMsg_BuyBackStateAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BuyBackStateAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_BuyBackStateAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_BuyBackStateAlert} CDOTAClientMsg_BuyBackStateAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BuyBackStateAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_BuyBackStateAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_BuyBackStateAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_BuyBackStateAlert} CDOTAClientMsg_BuyBackStateAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BuyBackStateAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_BuyBackStateAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_BuyBackStateAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_BuyBackStateAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_BuyBackStateAlert} CDOTAClientMsg_BuyBackStateAlert
         */
        CDOTAClientMsg_BuyBackStateAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_BuyBackStateAlert)
                return object;
            return new $root.CDOTAClientMsg_BuyBackStateAlert();
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_BuyBackStateAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @static
         * @param {CDOTAClientMsg_BuyBackStateAlert} message CDOTAClientMsg_BuyBackStateAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_BuyBackStateAlert.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAClientMsg_BuyBackStateAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_BuyBackStateAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_BuyBackStateAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_BuyBackStateAlert;
    })();
    
    $root.CDOTAClientMsg_QuickBuyAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_QuickBuyAlert.
         * @exports ICDOTAClientMsg_QuickBuyAlert
         * @interface ICDOTAClientMsg_QuickBuyAlert
         * @property {number|null} [item_ability_id] CDOTAClientMsg_QuickBuyAlert item_ability_id
         * @property {number|null} [gold_cost] CDOTAClientMsg_QuickBuyAlert gold_cost
         * @property {number|null} [item_cooldown_seconds] CDOTAClientMsg_QuickBuyAlert item_cooldown_seconds
         * @property {boolean|null} [show_buyback] CDOTAClientMsg_QuickBuyAlert show_buyback
         */
    
        /**
         * Constructs a new CDOTAClientMsg_QuickBuyAlert.
         * @exports CDOTAClientMsg_QuickBuyAlert
         * @classdesc Represents a CDOTAClientMsg_QuickBuyAlert.
         * @implements ICDOTAClientMsg_QuickBuyAlert
         * @constructor
         * @param {ICDOTAClientMsg_QuickBuyAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_QuickBuyAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_QuickBuyAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @instance
         */
        CDOTAClientMsg_QuickBuyAlert.prototype.item_ability_id = 0;
    
        /**
         * CDOTAClientMsg_QuickBuyAlert gold_cost.
         * @member {number} gold_cost
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @instance
         */
        CDOTAClientMsg_QuickBuyAlert.prototype.gold_cost = 0;
    
        /**
         * CDOTAClientMsg_QuickBuyAlert item_cooldown_seconds.
         * @member {number} item_cooldown_seconds
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @instance
         */
        CDOTAClientMsg_QuickBuyAlert.prototype.item_cooldown_seconds = 0;
    
        /**
         * CDOTAClientMsg_QuickBuyAlert show_buyback.
         * @member {boolean} show_buyback
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @instance
         */
        CDOTAClientMsg_QuickBuyAlert.prototype.show_buyback = false;
    
        /**
         * Creates a new CDOTAClientMsg_QuickBuyAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {ICDOTAClientMsg_QuickBuyAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_QuickBuyAlert} CDOTAClientMsg_QuickBuyAlert instance
         */
        CDOTAClientMsg_QuickBuyAlert.create = function create(properties) {
            return new CDOTAClientMsg_QuickBuyAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_QuickBuyAlert message. Does not implicitly {@link CDOTAClientMsg_QuickBuyAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {ICDOTAClientMsg_QuickBuyAlert} message CDOTAClientMsg_QuickBuyAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_QuickBuyAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item_ability_id);
            if (message.gold_cost != null && Object.hasOwnProperty.call(message, "gold_cost"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gold_cost);
            if (message.item_cooldown_seconds != null && Object.hasOwnProperty.call(message, "item_cooldown_seconds"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.item_cooldown_seconds);
            if (message.show_buyback != null && Object.hasOwnProperty.call(message, "show_buyback"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.show_buyback);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_QuickBuyAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_QuickBuyAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {ICDOTAClientMsg_QuickBuyAlert} message CDOTAClientMsg_QuickBuyAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_QuickBuyAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_QuickBuyAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_QuickBuyAlert} CDOTAClientMsg_QuickBuyAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_QuickBuyAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_QuickBuyAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item_ability_id = reader.int32();
                    break;
                case 2:
                    message.gold_cost = reader.int32();
                    break;
                case 3:
                    message.item_cooldown_seconds = reader.int32();
                    break;
                case 4:
                    message.show_buyback = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_QuickBuyAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_QuickBuyAlert} CDOTAClientMsg_QuickBuyAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_QuickBuyAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_QuickBuyAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_QuickBuyAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.gold_cost != null && message.hasOwnProperty("gold_cost"))
                if (!$util.isInteger(message.gold_cost))
                    return "gold_cost: integer expected";
            if (message.item_cooldown_seconds != null && message.hasOwnProperty("item_cooldown_seconds"))
                if (!$util.isInteger(message.item_cooldown_seconds))
                    return "item_cooldown_seconds: integer expected";
            if (message.show_buyback != null && message.hasOwnProperty("show_buyback"))
                if (typeof message.show_buyback !== "boolean")
                    return "show_buyback: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_QuickBuyAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_QuickBuyAlert} CDOTAClientMsg_QuickBuyAlert
         */
        CDOTAClientMsg_QuickBuyAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_QuickBuyAlert)
                return object;
            var message = new $root.CDOTAClientMsg_QuickBuyAlert();
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            if (object.gold_cost != null)
                message.gold_cost = object.gold_cost | 0;
            if (object.item_cooldown_seconds != null)
                message.item_cooldown_seconds = object.item_cooldown_seconds | 0;
            if (object.show_buyback != null)
                message.show_buyback = Boolean(object.show_buyback);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_QuickBuyAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @static
         * @param {CDOTAClientMsg_QuickBuyAlert} message CDOTAClientMsg_QuickBuyAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_QuickBuyAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item_ability_id = 0;
                object.gold_cost = 0;
                object.item_cooldown_seconds = 0;
                object.show_buyback = false;
            }
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.gold_cost != null && message.hasOwnProperty("gold_cost"))
                object.gold_cost = message.gold_cost;
            if (message.item_cooldown_seconds != null && message.hasOwnProperty("item_cooldown_seconds"))
                object.item_cooldown_seconds = message.item_cooldown_seconds;
            if (message.show_buyback != null && message.hasOwnProperty("show_buyback"))
                object.show_buyback = message.show_buyback;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_QuickBuyAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_QuickBuyAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_QuickBuyAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_QuickBuyAlert;
    })();
    
    $root.CDOTAClientMsg_PlayerShowCase = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_PlayerShowCase.
         * @exports ICDOTAClientMsg_PlayerShowCase
         * @interface ICDOTAClientMsg_PlayerShowCase
         * @property {boolean|null} [showcase] CDOTAClientMsg_PlayerShowCase showcase
         */
    
        /**
         * Constructs a new CDOTAClientMsg_PlayerShowCase.
         * @exports CDOTAClientMsg_PlayerShowCase
         * @classdesc Represents a CDOTAClientMsg_PlayerShowCase.
         * @implements ICDOTAClientMsg_PlayerShowCase
         * @constructor
         * @param {ICDOTAClientMsg_PlayerShowCase=} [properties] Properties to set
         */
        function CDOTAClientMsg_PlayerShowCase(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_PlayerShowCase showcase.
         * @member {boolean} showcase
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @instance
         */
        CDOTAClientMsg_PlayerShowCase.prototype.showcase = false;
    
        /**
         * Creates a new CDOTAClientMsg_PlayerShowCase instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {ICDOTAClientMsg_PlayerShowCase=} [properties] Properties to set
         * @returns {CDOTAClientMsg_PlayerShowCase} CDOTAClientMsg_PlayerShowCase instance
         */
        CDOTAClientMsg_PlayerShowCase.create = function create(properties) {
            return new CDOTAClientMsg_PlayerShowCase(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PlayerShowCase message. Does not implicitly {@link CDOTAClientMsg_PlayerShowCase.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {ICDOTAClientMsg_PlayerShowCase} message CDOTAClientMsg_PlayerShowCase message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PlayerShowCase.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.showcase != null && Object.hasOwnProperty.call(message, "showcase"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.showcase);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PlayerShowCase message, length delimited. Does not implicitly {@link CDOTAClientMsg_PlayerShowCase.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {ICDOTAClientMsg_PlayerShowCase} message CDOTAClientMsg_PlayerShowCase message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PlayerShowCase.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_PlayerShowCase message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_PlayerShowCase} CDOTAClientMsg_PlayerShowCase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PlayerShowCase.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_PlayerShowCase();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.showcase = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_PlayerShowCase message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_PlayerShowCase} CDOTAClientMsg_PlayerShowCase
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PlayerShowCase.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_PlayerShowCase message.
         * @function verify
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_PlayerShowCase.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.showcase != null && message.hasOwnProperty("showcase"))
                if (typeof message.showcase !== "boolean")
                    return "showcase: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_PlayerShowCase message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_PlayerShowCase} CDOTAClientMsg_PlayerShowCase
         */
        CDOTAClientMsg_PlayerShowCase.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_PlayerShowCase)
                return object;
            var message = new $root.CDOTAClientMsg_PlayerShowCase();
            if (object.showcase != null)
                message.showcase = Boolean(object.showcase);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_PlayerShowCase message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @static
         * @param {CDOTAClientMsg_PlayerShowCase} message CDOTAClientMsg_PlayerShowCase
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_PlayerShowCase.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.showcase = false;
            if (message.showcase != null && message.hasOwnProperty("showcase"))
                object.showcase = message.showcase;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_PlayerShowCase to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_PlayerShowCase
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_PlayerShowCase.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_PlayerShowCase;
    })();
    
    $root.CDOTAClientMsg_CameraZoomAmount = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_CameraZoomAmount.
         * @exports ICDOTAClientMsg_CameraZoomAmount
         * @interface ICDOTAClientMsg_CameraZoomAmount
         * @property {number|null} [zoom_amount] CDOTAClientMsg_CameraZoomAmount zoom_amount
         */
    
        /**
         * Constructs a new CDOTAClientMsg_CameraZoomAmount.
         * @exports CDOTAClientMsg_CameraZoomAmount
         * @classdesc Represents a CDOTAClientMsg_CameraZoomAmount.
         * @implements ICDOTAClientMsg_CameraZoomAmount
         * @constructor
         * @param {ICDOTAClientMsg_CameraZoomAmount=} [properties] Properties to set
         */
        function CDOTAClientMsg_CameraZoomAmount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_CameraZoomAmount zoom_amount.
         * @member {number} zoom_amount
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @instance
         */
        CDOTAClientMsg_CameraZoomAmount.prototype.zoom_amount = 0;
    
        /**
         * Creates a new CDOTAClientMsg_CameraZoomAmount instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {ICDOTAClientMsg_CameraZoomAmount=} [properties] Properties to set
         * @returns {CDOTAClientMsg_CameraZoomAmount} CDOTAClientMsg_CameraZoomAmount instance
         */
        CDOTAClientMsg_CameraZoomAmount.create = function create(properties) {
            return new CDOTAClientMsg_CameraZoomAmount(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_CameraZoomAmount message. Does not implicitly {@link CDOTAClientMsg_CameraZoomAmount.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {ICDOTAClientMsg_CameraZoomAmount} message CDOTAClientMsg_CameraZoomAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_CameraZoomAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.zoom_amount != null && Object.hasOwnProperty.call(message, "zoom_amount"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.zoom_amount);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_CameraZoomAmount message, length delimited. Does not implicitly {@link CDOTAClientMsg_CameraZoomAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {ICDOTAClientMsg_CameraZoomAmount} message CDOTAClientMsg_CameraZoomAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_CameraZoomAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_CameraZoomAmount message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_CameraZoomAmount} CDOTAClientMsg_CameraZoomAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_CameraZoomAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_CameraZoomAmount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.zoom_amount = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_CameraZoomAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_CameraZoomAmount} CDOTAClientMsg_CameraZoomAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_CameraZoomAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_CameraZoomAmount message.
         * @function verify
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_CameraZoomAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.zoom_amount != null && message.hasOwnProperty("zoom_amount"))
                if (typeof message.zoom_amount !== "number")
                    return "zoom_amount: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_CameraZoomAmount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_CameraZoomAmount} CDOTAClientMsg_CameraZoomAmount
         */
        CDOTAClientMsg_CameraZoomAmount.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_CameraZoomAmount)
                return object;
            var message = new $root.CDOTAClientMsg_CameraZoomAmount();
            if (object.zoom_amount != null)
                message.zoom_amount = Number(object.zoom_amount);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_CameraZoomAmount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @static
         * @param {CDOTAClientMsg_CameraZoomAmount} message CDOTAClientMsg_CameraZoomAmount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_CameraZoomAmount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.zoom_amount = 0;
            if (message.zoom_amount != null && message.hasOwnProperty("zoom_amount"))
                object.zoom_amount = options.json && !isFinite(message.zoom_amount) ? String(message.zoom_amount) : message.zoom_amount;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_CameraZoomAmount to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_CameraZoomAmount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_CameraZoomAmount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_CameraZoomAmount;
    })();
    
    $root.CDOTAClientMsg_BroadcasterUsingCameraman = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_BroadcasterUsingCameraman.
         * @exports ICDOTAClientMsg_BroadcasterUsingCameraman
         * @interface ICDOTAClientMsg_BroadcasterUsingCameraman
         * @property {boolean|null} [cameraman] CDOTAClientMsg_BroadcasterUsingCameraman cameraman
         */
    
        /**
         * Constructs a new CDOTAClientMsg_BroadcasterUsingCameraman.
         * @exports CDOTAClientMsg_BroadcasterUsingCameraman
         * @classdesc Represents a CDOTAClientMsg_BroadcasterUsingCameraman.
         * @implements ICDOTAClientMsg_BroadcasterUsingCameraman
         * @constructor
         * @param {ICDOTAClientMsg_BroadcasterUsingCameraman=} [properties] Properties to set
         */
        function CDOTAClientMsg_BroadcasterUsingCameraman(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_BroadcasterUsingCameraman cameraman.
         * @member {boolean} cameraman
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @instance
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.prototype.cameraman = false;
    
        /**
         * Creates a new CDOTAClientMsg_BroadcasterUsingCameraman instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {ICDOTAClientMsg_BroadcasterUsingCameraman=} [properties] Properties to set
         * @returns {CDOTAClientMsg_BroadcasterUsingCameraman} CDOTAClientMsg_BroadcasterUsingCameraman instance
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.create = function create(properties) {
            return new CDOTAClientMsg_BroadcasterUsingCameraman(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BroadcasterUsingCameraman message. Does not implicitly {@link CDOTAClientMsg_BroadcasterUsingCameraman.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {ICDOTAClientMsg_BroadcasterUsingCameraman} message CDOTAClientMsg_BroadcasterUsingCameraman message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cameraman != null && Object.hasOwnProperty.call(message, "cameraman"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.cameraman);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BroadcasterUsingCameraman message, length delimited. Does not implicitly {@link CDOTAClientMsg_BroadcasterUsingCameraman.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {ICDOTAClientMsg_BroadcasterUsingCameraman} message CDOTAClientMsg_BroadcasterUsingCameraman message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_BroadcasterUsingCameraman message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_BroadcasterUsingCameraman} CDOTAClientMsg_BroadcasterUsingCameraman
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_BroadcasterUsingCameraman();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cameraman = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_BroadcasterUsingCameraman message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_BroadcasterUsingCameraman} CDOTAClientMsg_BroadcasterUsingCameraman
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_BroadcasterUsingCameraman message.
         * @function verify
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cameraman != null && message.hasOwnProperty("cameraman"))
                if (typeof message.cameraman !== "boolean")
                    return "cameraman: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_BroadcasterUsingCameraman message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_BroadcasterUsingCameraman} CDOTAClientMsg_BroadcasterUsingCameraman
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_BroadcasterUsingCameraman)
                return object;
            var message = new $root.CDOTAClientMsg_BroadcasterUsingCameraman();
            if (object.cameraman != null)
                message.cameraman = Boolean(object.cameraman);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_BroadcasterUsingCameraman message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @static
         * @param {CDOTAClientMsg_BroadcasterUsingCameraman} message CDOTAClientMsg_BroadcasterUsingCameraman
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cameraman = false;
            if (message.cameraman != null && message.hasOwnProperty("cameraman"))
                object.cameraman = message.cameraman;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_BroadcasterUsingCameraman to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_BroadcasterUsingCameraman
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_BroadcasterUsingCameraman.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_BroadcasterUsingCameraman;
    })();
    
    $root.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.
         * @exports ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @interface ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @property {boolean|null} [enabled] CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator enabled
         */
    
        /**
         * Constructs a new CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.
         * @exports CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @classdesc Represents a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.
         * @implements ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @constructor
         * @param {ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator=} [properties] Properties to set
         */
        function CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator enabled.
         * @member {boolean} enabled
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @instance
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.prototype.enabled = false;
    
        /**
         * Creates a new CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator=} [properties] Properties to set
         * @returns {CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator instance
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.create = function create(properties) {
            return new CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message. Does not implicitly {@link CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} message CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message, length delimited. Does not implicitly {@link CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {ICDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} message CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message.
         * @function verify
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
                return object;
            var message = new $root.CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator();
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @static
         * @param {CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator} message CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enabled = false;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator;
    })();
    
    $root.CAdditionalEquipSlotClientMsg = (function() {
    
        /**
         * Properties of a CAdditionalEquipSlotClientMsg.
         * @exports ICAdditionalEquipSlotClientMsg
         * @interface ICAdditionalEquipSlotClientMsg
         * @property {number|null} [class_id] CAdditionalEquipSlotClientMsg class_id
         * @property {number|null} [slot_id] CAdditionalEquipSlotClientMsg slot_id
         * @property {number|null} [def_index] CAdditionalEquipSlotClientMsg def_index
         */
    
        /**
         * Constructs a new CAdditionalEquipSlotClientMsg.
         * @exports CAdditionalEquipSlotClientMsg
         * @classdesc Represents a CAdditionalEquipSlotClientMsg.
         * @implements ICAdditionalEquipSlotClientMsg
         * @constructor
         * @param {ICAdditionalEquipSlotClientMsg=} [properties] Properties to set
         */
        function CAdditionalEquipSlotClientMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CAdditionalEquipSlotClientMsg class_id.
         * @member {number} class_id
         * @memberof CAdditionalEquipSlotClientMsg
         * @instance
         */
        CAdditionalEquipSlotClientMsg.prototype.class_id = 0;
    
        /**
         * CAdditionalEquipSlotClientMsg slot_id.
         * @member {number} slot_id
         * @memberof CAdditionalEquipSlotClientMsg
         * @instance
         */
        CAdditionalEquipSlotClientMsg.prototype.slot_id = 0;
    
        /**
         * CAdditionalEquipSlotClientMsg def_index.
         * @member {number} def_index
         * @memberof CAdditionalEquipSlotClientMsg
         * @instance
         */
        CAdditionalEquipSlotClientMsg.prototype.def_index = 0;
    
        /**
         * Creates a new CAdditionalEquipSlotClientMsg instance using the specified properties.
         * @function create
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {ICAdditionalEquipSlotClientMsg=} [properties] Properties to set
         * @returns {CAdditionalEquipSlotClientMsg} CAdditionalEquipSlotClientMsg instance
         */
        CAdditionalEquipSlotClientMsg.create = function create(properties) {
            return new CAdditionalEquipSlotClientMsg(properties);
        };
    
        /**
         * Encodes the specified CAdditionalEquipSlotClientMsg message. Does not implicitly {@link CAdditionalEquipSlotClientMsg.verify|verify} messages.
         * @function encode
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {ICAdditionalEquipSlotClientMsg} message CAdditionalEquipSlotClientMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CAdditionalEquipSlotClientMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.class_id != null && Object.hasOwnProperty.call(message, "class_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.class_id);
            if (message.slot_id != null && Object.hasOwnProperty.call(message, "slot_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.slot_id);
            if (message.def_index != null && Object.hasOwnProperty.call(message, "def_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.def_index);
            return writer;
        };
    
        /**
         * Encodes the specified CAdditionalEquipSlotClientMsg message, length delimited. Does not implicitly {@link CAdditionalEquipSlotClientMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {ICAdditionalEquipSlotClientMsg} message CAdditionalEquipSlotClientMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CAdditionalEquipSlotClientMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CAdditionalEquipSlotClientMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CAdditionalEquipSlotClientMsg} CAdditionalEquipSlotClientMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CAdditionalEquipSlotClientMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CAdditionalEquipSlotClientMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.class_id = reader.uint32();
                    break;
                case 2:
                    message.slot_id = reader.uint32();
                    break;
                case 3:
                    message.def_index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CAdditionalEquipSlotClientMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CAdditionalEquipSlotClientMsg} CAdditionalEquipSlotClientMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CAdditionalEquipSlotClientMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CAdditionalEquipSlotClientMsg message.
         * @function verify
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CAdditionalEquipSlotClientMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.class_id != null && message.hasOwnProperty("class_id"))
                if (!$util.isInteger(message.class_id))
                    return "class_id: integer expected";
            if (message.slot_id != null && message.hasOwnProperty("slot_id"))
                if (!$util.isInteger(message.slot_id))
                    return "slot_id: integer expected";
            if (message.def_index != null && message.hasOwnProperty("def_index"))
                if (!$util.isInteger(message.def_index))
                    return "def_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CAdditionalEquipSlotClientMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CAdditionalEquipSlotClientMsg} CAdditionalEquipSlotClientMsg
         */
        CAdditionalEquipSlotClientMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CAdditionalEquipSlotClientMsg)
                return object;
            var message = new $root.CAdditionalEquipSlotClientMsg();
            if (object.class_id != null)
                message.class_id = object.class_id >>> 0;
            if (object.slot_id != null)
                message.slot_id = object.slot_id >>> 0;
            if (object.def_index != null)
                message.def_index = object.def_index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CAdditionalEquipSlotClientMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CAdditionalEquipSlotClientMsg
         * @static
         * @param {CAdditionalEquipSlotClientMsg} message CAdditionalEquipSlotClientMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CAdditionalEquipSlotClientMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.class_id = 0;
                object.slot_id = 0;
                object.def_index = 0;
            }
            if (message.class_id != null && message.hasOwnProperty("class_id"))
                object.class_id = message.class_id;
            if (message.slot_id != null && message.hasOwnProperty("slot_id"))
                object.slot_id = message.slot_id;
            if (message.def_index != null && message.hasOwnProperty("def_index"))
                object.def_index = message.def_index;
            return object;
        };
    
        /**
         * Converts this CAdditionalEquipSlotClientMsg to JSON.
         * @function toJSON
         * @memberof CAdditionalEquipSlotClientMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CAdditionalEquipSlotClientMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CAdditionalEquipSlotClientMsg;
    })();
    
    $root.CDOTAClientMsg_FreeInventory = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_FreeInventory.
         * @exports ICDOTAClientMsg_FreeInventory
         * @interface ICDOTAClientMsg_FreeInventory
         * @property {Array.<ICAdditionalEquipSlotClientMsg>|null} [equips] CDOTAClientMsg_FreeInventory equips
         */
    
        /**
         * Constructs a new CDOTAClientMsg_FreeInventory.
         * @exports CDOTAClientMsg_FreeInventory
         * @classdesc Represents a CDOTAClientMsg_FreeInventory.
         * @implements ICDOTAClientMsg_FreeInventory
         * @constructor
         * @param {ICDOTAClientMsg_FreeInventory=} [properties] Properties to set
         */
        function CDOTAClientMsg_FreeInventory(properties) {
            this.equips = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_FreeInventory equips.
         * @member {Array.<ICAdditionalEquipSlotClientMsg>} equips
         * @memberof CDOTAClientMsg_FreeInventory
         * @instance
         */
        CDOTAClientMsg_FreeInventory.prototype.equips = $util.emptyArray;
    
        /**
         * Creates a new CDOTAClientMsg_FreeInventory instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {ICDOTAClientMsg_FreeInventory=} [properties] Properties to set
         * @returns {CDOTAClientMsg_FreeInventory} CDOTAClientMsg_FreeInventory instance
         */
        CDOTAClientMsg_FreeInventory.create = function create(properties) {
            return new CDOTAClientMsg_FreeInventory(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_FreeInventory message. Does not implicitly {@link CDOTAClientMsg_FreeInventory.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {ICDOTAClientMsg_FreeInventory} message CDOTAClientMsg_FreeInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_FreeInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equips != null && message.equips.length)
                for (var i = 0; i < message.equips.length; ++i)
                    $root.CAdditionalEquipSlotClientMsg.encode(message.equips[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_FreeInventory message, length delimited. Does not implicitly {@link CDOTAClientMsg_FreeInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {ICDOTAClientMsg_FreeInventory} message CDOTAClientMsg_FreeInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_FreeInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_FreeInventory message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_FreeInventory} CDOTAClientMsg_FreeInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_FreeInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_FreeInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.equips && message.equips.length))
                        message.equips = [];
                    message.equips.push($root.CAdditionalEquipSlotClientMsg.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_FreeInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_FreeInventory} CDOTAClientMsg_FreeInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_FreeInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_FreeInventory message.
         * @function verify
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_FreeInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.equips != null && message.hasOwnProperty("equips")) {
                if (!Array.isArray(message.equips))
                    return "equips: array expected";
                for (var i = 0; i < message.equips.length; ++i) {
                    var error = $root.CAdditionalEquipSlotClientMsg.verify(message.equips[i]);
                    if (error)
                        return "equips." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_FreeInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_FreeInventory} CDOTAClientMsg_FreeInventory
         */
        CDOTAClientMsg_FreeInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_FreeInventory)
                return object;
            var message = new $root.CDOTAClientMsg_FreeInventory();
            if (object.equips) {
                if (!Array.isArray(object.equips))
                    throw TypeError(".CDOTAClientMsg_FreeInventory.equips: array expected");
                message.equips = [];
                for (var i = 0; i < object.equips.length; ++i) {
                    if (typeof object.equips[i] !== "object")
                        throw TypeError(".CDOTAClientMsg_FreeInventory.equips: object expected");
                    message.equips[i] = $root.CAdditionalEquipSlotClientMsg.fromObject(object.equips[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_FreeInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_FreeInventory
         * @static
         * @param {CDOTAClientMsg_FreeInventory} message CDOTAClientMsg_FreeInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_FreeInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.equips = [];
            if (message.equips && message.equips.length) {
                object.equips = [];
                for (var j = 0; j < message.equips.length; ++j)
                    object.equips[j] = $root.CAdditionalEquipSlotClientMsg.toObject(message.equips[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_FreeInventory to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_FreeInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_FreeInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_FreeInventory;
    })();
    
    $root.CDOTAClientMsg_FillEmptySlotsWithBots = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_FillEmptySlotsWithBots.
         * @exports ICDOTAClientMsg_FillEmptySlotsWithBots
         * @interface ICDOTAClientMsg_FillEmptySlotsWithBots
         * @property {boolean|null} [fillwithbots] CDOTAClientMsg_FillEmptySlotsWithBots fillwithbots
         */
    
        /**
         * Constructs a new CDOTAClientMsg_FillEmptySlotsWithBots.
         * @exports CDOTAClientMsg_FillEmptySlotsWithBots
         * @classdesc Represents a CDOTAClientMsg_FillEmptySlotsWithBots.
         * @implements ICDOTAClientMsg_FillEmptySlotsWithBots
         * @constructor
         * @param {ICDOTAClientMsg_FillEmptySlotsWithBots=} [properties] Properties to set
         */
        function CDOTAClientMsg_FillEmptySlotsWithBots(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_FillEmptySlotsWithBots fillwithbots.
         * @member {boolean} fillwithbots
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @instance
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.prototype.fillwithbots = false;
    
        /**
         * Creates a new CDOTAClientMsg_FillEmptySlotsWithBots instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {ICDOTAClientMsg_FillEmptySlotsWithBots=} [properties] Properties to set
         * @returns {CDOTAClientMsg_FillEmptySlotsWithBots} CDOTAClientMsg_FillEmptySlotsWithBots instance
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.create = function create(properties) {
            return new CDOTAClientMsg_FillEmptySlotsWithBots(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_FillEmptySlotsWithBots message. Does not implicitly {@link CDOTAClientMsg_FillEmptySlotsWithBots.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {ICDOTAClientMsg_FillEmptySlotsWithBots} message CDOTAClientMsg_FillEmptySlotsWithBots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fillwithbots != null && Object.hasOwnProperty.call(message, "fillwithbots"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.fillwithbots);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_FillEmptySlotsWithBots message, length delimited. Does not implicitly {@link CDOTAClientMsg_FillEmptySlotsWithBots.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {ICDOTAClientMsg_FillEmptySlotsWithBots} message CDOTAClientMsg_FillEmptySlotsWithBots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_FillEmptySlotsWithBots message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_FillEmptySlotsWithBots} CDOTAClientMsg_FillEmptySlotsWithBots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_FillEmptySlotsWithBots();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fillwithbots = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_FillEmptySlotsWithBots message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_FillEmptySlotsWithBots} CDOTAClientMsg_FillEmptySlotsWithBots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_FillEmptySlotsWithBots message.
         * @function verify
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fillwithbots != null && message.hasOwnProperty("fillwithbots"))
                if (typeof message.fillwithbots !== "boolean")
                    return "fillwithbots: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_FillEmptySlotsWithBots message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_FillEmptySlotsWithBots} CDOTAClientMsg_FillEmptySlotsWithBots
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_FillEmptySlotsWithBots)
                return object;
            var message = new $root.CDOTAClientMsg_FillEmptySlotsWithBots();
            if (object.fillwithbots != null)
                message.fillwithbots = Boolean(object.fillwithbots);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_FillEmptySlotsWithBots message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @static
         * @param {CDOTAClientMsg_FillEmptySlotsWithBots} message CDOTAClientMsg_FillEmptySlotsWithBots
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fillwithbots = false;
            if (message.fillwithbots != null && message.hasOwnProperty("fillwithbots"))
                object.fillwithbots = message.fillwithbots;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_FillEmptySlotsWithBots to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_FillEmptySlotsWithBots
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_FillEmptySlotsWithBots.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_FillEmptySlotsWithBots;
    })();
    
    $root.CDOTAClientMsg_HeroStatueLike = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_HeroStatueLike.
         * @exports ICDOTAClientMsg_HeroStatueLike
         * @interface ICDOTAClientMsg_HeroStatueLike
         * @property {number|null} [owner_player_id] CDOTAClientMsg_HeroStatueLike owner_player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_HeroStatueLike.
         * @exports CDOTAClientMsg_HeroStatueLike
         * @classdesc Represents a CDOTAClientMsg_HeroStatueLike.
         * @implements ICDOTAClientMsg_HeroStatueLike
         * @constructor
         * @param {ICDOTAClientMsg_HeroStatueLike=} [properties] Properties to set
         */
        function CDOTAClientMsg_HeroStatueLike(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_HeroStatueLike owner_player_id.
         * @member {number} owner_player_id
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @instance
         */
        CDOTAClientMsg_HeroStatueLike.prototype.owner_player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_HeroStatueLike instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {ICDOTAClientMsg_HeroStatueLike=} [properties] Properties to set
         * @returns {CDOTAClientMsg_HeroStatueLike} CDOTAClientMsg_HeroStatueLike instance
         */
        CDOTAClientMsg_HeroStatueLike.create = function create(properties) {
            return new CDOTAClientMsg_HeroStatueLike(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_HeroStatueLike message. Does not implicitly {@link CDOTAClientMsg_HeroStatueLike.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {ICDOTAClientMsg_HeroStatueLike} message CDOTAClientMsg_HeroStatueLike message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_HeroStatueLike.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_player_id != null && Object.hasOwnProperty.call(message, "owner_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.owner_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_HeroStatueLike message, length delimited. Does not implicitly {@link CDOTAClientMsg_HeroStatueLike.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {ICDOTAClientMsg_HeroStatueLike} message CDOTAClientMsg_HeroStatueLike message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_HeroStatueLike.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_HeroStatueLike message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_HeroStatueLike} CDOTAClientMsg_HeroStatueLike
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_HeroStatueLike.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_HeroStatueLike();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_HeroStatueLike message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_HeroStatueLike} CDOTAClientMsg_HeroStatueLike
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_HeroStatueLike.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_HeroStatueLike message.
         * @function verify
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_HeroStatueLike.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_player_id != null && message.hasOwnProperty("owner_player_id"))
                if (!$util.isInteger(message.owner_player_id))
                    return "owner_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_HeroStatueLike message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_HeroStatueLike} CDOTAClientMsg_HeroStatueLike
         */
        CDOTAClientMsg_HeroStatueLike.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_HeroStatueLike)
                return object;
            var message = new $root.CDOTAClientMsg_HeroStatueLike();
            if (object.owner_player_id != null)
                message.owner_player_id = object.owner_player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_HeroStatueLike message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @static
         * @param {CDOTAClientMsg_HeroStatueLike} message CDOTAClientMsg_HeroStatueLike
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_HeroStatueLike.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.owner_player_id = 0;
            if (message.owner_player_id != null && message.hasOwnProperty("owner_player_id"))
                object.owner_player_id = message.owner_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_HeroStatueLike to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_HeroStatueLike
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_HeroStatueLike.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_HeroStatueLike;
    })();
    
    $root.CDOTAClientMsg_EventCNY2015Cmd = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_EventCNY2015Cmd.
         * @exports ICDOTAClientMsg_EventCNY2015Cmd
         * @interface ICDOTAClientMsg_EventCNY2015Cmd
         * @property {Uint8Array|null} [data] CDOTAClientMsg_EventCNY2015Cmd data
         */
    
        /**
         * Constructs a new CDOTAClientMsg_EventCNY2015Cmd.
         * @exports CDOTAClientMsg_EventCNY2015Cmd
         * @classdesc Represents a CDOTAClientMsg_EventCNY2015Cmd.
         * @implements ICDOTAClientMsg_EventCNY2015Cmd
         * @constructor
         * @param {ICDOTAClientMsg_EventCNY2015Cmd=} [properties] Properties to set
         */
        function CDOTAClientMsg_EventCNY2015Cmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_EventCNY2015Cmd data.
         * @member {Uint8Array} data
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @instance
         */
        CDOTAClientMsg_EventCNY2015Cmd.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CDOTAClientMsg_EventCNY2015Cmd instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {ICDOTAClientMsg_EventCNY2015Cmd=} [properties] Properties to set
         * @returns {CDOTAClientMsg_EventCNY2015Cmd} CDOTAClientMsg_EventCNY2015Cmd instance
         */
        CDOTAClientMsg_EventCNY2015Cmd.create = function create(properties) {
            return new CDOTAClientMsg_EventCNY2015Cmd(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EventCNY2015Cmd message. Does not implicitly {@link CDOTAClientMsg_EventCNY2015Cmd.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {ICDOTAClientMsg_EventCNY2015Cmd} message CDOTAClientMsg_EventCNY2015Cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EventCNY2015Cmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EventCNY2015Cmd message, length delimited. Does not implicitly {@link CDOTAClientMsg_EventCNY2015Cmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {ICDOTAClientMsg_EventCNY2015Cmd} message CDOTAClientMsg_EventCNY2015Cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EventCNY2015Cmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_EventCNY2015Cmd message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_EventCNY2015Cmd} CDOTAClientMsg_EventCNY2015Cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EventCNY2015Cmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_EventCNY2015Cmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_EventCNY2015Cmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_EventCNY2015Cmd} CDOTAClientMsg_EventCNY2015Cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EventCNY2015Cmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_EventCNY2015Cmd message.
         * @function verify
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_EventCNY2015Cmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_EventCNY2015Cmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_EventCNY2015Cmd} CDOTAClientMsg_EventCNY2015Cmd
         */
        CDOTAClientMsg_EventCNY2015Cmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_EventCNY2015Cmd)
                return object;
            var message = new $root.CDOTAClientMsg_EventCNY2015Cmd();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_EventCNY2015Cmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @static
         * @param {CDOTAClientMsg_EventCNY2015Cmd} message CDOTAClientMsg_EventCNY2015Cmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_EventCNY2015Cmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_EventCNY2015Cmd to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_EventCNY2015Cmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_EventCNY2015Cmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_EventCNY2015Cmd;
    })();
    
    $root.CDOTAClientMsg_DemoHero = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_DemoHero.
         * @exports ICDOTAClientMsg_DemoHero
         * @interface ICDOTAClientMsg_DemoHero
         * @property {number|null} [hero_id] CDOTAClientMsg_DemoHero hero_id
         * @property {number|null} [hero_id_to_spawn] CDOTAClientMsg_DemoHero hero_id_to_spawn
         * @property {Array.<number>|null} [item_defs] CDOTAClientMsg_DemoHero item_defs
         * @property {Array.<number|Long>|null} [item_ids] CDOTAClientMsg_DemoHero item_ids
         * @property {number|null} [style_index] CDOTAClientMsg_DemoHero style_index
         * @property {boolean|null} [keep_existing_demohero] CDOTAClientMsg_DemoHero keep_existing_demohero
         */
    
        /**
         * Constructs a new CDOTAClientMsg_DemoHero.
         * @exports CDOTAClientMsg_DemoHero
         * @classdesc Represents a CDOTAClientMsg_DemoHero.
         * @implements ICDOTAClientMsg_DemoHero
         * @constructor
         * @param {ICDOTAClientMsg_DemoHero=} [properties] Properties to set
         */
        function CDOTAClientMsg_DemoHero(properties) {
            this.item_defs = [];
            this.item_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_DemoHero hero_id.
         * @member {number} hero_id
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         */
        CDOTAClientMsg_DemoHero.prototype.hero_id = 0;
    
        /**
         * CDOTAClientMsg_DemoHero hero_id_to_spawn.
         * @member {number} hero_id_to_spawn
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         */
        CDOTAClientMsg_DemoHero.prototype.hero_id_to_spawn = 0;
    
        /**
         * CDOTAClientMsg_DemoHero item_defs.
         * @member {Array.<number>} item_defs
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         */
        CDOTAClientMsg_DemoHero.prototype.item_defs = $util.emptyArray;
    
        /**
         * CDOTAClientMsg_DemoHero item_ids.
         * @member {Array.<number|Long>} item_ids
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         */
        CDOTAClientMsg_DemoHero.prototype.item_ids = $util.emptyArray;
    
        /**
         * CDOTAClientMsg_DemoHero style_index.
         * @member {number} style_index
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         */
        CDOTAClientMsg_DemoHero.prototype.style_index = 0;
    
        /**
         * CDOTAClientMsg_DemoHero keep_existing_demohero.
         * @member {boolean} keep_existing_demohero
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         */
        CDOTAClientMsg_DemoHero.prototype.keep_existing_demohero = false;
    
        /**
         * Creates a new CDOTAClientMsg_DemoHero instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {ICDOTAClientMsg_DemoHero=} [properties] Properties to set
         * @returns {CDOTAClientMsg_DemoHero} CDOTAClientMsg_DemoHero instance
         */
        CDOTAClientMsg_DemoHero.create = function create(properties) {
            return new CDOTAClientMsg_DemoHero(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_DemoHero message. Does not implicitly {@link CDOTAClientMsg_DemoHero.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {ICDOTAClientMsg_DemoHero} message CDOTAClientMsg_DemoHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_DemoHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hero_id != null && Object.hasOwnProperty.call(message, "hero_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hero_id);
            if (message.hero_id_to_spawn != null && Object.hasOwnProperty.call(message, "hero_id_to_spawn"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hero_id_to_spawn);
            if (message.item_defs != null && message.item_defs.length)
                for (var i = 0; i < message.item_defs.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.item_defs[i]);
            if (message.item_ids != null && message.item_ids.length)
                for (var i = 0; i < message.item_ids.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.item_ids[i]);
            if (message.style_index != null && Object.hasOwnProperty.call(message, "style_index"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.style_index);
            if (message.keep_existing_demohero != null && Object.hasOwnProperty.call(message, "keep_existing_demohero"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.keep_existing_demohero);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_DemoHero message, length delimited. Does not implicitly {@link CDOTAClientMsg_DemoHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {ICDOTAClientMsg_DemoHero} message CDOTAClientMsg_DemoHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_DemoHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_DemoHero message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_DemoHero} CDOTAClientMsg_DemoHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_DemoHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_DemoHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hero_id = reader.int32();
                    break;
                case 2:
                    message.hero_id_to_spawn = reader.int32();
                    break;
                case 3:
                    if (!(message.item_defs && message.item_defs.length))
                        message.item_defs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.item_defs.push(reader.uint32());
                    } else
                        message.item_defs.push(reader.uint32());
                    break;
                case 4:
                    if (!(message.item_ids && message.item_ids.length))
                        message.item_ids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.item_ids.push(reader.uint64());
                    } else
                        message.item_ids.push(reader.uint64());
                    break;
                case 5:
                    message.style_index = reader.uint32();
                    break;
                case 6:
                    message.keep_existing_demohero = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_DemoHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_DemoHero} CDOTAClientMsg_DemoHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_DemoHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_DemoHero message.
         * @function verify
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_DemoHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                if (!$util.isInteger(message.hero_id))
                    return "hero_id: integer expected";
            if (message.hero_id_to_spawn != null && message.hasOwnProperty("hero_id_to_spawn"))
                if (!$util.isInteger(message.hero_id_to_spawn))
                    return "hero_id_to_spawn: integer expected";
            if (message.item_defs != null && message.hasOwnProperty("item_defs")) {
                if (!Array.isArray(message.item_defs))
                    return "item_defs: array expected";
                for (var i = 0; i < message.item_defs.length; ++i)
                    if (!$util.isInteger(message.item_defs[i]))
                        return "item_defs: integer[] expected";
            }
            if (message.item_ids != null && message.hasOwnProperty("item_ids")) {
                if (!Array.isArray(message.item_ids))
                    return "item_ids: array expected";
                for (var i = 0; i < message.item_ids.length; ++i)
                    if (!$util.isInteger(message.item_ids[i]) && !(message.item_ids[i] && $util.isInteger(message.item_ids[i].low) && $util.isInteger(message.item_ids[i].high)))
                        return "item_ids: integer|Long[] expected";
            }
            if (message.style_index != null && message.hasOwnProperty("style_index"))
                if (!$util.isInteger(message.style_index))
                    return "style_index: integer expected";
            if (message.keep_existing_demohero != null && message.hasOwnProperty("keep_existing_demohero"))
                if (typeof message.keep_existing_demohero !== "boolean")
                    return "keep_existing_demohero: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_DemoHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_DemoHero} CDOTAClientMsg_DemoHero
         */
        CDOTAClientMsg_DemoHero.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_DemoHero)
                return object;
            var message = new $root.CDOTAClientMsg_DemoHero();
            if (object.hero_id != null)
                message.hero_id = object.hero_id | 0;
            if (object.hero_id_to_spawn != null)
                message.hero_id_to_spawn = object.hero_id_to_spawn | 0;
            if (object.item_defs) {
                if (!Array.isArray(object.item_defs))
                    throw TypeError(".CDOTAClientMsg_DemoHero.item_defs: array expected");
                message.item_defs = [];
                for (var i = 0; i < object.item_defs.length; ++i)
                    message.item_defs[i] = object.item_defs[i] >>> 0;
            }
            if (object.item_ids) {
                if (!Array.isArray(object.item_ids))
                    throw TypeError(".CDOTAClientMsg_DemoHero.item_ids: array expected");
                message.item_ids = [];
                for (var i = 0; i < object.item_ids.length; ++i)
                    if ($util.Long)
                        (message.item_ids[i] = $util.Long.fromValue(object.item_ids[i])).unsigned = true;
                    else if (typeof object.item_ids[i] === "string")
                        message.item_ids[i] = parseInt(object.item_ids[i], 10);
                    else if (typeof object.item_ids[i] === "number")
                        message.item_ids[i] = object.item_ids[i];
                    else if (typeof object.item_ids[i] === "object")
                        message.item_ids[i] = new $util.LongBits(object.item_ids[i].low >>> 0, object.item_ids[i].high >>> 0).toNumber(true);
            }
            if (object.style_index != null)
                message.style_index = object.style_index >>> 0;
            if (object.keep_existing_demohero != null)
                message.keep_existing_demohero = Boolean(object.keep_existing_demohero);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_DemoHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_DemoHero
         * @static
         * @param {CDOTAClientMsg_DemoHero} message CDOTAClientMsg_DemoHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_DemoHero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.item_defs = [];
                object.item_ids = [];
            }
            if (options.defaults) {
                object.hero_id = 0;
                object.hero_id_to_spawn = 0;
                object.style_index = 0;
                object.keep_existing_demohero = false;
            }
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                object.hero_id = message.hero_id;
            if (message.hero_id_to_spawn != null && message.hasOwnProperty("hero_id_to_spawn"))
                object.hero_id_to_spawn = message.hero_id_to_spawn;
            if (message.item_defs && message.item_defs.length) {
                object.item_defs = [];
                for (var j = 0; j < message.item_defs.length; ++j)
                    object.item_defs[j] = message.item_defs[j];
            }
            if (message.item_ids && message.item_ids.length) {
                object.item_ids = [];
                for (var j = 0; j < message.item_ids.length; ++j)
                    if (typeof message.item_ids[j] === "number")
                        object.item_ids[j] = options.longs === String ? String(message.item_ids[j]) : message.item_ids[j];
                    else
                        object.item_ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.item_ids[j]) : options.longs === Number ? new $util.LongBits(message.item_ids[j].low >>> 0, message.item_ids[j].high >>> 0).toNumber(true) : message.item_ids[j];
            }
            if (message.style_index != null && message.hasOwnProperty("style_index"))
                object.style_index = message.style_index;
            if (message.keep_existing_demohero != null && message.hasOwnProperty("keep_existing_demohero"))
                object.keep_existing_demohero = message.keep_existing_demohero;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_DemoHero to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_DemoHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_DemoHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_DemoHero;
    })();
    
    $root.CDOTAClientMsg_ChallengeSelect = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ChallengeSelect.
         * @exports ICDOTAClientMsg_ChallengeSelect
         * @interface ICDOTAClientMsg_ChallengeSelect
         * @property {number|null} [event_id] CDOTAClientMsg_ChallengeSelect event_id
         * @property {number|null} [slot_id] CDOTAClientMsg_ChallengeSelect slot_id
         * @property {number|null} [sequence_id] CDOTAClientMsg_ChallengeSelect sequence_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ChallengeSelect.
         * @exports CDOTAClientMsg_ChallengeSelect
         * @classdesc Represents a CDOTAClientMsg_ChallengeSelect.
         * @implements ICDOTAClientMsg_ChallengeSelect
         * @constructor
         * @param {ICDOTAClientMsg_ChallengeSelect=} [properties] Properties to set
         */
        function CDOTAClientMsg_ChallengeSelect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ChallengeSelect event_id.
         * @member {number} event_id
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @instance
         */
        CDOTAClientMsg_ChallengeSelect.prototype.event_id = 0;
    
        /**
         * CDOTAClientMsg_ChallengeSelect slot_id.
         * @member {number} slot_id
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @instance
         */
        CDOTAClientMsg_ChallengeSelect.prototype.slot_id = 0;
    
        /**
         * CDOTAClientMsg_ChallengeSelect sequence_id.
         * @member {number} sequence_id
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @instance
         */
        CDOTAClientMsg_ChallengeSelect.prototype.sequence_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_ChallengeSelect instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {ICDOTAClientMsg_ChallengeSelect=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ChallengeSelect} CDOTAClientMsg_ChallengeSelect instance
         */
        CDOTAClientMsg_ChallengeSelect.create = function create(properties) {
            return new CDOTAClientMsg_ChallengeSelect(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChallengeSelect message. Does not implicitly {@link CDOTAClientMsg_ChallengeSelect.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {ICDOTAClientMsg_ChallengeSelect} message CDOTAClientMsg_ChallengeSelect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChallengeSelect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.event_id);
            if (message.slot_id != null && Object.hasOwnProperty.call(message, "slot_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.slot_id);
            if (message.sequence_id != null && Object.hasOwnProperty.call(message, "sequence_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sequence_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChallengeSelect message, length delimited. Does not implicitly {@link CDOTAClientMsg_ChallengeSelect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {ICDOTAClientMsg_ChallengeSelect} message CDOTAClientMsg_ChallengeSelect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChallengeSelect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChallengeSelect message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ChallengeSelect} CDOTAClientMsg_ChallengeSelect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChallengeSelect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ChallengeSelect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_id = reader.uint32();
                    break;
                case 2:
                    message.slot_id = reader.uint32();
                    break;
                case 3:
                    message.sequence_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChallengeSelect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ChallengeSelect} CDOTAClientMsg_ChallengeSelect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChallengeSelect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ChallengeSelect message.
         * @function verify
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ChallengeSelect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                if (!$util.isInteger(message.event_id))
                    return "event_id: integer expected";
            if (message.slot_id != null && message.hasOwnProperty("slot_id"))
                if (!$util.isInteger(message.slot_id))
                    return "slot_id: integer expected";
            if (message.sequence_id != null && message.hasOwnProperty("sequence_id"))
                if (!$util.isInteger(message.sequence_id))
                    return "sequence_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ChallengeSelect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ChallengeSelect} CDOTAClientMsg_ChallengeSelect
         */
        CDOTAClientMsg_ChallengeSelect.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ChallengeSelect)
                return object;
            var message = new $root.CDOTAClientMsg_ChallengeSelect();
            if (object.event_id != null)
                message.event_id = object.event_id >>> 0;
            if (object.slot_id != null)
                message.slot_id = object.slot_id >>> 0;
            if (object.sequence_id != null)
                message.sequence_id = object.sequence_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ChallengeSelect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @static
         * @param {CDOTAClientMsg_ChallengeSelect} message CDOTAClientMsg_ChallengeSelect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ChallengeSelect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_id = 0;
                object.slot_id = 0;
                object.sequence_id = 0;
            }
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            if (message.slot_id != null && message.hasOwnProperty("slot_id"))
                object.slot_id = message.slot_id;
            if (message.sequence_id != null && message.hasOwnProperty("sequence_id"))
                object.sequence_id = message.sequence_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ChallengeSelect to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ChallengeSelect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ChallengeSelect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ChallengeSelect;
    })();
    
    $root.CDOTAClientMsg_ChallengeReroll = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ChallengeReroll.
         * @exports ICDOTAClientMsg_ChallengeReroll
         * @interface ICDOTAClientMsg_ChallengeReroll
         * @property {EEvent|null} [event_id] CDOTAClientMsg_ChallengeReroll event_id
         * @property {number|null} [slot_id] CDOTAClientMsg_ChallengeReroll slot_id
         * @property {number|null} [sequence_id] CDOTAClientMsg_ChallengeReroll sequence_id
         * @property {number|null} [hero_id] CDOTAClientMsg_ChallengeReroll hero_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ChallengeReroll.
         * @exports CDOTAClientMsg_ChallengeReroll
         * @classdesc Represents a CDOTAClientMsg_ChallengeReroll.
         * @implements ICDOTAClientMsg_ChallengeReroll
         * @constructor
         * @param {ICDOTAClientMsg_ChallengeReroll=} [properties] Properties to set
         */
        function CDOTAClientMsg_ChallengeReroll(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ChallengeReroll event_id.
         * @member {EEvent} event_id
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @instance
         */
        CDOTAClientMsg_ChallengeReroll.prototype.event_id = 0;
    
        /**
         * CDOTAClientMsg_ChallengeReroll slot_id.
         * @member {number} slot_id
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @instance
         */
        CDOTAClientMsg_ChallengeReroll.prototype.slot_id = 0;
    
        /**
         * CDOTAClientMsg_ChallengeReroll sequence_id.
         * @member {number} sequence_id
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @instance
         */
        CDOTAClientMsg_ChallengeReroll.prototype.sequence_id = 0;
    
        /**
         * CDOTAClientMsg_ChallengeReroll hero_id.
         * @member {number} hero_id
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @instance
         */
        CDOTAClientMsg_ChallengeReroll.prototype.hero_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_ChallengeReroll instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {ICDOTAClientMsg_ChallengeReroll=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ChallengeReroll} CDOTAClientMsg_ChallengeReroll instance
         */
        CDOTAClientMsg_ChallengeReroll.create = function create(properties) {
            return new CDOTAClientMsg_ChallengeReroll(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChallengeReroll message. Does not implicitly {@link CDOTAClientMsg_ChallengeReroll.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {ICDOTAClientMsg_ChallengeReroll} message CDOTAClientMsg_ChallengeReroll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChallengeReroll.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event_id);
            if (message.slot_id != null && Object.hasOwnProperty.call(message, "slot_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.slot_id);
            if (message.sequence_id != null && Object.hasOwnProperty.call(message, "sequence_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sequence_id);
            if (message.hero_id != null && Object.hasOwnProperty.call(message, "hero_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hero_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ChallengeReroll message, length delimited. Does not implicitly {@link CDOTAClientMsg_ChallengeReroll.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {ICDOTAClientMsg_ChallengeReroll} message CDOTAClientMsg_ChallengeReroll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ChallengeReroll.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChallengeReroll message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ChallengeReroll} CDOTAClientMsg_ChallengeReroll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChallengeReroll.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ChallengeReroll();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_id = reader.int32();
                    break;
                case 2:
                    message.slot_id = reader.uint32();
                    break;
                case 3:
                    message.sequence_id = reader.uint32();
                    break;
                case 4:
                    message.hero_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ChallengeReroll message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ChallengeReroll} CDOTAClientMsg_ChallengeReroll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ChallengeReroll.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ChallengeReroll message.
         * @function verify
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ChallengeReroll.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                switch (message.event_id) {
                default:
                    return "event_id: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                    break;
                }
            if (message.slot_id != null && message.hasOwnProperty("slot_id"))
                if (!$util.isInteger(message.slot_id))
                    return "slot_id: integer expected";
            if (message.sequence_id != null && message.hasOwnProperty("sequence_id"))
                if (!$util.isInteger(message.sequence_id))
                    return "sequence_id: integer expected";
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                if (!$util.isInteger(message.hero_id))
                    return "hero_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ChallengeReroll message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ChallengeReroll} CDOTAClientMsg_ChallengeReroll
         */
        CDOTAClientMsg_ChallengeReroll.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ChallengeReroll)
                return object;
            var message = new $root.CDOTAClientMsg_ChallengeReroll();
            switch (object.event_id) {
            case "EVENT_ID_NONE":
            case 0:
                message.event_id = 0;
                break;
            case "EVENT_ID_DIRETIDE":
            case 1:
                message.event_id = 1;
                break;
            case "EVENT_ID_SPRING_FESTIVAL":
            case 2:
                message.event_id = 2;
                break;
            case "EVENT_ID_FROSTIVUS_2013":
            case 3:
                message.event_id = 3;
                break;
            case "EVENT_ID_COMPENDIUM_2014":
            case 4:
                message.event_id = 4;
                break;
            case "EVENT_ID_NEXON_PC_BANG":
            case 5:
                message.event_id = 5;
                break;
            case "EVENT_ID_PWRD_DAC_2015":
            case 6:
                message.event_id = 6;
                break;
            case "EVENT_ID_NEW_BLOOM_2015":
            case 7:
                message.event_id = 7;
                break;
            case "EVENT_ID_INTERNATIONAL_2015":
            case 8:
                message.event_id = 8;
                break;
            case "EVENT_ID_FALL_MAJOR_2015":
            case 9:
                message.event_id = 9;
                break;
            case "EVENT_ID_ORACLE_PA":
            case 10:
                message.event_id = 10;
                break;
            case "EVENT_ID_NEW_BLOOM_2015_PREBEAST":
            case 11:
                message.event_id = 11;
                break;
            case "EVENT_ID_FROSTIVUS":
            case 12:
                message.event_id = 12;
                break;
            case "EVENT_ID_WINTER_MAJOR_2016":
            case 13:
                message.event_id = 13;
                break;
            case "EVENT_ID_INTERNATIONAL_2016":
            case 14:
                message.event_id = 14;
                break;
            case "EVENT_ID_FALL_MAJOR_2016":
            case 15:
                message.event_id = 15;
                break;
            case "EVENT_ID_WINTER_MAJOR_2017":
            case 16:
                message.event_id = 16;
                break;
            case "EVENT_ID_NEW_BLOOM_2017":
            case 17:
                message.event_id = 17;
                break;
            case "EVENT_ID_INTERNATIONAL_2017":
            case 18:
                message.event_id = 18;
                break;
            case "EVENT_ID_PLUS_SUBSCRIPTION":
            case 19:
                message.event_id = 19;
                break;
            case "EVENT_ID_SINGLES_DAY_2017":
            case 20:
                message.event_id = 20;
                break;
            case "EVENT_ID_FROSTIVUS_2017":
            case 21:
                message.event_id = 21;
                break;
            case "EVENT_ID_INTERNATIONAL_2018":
            case 22:
                message.event_id = 22;
                break;
            case "EVENT_ID_FROSTIVUS_2018":
            case 23:
                message.event_id = 23;
                break;
            case "EVENT_ID_NEW_BLOOM_2019":
            case 24:
                message.event_id = 24;
                break;
            case "EVENT_ID_INTERNATIONAL_2019":
            case 25:
                message.event_id = 25;
                break;
            case "EVENT_ID_NEW_PLAYER_EXPERIENCE":
            case 26:
                message.event_id = 26;
                break;
            case "EVENT_ID_FROSTIVUS_2019":
            case 27:
                message.event_id = 27;
                break;
            case "EVENT_ID_NEW_BLOOM_2020":
            case 28:
                message.event_id = 28;
                break;
            case "EVENT_ID_INTERNATIONAL_2020":
            case 29:
                message.event_id = 29;
                break;
            case "EVENT_ID_TEAM_FANDOM":
            case 30:
                message.event_id = 30;
                break;
            case "EVENT_ID_DIRETIDE_2020":
            case 31:
                message.event_id = 31;
                break;
            case "EVENT_ID_COUNT":
            case 32:
                message.event_id = 32;
                break;
            }
            if (object.slot_id != null)
                message.slot_id = object.slot_id >>> 0;
            if (object.sequence_id != null)
                message.sequence_id = object.sequence_id >>> 0;
            if (object.hero_id != null)
                message.hero_id = object.hero_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ChallengeReroll message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @static
         * @param {CDOTAClientMsg_ChallengeReroll} message CDOTAClientMsg_ChallengeReroll
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ChallengeReroll.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_id = options.enums === String ? "EVENT_ID_NONE" : 0;
                object.slot_id = 0;
                object.sequence_id = 0;
                object.hero_id = 0;
            }
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = options.enums === String ? $root.EEvent[message.event_id] : message.event_id;
            if (message.slot_id != null && message.hasOwnProperty("slot_id"))
                object.slot_id = message.slot_id;
            if (message.sequence_id != null && message.hasOwnProperty("sequence_id"))
                object.sequence_id = message.sequence_id;
            if (message.hero_id != null && message.hasOwnProperty("hero_id"))
                object.hero_id = message.hero_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ChallengeReroll to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ChallengeReroll
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ChallengeReroll.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ChallengeReroll;
    })();
    
    $root.CDOTAClientMsg_CoinWager = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_CoinWager.
         * @exports ICDOTAClientMsg_CoinWager
         * @interface ICDOTAClientMsg_CoinWager
         * @property {number|null} [wager_amount] CDOTAClientMsg_CoinWager wager_amount
         */
    
        /**
         * Constructs a new CDOTAClientMsg_CoinWager.
         * @exports CDOTAClientMsg_CoinWager
         * @classdesc Represents a CDOTAClientMsg_CoinWager.
         * @implements ICDOTAClientMsg_CoinWager
         * @constructor
         * @param {ICDOTAClientMsg_CoinWager=} [properties] Properties to set
         */
        function CDOTAClientMsg_CoinWager(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_CoinWager wager_amount.
         * @member {number} wager_amount
         * @memberof CDOTAClientMsg_CoinWager
         * @instance
         */
        CDOTAClientMsg_CoinWager.prototype.wager_amount = 0;
    
        /**
         * Creates a new CDOTAClientMsg_CoinWager instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {ICDOTAClientMsg_CoinWager=} [properties] Properties to set
         * @returns {CDOTAClientMsg_CoinWager} CDOTAClientMsg_CoinWager instance
         */
        CDOTAClientMsg_CoinWager.create = function create(properties) {
            return new CDOTAClientMsg_CoinWager(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_CoinWager message. Does not implicitly {@link CDOTAClientMsg_CoinWager.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {ICDOTAClientMsg_CoinWager} message CDOTAClientMsg_CoinWager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_CoinWager.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wager_amount != null && Object.hasOwnProperty.call(message, "wager_amount"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.wager_amount);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_CoinWager message, length delimited. Does not implicitly {@link CDOTAClientMsg_CoinWager.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {ICDOTAClientMsg_CoinWager} message CDOTAClientMsg_CoinWager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_CoinWager.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_CoinWager message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_CoinWager} CDOTAClientMsg_CoinWager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_CoinWager.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_CoinWager();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.wager_amount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_CoinWager message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_CoinWager} CDOTAClientMsg_CoinWager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_CoinWager.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_CoinWager message.
         * @function verify
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_CoinWager.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wager_amount != null && message.hasOwnProperty("wager_amount"))
                if (!$util.isInteger(message.wager_amount))
                    return "wager_amount: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_CoinWager message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_CoinWager} CDOTAClientMsg_CoinWager
         */
        CDOTAClientMsg_CoinWager.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_CoinWager)
                return object;
            var message = new $root.CDOTAClientMsg_CoinWager();
            if (object.wager_amount != null)
                message.wager_amount = object.wager_amount >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_CoinWager message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_CoinWager
         * @static
         * @param {CDOTAClientMsg_CoinWager} message CDOTAClientMsg_CoinWager
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_CoinWager.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.wager_amount = 0;
            if (message.wager_amount != null && message.hasOwnProperty("wager_amount"))
                object.wager_amount = message.wager_amount;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_CoinWager to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_CoinWager
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_CoinWager.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_CoinWager;
    })();
    
    $root.CDOTAClientMsg_CoinWagerToken = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_CoinWagerToken.
         * @exports ICDOTAClientMsg_CoinWagerToken
         * @interface ICDOTAClientMsg_CoinWagerToken
         * @property {number|Long|null} [wager_token_item_id] CDOTAClientMsg_CoinWagerToken wager_token_item_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_CoinWagerToken.
         * @exports CDOTAClientMsg_CoinWagerToken
         * @classdesc Represents a CDOTAClientMsg_CoinWagerToken.
         * @implements ICDOTAClientMsg_CoinWagerToken
         * @constructor
         * @param {ICDOTAClientMsg_CoinWagerToken=} [properties] Properties to set
         */
        function CDOTAClientMsg_CoinWagerToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_CoinWagerToken wager_token_item_id.
         * @member {number|Long} wager_token_item_id
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @instance
         */
        CDOTAClientMsg_CoinWagerToken.prototype.wager_token_item_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CDOTAClientMsg_CoinWagerToken instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {ICDOTAClientMsg_CoinWagerToken=} [properties] Properties to set
         * @returns {CDOTAClientMsg_CoinWagerToken} CDOTAClientMsg_CoinWagerToken instance
         */
        CDOTAClientMsg_CoinWagerToken.create = function create(properties) {
            return new CDOTAClientMsg_CoinWagerToken(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_CoinWagerToken message. Does not implicitly {@link CDOTAClientMsg_CoinWagerToken.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {ICDOTAClientMsg_CoinWagerToken} message CDOTAClientMsg_CoinWagerToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_CoinWagerToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wager_token_item_id != null && Object.hasOwnProperty.call(message, "wager_token_item_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.wager_token_item_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_CoinWagerToken message, length delimited. Does not implicitly {@link CDOTAClientMsg_CoinWagerToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {ICDOTAClientMsg_CoinWagerToken} message CDOTAClientMsg_CoinWagerToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_CoinWagerToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_CoinWagerToken message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_CoinWagerToken} CDOTAClientMsg_CoinWagerToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_CoinWagerToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_CoinWagerToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.wager_token_item_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_CoinWagerToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_CoinWagerToken} CDOTAClientMsg_CoinWagerToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_CoinWagerToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_CoinWagerToken message.
         * @function verify
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_CoinWagerToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wager_token_item_id != null && message.hasOwnProperty("wager_token_item_id"))
                if (!$util.isInteger(message.wager_token_item_id) && !(message.wager_token_item_id && $util.isInteger(message.wager_token_item_id.low) && $util.isInteger(message.wager_token_item_id.high)))
                    return "wager_token_item_id: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_CoinWagerToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_CoinWagerToken} CDOTAClientMsg_CoinWagerToken
         */
        CDOTAClientMsg_CoinWagerToken.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_CoinWagerToken)
                return object;
            var message = new $root.CDOTAClientMsg_CoinWagerToken();
            if (object.wager_token_item_id != null)
                if ($util.Long)
                    (message.wager_token_item_id = $util.Long.fromValue(object.wager_token_item_id)).unsigned = true;
                else if (typeof object.wager_token_item_id === "string")
                    message.wager_token_item_id = parseInt(object.wager_token_item_id, 10);
                else if (typeof object.wager_token_item_id === "number")
                    message.wager_token_item_id = object.wager_token_item_id;
                else if (typeof object.wager_token_item_id === "object")
                    message.wager_token_item_id = new $util.LongBits(object.wager_token_item_id.low >>> 0, object.wager_token_item_id.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_CoinWagerToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @static
         * @param {CDOTAClientMsg_CoinWagerToken} message CDOTAClientMsg_CoinWagerToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_CoinWagerToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.wager_token_item_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.wager_token_item_id = options.longs === String ? "0" : 0;
            if (message.wager_token_item_id != null && message.hasOwnProperty("wager_token_item_id"))
                if (typeof message.wager_token_item_id === "number")
                    object.wager_token_item_id = options.longs === String ? String(message.wager_token_item_id) : message.wager_token_item_id;
                else
                    object.wager_token_item_id = options.longs === String ? $util.Long.prototype.toString.call(message.wager_token_item_id) : options.longs === Number ? new $util.LongBits(message.wager_token_item_id.low >>> 0, message.wager_token_item_id.high >>> 0).toNumber(true) : message.wager_token_item_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_CoinWagerToken to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_CoinWagerToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_CoinWagerToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_CoinWagerToken;
    })();
    
    $root.CDOTAClientMsg_RankWager = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RankWager.
         * @exports ICDOTAClientMsg_RankWager
         * @interface ICDOTAClientMsg_RankWager
         * @property {boolean|null} [announce_wager] CDOTAClientMsg_RankWager announce_wager
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RankWager.
         * @exports CDOTAClientMsg_RankWager
         * @classdesc Represents a CDOTAClientMsg_RankWager.
         * @implements ICDOTAClientMsg_RankWager
         * @constructor
         * @param {ICDOTAClientMsg_RankWager=} [properties] Properties to set
         */
        function CDOTAClientMsg_RankWager(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_RankWager announce_wager.
         * @member {boolean} announce_wager
         * @memberof CDOTAClientMsg_RankWager
         * @instance
         */
        CDOTAClientMsg_RankWager.prototype.announce_wager = false;
    
        /**
         * Creates a new CDOTAClientMsg_RankWager instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {ICDOTAClientMsg_RankWager=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RankWager} CDOTAClientMsg_RankWager instance
         */
        CDOTAClientMsg_RankWager.create = function create(properties) {
            return new CDOTAClientMsg_RankWager(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RankWager message. Does not implicitly {@link CDOTAClientMsg_RankWager.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {ICDOTAClientMsg_RankWager} message CDOTAClientMsg_RankWager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RankWager.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.announce_wager != null && Object.hasOwnProperty.call(message, "announce_wager"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.announce_wager);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RankWager message, length delimited. Does not implicitly {@link CDOTAClientMsg_RankWager.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {ICDOTAClientMsg_RankWager} message CDOTAClientMsg_RankWager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RankWager.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RankWager message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RankWager} CDOTAClientMsg_RankWager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RankWager.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RankWager();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.announce_wager = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RankWager message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RankWager} CDOTAClientMsg_RankWager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RankWager.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RankWager message.
         * @function verify
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RankWager.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.announce_wager != null && message.hasOwnProperty("announce_wager"))
                if (typeof message.announce_wager !== "boolean")
                    return "announce_wager: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RankWager message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RankWager} CDOTAClientMsg_RankWager
         */
        CDOTAClientMsg_RankWager.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RankWager)
                return object;
            var message = new $root.CDOTAClientMsg_RankWager();
            if (object.announce_wager != null)
                message.announce_wager = Boolean(object.announce_wager);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RankWager message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RankWager
         * @static
         * @param {CDOTAClientMsg_RankWager} message CDOTAClientMsg_RankWager
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RankWager.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.announce_wager = false;
            if (message.announce_wager != null && message.hasOwnProperty("announce_wager"))
                object.announce_wager = message.announce_wager;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_RankWager to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RankWager
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RankWager.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RankWager;
    })();
    
    $root.CDOTAClientMsg_PlayerBounty = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_PlayerBounty.
         * @exports ICDOTAClientMsg_PlayerBounty
         * @interface ICDOTAClientMsg_PlayerBounty
         * @property {number|null} [player_id] CDOTAClientMsg_PlayerBounty player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_PlayerBounty.
         * @exports CDOTAClientMsg_PlayerBounty
         * @classdesc Represents a CDOTAClientMsg_PlayerBounty.
         * @implements ICDOTAClientMsg_PlayerBounty
         * @constructor
         * @param {ICDOTAClientMsg_PlayerBounty=} [properties] Properties to set
         */
        function CDOTAClientMsg_PlayerBounty(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_PlayerBounty player_id.
         * @member {number} player_id
         * @memberof CDOTAClientMsg_PlayerBounty
         * @instance
         */
        CDOTAClientMsg_PlayerBounty.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_PlayerBounty instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {ICDOTAClientMsg_PlayerBounty=} [properties] Properties to set
         * @returns {CDOTAClientMsg_PlayerBounty} CDOTAClientMsg_PlayerBounty instance
         */
        CDOTAClientMsg_PlayerBounty.create = function create(properties) {
            return new CDOTAClientMsg_PlayerBounty(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PlayerBounty message. Does not implicitly {@link CDOTAClientMsg_PlayerBounty.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {ICDOTAClientMsg_PlayerBounty} message CDOTAClientMsg_PlayerBounty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PlayerBounty.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PlayerBounty message, length delimited. Does not implicitly {@link CDOTAClientMsg_PlayerBounty.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {ICDOTAClientMsg_PlayerBounty} message CDOTAClientMsg_PlayerBounty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PlayerBounty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_PlayerBounty message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_PlayerBounty} CDOTAClientMsg_PlayerBounty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PlayerBounty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_PlayerBounty();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_PlayerBounty message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_PlayerBounty} CDOTAClientMsg_PlayerBounty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PlayerBounty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_PlayerBounty message.
         * @function verify
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_PlayerBounty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_PlayerBounty message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_PlayerBounty} CDOTAClientMsg_PlayerBounty
         */
        CDOTAClientMsg_PlayerBounty.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_PlayerBounty)
                return object;
            var message = new $root.CDOTAClientMsg_PlayerBounty();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_PlayerBounty message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_PlayerBounty
         * @static
         * @param {CDOTAClientMsg_PlayerBounty} message CDOTAClientMsg_PlayerBounty
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_PlayerBounty.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_PlayerBounty to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_PlayerBounty
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_PlayerBounty.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_PlayerBounty;
    })();
    
    $root.CDOTAClientMsg_EventPointsTip = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_EventPointsTip.
         * @exports ICDOTAClientMsg_EventPointsTip
         * @interface ICDOTAClientMsg_EventPointsTip
         * @property {number|null} [recipient_player_id] CDOTAClientMsg_EventPointsTip recipient_player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_EventPointsTip.
         * @exports CDOTAClientMsg_EventPointsTip
         * @classdesc Represents a CDOTAClientMsg_EventPointsTip.
         * @implements ICDOTAClientMsg_EventPointsTip
         * @constructor
         * @param {ICDOTAClientMsg_EventPointsTip=} [properties] Properties to set
         */
        function CDOTAClientMsg_EventPointsTip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_EventPointsTip recipient_player_id.
         * @member {number} recipient_player_id
         * @memberof CDOTAClientMsg_EventPointsTip
         * @instance
         */
        CDOTAClientMsg_EventPointsTip.prototype.recipient_player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_EventPointsTip instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {ICDOTAClientMsg_EventPointsTip=} [properties] Properties to set
         * @returns {CDOTAClientMsg_EventPointsTip} CDOTAClientMsg_EventPointsTip instance
         */
        CDOTAClientMsg_EventPointsTip.create = function create(properties) {
            return new CDOTAClientMsg_EventPointsTip(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EventPointsTip message. Does not implicitly {@link CDOTAClientMsg_EventPointsTip.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {ICDOTAClientMsg_EventPointsTip} message CDOTAClientMsg_EventPointsTip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EventPointsTip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recipient_player_id != null && Object.hasOwnProperty.call(message, "recipient_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.recipient_player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EventPointsTip message, length delimited. Does not implicitly {@link CDOTAClientMsg_EventPointsTip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {ICDOTAClientMsg_EventPointsTip} message CDOTAClientMsg_EventPointsTip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EventPointsTip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_EventPointsTip message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_EventPointsTip} CDOTAClientMsg_EventPointsTip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EventPointsTip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_EventPointsTip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recipient_player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_EventPointsTip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_EventPointsTip} CDOTAClientMsg_EventPointsTip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EventPointsTip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_EventPointsTip message.
         * @function verify
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_EventPointsTip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recipient_player_id != null && message.hasOwnProperty("recipient_player_id"))
                if (!$util.isInteger(message.recipient_player_id))
                    return "recipient_player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_EventPointsTip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_EventPointsTip} CDOTAClientMsg_EventPointsTip
         */
        CDOTAClientMsg_EventPointsTip.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_EventPointsTip)
                return object;
            var message = new $root.CDOTAClientMsg_EventPointsTip();
            if (object.recipient_player_id != null)
                message.recipient_player_id = object.recipient_player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_EventPointsTip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_EventPointsTip
         * @static
         * @param {CDOTAClientMsg_EventPointsTip} message CDOTAClientMsg_EventPointsTip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_EventPointsTip.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.recipient_player_id = 0;
            if (message.recipient_player_id != null && message.hasOwnProperty("recipient_player_id"))
                object.recipient_player_id = message.recipient_player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_EventPointsTip to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_EventPointsTip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_EventPointsTip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_EventPointsTip;
    })();
    
    $root.CDOTAClientMsg_ExecuteOrders = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ExecuteOrders.
         * @exports ICDOTAClientMsg_ExecuteOrders
         * @interface ICDOTAClientMsg_ExecuteOrders
         * @property {Array.<ICDOTAMsg_UnitOrder>|null} [orders] CDOTAClientMsg_ExecuteOrders orders
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ExecuteOrders.
         * @exports CDOTAClientMsg_ExecuteOrders
         * @classdesc Represents a CDOTAClientMsg_ExecuteOrders.
         * @implements ICDOTAClientMsg_ExecuteOrders
         * @constructor
         * @param {ICDOTAClientMsg_ExecuteOrders=} [properties] Properties to set
         */
        function CDOTAClientMsg_ExecuteOrders(properties) {
            this.orders = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ExecuteOrders orders.
         * @member {Array.<ICDOTAMsg_UnitOrder>} orders
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @instance
         */
        CDOTAClientMsg_ExecuteOrders.prototype.orders = $util.emptyArray;
    
        /**
         * Creates a new CDOTAClientMsg_ExecuteOrders instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {ICDOTAClientMsg_ExecuteOrders=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ExecuteOrders} CDOTAClientMsg_ExecuteOrders instance
         */
        CDOTAClientMsg_ExecuteOrders.create = function create(properties) {
            return new CDOTAClientMsg_ExecuteOrders(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ExecuteOrders message. Does not implicitly {@link CDOTAClientMsg_ExecuteOrders.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {ICDOTAClientMsg_ExecuteOrders} message CDOTAClientMsg_ExecuteOrders message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ExecuteOrders.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orders != null && message.orders.length)
                for (var i = 0; i < message.orders.length; ++i)
                    $root.CDOTAMsg_UnitOrder.encode(message.orders[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ExecuteOrders message, length delimited. Does not implicitly {@link CDOTAClientMsg_ExecuteOrders.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {ICDOTAClientMsg_ExecuteOrders} message CDOTAClientMsg_ExecuteOrders message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ExecuteOrders.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ExecuteOrders message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ExecuteOrders} CDOTAClientMsg_ExecuteOrders
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ExecuteOrders.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ExecuteOrders();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.orders && message.orders.length))
                        message.orders = [];
                    message.orders.push($root.CDOTAMsg_UnitOrder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ExecuteOrders message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ExecuteOrders} CDOTAClientMsg_ExecuteOrders
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ExecuteOrders.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ExecuteOrders message.
         * @function verify
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ExecuteOrders.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orders != null && message.hasOwnProperty("orders")) {
                if (!Array.isArray(message.orders))
                    return "orders: array expected";
                for (var i = 0; i < message.orders.length; ++i) {
                    var error = $root.CDOTAMsg_UnitOrder.verify(message.orders[i]);
                    if (error)
                        return "orders." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ExecuteOrders message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ExecuteOrders} CDOTAClientMsg_ExecuteOrders
         */
        CDOTAClientMsg_ExecuteOrders.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ExecuteOrders)
                return object;
            var message = new $root.CDOTAClientMsg_ExecuteOrders();
            if (object.orders) {
                if (!Array.isArray(object.orders))
                    throw TypeError(".CDOTAClientMsg_ExecuteOrders.orders: array expected");
                message.orders = [];
                for (var i = 0; i < object.orders.length; ++i) {
                    if (typeof object.orders[i] !== "object")
                        throw TypeError(".CDOTAClientMsg_ExecuteOrders.orders: object expected");
                    message.orders[i] = $root.CDOTAMsg_UnitOrder.fromObject(object.orders[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ExecuteOrders message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @static
         * @param {CDOTAClientMsg_ExecuteOrders} message CDOTAClientMsg_ExecuteOrders
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ExecuteOrders.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orders = [];
            if (message.orders && message.orders.length) {
                object.orders = [];
                for (var j = 0; j < message.orders.length; ++j)
                    object.orders[j] = $root.CDOTAMsg_UnitOrder.toObject(message.orders[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ExecuteOrders to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ExecuteOrders
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ExecuteOrders.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ExecuteOrders;
    })();
    
    $root.CDOTAClientMsg_XPAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_XPAlert.
         * @exports ICDOTAClientMsg_XPAlert
         * @interface ICDOTAClientMsg_XPAlert
         * @property {number|null} [target_entindex] CDOTAClientMsg_XPAlert target_entindex
         * @property {number|null} [damage_taken] CDOTAClientMsg_XPAlert damage_taken
         */
    
        /**
         * Constructs a new CDOTAClientMsg_XPAlert.
         * @exports CDOTAClientMsg_XPAlert
         * @classdesc Represents a CDOTAClientMsg_XPAlert.
         * @implements ICDOTAClientMsg_XPAlert
         * @constructor
         * @param {ICDOTAClientMsg_XPAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_XPAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_XPAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_XPAlert
         * @instance
         */
        CDOTAClientMsg_XPAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAClientMsg_XPAlert damage_taken.
         * @member {number} damage_taken
         * @memberof CDOTAClientMsg_XPAlert
         * @instance
         */
        CDOTAClientMsg_XPAlert.prototype.damage_taken = 0;
    
        /**
         * Creates a new CDOTAClientMsg_XPAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {ICDOTAClientMsg_XPAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_XPAlert} CDOTAClientMsg_XPAlert instance
         */
        CDOTAClientMsg_XPAlert.create = function create(properties) {
            return new CDOTAClientMsg_XPAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_XPAlert message. Does not implicitly {@link CDOTAClientMsg_XPAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {ICDOTAClientMsg_XPAlert} message CDOTAClientMsg_XPAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_XPAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entindex);
            if (message.damage_taken != null && Object.hasOwnProperty.call(message, "damage_taken"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.damage_taken);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_XPAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_XPAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {ICDOTAClientMsg_XPAlert} message CDOTAClientMsg_XPAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_XPAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_XPAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_XPAlert} CDOTAClientMsg_XPAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_XPAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_XPAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entindex = reader.uint32();
                    break;
                case 2:
                    message.damage_taken = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_XPAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_XPAlert} CDOTAClientMsg_XPAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_XPAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_XPAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_XPAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.damage_taken != null && message.hasOwnProperty("damage_taken"))
                if (!$util.isInteger(message.damage_taken))
                    return "damage_taken: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_XPAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_XPAlert} CDOTAClientMsg_XPAlert
         */
        CDOTAClientMsg_XPAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_XPAlert)
                return object;
            var message = new $root.CDOTAClientMsg_XPAlert();
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.damage_taken != null)
                message.damage_taken = object.damage_taken >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_XPAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_XPAlert
         * @static
         * @param {CDOTAClientMsg_XPAlert} message CDOTAClientMsg_XPAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_XPAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_entindex = 0;
                object.damage_taken = 0;
            }
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.damage_taken != null && message.hasOwnProperty("damage_taken"))
                object.damage_taken = message.damage_taken;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_XPAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_XPAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_XPAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_XPAlert;
    })();
    
    $root.CDOTAClientMsg_TalentTreeAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_TalentTreeAlert.
         * @exports ICDOTAClientMsg_TalentTreeAlert
         * @interface ICDOTAClientMsg_TalentTreeAlert
         * @property {number|null} [target_entindex] CDOTAClientMsg_TalentTreeAlert target_entindex
         * @property {number|null} [ability_id] CDOTAClientMsg_TalentTreeAlert ability_id
         * @property {number|null} [slot] CDOTAClientMsg_TalentTreeAlert slot
         * @property {boolean|null} [learned] CDOTAClientMsg_TalentTreeAlert learned
         */
    
        /**
         * Constructs a new CDOTAClientMsg_TalentTreeAlert.
         * @exports CDOTAClientMsg_TalentTreeAlert
         * @classdesc Represents a CDOTAClientMsg_TalentTreeAlert.
         * @implements ICDOTAClientMsg_TalentTreeAlert
         * @constructor
         * @param {ICDOTAClientMsg_TalentTreeAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_TalentTreeAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_TalentTreeAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @instance
         */
        CDOTAClientMsg_TalentTreeAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAClientMsg_TalentTreeAlert ability_id.
         * @member {number} ability_id
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @instance
         */
        CDOTAClientMsg_TalentTreeAlert.prototype.ability_id = 0;
    
        /**
         * CDOTAClientMsg_TalentTreeAlert slot.
         * @member {number} slot
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @instance
         */
        CDOTAClientMsg_TalentTreeAlert.prototype.slot = 0;
    
        /**
         * CDOTAClientMsg_TalentTreeAlert learned.
         * @member {boolean} learned
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @instance
         */
        CDOTAClientMsg_TalentTreeAlert.prototype.learned = false;
    
        /**
         * Creates a new CDOTAClientMsg_TalentTreeAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {ICDOTAClientMsg_TalentTreeAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_TalentTreeAlert} CDOTAClientMsg_TalentTreeAlert instance
         */
        CDOTAClientMsg_TalentTreeAlert.create = function create(properties) {
            return new CDOTAClientMsg_TalentTreeAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_TalentTreeAlert message. Does not implicitly {@link CDOTAClientMsg_TalentTreeAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {ICDOTAClientMsg_TalentTreeAlert} message CDOTAClientMsg_TalentTreeAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_TalentTreeAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entindex);
            if (message.ability_id != null && Object.hasOwnProperty.call(message, "ability_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ability_id);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.slot);
            if (message.learned != null && Object.hasOwnProperty.call(message, "learned"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.learned);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_TalentTreeAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_TalentTreeAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {ICDOTAClientMsg_TalentTreeAlert} message CDOTAClientMsg_TalentTreeAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_TalentTreeAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_TalentTreeAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_TalentTreeAlert} CDOTAClientMsg_TalentTreeAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_TalentTreeAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_TalentTreeAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entindex = reader.uint32();
                    break;
                case 2:
                    message.ability_id = reader.int32();
                    break;
                case 3:
                    message.slot = reader.int32();
                    break;
                case 4:
                    message.learned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_TalentTreeAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_TalentTreeAlert} CDOTAClientMsg_TalentTreeAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_TalentTreeAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_TalentTreeAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_TalentTreeAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                if (!$util.isInteger(message.ability_id))
                    return "ability_id: integer expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            if (message.learned != null && message.hasOwnProperty("learned"))
                if (typeof message.learned !== "boolean")
                    return "learned: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_TalentTreeAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_TalentTreeAlert} CDOTAClientMsg_TalentTreeAlert
         */
        CDOTAClientMsg_TalentTreeAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_TalentTreeAlert)
                return object;
            var message = new $root.CDOTAClientMsg_TalentTreeAlert();
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.ability_id != null)
                message.ability_id = object.ability_id | 0;
            if (object.slot != null)
                message.slot = object.slot | 0;
            if (object.learned != null)
                message.learned = Boolean(object.learned);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_TalentTreeAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @static
         * @param {CDOTAClientMsg_TalentTreeAlert} message CDOTAClientMsg_TalentTreeAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_TalentTreeAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_entindex = 0;
                object.ability_id = 0;
                object.slot = 0;
                object.learned = false;
            }
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.ability_id != null && message.hasOwnProperty("ability_id"))
                object.ability_id = message.ability_id;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.learned != null && message.hasOwnProperty("learned"))
                object.learned = message.learned;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_TalentTreeAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_TalentTreeAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_TalentTreeAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_TalentTreeAlert;
    })();
    
    $root.CDOTAClientMsg_KillcamDamageTaken = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_KillcamDamageTaken.
         * @exports ICDOTAClientMsg_KillcamDamageTaken
         * @interface ICDOTAClientMsg_KillcamDamageTaken
         * @property {number|null} [target_entindex] CDOTAClientMsg_KillcamDamageTaken target_entindex
         * @property {number|null} [damage_taken] CDOTAClientMsg_KillcamDamageTaken damage_taken
         * @property {number|null} [item_type] CDOTAClientMsg_KillcamDamageTaken item_type
         * @property {number|null} [item_ability_id] CDOTAClientMsg_KillcamDamageTaken item_ability_id
         * @property {string|null} [hero_name] CDOTAClientMsg_KillcamDamageTaken hero_name
         * @property {string|null} [damage_color] CDOTAClientMsg_KillcamDamageTaken damage_color
         */
    
        /**
         * Constructs a new CDOTAClientMsg_KillcamDamageTaken.
         * @exports CDOTAClientMsg_KillcamDamageTaken
         * @classdesc Represents a CDOTAClientMsg_KillcamDamageTaken.
         * @implements ICDOTAClientMsg_KillcamDamageTaken
         * @constructor
         * @param {ICDOTAClientMsg_KillcamDamageTaken=} [properties] Properties to set
         */
        function CDOTAClientMsg_KillcamDamageTaken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_KillcamDamageTaken target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.target_entindex = 0;
    
        /**
         * CDOTAClientMsg_KillcamDamageTaken damage_taken.
         * @member {number} damage_taken
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.damage_taken = 0;
    
        /**
         * CDOTAClientMsg_KillcamDamageTaken item_type.
         * @member {number} item_type
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.item_type = 0;
    
        /**
         * CDOTAClientMsg_KillcamDamageTaken item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.item_ability_id = 0;
    
        /**
         * CDOTAClientMsg_KillcamDamageTaken hero_name.
         * @member {string} hero_name
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.hero_name = "";
    
        /**
         * CDOTAClientMsg_KillcamDamageTaken damage_color.
         * @member {string} damage_color
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.damage_color = "";
    
        /**
         * Creates a new CDOTAClientMsg_KillcamDamageTaken instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {ICDOTAClientMsg_KillcamDamageTaken=} [properties] Properties to set
         * @returns {CDOTAClientMsg_KillcamDamageTaken} CDOTAClientMsg_KillcamDamageTaken instance
         */
        CDOTAClientMsg_KillcamDamageTaken.create = function create(properties) {
            return new CDOTAClientMsg_KillcamDamageTaken(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_KillcamDamageTaken message. Does not implicitly {@link CDOTAClientMsg_KillcamDamageTaken.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {ICDOTAClientMsg_KillcamDamageTaken} message CDOTAClientMsg_KillcamDamageTaken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_KillcamDamageTaken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entindex);
            if (message.damage_taken != null && Object.hasOwnProperty.call(message, "damage_taken"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.damage_taken);
            if (message.item_type != null && Object.hasOwnProperty.call(message, "item_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.item_type);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.item_ability_id);
            if (message.hero_name != null && Object.hasOwnProperty.call(message, "hero_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.hero_name);
            if (message.damage_color != null && Object.hasOwnProperty.call(message, "damage_color"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.damage_color);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_KillcamDamageTaken message, length delimited. Does not implicitly {@link CDOTAClientMsg_KillcamDamageTaken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {ICDOTAClientMsg_KillcamDamageTaken} message CDOTAClientMsg_KillcamDamageTaken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_KillcamDamageTaken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_KillcamDamageTaken message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_KillcamDamageTaken} CDOTAClientMsg_KillcamDamageTaken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_KillcamDamageTaken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_KillcamDamageTaken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entindex = reader.uint32();
                    break;
                case 2:
                    message.damage_taken = reader.uint32();
                    break;
                case 3:
                    message.item_type = reader.uint32();
                    break;
                case 4:
                    message.item_ability_id = reader.uint32();
                    break;
                case 5:
                    message.hero_name = reader.string();
                    break;
                case 6:
                    message.damage_color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_KillcamDamageTaken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_KillcamDamageTaken} CDOTAClientMsg_KillcamDamageTaken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_KillcamDamageTaken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_KillcamDamageTaken message.
         * @function verify
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_KillcamDamageTaken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.damage_taken != null && message.hasOwnProperty("damage_taken"))
                if (!$util.isInteger(message.damage_taken))
                    return "damage_taken: integer expected";
            if (message.item_type != null && message.hasOwnProperty("item_type"))
                if (!$util.isInteger(message.item_type))
                    return "item_type: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            if (message.hero_name != null && message.hasOwnProperty("hero_name"))
                if (!$util.isString(message.hero_name))
                    return "hero_name: string expected";
            if (message.damage_color != null && message.hasOwnProperty("damage_color"))
                if (!$util.isString(message.damage_color))
                    return "damage_color: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_KillcamDamageTaken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_KillcamDamageTaken} CDOTAClientMsg_KillcamDamageTaken
         */
        CDOTAClientMsg_KillcamDamageTaken.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_KillcamDamageTaken)
                return object;
            var message = new $root.CDOTAClientMsg_KillcamDamageTaken();
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            if (object.damage_taken != null)
                message.damage_taken = object.damage_taken >>> 0;
            if (object.item_type != null)
                message.item_type = object.item_type >>> 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id >>> 0;
            if (object.hero_name != null)
                message.hero_name = String(object.hero_name);
            if (object.damage_color != null)
                message.damage_color = String(object.damage_color);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_KillcamDamageTaken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @static
         * @param {CDOTAClientMsg_KillcamDamageTaken} message CDOTAClientMsg_KillcamDamageTaken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_KillcamDamageTaken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_entindex = 0;
                object.damage_taken = 0;
                object.item_type = 0;
                object.item_ability_id = 0;
                object.hero_name = "";
                object.damage_color = "";
            }
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.damage_taken != null && message.hasOwnProperty("damage_taken"))
                object.damage_taken = message.damage_taken;
            if (message.item_type != null && message.hasOwnProperty("item_type"))
                object.item_type = message.item_type;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            if (message.hero_name != null && message.hasOwnProperty("hero_name"))
                object.hero_name = message.hero_name;
            if (message.damage_color != null && message.hasOwnProperty("damage_color"))
                object.damage_color = message.damage_color;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_KillcamDamageTaken to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_KillcamDamageTaken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_KillcamDamageTaken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_KillcamDamageTaken;
    })();
    
    $root.CDOTAClientMsg_MatchMetadata = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_MatchMetadata.
         * @exports ICDOTAClientMsg_MatchMetadata
         * @interface ICDOTAClientMsg_MatchMetadata
         * @property {number|Long|null} [match_id] CDOTAClientMsg_MatchMetadata match_id
         * @property {Uint8Array|null} [metadata] CDOTAClientMsg_MatchMetadata metadata
         */
    
        /**
         * Constructs a new CDOTAClientMsg_MatchMetadata.
         * @exports CDOTAClientMsg_MatchMetadata
         * @classdesc Represents a CDOTAClientMsg_MatchMetadata.
         * @implements ICDOTAClientMsg_MatchMetadata
         * @constructor
         * @param {ICDOTAClientMsg_MatchMetadata=} [properties] Properties to set
         */
        function CDOTAClientMsg_MatchMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_MatchMetadata match_id.
         * @member {number|Long} match_id
         * @memberof CDOTAClientMsg_MatchMetadata
         * @instance
         */
        CDOTAClientMsg_MatchMetadata.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAClientMsg_MatchMetadata metadata.
         * @member {Uint8Array} metadata
         * @memberof CDOTAClientMsg_MatchMetadata
         * @instance
         */
        CDOTAClientMsg_MatchMetadata.prototype.metadata = $util.newBuffer([]);
    
        /**
         * Creates a new CDOTAClientMsg_MatchMetadata instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {ICDOTAClientMsg_MatchMetadata=} [properties] Properties to set
         * @returns {CDOTAClientMsg_MatchMetadata} CDOTAClientMsg_MatchMetadata instance
         */
        CDOTAClientMsg_MatchMetadata.create = function create(properties) {
            return new CDOTAClientMsg_MatchMetadata(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MatchMetadata message. Does not implicitly {@link CDOTAClientMsg_MatchMetadata.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {ICDOTAClientMsg_MatchMetadata} message CDOTAClientMsg_MatchMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MatchMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.match_id);
            if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MatchMetadata message, length delimited. Does not implicitly {@link CDOTAClientMsg_MatchMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {ICDOTAClientMsg_MatchMetadata} message CDOTAClientMsg_MatchMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MatchMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_MatchMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_MatchMetadata} CDOTAClientMsg_MatchMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MatchMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_MatchMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.match_id = reader.uint64();
                    break;
                case 2:
                    message.metadata = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_MatchMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_MatchMetadata} CDOTAClientMsg_MatchMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MatchMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_MatchMetadata message.
         * @function verify
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_MatchMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                    return "metadata: buffer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_MatchMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_MatchMetadata} CDOTAClientMsg_MatchMetadata
         */
        CDOTAClientMsg_MatchMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_MatchMetadata)
                return object;
            var message = new $root.CDOTAClientMsg_MatchMetadata();
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.metadata != null)
                if (typeof object.metadata === "string")
                    $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                else if (object.metadata.length)
                    message.metadata = object.metadata;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_MatchMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_MatchMetadata
         * @static
         * @param {CDOTAClientMsg_MatchMetadata} message CDOTAClientMsg_MatchMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_MatchMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.metadata = "";
                else {
                    object.metadata = [];
                    if (options.bytes !== Array)
                        object.metadata = $util.newBuffer(object.metadata);
                }
            }
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_MatchMetadata to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_MatchMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_MatchMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_MatchMetadata;
    })();
    
    $root.CDOTAClientMsg_KillMyHero = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_KillMyHero.
         * @exports ICDOTAClientMsg_KillMyHero
         * @interface ICDOTAClientMsg_KillMyHero
         */
    
        /**
         * Constructs a new CDOTAClientMsg_KillMyHero.
         * @exports CDOTAClientMsg_KillMyHero
         * @classdesc Represents a CDOTAClientMsg_KillMyHero.
         * @implements ICDOTAClientMsg_KillMyHero
         * @constructor
         * @param {ICDOTAClientMsg_KillMyHero=} [properties] Properties to set
         */
        function CDOTAClientMsg_KillMyHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAClientMsg_KillMyHero instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {ICDOTAClientMsg_KillMyHero=} [properties] Properties to set
         * @returns {CDOTAClientMsg_KillMyHero} CDOTAClientMsg_KillMyHero instance
         */
        CDOTAClientMsg_KillMyHero.create = function create(properties) {
            return new CDOTAClientMsg_KillMyHero(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_KillMyHero message. Does not implicitly {@link CDOTAClientMsg_KillMyHero.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {ICDOTAClientMsg_KillMyHero} message CDOTAClientMsg_KillMyHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_KillMyHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_KillMyHero message, length delimited. Does not implicitly {@link CDOTAClientMsg_KillMyHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {ICDOTAClientMsg_KillMyHero} message CDOTAClientMsg_KillMyHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_KillMyHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_KillMyHero message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_KillMyHero} CDOTAClientMsg_KillMyHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_KillMyHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_KillMyHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_KillMyHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_KillMyHero} CDOTAClientMsg_KillMyHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_KillMyHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_KillMyHero message.
         * @function verify
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_KillMyHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_KillMyHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_KillMyHero} CDOTAClientMsg_KillMyHero
         */
        CDOTAClientMsg_KillMyHero.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_KillMyHero)
                return object;
            return new $root.CDOTAClientMsg_KillMyHero();
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_KillMyHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_KillMyHero
         * @static
         * @param {CDOTAClientMsg_KillMyHero} message CDOTAClientMsg_KillMyHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_KillMyHero.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAClientMsg_KillMyHero to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_KillMyHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_KillMyHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_KillMyHero;
    })();
    
    $root.CDOTAClientMsg_QuestStatus = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_QuestStatus.
         * @exports ICDOTAClientMsg_QuestStatus
         * @interface ICDOTAClientMsg_QuestStatus
         * @property {number|null} [quest_id] CDOTAClientMsg_QuestStatus quest_id
         * @property {number|null} [challenge_id] CDOTAClientMsg_QuestStatus challenge_id
         * @property {number|null} [progress] CDOTAClientMsg_QuestStatus progress
         * @property {number|null} [goal] CDOTAClientMsg_QuestStatus goal
         * @property {number|null} [query] CDOTAClientMsg_QuestStatus query
         * @property {number|null} [fail_gametime] CDOTAClientMsg_QuestStatus fail_gametime
         * @property {number|null} [item_ability_id] CDOTAClientMsg_QuestStatus item_ability_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_QuestStatus.
         * @exports CDOTAClientMsg_QuestStatus
         * @classdesc Represents a CDOTAClientMsg_QuestStatus.
         * @implements ICDOTAClientMsg_QuestStatus
         * @constructor
         * @param {ICDOTAClientMsg_QuestStatus=} [properties] Properties to set
         */
        function CDOTAClientMsg_QuestStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_QuestStatus quest_id.
         * @member {number} quest_id
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.quest_id = 0;
    
        /**
         * CDOTAClientMsg_QuestStatus challenge_id.
         * @member {number} challenge_id
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.challenge_id = 0;
    
        /**
         * CDOTAClientMsg_QuestStatus progress.
         * @member {number} progress
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.progress = 0;
    
        /**
         * CDOTAClientMsg_QuestStatus goal.
         * @member {number} goal
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.goal = 0;
    
        /**
         * CDOTAClientMsg_QuestStatus query.
         * @member {number} query
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.query = 0;
    
        /**
         * CDOTAClientMsg_QuestStatus fail_gametime.
         * @member {number} fail_gametime
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.fail_gametime = 0;
    
        /**
         * CDOTAClientMsg_QuestStatus item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         */
        CDOTAClientMsg_QuestStatus.prototype.item_ability_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_QuestStatus instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {ICDOTAClientMsg_QuestStatus=} [properties] Properties to set
         * @returns {CDOTAClientMsg_QuestStatus} CDOTAClientMsg_QuestStatus instance
         */
        CDOTAClientMsg_QuestStatus.create = function create(properties) {
            return new CDOTAClientMsg_QuestStatus(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_QuestStatus message. Does not implicitly {@link CDOTAClientMsg_QuestStatus.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {ICDOTAClientMsg_QuestStatus} message CDOTAClientMsg_QuestStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_QuestStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quest_id != null && Object.hasOwnProperty.call(message, "quest_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.quest_id);
            if (message.challenge_id != null && Object.hasOwnProperty.call(message, "challenge_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.challenge_id);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.progress);
            if (message.goal != null && Object.hasOwnProperty.call(message, "goal"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.goal);
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.query);
            if (message.fail_gametime != null && Object.hasOwnProperty.call(message, "fail_gametime"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.fail_gametime);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.item_ability_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_QuestStatus message, length delimited. Does not implicitly {@link CDOTAClientMsg_QuestStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {ICDOTAClientMsg_QuestStatus} message CDOTAClientMsg_QuestStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_QuestStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_QuestStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_QuestStatus} CDOTAClientMsg_QuestStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_QuestStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_QuestStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.quest_id = reader.uint32();
                    break;
                case 2:
                    message.challenge_id = reader.uint32();
                    break;
                case 3:
                    message.progress = reader.uint32();
                    break;
                case 4:
                    message.goal = reader.uint32();
                    break;
                case 5:
                    message.query = reader.uint32();
                    break;
                case 6:
                    message.fail_gametime = reader.float();
                    break;
                case 7:
                    message.item_ability_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_QuestStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_QuestStatus} CDOTAClientMsg_QuestStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_QuestStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_QuestStatus message.
         * @function verify
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_QuestStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.quest_id != null && message.hasOwnProperty("quest_id"))
                if (!$util.isInteger(message.quest_id))
                    return "quest_id: integer expected";
            if (message.challenge_id != null && message.hasOwnProperty("challenge_id"))
                if (!$util.isInteger(message.challenge_id))
                    return "challenge_id: integer expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            if (message.goal != null && message.hasOwnProperty("goal"))
                if (!$util.isInteger(message.goal))
                    return "goal: integer expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isInteger(message.query))
                    return "query: integer expected";
            if (message.fail_gametime != null && message.hasOwnProperty("fail_gametime"))
                if (typeof message.fail_gametime !== "number")
                    return "fail_gametime: number expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_QuestStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_QuestStatus} CDOTAClientMsg_QuestStatus
         */
        CDOTAClientMsg_QuestStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_QuestStatus)
                return object;
            var message = new $root.CDOTAClientMsg_QuestStatus();
            if (object.quest_id != null)
                message.quest_id = object.quest_id >>> 0;
            if (object.challenge_id != null)
                message.challenge_id = object.challenge_id >>> 0;
            if (object.progress != null)
                message.progress = object.progress >>> 0;
            if (object.goal != null)
                message.goal = object.goal >>> 0;
            if (object.query != null)
                message.query = object.query >>> 0;
            if (object.fail_gametime != null)
                message.fail_gametime = Number(object.fail_gametime);
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_QuestStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_QuestStatus
         * @static
         * @param {CDOTAClientMsg_QuestStatus} message CDOTAClientMsg_QuestStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_QuestStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.quest_id = 0;
                object.challenge_id = 0;
                object.progress = 0;
                object.goal = 0;
                object.query = 0;
                object.fail_gametime = 0;
                object.item_ability_id = 0;
            }
            if (message.quest_id != null && message.hasOwnProperty("quest_id"))
                object.quest_id = message.quest_id;
            if (message.challenge_id != null && message.hasOwnProperty("challenge_id"))
                object.challenge_id = message.challenge_id;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            if (message.goal != null && message.hasOwnProperty("goal"))
                object.goal = message.goal;
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.fail_gametime != null && message.hasOwnProperty("fail_gametime"))
                object.fail_gametime = options.json && !isFinite(message.fail_gametime) ? String(message.fail_gametime) : message.fail_gametime;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_QuestStatus to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_QuestStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_QuestStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_QuestStatus;
    })();
    
    $root.CDOTAClientMsg_ToggleAutoattack = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_ToggleAutoattack.
         * @exports ICDOTAClientMsg_ToggleAutoattack
         * @interface ICDOTAClientMsg_ToggleAutoattack
         * @property {number|null} [mode] CDOTAClientMsg_ToggleAutoattack mode
         * @property {boolean|null} [show_message] CDOTAClientMsg_ToggleAutoattack show_message
         */
    
        /**
         * Constructs a new CDOTAClientMsg_ToggleAutoattack.
         * @exports CDOTAClientMsg_ToggleAutoattack
         * @classdesc Represents a CDOTAClientMsg_ToggleAutoattack.
         * @implements ICDOTAClientMsg_ToggleAutoattack
         * @constructor
         * @param {ICDOTAClientMsg_ToggleAutoattack=} [properties] Properties to set
         */
        function CDOTAClientMsg_ToggleAutoattack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_ToggleAutoattack mode.
         * @member {number} mode
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @instance
         */
        CDOTAClientMsg_ToggleAutoattack.prototype.mode = 0;
    
        /**
         * CDOTAClientMsg_ToggleAutoattack show_message.
         * @member {boolean} show_message
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @instance
         */
        CDOTAClientMsg_ToggleAutoattack.prototype.show_message = false;
    
        /**
         * Creates a new CDOTAClientMsg_ToggleAutoattack instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {ICDOTAClientMsg_ToggleAutoattack=} [properties] Properties to set
         * @returns {CDOTAClientMsg_ToggleAutoattack} CDOTAClientMsg_ToggleAutoattack instance
         */
        CDOTAClientMsg_ToggleAutoattack.create = function create(properties) {
            return new CDOTAClientMsg_ToggleAutoattack(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ToggleAutoattack message. Does not implicitly {@link CDOTAClientMsg_ToggleAutoattack.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {ICDOTAClientMsg_ToggleAutoattack} message CDOTAClientMsg_ToggleAutoattack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ToggleAutoattack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            if (message.show_message != null && Object.hasOwnProperty.call(message, "show_message"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.show_message);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_ToggleAutoattack message, length delimited. Does not implicitly {@link CDOTAClientMsg_ToggleAutoattack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {ICDOTAClientMsg_ToggleAutoattack} message CDOTAClientMsg_ToggleAutoattack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_ToggleAutoattack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_ToggleAutoattack message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_ToggleAutoattack} CDOTAClientMsg_ToggleAutoattack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ToggleAutoattack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_ToggleAutoattack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                case 2:
                    message.show_message = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_ToggleAutoattack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_ToggleAutoattack} CDOTAClientMsg_ToggleAutoattack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_ToggleAutoattack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_ToggleAutoattack message.
         * @function verify
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_ToggleAutoattack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                if (!$util.isInteger(message.mode))
                    return "mode: integer expected";
            if (message.show_message != null && message.hasOwnProperty("show_message"))
                if (typeof message.show_message !== "boolean")
                    return "show_message: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_ToggleAutoattack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_ToggleAutoattack} CDOTAClientMsg_ToggleAutoattack
         */
        CDOTAClientMsg_ToggleAutoattack.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_ToggleAutoattack)
                return object;
            var message = new $root.CDOTAClientMsg_ToggleAutoattack();
            if (object.mode != null)
                message.mode = object.mode | 0;
            if (object.show_message != null)
                message.show_message = Boolean(object.show_message);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_ToggleAutoattack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @static
         * @param {CDOTAClientMsg_ToggleAutoattack} message CDOTAClientMsg_ToggleAutoattack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_ToggleAutoattack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mode = 0;
                object.show_message = false;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = message.mode;
            if (message.show_message != null && message.hasOwnProperty("show_message"))
                object.show_message = message.show_message;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_ToggleAutoattack to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_ToggleAutoattack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_ToggleAutoattack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_ToggleAutoattack;
    })();
    
    $root.CDOTAClientMsg_SpecialAbility = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SpecialAbility.
         * @exports ICDOTAClientMsg_SpecialAbility
         * @interface ICDOTAClientMsg_SpecialAbility
         * @property {number|null} [ability_index] CDOTAClientMsg_SpecialAbility ability_index
         * @property {number|null} [target_entindex] CDOTAClientMsg_SpecialAbility target_entindex
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SpecialAbility.
         * @exports CDOTAClientMsg_SpecialAbility
         * @classdesc Represents a CDOTAClientMsg_SpecialAbility.
         * @implements ICDOTAClientMsg_SpecialAbility
         * @constructor
         * @param {ICDOTAClientMsg_SpecialAbility=} [properties] Properties to set
         */
        function CDOTAClientMsg_SpecialAbility(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SpecialAbility ability_index.
         * @member {number} ability_index
         * @memberof CDOTAClientMsg_SpecialAbility
         * @instance
         */
        CDOTAClientMsg_SpecialAbility.prototype.ability_index = 0;
    
        /**
         * CDOTAClientMsg_SpecialAbility target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_SpecialAbility
         * @instance
         */
        CDOTAClientMsg_SpecialAbility.prototype.target_entindex = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SpecialAbility instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {ICDOTAClientMsg_SpecialAbility=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SpecialAbility} CDOTAClientMsg_SpecialAbility instance
         */
        CDOTAClientMsg_SpecialAbility.create = function create(properties) {
            return new CDOTAClientMsg_SpecialAbility(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SpecialAbility message. Does not implicitly {@link CDOTAClientMsg_SpecialAbility.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {ICDOTAClientMsg_SpecialAbility} message CDOTAClientMsg_SpecialAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SpecialAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ability_index != null && Object.hasOwnProperty.call(message, "ability_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ability_index);
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SpecialAbility message, length delimited. Does not implicitly {@link CDOTAClientMsg_SpecialAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {ICDOTAClientMsg_SpecialAbility} message CDOTAClientMsg_SpecialAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SpecialAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SpecialAbility message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SpecialAbility} CDOTAClientMsg_SpecialAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SpecialAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SpecialAbility();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ability_index = reader.uint32();
                    break;
                case 2:
                    message.target_entindex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SpecialAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SpecialAbility} CDOTAClientMsg_SpecialAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SpecialAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SpecialAbility message.
         * @function verify
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SpecialAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ability_index != null && message.hasOwnProperty("ability_index"))
                if (!$util.isInteger(message.ability_index))
                    return "ability_index: integer expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SpecialAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SpecialAbility} CDOTAClientMsg_SpecialAbility
         */
        CDOTAClientMsg_SpecialAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SpecialAbility)
                return object;
            var message = new $root.CDOTAClientMsg_SpecialAbility();
            if (object.ability_index != null)
                message.ability_index = object.ability_index >>> 0;
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SpecialAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SpecialAbility
         * @static
         * @param {CDOTAClientMsg_SpecialAbility} message CDOTAClientMsg_SpecialAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SpecialAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ability_index = 0;
                object.target_entindex = 0;
            }
            if (message.ability_index != null && message.hasOwnProperty("ability_index"))
                object.ability_index = message.ability_index;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SpecialAbility to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SpecialAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SpecialAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SpecialAbility;
    })();
    
    $root.CDOTAClientMsg_SetEnemyStartingPosition = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SetEnemyStartingPosition.
         * @exports ICDOTAClientMsg_SetEnemyStartingPosition
         * @interface ICDOTAClientMsg_SetEnemyStartingPosition
         * @property {number|null} [enemy_player_id] CDOTAClientMsg_SetEnemyStartingPosition enemy_player_id
         * @property {number|null} [enemy_starting_position] CDOTAClientMsg_SetEnemyStartingPosition enemy_starting_position
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SetEnemyStartingPosition.
         * @exports CDOTAClientMsg_SetEnemyStartingPosition
         * @classdesc Represents a CDOTAClientMsg_SetEnemyStartingPosition.
         * @implements ICDOTAClientMsg_SetEnemyStartingPosition
         * @constructor
         * @param {ICDOTAClientMsg_SetEnemyStartingPosition=} [properties] Properties to set
         */
        function CDOTAClientMsg_SetEnemyStartingPosition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SetEnemyStartingPosition enemy_player_id.
         * @member {number} enemy_player_id
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @instance
         */
        CDOTAClientMsg_SetEnemyStartingPosition.prototype.enemy_player_id = 0;
    
        /**
         * CDOTAClientMsg_SetEnemyStartingPosition enemy_starting_position.
         * @member {number} enemy_starting_position
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @instance
         */
        CDOTAClientMsg_SetEnemyStartingPosition.prototype.enemy_starting_position = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SetEnemyStartingPosition instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {ICDOTAClientMsg_SetEnemyStartingPosition=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SetEnemyStartingPosition} CDOTAClientMsg_SetEnemyStartingPosition instance
         */
        CDOTAClientMsg_SetEnemyStartingPosition.create = function create(properties) {
            return new CDOTAClientMsg_SetEnemyStartingPosition(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetEnemyStartingPosition message. Does not implicitly {@link CDOTAClientMsg_SetEnemyStartingPosition.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {ICDOTAClientMsg_SetEnemyStartingPosition} message CDOTAClientMsg_SetEnemyStartingPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetEnemyStartingPosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemy_player_id != null && Object.hasOwnProperty.call(message, "enemy_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.enemy_player_id);
            if (message.enemy_starting_position != null && Object.hasOwnProperty.call(message, "enemy_starting_position"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.enemy_starting_position);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetEnemyStartingPosition message, length delimited. Does not implicitly {@link CDOTAClientMsg_SetEnemyStartingPosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {ICDOTAClientMsg_SetEnemyStartingPosition} message CDOTAClientMsg_SetEnemyStartingPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetEnemyStartingPosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetEnemyStartingPosition message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SetEnemyStartingPosition} CDOTAClientMsg_SetEnemyStartingPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetEnemyStartingPosition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SetEnemyStartingPosition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemy_player_id = reader.uint32();
                    break;
                case 2:
                    message.enemy_starting_position = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetEnemyStartingPosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SetEnemyStartingPosition} CDOTAClientMsg_SetEnemyStartingPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetEnemyStartingPosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SetEnemyStartingPosition message.
         * @function verify
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SetEnemyStartingPosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enemy_player_id != null && message.hasOwnProperty("enemy_player_id"))
                if (!$util.isInteger(message.enemy_player_id))
                    return "enemy_player_id: integer expected";
            if (message.enemy_starting_position != null && message.hasOwnProperty("enemy_starting_position"))
                if (!$util.isInteger(message.enemy_starting_position))
                    return "enemy_starting_position: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SetEnemyStartingPosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SetEnemyStartingPosition} CDOTAClientMsg_SetEnemyStartingPosition
         */
        CDOTAClientMsg_SetEnemyStartingPosition.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SetEnemyStartingPosition)
                return object;
            var message = new $root.CDOTAClientMsg_SetEnemyStartingPosition();
            if (object.enemy_player_id != null)
                message.enemy_player_id = object.enemy_player_id >>> 0;
            if (object.enemy_starting_position != null)
                message.enemy_starting_position = object.enemy_starting_position >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SetEnemyStartingPosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @static
         * @param {CDOTAClientMsg_SetEnemyStartingPosition} message CDOTAClientMsg_SetEnemyStartingPosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SetEnemyStartingPosition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.enemy_player_id = 0;
                object.enemy_starting_position = 0;
            }
            if (message.enemy_player_id != null && message.hasOwnProperty("enemy_player_id"))
                object.enemy_player_id = message.enemy_player_id;
            if (message.enemy_starting_position != null && message.hasOwnProperty("enemy_starting_position"))
                object.enemy_starting_position = message.enemy_starting_position;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SetEnemyStartingPosition to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SetEnemyStartingPosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SetEnemyStartingPosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SetEnemyStartingPosition;
    })();
    
    $root.CDOTAClientMsg_SetDesiredWardPlacement = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SetDesiredWardPlacement.
         * @exports ICDOTAClientMsg_SetDesiredWardPlacement
         * @interface ICDOTAClientMsg_SetDesiredWardPlacement
         * @property {number|null} [ward_index] CDOTAClientMsg_SetDesiredWardPlacement ward_index
         * @property {number|null} [ward_x] CDOTAClientMsg_SetDesiredWardPlacement ward_x
         * @property {number|null} [ward_y] CDOTAClientMsg_SetDesiredWardPlacement ward_y
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SetDesiredWardPlacement.
         * @exports CDOTAClientMsg_SetDesiredWardPlacement
         * @classdesc Represents a CDOTAClientMsg_SetDesiredWardPlacement.
         * @implements ICDOTAClientMsg_SetDesiredWardPlacement
         * @constructor
         * @param {ICDOTAClientMsg_SetDesiredWardPlacement=} [properties] Properties to set
         */
        function CDOTAClientMsg_SetDesiredWardPlacement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SetDesiredWardPlacement ward_index.
         * @member {number} ward_index
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @instance
         */
        CDOTAClientMsg_SetDesiredWardPlacement.prototype.ward_index = 0;
    
        /**
         * CDOTAClientMsg_SetDesiredWardPlacement ward_x.
         * @member {number} ward_x
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @instance
         */
        CDOTAClientMsg_SetDesiredWardPlacement.prototype.ward_x = 0;
    
        /**
         * CDOTAClientMsg_SetDesiredWardPlacement ward_y.
         * @member {number} ward_y
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @instance
         */
        CDOTAClientMsg_SetDesiredWardPlacement.prototype.ward_y = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SetDesiredWardPlacement instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {ICDOTAClientMsg_SetDesiredWardPlacement=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SetDesiredWardPlacement} CDOTAClientMsg_SetDesiredWardPlacement instance
         */
        CDOTAClientMsg_SetDesiredWardPlacement.create = function create(properties) {
            return new CDOTAClientMsg_SetDesiredWardPlacement(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetDesiredWardPlacement message. Does not implicitly {@link CDOTAClientMsg_SetDesiredWardPlacement.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {ICDOTAClientMsg_SetDesiredWardPlacement} message CDOTAClientMsg_SetDesiredWardPlacement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetDesiredWardPlacement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ward_index != null && Object.hasOwnProperty.call(message, "ward_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ward_index);
            if (message.ward_x != null && Object.hasOwnProperty.call(message, "ward_x"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.ward_x);
            if (message.ward_y != null && Object.hasOwnProperty.call(message, "ward_y"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.ward_y);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetDesiredWardPlacement message, length delimited. Does not implicitly {@link CDOTAClientMsg_SetDesiredWardPlacement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {ICDOTAClientMsg_SetDesiredWardPlacement} message CDOTAClientMsg_SetDesiredWardPlacement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetDesiredWardPlacement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetDesiredWardPlacement message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SetDesiredWardPlacement} CDOTAClientMsg_SetDesiredWardPlacement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetDesiredWardPlacement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SetDesiredWardPlacement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ward_index = reader.uint32();
                    break;
                case 2:
                    message.ward_x = reader.float();
                    break;
                case 3:
                    message.ward_y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetDesiredWardPlacement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SetDesiredWardPlacement} CDOTAClientMsg_SetDesiredWardPlacement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetDesiredWardPlacement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SetDesiredWardPlacement message.
         * @function verify
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SetDesiredWardPlacement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ward_index != null && message.hasOwnProperty("ward_index"))
                if (!$util.isInteger(message.ward_index))
                    return "ward_index: integer expected";
            if (message.ward_x != null && message.hasOwnProperty("ward_x"))
                if (typeof message.ward_x !== "number")
                    return "ward_x: number expected";
            if (message.ward_y != null && message.hasOwnProperty("ward_y"))
                if (typeof message.ward_y !== "number")
                    return "ward_y: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SetDesiredWardPlacement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SetDesiredWardPlacement} CDOTAClientMsg_SetDesiredWardPlacement
         */
        CDOTAClientMsg_SetDesiredWardPlacement.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SetDesiredWardPlacement)
                return object;
            var message = new $root.CDOTAClientMsg_SetDesiredWardPlacement();
            if (object.ward_index != null)
                message.ward_index = object.ward_index >>> 0;
            if (object.ward_x != null)
                message.ward_x = Number(object.ward_x);
            if (object.ward_y != null)
                message.ward_y = Number(object.ward_y);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SetDesiredWardPlacement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @static
         * @param {CDOTAClientMsg_SetDesiredWardPlacement} message CDOTAClientMsg_SetDesiredWardPlacement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SetDesiredWardPlacement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ward_index = 0;
                object.ward_x = 0;
                object.ward_y = 0;
            }
            if (message.ward_index != null && message.hasOwnProperty("ward_index"))
                object.ward_index = message.ward_index;
            if (message.ward_x != null && message.hasOwnProperty("ward_x"))
                object.ward_x = options.json && !isFinite(message.ward_x) ? String(message.ward_x) : message.ward_x;
            if (message.ward_y != null && message.hasOwnProperty("ward_y"))
                object.ward_y = options.json && !isFinite(message.ward_y) ? String(message.ward_y) : message.ward_y;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SetDesiredWardPlacement to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SetDesiredWardPlacement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SetDesiredWardPlacement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SetDesiredWardPlacement;
    })();
    
    $root.CDOTAClientMsg_RollDice = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RollDice.
         * @exports ICDOTAClientMsg_RollDice
         * @interface ICDOTAClientMsg_RollDice
         * @property {number|null} [channel_type] CDOTAClientMsg_RollDice channel_type
         * @property {number|null} [roll_min] CDOTAClientMsg_RollDice roll_min
         * @property {number|null} [roll_max] CDOTAClientMsg_RollDice roll_max
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RollDice.
         * @exports CDOTAClientMsg_RollDice
         * @classdesc Represents a CDOTAClientMsg_RollDice.
         * @implements ICDOTAClientMsg_RollDice
         * @constructor
         * @param {ICDOTAClientMsg_RollDice=} [properties] Properties to set
         */
        function CDOTAClientMsg_RollDice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_RollDice channel_type.
         * @member {number} channel_type
         * @memberof CDOTAClientMsg_RollDice
         * @instance
         */
        CDOTAClientMsg_RollDice.prototype.channel_type = 0;
    
        /**
         * CDOTAClientMsg_RollDice roll_min.
         * @member {number} roll_min
         * @memberof CDOTAClientMsg_RollDice
         * @instance
         */
        CDOTAClientMsg_RollDice.prototype.roll_min = 0;
    
        /**
         * CDOTAClientMsg_RollDice roll_max.
         * @member {number} roll_max
         * @memberof CDOTAClientMsg_RollDice
         * @instance
         */
        CDOTAClientMsg_RollDice.prototype.roll_max = 0;
    
        /**
         * Creates a new CDOTAClientMsg_RollDice instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {ICDOTAClientMsg_RollDice=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RollDice} CDOTAClientMsg_RollDice instance
         */
        CDOTAClientMsg_RollDice.create = function create(properties) {
            return new CDOTAClientMsg_RollDice(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RollDice message. Does not implicitly {@link CDOTAClientMsg_RollDice.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {ICDOTAClientMsg_RollDice} message CDOTAClientMsg_RollDice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RollDice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel_type != null && Object.hasOwnProperty.call(message, "channel_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel_type);
            if (message.roll_min != null && Object.hasOwnProperty.call(message, "roll_min"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.roll_min);
            if (message.roll_max != null && Object.hasOwnProperty.call(message, "roll_max"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.roll_max);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RollDice message, length delimited. Does not implicitly {@link CDOTAClientMsg_RollDice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {ICDOTAClientMsg_RollDice} message CDOTAClientMsg_RollDice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RollDice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RollDice message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RollDice} CDOTAClientMsg_RollDice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RollDice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RollDice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channel_type = reader.uint32();
                    break;
                case 2:
                    message.roll_min = reader.uint32();
                    break;
                case 3:
                    message.roll_max = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RollDice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RollDice} CDOTAClientMsg_RollDice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RollDice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RollDice message.
         * @function verify
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RollDice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                if (!$util.isInteger(message.channel_type))
                    return "channel_type: integer expected";
            if (message.roll_min != null && message.hasOwnProperty("roll_min"))
                if (!$util.isInteger(message.roll_min))
                    return "roll_min: integer expected";
            if (message.roll_max != null && message.hasOwnProperty("roll_max"))
                if (!$util.isInteger(message.roll_max))
                    return "roll_max: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RollDice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RollDice} CDOTAClientMsg_RollDice
         */
        CDOTAClientMsg_RollDice.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RollDice)
                return object;
            var message = new $root.CDOTAClientMsg_RollDice();
            if (object.channel_type != null)
                message.channel_type = object.channel_type >>> 0;
            if (object.roll_min != null)
                message.roll_min = object.roll_min >>> 0;
            if (object.roll_max != null)
                message.roll_max = object.roll_max >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RollDice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RollDice
         * @static
         * @param {CDOTAClientMsg_RollDice} message CDOTAClientMsg_RollDice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RollDice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channel_type = 0;
                object.roll_min = 0;
                object.roll_max = 0;
            }
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                object.channel_type = message.channel_type;
            if (message.roll_min != null && message.hasOwnProperty("roll_min"))
                object.roll_min = message.roll_min;
            if (message.roll_max != null && message.hasOwnProperty("roll_max"))
                object.roll_max = message.roll_max;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_RollDice to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RollDice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RollDice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RollDice;
    })();
    
    $root.CDOTAClientMsg_FlipCoin = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_FlipCoin.
         * @exports ICDOTAClientMsg_FlipCoin
         * @interface ICDOTAClientMsg_FlipCoin
         * @property {number|null} [channel_type] CDOTAClientMsg_FlipCoin channel_type
         */
    
        /**
         * Constructs a new CDOTAClientMsg_FlipCoin.
         * @exports CDOTAClientMsg_FlipCoin
         * @classdesc Represents a CDOTAClientMsg_FlipCoin.
         * @implements ICDOTAClientMsg_FlipCoin
         * @constructor
         * @param {ICDOTAClientMsg_FlipCoin=} [properties] Properties to set
         */
        function CDOTAClientMsg_FlipCoin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_FlipCoin channel_type.
         * @member {number} channel_type
         * @memberof CDOTAClientMsg_FlipCoin
         * @instance
         */
        CDOTAClientMsg_FlipCoin.prototype.channel_type = 0;
    
        /**
         * Creates a new CDOTAClientMsg_FlipCoin instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {ICDOTAClientMsg_FlipCoin=} [properties] Properties to set
         * @returns {CDOTAClientMsg_FlipCoin} CDOTAClientMsg_FlipCoin instance
         */
        CDOTAClientMsg_FlipCoin.create = function create(properties) {
            return new CDOTAClientMsg_FlipCoin(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_FlipCoin message. Does not implicitly {@link CDOTAClientMsg_FlipCoin.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {ICDOTAClientMsg_FlipCoin} message CDOTAClientMsg_FlipCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_FlipCoin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel_type != null && Object.hasOwnProperty.call(message, "channel_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel_type);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_FlipCoin message, length delimited. Does not implicitly {@link CDOTAClientMsg_FlipCoin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {ICDOTAClientMsg_FlipCoin} message CDOTAClientMsg_FlipCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_FlipCoin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_FlipCoin message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_FlipCoin} CDOTAClientMsg_FlipCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_FlipCoin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_FlipCoin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channel_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_FlipCoin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_FlipCoin} CDOTAClientMsg_FlipCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_FlipCoin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_FlipCoin message.
         * @function verify
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_FlipCoin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                if (!$util.isInteger(message.channel_type))
                    return "channel_type: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_FlipCoin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_FlipCoin} CDOTAClientMsg_FlipCoin
         */
        CDOTAClientMsg_FlipCoin.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_FlipCoin)
                return object;
            var message = new $root.CDOTAClientMsg_FlipCoin();
            if (object.channel_type != null)
                message.channel_type = object.channel_type >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_FlipCoin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_FlipCoin
         * @static
         * @param {CDOTAClientMsg_FlipCoin} message CDOTAClientMsg_FlipCoin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_FlipCoin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.channel_type = 0;
            if (message.channel_type != null && message.hasOwnProperty("channel_type"))
                object.channel_type = message.channel_type;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_FlipCoin to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_FlipCoin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_FlipCoin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_FlipCoin;
    })();
    
    $root.CDOTAClientMsg_RequestItemSuggestions = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RequestItemSuggestions.
         * @exports ICDOTAClientMsg_RequestItemSuggestions
         * @interface ICDOTAClientMsg_RequestItemSuggestions
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RequestItemSuggestions.
         * @exports CDOTAClientMsg_RequestItemSuggestions
         * @classdesc Represents a CDOTAClientMsg_RequestItemSuggestions.
         * @implements ICDOTAClientMsg_RequestItemSuggestions
         * @constructor
         * @param {ICDOTAClientMsg_RequestItemSuggestions=} [properties] Properties to set
         */
        function CDOTAClientMsg_RequestItemSuggestions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CDOTAClientMsg_RequestItemSuggestions instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {ICDOTAClientMsg_RequestItemSuggestions=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RequestItemSuggestions} CDOTAClientMsg_RequestItemSuggestions instance
         */
        CDOTAClientMsg_RequestItemSuggestions.create = function create(properties) {
            return new CDOTAClientMsg_RequestItemSuggestions(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RequestItemSuggestions message. Does not implicitly {@link CDOTAClientMsg_RequestItemSuggestions.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {ICDOTAClientMsg_RequestItemSuggestions} message CDOTAClientMsg_RequestItemSuggestions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RequestItemSuggestions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RequestItemSuggestions message, length delimited. Does not implicitly {@link CDOTAClientMsg_RequestItemSuggestions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {ICDOTAClientMsg_RequestItemSuggestions} message CDOTAClientMsg_RequestItemSuggestions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RequestItemSuggestions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RequestItemSuggestions message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RequestItemSuggestions} CDOTAClientMsg_RequestItemSuggestions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RequestItemSuggestions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RequestItemSuggestions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RequestItemSuggestions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RequestItemSuggestions} CDOTAClientMsg_RequestItemSuggestions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RequestItemSuggestions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RequestItemSuggestions message.
         * @function verify
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RequestItemSuggestions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RequestItemSuggestions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RequestItemSuggestions} CDOTAClientMsg_RequestItemSuggestions
         */
        CDOTAClientMsg_RequestItemSuggestions.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RequestItemSuggestions)
                return object;
            return new $root.CDOTAClientMsg_RequestItemSuggestions();
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RequestItemSuggestions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @static
         * @param {CDOTAClientMsg_RequestItemSuggestions} message CDOTAClientMsg_RequestItemSuggestions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RequestItemSuggestions.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CDOTAClientMsg_RequestItemSuggestions to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RequestItemSuggestions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RequestItemSuggestions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RequestItemSuggestions;
    })();
    
    $root.CDOTAClientMsg_MakeTeamCaptain = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_MakeTeamCaptain.
         * @exports ICDOTAClientMsg_MakeTeamCaptain
         * @interface ICDOTAClientMsg_MakeTeamCaptain
         * @property {number|null} [player_id] CDOTAClientMsg_MakeTeamCaptain player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_MakeTeamCaptain.
         * @exports CDOTAClientMsg_MakeTeamCaptain
         * @classdesc Represents a CDOTAClientMsg_MakeTeamCaptain.
         * @implements ICDOTAClientMsg_MakeTeamCaptain
         * @constructor
         * @param {ICDOTAClientMsg_MakeTeamCaptain=} [properties] Properties to set
         */
        function CDOTAClientMsg_MakeTeamCaptain(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_MakeTeamCaptain player_id.
         * @member {number} player_id
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @instance
         */
        CDOTAClientMsg_MakeTeamCaptain.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_MakeTeamCaptain instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {ICDOTAClientMsg_MakeTeamCaptain=} [properties] Properties to set
         * @returns {CDOTAClientMsg_MakeTeamCaptain} CDOTAClientMsg_MakeTeamCaptain instance
         */
        CDOTAClientMsg_MakeTeamCaptain.create = function create(properties) {
            return new CDOTAClientMsg_MakeTeamCaptain(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MakeTeamCaptain message. Does not implicitly {@link CDOTAClientMsg_MakeTeamCaptain.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {ICDOTAClientMsg_MakeTeamCaptain} message CDOTAClientMsg_MakeTeamCaptain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MakeTeamCaptain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_MakeTeamCaptain message, length delimited. Does not implicitly {@link CDOTAClientMsg_MakeTeamCaptain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {ICDOTAClientMsg_MakeTeamCaptain} message CDOTAClientMsg_MakeTeamCaptain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_MakeTeamCaptain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_MakeTeamCaptain message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_MakeTeamCaptain} CDOTAClientMsg_MakeTeamCaptain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MakeTeamCaptain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_MakeTeamCaptain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_MakeTeamCaptain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_MakeTeamCaptain} CDOTAClientMsg_MakeTeamCaptain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_MakeTeamCaptain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_MakeTeamCaptain message.
         * @function verify
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_MakeTeamCaptain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_MakeTeamCaptain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_MakeTeamCaptain} CDOTAClientMsg_MakeTeamCaptain
         */
        CDOTAClientMsg_MakeTeamCaptain.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_MakeTeamCaptain)
                return object;
            var message = new $root.CDOTAClientMsg_MakeTeamCaptain();
            if (object.player_id != null)
                message.player_id = object.player_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_MakeTeamCaptain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @static
         * @param {CDOTAClientMsg_MakeTeamCaptain} message CDOTAClientMsg_MakeTeamCaptain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_MakeTeamCaptain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.player_id = 0;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_MakeTeamCaptain to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_MakeTeamCaptain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_MakeTeamCaptain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_MakeTeamCaptain;
    })();
    
    $root.CDOTAClientMsg_HelpTipSystemStateChanged = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_HelpTipSystemStateChanged.
         * @exports ICDOTAClientMsg_HelpTipSystemStateChanged
         * @interface ICDOTAClientMsg_HelpTipSystemStateChanged
         * @property {boolean|null} [tip_displayed] CDOTAClientMsg_HelpTipSystemStateChanged tip_displayed
         */
    
        /**
         * Constructs a new CDOTAClientMsg_HelpTipSystemStateChanged.
         * @exports CDOTAClientMsg_HelpTipSystemStateChanged
         * @classdesc Represents a CDOTAClientMsg_HelpTipSystemStateChanged.
         * @implements ICDOTAClientMsg_HelpTipSystemStateChanged
         * @constructor
         * @param {ICDOTAClientMsg_HelpTipSystemStateChanged=} [properties] Properties to set
         */
        function CDOTAClientMsg_HelpTipSystemStateChanged(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_HelpTipSystemStateChanged tip_displayed.
         * @member {boolean} tip_displayed
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @instance
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.prototype.tip_displayed = false;
    
        /**
         * Creates a new CDOTAClientMsg_HelpTipSystemStateChanged instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {ICDOTAClientMsg_HelpTipSystemStateChanged=} [properties] Properties to set
         * @returns {CDOTAClientMsg_HelpTipSystemStateChanged} CDOTAClientMsg_HelpTipSystemStateChanged instance
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.create = function create(properties) {
            return new CDOTAClientMsg_HelpTipSystemStateChanged(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_HelpTipSystemStateChanged message. Does not implicitly {@link CDOTAClientMsg_HelpTipSystemStateChanged.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {ICDOTAClientMsg_HelpTipSystemStateChanged} message CDOTAClientMsg_HelpTipSystemStateChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tip_displayed != null && Object.hasOwnProperty.call(message, "tip_displayed"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tip_displayed);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_HelpTipSystemStateChanged message, length delimited. Does not implicitly {@link CDOTAClientMsg_HelpTipSystemStateChanged.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {ICDOTAClientMsg_HelpTipSystemStateChanged} message CDOTAClientMsg_HelpTipSystemStateChanged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_HelpTipSystemStateChanged message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_HelpTipSystemStateChanged} CDOTAClientMsg_HelpTipSystemStateChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_HelpTipSystemStateChanged();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tip_displayed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_HelpTipSystemStateChanged message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_HelpTipSystemStateChanged} CDOTAClientMsg_HelpTipSystemStateChanged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_HelpTipSystemStateChanged message.
         * @function verify
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tip_displayed != null && message.hasOwnProperty("tip_displayed"))
                if (typeof message.tip_displayed !== "boolean")
                    return "tip_displayed: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_HelpTipSystemStateChanged message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_HelpTipSystemStateChanged} CDOTAClientMsg_HelpTipSystemStateChanged
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_HelpTipSystemStateChanged)
                return object;
            var message = new $root.CDOTAClientMsg_HelpTipSystemStateChanged();
            if (object.tip_displayed != null)
                message.tip_displayed = Boolean(object.tip_displayed);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_HelpTipSystemStateChanged message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @static
         * @param {CDOTAClientMsg_HelpTipSystemStateChanged} message CDOTAClientMsg_HelpTipSystemStateChanged
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tip_displayed = false;
            if (message.tip_displayed != null && message.hasOwnProperty("tip_displayed"))
                object.tip_displayed = message.tip_displayed;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_HelpTipSystemStateChanged to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_HelpTipSystemStateChanged
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_HelpTipSystemStateChanged.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_HelpTipSystemStateChanged;
    })();
    
    $root.CDOTAClientMsg_RequestBulkCombatLog = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_RequestBulkCombatLog.
         * @exports ICDOTAClientMsg_RequestBulkCombatLog
         * @interface ICDOTAClientMsg_RequestBulkCombatLog
         * @property {number|null} [game_time] CDOTAClientMsg_RequestBulkCombatLog game_time
         * @property {number|null} [duration] CDOTAClientMsg_RequestBulkCombatLog duration
         * @property {boolean|null} [recent_player_death] CDOTAClientMsg_RequestBulkCombatLog recent_player_death
         * @property {number|null} [player_id] CDOTAClientMsg_RequestBulkCombatLog player_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_RequestBulkCombatLog.
         * @exports CDOTAClientMsg_RequestBulkCombatLog
         * @classdesc Represents a CDOTAClientMsg_RequestBulkCombatLog.
         * @implements ICDOTAClientMsg_RequestBulkCombatLog
         * @constructor
         * @param {ICDOTAClientMsg_RequestBulkCombatLog=} [properties] Properties to set
         */
        function CDOTAClientMsg_RequestBulkCombatLog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_RequestBulkCombatLog game_time.
         * @member {number} game_time
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @instance
         */
        CDOTAClientMsg_RequestBulkCombatLog.prototype.game_time = 0;
    
        /**
         * CDOTAClientMsg_RequestBulkCombatLog duration.
         * @member {number} duration
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @instance
         */
        CDOTAClientMsg_RequestBulkCombatLog.prototype.duration = 0;
    
        /**
         * CDOTAClientMsg_RequestBulkCombatLog recent_player_death.
         * @member {boolean} recent_player_death
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @instance
         */
        CDOTAClientMsg_RequestBulkCombatLog.prototype.recent_player_death = false;
    
        /**
         * CDOTAClientMsg_RequestBulkCombatLog player_id.
         * @member {number} player_id
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @instance
         */
        CDOTAClientMsg_RequestBulkCombatLog.prototype.player_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_RequestBulkCombatLog instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {ICDOTAClientMsg_RequestBulkCombatLog=} [properties] Properties to set
         * @returns {CDOTAClientMsg_RequestBulkCombatLog} CDOTAClientMsg_RequestBulkCombatLog instance
         */
        CDOTAClientMsg_RequestBulkCombatLog.create = function create(properties) {
            return new CDOTAClientMsg_RequestBulkCombatLog(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RequestBulkCombatLog message. Does not implicitly {@link CDOTAClientMsg_RequestBulkCombatLog.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {ICDOTAClientMsg_RequestBulkCombatLog} message CDOTAClientMsg_RequestBulkCombatLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RequestBulkCombatLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.game_time != null && Object.hasOwnProperty.call(message, "game_time"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.game_time);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.recent_player_death != null && Object.hasOwnProperty.call(message, "recent_player_death"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recent_player_death);
            if (message.player_id != null && Object.hasOwnProperty.call(message, "player_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.player_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_RequestBulkCombatLog message, length delimited. Does not implicitly {@link CDOTAClientMsg_RequestBulkCombatLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {ICDOTAClientMsg_RequestBulkCombatLog} message CDOTAClientMsg_RequestBulkCombatLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_RequestBulkCombatLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_RequestBulkCombatLog message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_RequestBulkCombatLog} CDOTAClientMsg_RequestBulkCombatLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RequestBulkCombatLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_RequestBulkCombatLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.game_time = reader.float();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.recent_player_death = reader.bool();
                    break;
                case 4:
                    message.player_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_RequestBulkCombatLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_RequestBulkCombatLog} CDOTAClientMsg_RequestBulkCombatLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_RequestBulkCombatLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_RequestBulkCombatLog message.
         * @function verify
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_RequestBulkCombatLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.game_time != null && message.hasOwnProperty("game_time"))
                if (typeof message.game_time !== "number")
                    return "game_time: number expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.recent_player_death != null && message.hasOwnProperty("recent_player_death"))
                if (typeof message.recent_player_death !== "boolean")
                    return "recent_player_death: boolean expected";
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                if (!$util.isInteger(message.player_id))
                    return "player_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_RequestBulkCombatLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_RequestBulkCombatLog} CDOTAClientMsg_RequestBulkCombatLog
         */
        CDOTAClientMsg_RequestBulkCombatLog.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_RequestBulkCombatLog)
                return object;
            var message = new $root.CDOTAClientMsg_RequestBulkCombatLog();
            if (object.game_time != null)
                message.game_time = Number(object.game_time);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.recent_player_death != null)
                message.recent_player_death = Boolean(object.recent_player_death);
            if (object.player_id != null)
                message.player_id = object.player_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_RequestBulkCombatLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @static
         * @param {CDOTAClientMsg_RequestBulkCombatLog} message CDOTAClientMsg_RequestBulkCombatLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_RequestBulkCombatLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.game_time = 0;
                object.duration = 0;
                object.recent_player_death = false;
                object.player_id = 0;
            }
            if (message.game_time != null && message.hasOwnProperty("game_time"))
                object.game_time = options.json && !isFinite(message.game_time) ? String(message.game_time) : message.game_time;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.recent_player_death != null && message.hasOwnProperty("recent_player_death"))
                object.recent_player_death = message.recent_player_death;
            if (message.player_id != null && message.hasOwnProperty("player_id"))
                object.player_id = message.player_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_RequestBulkCombatLog to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_RequestBulkCombatLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_RequestBulkCombatLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_RequestBulkCombatLog;
    })();
    
    $root.CDOTAClientMsg_AbilityDraftRequestAbility = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_AbilityDraftRequestAbility.
         * @exports ICDOTAClientMsg_AbilityDraftRequestAbility
         * @interface ICDOTAClientMsg_AbilityDraftRequestAbility
         * @property {number|null} [requested_ability_id] CDOTAClientMsg_AbilityDraftRequestAbility requested_ability_id
         * @property {boolean|null} [ctrl_is_down] CDOTAClientMsg_AbilityDraftRequestAbility ctrl_is_down
         */
    
        /**
         * Constructs a new CDOTAClientMsg_AbilityDraftRequestAbility.
         * @exports CDOTAClientMsg_AbilityDraftRequestAbility
         * @classdesc Represents a CDOTAClientMsg_AbilityDraftRequestAbility.
         * @implements ICDOTAClientMsg_AbilityDraftRequestAbility
         * @constructor
         * @param {ICDOTAClientMsg_AbilityDraftRequestAbility=} [properties] Properties to set
         */
        function CDOTAClientMsg_AbilityDraftRequestAbility(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_AbilityDraftRequestAbility requested_ability_id.
         * @member {number} requested_ability_id
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @instance
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.prototype.requested_ability_id = 0;
    
        /**
         * CDOTAClientMsg_AbilityDraftRequestAbility ctrl_is_down.
         * @member {boolean} ctrl_is_down
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @instance
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.prototype.ctrl_is_down = false;
    
        /**
         * Creates a new CDOTAClientMsg_AbilityDraftRequestAbility instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {ICDOTAClientMsg_AbilityDraftRequestAbility=} [properties] Properties to set
         * @returns {CDOTAClientMsg_AbilityDraftRequestAbility} CDOTAClientMsg_AbilityDraftRequestAbility instance
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.create = function create(properties) {
            return new CDOTAClientMsg_AbilityDraftRequestAbility(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_AbilityDraftRequestAbility message. Does not implicitly {@link CDOTAClientMsg_AbilityDraftRequestAbility.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {ICDOTAClientMsg_AbilityDraftRequestAbility} message CDOTAClientMsg_AbilityDraftRequestAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requested_ability_id != null && Object.hasOwnProperty.call(message, "requested_ability_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.requested_ability_id);
            if (message.ctrl_is_down != null && Object.hasOwnProperty.call(message, "ctrl_is_down"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ctrl_is_down);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_AbilityDraftRequestAbility message, length delimited. Does not implicitly {@link CDOTAClientMsg_AbilityDraftRequestAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {ICDOTAClientMsg_AbilityDraftRequestAbility} message CDOTAClientMsg_AbilityDraftRequestAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_AbilityDraftRequestAbility message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_AbilityDraftRequestAbility} CDOTAClientMsg_AbilityDraftRequestAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_AbilityDraftRequestAbility();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requested_ability_id = reader.uint32();
                    break;
                case 2:
                    message.ctrl_is_down = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_AbilityDraftRequestAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_AbilityDraftRequestAbility} CDOTAClientMsg_AbilityDraftRequestAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_AbilityDraftRequestAbility message.
         * @function verify
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requested_ability_id != null && message.hasOwnProperty("requested_ability_id"))
                if (!$util.isInteger(message.requested_ability_id))
                    return "requested_ability_id: integer expected";
            if (message.ctrl_is_down != null && message.hasOwnProperty("ctrl_is_down"))
                if (typeof message.ctrl_is_down !== "boolean")
                    return "ctrl_is_down: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_AbilityDraftRequestAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_AbilityDraftRequestAbility} CDOTAClientMsg_AbilityDraftRequestAbility
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_AbilityDraftRequestAbility)
                return object;
            var message = new $root.CDOTAClientMsg_AbilityDraftRequestAbility();
            if (object.requested_ability_id != null)
                message.requested_ability_id = object.requested_ability_id >>> 0;
            if (object.ctrl_is_down != null)
                message.ctrl_is_down = Boolean(object.ctrl_is_down);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_AbilityDraftRequestAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @static
         * @param {CDOTAClientMsg_AbilityDraftRequestAbility} message CDOTAClientMsg_AbilityDraftRequestAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.requested_ability_id = 0;
                object.ctrl_is_down = false;
            }
            if (message.requested_ability_id != null && message.hasOwnProperty("requested_ability_id"))
                object.requested_ability_id = message.requested_ability_id;
            if (message.ctrl_is_down != null && message.hasOwnProperty("ctrl_is_down"))
                object.ctrl_is_down = message.ctrl_is_down;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_AbilityDraftRequestAbility to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_AbilityDraftRequestAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_AbilityDraftRequestAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_AbilityDraftRequestAbility;
    })();
    
    $root.CDOTAClientMsg_GuideSelectOption = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_GuideSelectOption.
         * @exports ICDOTAClientMsg_GuideSelectOption
         * @interface ICDOTAClientMsg_GuideSelectOption
         * @property {number|null} [option] CDOTAClientMsg_GuideSelectOption option
         * @property {boolean|null} [force_recalculate] CDOTAClientMsg_GuideSelectOption force_recalculate
         */
    
        /**
         * Constructs a new CDOTAClientMsg_GuideSelectOption.
         * @exports CDOTAClientMsg_GuideSelectOption
         * @classdesc Represents a CDOTAClientMsg_GuideSelectOption.
         * @implements ICDOTAClientMsg_GuideSelectOption
         * @constructor
         * @param {ICDOTAClientMsg_GuideSelectOption=} [properties] Properties to set
         */
        function CDOTAClientMsg_GuideSelectOption(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_GuideSelectOption option.
         * @member {number} option
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @instance
         */
        CDOTAClientMsg_GuideSelectOption.prototype.option = 0;
    
        /**
         * CDOTAClientMsg_GuideSelectOption force_recalculate.
         * @member {boolean} force_recalculate
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @instance
         */
        CDOTAClientMsg_GuideSelectOption.prototype.force_recalculate = false;
    
        /**
         * Creates a new CDOTAClientMsg_GuideSelectOption instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {ICDOTAClientMsg_GuideSelectOption=} [properties] Properties to set
         * @returns {CDOTAClientMsg_GuideSelectOption} CDOTAClientMsg_GuideSelectOption instance
         */
        CDOTAClientMsg_GuideSelectOption.create = function create(properties) {
            return new CDOTAClientMsg_GuideSelectOption(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_GuideSelectOption message. Does not implicitly {@link CDOTAClientMsg_GuideSelectOption.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {ICDOTAClientMsg_GuideSelectOption} message CDOTAClientMsg_GuideSelectOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_GuideSelectOption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.option != null && Object.hasOwnProperty.call(message, "option"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.option);
            if (message.force_recalculate != null && Object.hasOwnProperty.call(message, "force_recalculate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.force_recalculate);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_GuideSelectOption message, length delimited. Does not implicitly {@link CDOTAClientMsg_GuideSelectOption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {ICDOTAClientMsg_GuideSelectOption} message CDOTAClientMsg_GuideSelectOption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_GuideSelectOption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_GuideSelectOption message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_GuideSelectOption} CDOTAClientMsg_GuideSelectOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_GuideSelectOption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_GuideSelectOption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.option = reader.uint32();
                    break;
                case 2:
                    message.force_recalculate = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_GuideSelectOption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_GuideSelectOption} CDOTAClientMsg_GuideSelectOption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_GuideSelectOption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_GuideSelectOption message.
         * @function verify
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_GuideSelectOption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.option != null && message.hasOwnProperty("option"))
                if (!$util.isInteger(message.option))
                    return "option: integer expected";
            if (message.force_recalculate != null && message.hasOwnProperty("force_recalculate"))
                if (typeof message.force_recalculate !== "boolean")
                    return "force_recalculate: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_GuideSelectOption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_GuideSelectOption} CDOTAClientMsg_GuideSelectOption
         */
        CDOTAClientMsg_GuideSelectOption.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_GuideSelectOption)
                return object;
            var message = new $root.CDOTAClientMsg_GuideSelectOption();
            if (object.option != null)
                message.option = object.option >>> 0;
            if (object.force_recalculate != null)
                message.force_recalculate = Boolean(object.force_recalculate);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_GuideSelectOption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @static
         * @param {CDOTAClientMsg_GuideSelectOption} message CDOTAClientMsg_GuideSelectOption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_GuideSelectOption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.option = 0;
                object.force_recalculate = false;
            }
            if (message.option != null && message.hasOwnProperty("option"))
                object.option = message.option;
            if (message.force_recalculate != null && message.hasOwnProperty("force_recalculate"))
                object.force_recalculate = message.force_recalculate;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_GuideSelectOption to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_GuideSelectOption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_GuideSelectOption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_GuideSelectOption;
    })();
    
    $root.CDOTAClientMsg_GuideSelected = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_GuideSelected.
         * @exports ICDOTAClientMsg_GuideSelected
         * @interface ICDOTAClientMsg_GuideSelected
         * @property {number|Long|null} [guide_workshop_id] CDOTAClientMsg_GuideSelected guide_workshop_id
         * @property {boolean|null} [is_plus_guide] CDOTAClientMsg_GuideSelected is_plus_guide
         */
    
        /**
         * Constructs a new CDOTAClientMsg_GuideSelected.
         * @exports CDOTAClientMsg_GuideSelected
         * @classdesc Represents a CDOTAClientMsg_GuideSelected.
         * @implements ICDOTAClientMsg_GuideSelected
         * @constructor
         * @param {ICDOTAClientMsg_GuideSelected=} [properties] Properties to set
         */
        function CDOTAClientMsg_GuideSelected(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_GuideSelected guide_workshop_id.
         * @member {number|Long} guide_workshop_id
         * @memberof CDOTAClientMsg_GuideSelected
         * @instance
         */
        CDOTAClientMsg_GuideSelected.prototype.guide_workshop_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAClientMsg_GuideSelected is_plus_guide.
         * @member {boolean} is_plus_guide
         * @memberof CDOTAClientMsg_GuideSelected
         * @instance
         */
        CDOTAClientMsg_GuideSelected.prototype.is_plus_guide = false;
    
        /**
         * Creates a new CDOTAClientMsg_GuideSelected instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {ICDOTAClientMsg_GuideSelected=} [properties] Properties to set
         * @returns {CDOTAClientMsg_GuideSelected} CDOTAClientMsg_GuideSelected instance
         */
        CDOTAClientMsg_GuideSelected.create = function create(properties) {
            return new CDOTAClientMsg_GuideSelected(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_GuideSelected message. Does not implicitly {@link CDOTAClientMsg_GuideSelected.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {ICDOTAClientMsg_GuideSelected} message CDOTAClientMsg_GuideSelected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_GuideSelected.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guide_workshop_id != null && Object.hasOwnProperty.call(message, "guide_workshop_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guide_workshop_id);
            if (message.is_plus_guide != null && Object.hasOwnProperty.call(message, "is_plus_guide"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_plus_guide);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_GuideSelected message, length delimited. Does not implicitly {@link CDOTAClientMsg_GuideSelected.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {ICDOTAClientMsg_GuideSelected} message CDOTAClientMsg_GuideSelected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_GuideSelected.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_GuideSelected message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_GuideSelected} CDOTAClientMsg_GuideSelected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_GuideSelected.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_GuideSelected();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guide_workshop_id = reader.uint64();
                    break;
                case 2:
                    message.is_plus_guide = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_GuideSelected message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_GuideSelected} CDOTAClientMsg_GuideSelected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_GuideSelected.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_GuideSelected message.
         * @function verify
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_GuideSelected.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guide_workshop_id != null && message.hasOwnProperty("guide_workshop_id"))
                if (!$util.isInteger(message.guide_workshop_id) && !(message.guide_workshop_id && $util.isInteger(message.guide_workshop_id.low) && $util.isInteger(message.guide_workshop_id.high)))
                    return "guide_workshop_id: integer|Long expected";
            if (message.is_plus_guide != null && message.hasOwnProperty("is_plus_guide"))
                if (typeof message.is_plus_guide !== "boolean")
                    return "is_plus_guide: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_GuideSelected message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_GuideSelected} CDOTAClientMsg_GuideSelected
         */
        CDOTAClientMsg_GuideSelected.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_GuideSelected)
                return object;
            var message = new $root.CDOTAClientMsg_GuideSelected();
            if (object.guide_workshop_id != null)
                if ($util.Long)
                    (message.guide_workshop_id = $util.Long.fromValue(object.guide_workshop_id)).unsigned = true;
                else if (typeof object.guide_workshop_id === "string")
                    message.guide_workshop_id = parseInt(object.guide_workshop_id, 10);
                else if (typeof object.guide_workshop_id === "number")
                    message.guide_workshop_id = object.guide_workshop_id;
                else if (typeof object.guide_workshop_id === "object")
                    message.guide_workshop_id = new $util.LongBits(object.guide_workshop_id.low >>> 0, object.guide_workshop_id.high >>> 0).toNumber(true);
            if (object.is_plus_guide != null)
                message.is_plus_guide = Boolean(object.is_plus_guide);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_GuideSelected message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_GuideSelected
         * @static
         * @param {CDOTAClientMsg_GuideSelected} message CDOTAClientMsg_GuideSelected
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_GuideSelected.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.guide_workshop_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.guide_workshop_id = options.longs === String ? "0" : 0;
                object.is_plus_guide = false;
            }
            if (message.guide_workshop_id != null && message.hasOwnProperty("guide_workshop_id"))
                if (typeof message.guide_workshop_id === "number")
                    object.guide_workshop_id = options.longs === String ? String(message.guide_workshop_id) : message.guide_workshop_id;
                else
                    object.guide_workshop_id = options.longs === String ? $util.Long.prototype.toString.call(message.guide_workshop_id) : options.longs === Number ? new $util.LongBits(message.guide_workshop_id.low >>> 0, message.guide_workshop_id.high >>> 0).toNumber(true) : message.guide_workshop_id;
            if (message.is_plus_guide != null && message.hasOwnProperty("is_plus_guide"))
                object.is_plus_guide = message.is_plus_guide;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_GuideSelected to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_GuideSelected
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_GuideSelected.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_GuideSelected;
    })();
    
    $root.CDOTAClientMsg_DamageReport = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_DamageReport.
         * @exports ICDOTAClientMsg_DamageReport
         * @interface ICDOTAClientMsg_DamageReport
         * @property {number|null} [target_hero_id] CDOTAClientMsg_DamageReport target_hero_id
         * @property {number|null} [source_hero_id] CDOTAClientMsg_DamageReport source_hero_id
         * @property {number|null} [damage_amount] CDOTAClientMsg_DamageReport damage_amount
         * @property {boolean|null} [broadcast] CDOTAClientMsg_DamageReport broadcast
         */
    
        /**
         * Constructs a new CDOTAClientMsg_DamageReport.
         * @exports CDOTAClientMsg_DamageReport
         * @classdesc Represents a CDOTAClientMsg_DamageReport.
         * @implements ICDOTAClientMsg_DamageReport
         * @constructor
         * @param {ICDOTAClientMsg_DamageReport=} [properties] Properties to set
         */
        function CDOTAClientMsg_DamageReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_DamageReport target_hero_id.
         * @member {number} target_hero_id
         * @memberof CDOTAClientMsg_DamageReport
         * @instance
         */
        CDOTAClientMsg_DamageReport.prototype.target_hero_id = 0;
    
        /**
         * CDOTAClientMsg_DamageReport source_hero_id.
         * @member {number} source_hero_id
         * @memberof CDOTAClientMsg_DamageReport
         * @instance
         */
        CDOTAClientMsg_DamageReport.prototype.source_hero_id = 0;
    
        /**
         * CDOTAClientMsg_DamageReport damage_amount.
         * @member {number} damage_amount
         * @memberof CDOTAClientMsg_DamageReport
         * @instance
         */
        CDOTAClientMsg_DamageReport.prototype.damage_amount = 0;
    
        /**
         * CDOTAClientMsg_DamageReport broadcast.
         * @member {boolean} broadcast
         * @memberof CDOTAClientMsg_DamageReport
         * @instance
         */
        CDOTAClientMsg_DamageReport.prototype.broadcast = false;
    
        /**
         * Creates a new CDOTAClientMsg_DamageReport instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {ICDOTAClientMsg_DamageReport=} [properties] Properties to set
         * @returns {CDOTAClientMsg_DamageReport} CDOTAClientMsg_DamageReport instance
         */
        CDOTAClientMsg_DamageReport.create = function create(properties) {
            return new CDOTAClientMsg_DamageReport(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_DamageReport message. Does not implicitly {@link CDOTAClientMsg_DamageReport.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {ICDOTAClientMsg_DamageReport} message CDOTAClientMsg_DamageReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_DamageReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_hero_id != null && Object.hasOwnProperty.call(message, "target_hero_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_hero_id);
            if (message.source_hero_id != null && Object.hasOwnProperty.call(message, "source_hero_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.source_hero_id);
            if (message.damage_amount != null && Object.hasOwnProperty.call(message, "damage_amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.damage_amount);
            if (message.broadcast != null && Object.hasOwnProperty.call(message, "broadcast"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.broadcast);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_DamageReport message, length delimited. Does not implicitly {@link CDOTAClientMsg_DamageReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {ICDOTAClientMsg_DamageReport} message CDOTAClientMsg_DamageReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_DamageReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_DamageReport message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_DamageReport} CDOTAClientMsg_DamageReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_DamageReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_DamageReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_hero_id = reader.uint32();
                    break;
                case 2:
                    message.source_hero_id = reader.uint32();
                    break;
                case 3:
                    message.damage_amount = reader.int32();
                    break;
                case 4:
                    message.broadcast = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_DamageReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_DamageReport} CDOTAClientMsg_DamageReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_DamageReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_DamageReport message.
         * @function verify
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_DamageReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_hero_id != null && message.hasOwnProperty("target_hero_id"))
                if (!$util.isInteger(message.target_hero_id))
                    return "target_hero_id: integer expected";
            if (message.source_hero_id != null && message.hasOwnProperty("source_hero_id"))
                if (!$util.isInteger(message.source_hero_id))
                    return "source_hero_id: integer expected";
            if (message.damage_amount != null && message.hasOwnProperty("damage_amount"))
                if (!$util.isInteger(message.damage_amount))
                    return "damage_amount: integer expected";
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                if (typeof message.broadcast !== "boolean")
                    return "broadcast: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_DamageReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_DamageReport} CDOTAClientMsg_DamageReport
         */
        CDOTAClientMsg_DamageReport.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_DamageReport)
                return object;
            var message = new $root.CDOTAClientMsg_DamageReport();
            if (object.target_hero_id != null)
                message.target_hero_id = object.target_hero_id >>> 0;
            if (object.source_hero_id != null)
                message.source_hero_id = object.source_hero_id >>> 0;
            if (object.damage_amount != null)
                message.damage_amount = object.damage_amount | 0;
            if (object.broadcast != null)
                message.broadcast = Boolean(object.broadcast);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_DamageReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_DamageReport
         * @static
         * @param {CDOTAClientMsg_DamageReport} message CDOTAClientMsg_DamageReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_DamageReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_hero_id = 0;
                object.source_hero_id = 0;
                object.damage_amount = 0;
                object.broadcast = false;
            }
            if (message.target_hero_id != null && message.hasOwnProperty("target_hero_id"))
                object.target_hero_id = message.target_hero_id;
            if (message.source_hero_id != null && message.hasOwnProperty("source_hero_id"))
                object.source_hero_id = message.source_hero_id;
            if (message.damage_amount != null && message.hasOwnProperty("damage_amount"))
                object.damage_amount = message.damage_amount;
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                object.broadcast = message.broadcast;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_DamageReport to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_DamageReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_DamageReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_DamageReport;
    })();
    
    $root.CDOTAClientMsg_SalutePlayer = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SalutePlayer.
         * @exports ICDOTAClientMsg_SalutePlayer
         * @interface ICDOTAClientMsg_SalutePlayer
         * @property {number|null} [target_player_id] CDOTAClientMsg_SalutePlayer target_player_id
         * @property {number|null} [event_id] CDOTAClientMsg_SalutePlayer event_id
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SalutePlayer.
         * @exports CDOTAClientMsg_SalutePlayer
         * @classdesc Represents a CDOTAClientMsg_SalutePlayer.
         * @implements ICDOTAClientMsg_SalutePlayer
         * @constructor
         * @param {ICDOTAClientMsg_SalutePlayer=} [properties] Properties to set
         */
        function CDOTAClientMsg_SalutePlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SalutePlayer target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAClientMsg_SalutePlayer
         * @instance
         */
        CDOTAClientMsg_SalutePlayer.prototype.target_player_id = 0;
    
        /**
         * CDOTAClientMsg_SalutePlayer event_id.
         * @member {number} event_id
         * @memberof CDOTAClientMsg_SalutePlayer
         * @instance
         */
        CDOTAClientMsg_SalutePlayer.prototype.event_id = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SalutePlayer instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {ICDOTAClientMsg_SalutePlayer=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SalutePlayer} CDOTAClientMsg_SalutePlayer instance
         */
        CDOTAClientMsg_SalutePlayer.create = function create(properties) {
            return new CDOTAClientMsg_SalutePlayer(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SalutePlayer message. Does not implicitly {@link CDOTAClientMsg_SalutePlayer.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {ICDOTAClientMsg_SalutePlayer} message CDOTAClientMsg_SalutePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SalutePlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.target_player_id);
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.event_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SalutePlayer message, length delimited. Does not implicitly {@link CDOTAClientMsg_SalutePlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {ICDOTAClientMsg_SalutePlayer} message CDOTAClientMsg_SalutePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SalutePlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SalutePlayer message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SalutePlayer} CDOTAClientMsg_SalutePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SalutePlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SalutePlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_player_id = reader.int32();
                    break;
                case 2:
                    message.event_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SalutePlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SalutePlayer} CDOTAClientMsg_SalutePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SalutePlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SalutePlayer message.
         * @function verify
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SalutePlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                if (!$util.isInteger(message.event_id))
                    return "event_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SalutePlayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SalutePlayer} CDOTAClientMsg_SalutePlayer
         */
        CDOTAClientMsg_SalutePlayer.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SalutePlayer)
                return object;
            var message = new $root.CDOTAClientMsg_SalutePlayer();
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id | 0;
            if (object.event_id != null)
                message.event_id = object.event_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SalutePlayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SalutePlayer
         * @static
         * @param {CDOTAClientMsg_SalutePlayer} message CDOTAClientMsg_SalutePlayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SalutePlayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_player_id = 0;
                object.event_id = 0;
            }
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SalutePlayer to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SalutePlayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SalutePlayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SalutePlayer;
    })();
    
    $root.CDOTAClientMsg_PingConfirm = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_PingConfirm.
         * @exports ICDOTAClientMsg_PingConfirm
         * @interface ICDOTAClientMsg_PingConfirm
         * @property {number|null} [ping_owner_player_id] CDOTAClientMsg_PingConfirm ping_owner_player_id
         * @property {number|null} [ping_confirming_player_id] CDOTAClientMsg_PingConfirm ping_confirming_player_id
         * @property {boolean|null} [confirming] CDOTAClientMsg_PingConfirm confirming
         */
    
        /**
         * Constructs a new CDOTAClientMsg_PingConfirm.
         * @exports CDOTAClientMsg_PingConfirm
         * @classdesc Represents a CDOTAClientMsg_PingConfirm.
         * @implements ICDOTAClientMsg_PingConfirm
         * @constructor
         * @param {ICDOTAClientMsg_PingConfirm=} [properties] Properties to set
         */
        function CDOTAClientMsg_PingConfirm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_PingConfirm ping_owner_player_id.
         * @member {number} ping_owner_player_id
         * @memberof CDOTAClientMsg_PingConfirm
         * @instance
         */
        CDOTAClientMsg_PingConfirm.prototype.ping_owner_player_id = 0;
    
        /**
         * CDOTAClientMsg_PingConfirm ping_confirming_player_id.
         * @member {number} ping_confirming_player_id
         * @memberof CDOTAClientMsg_PingConfirm
         * @instance
         */
        CDOTAClientMsg_PingConfirm.prototype.ping_confirming_player_id = 0;
    
        /**
         * CDOTAClientMsg_PingConfirm confirming.
         * @member {boolean} confirming
         * @memberof CDOTAClientMsg_PingConfirm
         * @instance
         */
        CDOTAClientMsg_PingConfirm.prototype.confirming = false;
    
        /**
         * Creates a new CDOTAClientMsg_PingConfirm instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {ICDOTAClientMsg_PingConfirm=} [properties] Properties to set
         * @returns {CDOTAClientMsg_PingConfirm} CDOTAClientMsg_PingConfirm instance
         */
        CDOTAClientMsg_PingConfirm.create = function create(properties) {
            return new CDOTAClientMsg_PingConfirm(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PingConfirm message. Does not implicitly {@link CDOTAClientMsg_PingConfirm.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {ICDOTAClientMsg_PingConfirm} message CDOTAClientMsg_PingConfirm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PingConfirm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ping_owner_player_id != null && Object.hasOwnProperty.call(message, "ping_owner_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ping_owner_player_id);
            if (message.ping_confirming_player_id != null && Object.hasOwnProperty.call(message, "ping_confirming_player_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ping_confirming_player_id);
            if (message.confirming != null && Object.hasOwnProperty.call(message, "confirming"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.confirming);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PingConfirm message, length delimited. Does not implicitly {@link CDOTAClientMsg_PingConfirm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {ICDOTAClientMsg_PingConfirm} message CDOTAClientMsg_PingConfirm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PingConfirm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_PingConfirm message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_PingConfirm} CDOTAClientMsg_PingConfirm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PingConfirm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_PingConfirm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ping_owner_player_id = reader.int32();
                    break;
                case 2:
                    message.ping_confirming_player_id = reader.int32();
                    break;
                case 3:
                    message.confirming = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_PingConfirm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_PingConfirm} CDOTAClientMsg_PingConfirm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PingConfirm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_PingConfirm message.
         * @function verify
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_PingConfirm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ping_owner_player_id != null && message.hasOwnProperty("ping_owner_player_id"))
                if (!$util.isInteger(message.ping_owner_player_id))
                    return "ping_owner_player_id: integer expected";
            if (message.ping_confirming_player_id != null && message.hasOwnProperty("ping_confirming_player_id"))
                if (!$util.isInteger(message.ping_confirming_player_id))
                    return "ping_confirming_player_id: integer expected";
            if (message.confirming != null && message.hasOwnProperty("confirming"))
                if (typeof message.confirming !== "boolean")
                    return "confirming: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_PingConfirm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_PingConfirm} CDOTAClientMsg_PingConfirm
         */
        CDOTAClientMsg_PingConfirm.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_PingConfirm)
                return object;
            var message = new $root.CDOTAClientMsg_PingConfirm();
            if (object.ping_owner_player_id != null)
                message.ping_owner_player_id = object.ping_owner_player_id | 0;
            if (object.ping_confirming_player_id != null)
                message.ping_confirming_player_id = object.ping_confirming_player_id | 0;
            if (object.confirming != null)
                message.confirming = Boolean(object.confirming);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_PingConfirm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_PingConfirm
         * @static
         * @param {CDOTAClientMsg_PingConfirm} message CDOTAClientMsg_PingConfirm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_PingConfirm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ping_owner_player_id = 0;
                object.ping_confirming_player_id = 0;
                object.confirming = false;
            }
            if (message.ping_owner_player_id != null && message.hasOwnProperty("ping_owner_player_id"))
                object.ping_owner_player_id = message.ping_owner_player_id;
            if (message.ping_confirming_player_id != null && message.hasOwnProperty("ping_confirming_player_id"))
                object.ping_confirming_player_id = message.ping_confirming_player_id;
            if (message.confirming != null && message.hasOwnProperty("confirming"))
                object.confirming = message.confirming;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_PingConfirm to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_PingConfirm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_PingConfirm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_PingConfirm;
    })();
    
    $root.CDOTAClientMsg_TipAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_TipAlert.
         * @exports ICDOTAClientMsg_TipAlert
         * @interface ICDOTAClientMsg_TipAlert
         * @property {string|null} [tip_text] CDOTAClientMsg_TipAlert tip_text
         */
    
        /**
         * Constructs a new CDOTAClientMsg_TipAlert.
         * @exports CDOTAClientMsg_TipAlert
         * @classdesc Represents a CDOTAClientMsg_TipAlert.
         * @implements ICDOTAClientMsg_TipAlert
         * @constructor
         * @param {ICDOTAClientMsg_TipAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_TipAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_TipAlert tip_text.
         * @member {string} tip_text
         * @memberof CDOTAClientMsg_TipAlert
         * @instance
         */
        CDOTAClientMsg_TipAlert.prototype.tip_text = "";
    
        /**
         * Creates a new CDOTAClientMsg_TipAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {ICDOTAClientMsg_TipAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_TipAlert} CDOTAClientMsg_TipAlert instance
         */
        CDOTAClientMsg_TipAlert.create = function create(properties) {
            return new CDOTAClientMsg_TipAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_TipAlert message. Does not implicitly {@link CDOTAClientMsg_TipAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {ICDOTAClientMsg_TipAlert} message CDOTAClientMsg_TipAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_TipAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tip_text != null && Object.hasOwnProperty.call(message, "tip_text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tip_text);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_TipAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_TipAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {ICDOTAClientMsg_TipAlert} message CDOTAClientMsg_TipAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_TipAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_TipAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_TipAlert} CDOTAClientMsg_TipAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_TipAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_TipAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tip_text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_TipAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_TipAlert} CDOTAClientMsg_TipAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_TipAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_TipAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_TipAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                if (!$util.isString(message.tip_text))
                    return "tip_text: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_TipAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_TipAlert} CDOTAClientMsg_TipAlert
         */
        CDOTAClientMsg_TipAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_TipAlert)
                return object;
            var message = new $root.CDOTAClientMsg_TipAlert();
            if (object.tip_text != null)
                message.tip_text = String(object.tip_text);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_TipAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_TipAlert
         * @static
         * @param {CDOTAClientMsg_TipAlert} message CDOTAClientMsg_TipAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_TipAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tip_text = "";
            if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                object.tip_text = message.tip_text;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_TipAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_TipAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_TipAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_TipAlert;
    })();
    
    $root.CDOTAClientMsg_EmptyTeleportAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_EmptyTeleportAlert.
         * @exports ICDOTAClientMsg_EmptyTeleportAlert
         * @interface ICDOTAClientMsg_EmptyTeleportAlert
         * @property {number|null} [target_entindex] CDOTAClientMsg_EmptyTeleportAlert target_entindex
         */
    
        /**
         * Constructs a new CDOTAClientMsg_EmptyTeleportAlert.
         * @exports CDOTAClientMsg_EmptyTeleportAlert
         * @classdesc Represents a CDOTAClientMsg_EmptyTeleportAlert.
         * @implements ICDOTAClientMsg_EmptyTeleportAlert
         * @constructor
         * @param {ICDOTAClientMsg_EmptyTeleportAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_EmptyTeleportAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_EmptyTeleportAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @instance
         */
        CDOTAClientMsg_EmptyTeleportAlert.prototype.target_entindex = 0;
    
        /**
         * Creates a new CDOTAClientMsg_EmptyTeleportAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {ICDOTAClientMsg_EmptyTeleportAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_EmptyTeleportAlert} CDOTAClientMsg_EmptyTeleportAlert instance
         */
        CDOTAClientMsg_EmptyTeleportAlert.create = function create(properties) {
            return new CDOTAClientMsg_EmptyTeleportAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EmptyTeleportAlert message. Does not implicitly {@link CDOTAClientMsg_EmptyTeleportAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {ICDOTAClientMsg_EmptyTeleportAlert} message CDOTAClientMsg_EmptyTeleportAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EmptyTeleportAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.target_entindex);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EmptyTeleportAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_EmptyTeleportAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {ICDOTAClientMsg_EmptyTeleportAlert} message CDOTAClientMsg_EmptyTeleportAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EmptyTeleportAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_EmptyTeleportAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_EmptyTeleportAlert} CDOTAClientMsg_EmptyTeleportAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EmptyTeleportAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_EmptyTeleportAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entindex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_EmptyTeleportAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_EmptyTeleportAlert} CDOTAClientMsg_EmptyTeleportAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EmptyTeleportAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_EmptyTeleportAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_EmptyTeleportAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_EmptyTeleportAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_EmptyTeleportAlert} CDOTAClientMsg_EmptyTeleportAlert
         */
        CDOTAClientMsg_EmptyTeleportAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_EmptyTeleportAlert)
                return object;
            var message = new $root.CDOTAClientMsg_EmptyTeleportAlert();
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_EmptyTeleportAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @static
         * @param {CDOTAClientMsg_EmptyTeleportAlert} message CDOTAClientMsg_EmptyTeleportAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_EmptyTeleportAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.target_entindex = 0;
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_EmptyTeleportAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_EmptyTeleportAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_EmptyTeleportAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_EmptyTeleportAlert;
    })();
    
    $root.CDOTAClientMsg_SetCavernMapVariant = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_SetCavernMapVariant.
         * @exports ICDOTAClientMsg_SetCavernMapVariant
         * @interface ICDOTAClientMsg_SetCavernMapVariant
         * @property {number|null} [map_variant] CDOTAClientMsg_SetCavernMapVariant map_variant
         */
    
        /**
         * Constructs a new CDOTAClientMsg_SetCavernMapVariant.
         * @exports CDOTAClientMsg_SetCavernMapVariant
         * @classdesc Represents a CDOTAClientMsg_SetCavernMapVariant.
         * @implements ICDOTAClientMsg_SetCavernMapVariant
         * @constructor
         * @param {ICDOTAClientMsg_SetCavernMapVariant=} [properties] Properties to set
         */
        function CDOTAClientMsg_SetCavernMapVariant(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_SetCavernMapVariant map_variant.
         * @member {number} map_variant
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @instance
         */
        CDOTAClientMsg_SetCavernMapVariant.prototype.map_variant = 0;
    
        /**
         * Creates a new CDOTAClientMsg_SetCavernMapVariant instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {ICDOTAClientMsg_SetCavernMapVariant=} [properties] Properties to set
         * @returns {CDOTAClientMsg_SetCavernMapVariant} CDOTAClientMsg_SetCavernMapVariant instance
         */
        CDOTAClientMsg_SetCavernMapVariant.create = function create(properties) {
            return new CDOTAClientMsg_SetCavernMapVariant(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetCavernMapVariant message. Does not implicitly {@link CDOTAClientMsg_SetCavernMapVariant.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {ICDOTAClientMsg_SetCavernMapVariant} message CDOTAClientMsg_SetCavernMapVariant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetCavernMapVariant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.map_variant != null && Object.hasOwnProperty.call(message, "map_variant"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.map_variant);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_SetCavernMapVariant message, length delimited. Does not implicitly {@link CDOTAClientMsg_SetCavernMapVariant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {ICDOTAClientMsg_SetCavernMapVariant} message CDOTAClientMsg_SetCavernMapVariant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_SetCavernMapVariant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetCavernMapVariant message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_SetCavernMapVariant} CDOTAClientMsg_SetCavernMapVariant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetCavernMapVariant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_SetCavernMapVariant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.map_variant = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_SetCavernMapVariant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_SetCavernMapVariant} CDOTAClientMsg_SetCavernMapVariant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_SetCavernMapVariant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_SetCavernMapVariant message.
         * @function verify
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_SetCavernMapVariant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.map_variant != null && message.hasOwnProperty("map_variant"))
                if (!$util.isInteger(message.map_variant))
                    return "map_variant: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_SetCavernMapVariant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_SetCavernMapVariant} CDOTAClientMsg_SetCavernMapVariant
         */
        CDOTAClientMsg_SetCavernMapVariant.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_SetCavernMapVariant)
                return object;
            var message = new $root.CDOTAClientMsg_SetCavernMapVariant();
            if (object.map_variant != null)
                message.map_variant = object.map_variant >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_SetCavernMapVariant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @static
         * @param {CDOTAClientMsg_SetCavernMapVariant} message CDOTAClientMsg_SetCavernMapVariant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_SetCavernMapVariant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.map_variant = 0;
            if (message.map_variant != null && message.hasOwnProperty("map_variant"))
                object.map_variant = message.map_variant;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_SetCavernMapVariant to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_SetCavernMapVariant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_SetCavernMapVariant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_SetCavernMapVariant;
    })();
    
    $root.CDOTAClientMsg_PauseGameOrder = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_PauseGameOrder.
         * @exports ICDOTAClientMsg_PauseGameOrder
         * @interface ICDOTAClientMsg_PauseGameOrder
         * @property {number|null} [order_id] CDOTAClientMsg_PauseGameOrder order_id
         * @property {number|null} [data] CDOTAClientMsg_PauseGameOrder data
         */
    
        /**
         * Constructs a new CDOTAClientMsg_PauseGameOrder.
         * @exports CDOTAClientMsg_PauseGameOrder
         * @classdesc Represents a CDOTAClientMsg_PauseGameOrder.
         * @implements ICDOTAClientMsg_PauseGameOrder
         * @constructor
         * @param {ICDOTAClientMsg_PauseGameOrder=} [properties] Properties to set
         */
        function CDOTAClientMsg_PauseGameOrder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_PauseGameOrder order_id.
         * @member {number} order_id
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @instance
         */
        CDOTAClientMsg_PauseGameOrder.prototype.order_id = 0;
    
        /**
         * CDOTAClientMsg_PauseGameOrder data.
         * @member {number} data
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @instance
         */
        CDOTAClientMsg_PauseGameOrder.prototype.data = 0;
    
        /**
         * Creates a new CDOTAClientMsg_PauseGameOrder instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {ICDOTAClientMsg_PauseGameOrder=} [properties] Properties to set
         * @returns {CDOTAClientMsg_PauseGameOrder} CDOTAClientMsg_PauseGameOrder instance
         */
        CDOTAClientMsg_PauseGameOrder.create = function create(properties) {
            return new CDOTAClientMsg_PauseGameOrder(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PauseGameOrder message. Does not implicitly {@link CDOTAClientMsg_PauseGameOrder.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {ICDOTAClientMsg_PauseGameOrder} message CDOTAClientMsg_PauseGameOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PauseGameOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.order_id != null && Object.hasOwnProperty.call(message, "order_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order_id);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_PauseGameOrder message, length delimited. Does not implicitly {@link CDOTAClientMsg_PauseGameOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {ICDOTAClientMsg_PauseGameOrder} message CDOTAClientMsg_PauseGameOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_PauseGameOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_PauseGameOrder message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_PauseGameOrder} CDOTAClientMsg_PauseGameOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PauseGameOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_PauseGameOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.order_id = reader.int32();
                    break;
                case 2:
                    message.data = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_PauseGameOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_PauseGameOrder} CDOTAClientMsg_PauseGameOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_PauseGameOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_PauseGameOrder message.
         * @function verify
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_PauseGameOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.order_id != null && message.hasOwnProperty("order_id"))
                if (!$util.isInteger(message.order_id))
                    return "order_id: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isInteger(message.data))
                    return "data: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_PauseGameOrder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_PauseGameOrder} CDOTAClientMsg_PauseGameOrder
         */
        CDOTAClientMsg_PauseGameOrder.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_PauseGameOrder)
                return object;
            var message = new $root.CDOTAClientMsg_PauseGameOrder();
            if (object.order_id != null)
                message.order_id = object.order_id | 0;
            if (object.data != null)
                message.data = object.data | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_PauseGameOrder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @static
         * @param {CDOTAClientMsg_PauseGameOrder} message CDOTAClientMsg_PauseGameOrder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_PauseGameOrder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.order_id = 0;
                object.data = 0;
            }
            if (message.order_id != null && message.hasOwnProperty("order_id"))
                object.order_id = message.order_id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_PauseGameOrder to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_PauseGameOrder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_PauseGameOrder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_PauseGameOrder;
    })();
    
    $root.CDOTAClientMsg_VersusScene_PlayerBehavior = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_VersusScene_PlayerBehavior.
         * @exports ICDOTAClientMsg_VersusScene_PlayerBehavior
         * @interface ICDOTAClientMsg_VersusScene_PlayerBehavior
         * @property {EDOTAVersusScenePlayerBehavior|null} [behavior] CDOTAClientMsg_VersusScene_PlayerBehavior behavior
         * @property {IVersusScene_PlayActivity|null} [play_activity] CDOTAClientMsg_VersusScene_PlayerBehavior play_activity
         * @property {IVersusScene_ChatWheel|null} [chat_wheel] CDOTAClientMsg_VersusScene_PlayerBehavior chat_wheel
         * @property {IVersusScene_PlaybackRate|null} [playback_rate] CDOTAClientMsg_VersusScene_PlayerBehavior playback_rate
         */
    
        /**
         * Constructs a new CDOTAClientMsg_VersusScene_PlayerBehavior.
         * @exports CDOTAClientMsg_VersusScene_PlayerBehavior
         * @classdesc Represents a CDOTAClientMsg_VersusScene_PlayerBehavior.
         * @implements ICDOTAClientMsg_VersusScene_PlayerBehavior
         * @constructor
         * @param {ICDOTAClientMsg_VersusScene_PlayerBehavior=} [properties] Properties to set
         */
        function CDOTAClientMsg_VersusScene_PlayerBehavior(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_VersusScene_PlayerBehavior behavior.
         * @member {EDOTAVersusScenePlayerBehavior} behavior
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.prototype.behavior = 1;
    
        /**
         * CDOTAClientMsg_VersusScene_PlayerBehavior play_activity.
         * @member {IVersusScene_PlayActivity|null|undefined} play_activity
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.prototype.play_activity = null;
    
        /**
         * CDOTAClientMsg_VersusScene_PlayerBehavior chat_wheel.
         * @member {IVersusScene_ChatWheel|null|undefined} chat_wheel
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.prototype.chat_wheel = null;
    
        /**
         * CDOTAClientMsg_VersusScene_PlayerBehavior playback_rate.
         * @member {IVersusScene_PlaybackRate|null|undefined} playback_rate
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @instance
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.prototype.playback_rate = null;
    
        /**
         * Creates a new CDOTAClientMsg_VersusScene_PlayerBehavior instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {ICDOTAClientMsg_VersusScene_PlayerBehavior=} [properties] Properties to set
         * @returns {CDOTAClientMsg_VersusScene_PlayerBehavior} CDOTAClientMsg_VersusScene_PlayerBehavior instance
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.create = function create(properties) {
            return new CDOTAClientMsg_VersusScene_PlayerBehavior(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_VersusScene_PlayerBehavior message. Does not implicitly {@link CDOTAClientMsg_VersusScene_PlayerBehavior.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {ICDOTAClientMsg_VersusScene_PlayerBehavior} message CDOTAClientMsg_VersusScene_PlayerBehavior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.behavior != null && Object.hasOwnProperty.call(message, "behavior"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.behavior);
            if (message.play_activity != null && Object.hasOwnProperty.call(message, "play_activity"))
                $root.VersusScene_PlayActivity.encode(message.play_activity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.chat_wheel != null && Object.hasOwnProperty.call(message, "chat_wheel"))
                $root.VersusScene_ChatWheel.encode(message.chat_wheel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.playback_rate != null && Object.hasOwnProperty.call(message, "playback_rate"))
                $root.VersusScene_PlaybackRate.encode(message.playback_rate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_VersusScene_PlayerBehavior message, length delimited. Does not implicitly {@link CDOTAClientMsg_VersusScene_PlayerBehavior.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {ICDOTAClientMsg_VersusScene_PlayerBehavior} message CDOTAClientMsg_VersusScene_PlayerBehavior message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_VersusScene_PlayerBehavior message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_VersusScene_PlayerBehavior} CDOTAClientMsg_VersusScene_PlayerBehavior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_VersusScene_PlayerBehavior();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.behavior = reader.int32();
                    break;
                case 2:
                    message.play_activity = $root.VersusScene_PlayActivity.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chat_wheel = $root.VersusScene_ChatWheel.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.playback_rate = $root.VersusScene_PlaybackRate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_VersusScene_PlayerBehavior message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_VersusScene_PlayerBehavior} CDOTAClientMsg_VersusScene_PlayerBehavior
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_VersusScene_PlayerBehavior message.
         * @function verify
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.behavior != null && message.hasOwnProperty("behavior"))
                switch (message.behavior) {
                default:
                    return "behavior: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.play_activity != null && message.hasOwnProperty("play_activity")) {
                var error = $root.VersusScene_PlayActivity.verify(message.play_activity);
                if (error)
                    return "play_activity." + error;
            }
            if (message.chat_wheel != null && message.hasOwnProperty("chat_wheel")) {
                var error = $root.VersusScene_ChatWheel.verify(message.chat_wheel);
                if (error)
                    return "chat_wheel." + error;
            }
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate")) {
                var error = $root.VersusScene_PlaybackRate.verify(message.playback_rate);
                if (error)
                    return "playback_rate." + error;
            }
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_VersusScene_PlayerBehavior message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_VersusScene_PlayerBehavior} CDOTAClientMsg_VersusScene_PlayerBehavior
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_VersusScene_PlayerBehavior)
                return object;
            var message = new $root.CDOTAClientMsg_VersusScene_PlayerBehavior();
            switch (object.behavior) {
            case "VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY":
            case 1:
                message.behavior = 1;
                break;
            case "VS_PLAYER_BEHAVIOR_CHAT_WHEEL":
            case 2:
                message.behavior = 2;
                break;
            case "VS_PLAYER_BEHAVIOR_PLAYBACK_RATE":
            case 3:
                message.behavior = 3;
                break;
            }
            if (object.play_activity != null) {
                if (typeof object.play_activity !== "object")
                    throw TypeError(".CDOTAClientMsg_VersusScene_PlayerBehavior.play_activity: object expected");
                message.play_activity = $root.VersusScene_PlayActivity.fromObject(object.play_activity);
            }
            if (object.chat_wheel != null) {
                if (typeof object.chat_wheel !== "object")
                    throw TypeError(".CDOTAClientMsg_VersusScene_PlayerBehavior.chat_wheel: object expected");
                message.chat_wheel = $root.VersusScene_ChatWheel.fromObject(object.chat_wheel);
            }
            if (object.playback_rate != null) {
                if (typeof object.playback_rate !== "object")
                    throw TypeError(".CDOTAClientMsg_VersusScene_PlayerBehavior.playback_rate: object expected");
                message.playback_rate = $root.VersusScene_PlaybackRate.fromObject(object.playback_rate);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_VersusScene_PlayerBehavior message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @static
         * @param {CDOTAClientMsg_VersusScene_PlayerBehavior} message CDOTAClientMsg_VersusScene_PlayerBehavior
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.behavior = options.enums === String ? "VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY" : 1;
                object.play_activity = null;
                object.chat_wheel = null;
                object.playback_rate = null;
            }
            if (message.behavior != null && message.hasOwnProperty("behavior"))
                object.behavior = options.enums === String ? $root.EDOTAVersusScenePlayerBehavior[message.behavior] : message.behavior;
            if (message.play_activity != null && message.hasOwnProperty("play_activity"))
                object.play_activity = $root.VersusScene_PlayActivity.toObject(message.play_activity, options);
            if (message.chat_wheel != null && message.hasOwnProperty("chat_wheel"))
                object.chat_wheel = $root.VersusScene_ChatWheel.toObject(message.chat_wheel, options);
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                object.playback_rate = $root.VersusScene_PlaybackRate.toObject(message.playback_rate, options);
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_VersusScene_PlayerBehavior to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_VersusScene_PlayerBehavior
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_VersusScene_PlayerBehavior.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_VersusScene_PlayerBehavior;
    })();
    
    $root.CDOTAClientMsg_EmptyItemSlotAlert = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_EmptyItemSlotAlert.
         * @exports ICDOTAClientMsg_EmptyItemSlotAlert
         * @interface ICDOTAClientMsg_EmptyItemSlotAlert
         * @property {number|null} [target_entindex] CDOTAClientMsg_EmptyItemSlotAlert target_entindex
         * @property {number|null} [slot_index] CDOTAClientMsg_EmptyItemSlotAlert slot_index
         */
    
        /**
         * Constructs a new CDOTAClientMsg_EmptyItemSlotAlert.
         * @exports CDOTAClientMsg_EmptyItemSlotAlert
         * @classdesc Represents a CDOTAClientMsg_EmptyItemSlotAlert.
         * @implements ICDOTAClientMsg_EmptyItemSlotAlert
         * @constructor
         * @param {ICDOTAClientMsg_EmptyItemSlotAlert=} [properties] Properties to set
         */
        function CDOTAClientMsg_EmptyItemSlotAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_EmptyItemSlotAlert target_entindex.
         * @member {number} target_entindex
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @instance
         */
        CDOTAClientMsg_EmptyItemSlotAlert.prototype.target_entindex = 0;
    
        /**
         * CDOTAClientMsg_EmptyItemSlotAlert slot_index.
         * @member {number} slot_index
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @instance
         */
        CDOTAClientMsg_EmptyItemSlotAlert.prototype.slot_index = 0;
    
        /**
         * Creates a new CDOTAClientMsg_EmptyItemSlotAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {ICDOTAClientMsg_EmptyItemSlotAlert=} [properties] Properties to set
         * @returns {CDOTAClientMsg_EmptyItemSlotAlert} CDOTAClientMsg_EmptyItemSlotAlert instance
         */
        CDOTAClientMsg_EmptyItemSlotAlert.create = function create(properties) {
            return new CDOTAClientMsg_EmptyItemSlotAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EmptyItemSlotAlert message. Does not implicitly {@link CDOTAClientMsg_EmptyItemSlotAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {ICDOTAClientMsg_EmptyItemSlotAlert} message CDOTAClientMsg_EmptyItemSlotAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EmptyItemSlotAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entindex != null && Object.hasOwnProperty.call(message, "target_entindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.target_entindex);
            if (message.slot_index != null && Object.hasOwnProperty.call(message, "slot_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot_index);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_EmptyItemSlotAlert message, length delimited. Does not implicitly {@link CDOTAClientMsg_EmptyItemSlotAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {ICDOTAClientMsg_EmptyItemSlotAlert} message CDOTAClientMsg_EmptyItemSlotAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_EmptyItemSlotAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_EmptyItemSlotAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_EmptyItemSlotAlert} CDOTAClientMsg_EmptyItemSlotAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EmptyItemSlotAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_EmptyItemSlotAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entindex = reader.int32();
                    break;
                case 2:
                    message.slot_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_EmptyItemSlotAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_EmptyItemSlotAlert} CDOTAClientMsg_EmptyItemSlotAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_EmptyItemSlotAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_EmptyItemSlotAlert message.
         * @function verify
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_EmptyItemSlotAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                if (!$util.isInteger(message.target_entindex))
                    return "target_entindex: integer expected";
            if (message.slot_index != null && message.hasOwnProperty("slot_index"))
                if (!$util.isInteger(message.slot_index))
                    return "slot_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_EmptyItemSlotAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_EmptyItemSlotAlert} CDOTAClientMsg_EmptyItemSlotAlert
         */
        CDOTAClientMsg_EmptyItemSlotAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_EmptyItemSlotAlert)
                return object;
            var message = new $root.CDOTAClientMsg_EmptyItemSlotAlert();
            if (object.target_entindex != null)
                message.target_entindex = object.target_entindex | 0;
            if (object.slot_index != null)
                message.slot_index = object.slot_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_EmptyItemSlotAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @static
         * @param {CDOTAClientMsg_EmptyItemSlotAlert} message CDOTAClientMsg_EmptyItemSlotAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_EmptyItemSlotAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_entindex = 0;
                object.slot_index = 0;
            }
            if (message.target_entindex != null && message.hasOwnProperty("target_entindex"))
                object.target_entindex = message.target_entindex;
            if (message.slot_index != null && message.hasOwnProperty("slot_index"))
                object.slot_index = message.slot_index;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_EmptyItemSlotAlert to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_EmptyItemSlotAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_EmptyItemSlotAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_EmptyItemSlotAlert;
    })();
    
    $root.CDOTAClientMsg_AddMarker = (function() {
    
        /**
         * Properties of a CDOTAClientMsg_AddMarker.
         * @exports ICDOTAClientMsg_AddMarker
         * @interface ICDOTAClientMsg_AddMarker
         * @property {number|null} [target_player_id] CDOTAClientMsg_AddMarker target_player_id
         * @property {number|null} [reason] CDOTAClientMsg_AddMarker reason
         * @property {string|null} [comment] CDOTAClientMsg_AddMarker comment
         */
    
        /**
         * Constructs a new CDOTAClientMsg_AddMarker.
         * @exports CDOTAClientMsg_AddMarker
         * @classdesc Represents a CDOTAClientMsg_AddMarker.
         * @implements ICDOTAClientMsg_AddMarker
         * @constructor
         * @param {ICDOTAClientMsg_AddMarker=} [properties] Properties to set
         */
        function CDOTAClientMsg_AddMarker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientMsg_AddMarker target_player_id.
         * @member {number} target_player_id
         * @memberof CDOTAClientMsg_AddMarker
         * @instance
         */
        CDOTAClientMsg_AddMarker.prototype.target_player_id = 0;
    
        /**
         * CDOTAClientMsg_AddMarker reason.
         * @member {number} reason
         * @memberof CDOTAClientMsg_AddMarker
         * @instance
         */
        CDOTAClientMsg_AddMarker.prototype.reason = 0;
    
        /**
         * CDOTAClientMsg_AddMarker comment.
         * @member {string} comment
         * @memberof CDOTAClientMsg_AddMarker
         * @instance
         */
        CDOTAClientMsg_AddMarker.prototype.comment = "";
    
        /**
         * Creates a new CDOTAClientMsg_AddMarker instance using the specified properties.
         * @function create
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {ICDOTAClientMsg_AddMarker=} [properties] Properties to set
         * @returns {CDOTAClientMsg_AddMarker} CDOTAClientMsg_AddMarker instance
         */
        CDOTAClientMsg_AddMarker.create = function create(properties) {
            return new CDOTAClientMsg_AddMarker(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_AddMarker message. Does not implicitly {@link CDOTAClientMsg_AddMarker.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {ICDOTAClientMsg_AddMarker} message CDOTAClientMsg_AddMarker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_AddMarker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_player_id != null && Object.hasOwnProperty.call(message, "target_player_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.target_player_id);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.reason);
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.comment);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientMsg_AddMarker message, length delimited. Does not implicitly {@link CDOTAClientMsg_AddMarker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {ICDOTAClientMsg_AddMarker} message CDOTAClientMsg_AddMarker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientMsg_AddMarker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientMsg_AddMarker message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientMsg_AddMarker} CDOTAClientMsg_AddMarker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_AddMarker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientMsg_AddMarker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_player_id = reader.int32();
                    break;
                case 2:
                    message.reason = reader.uint32();
                    break;
                case 3:
                    message.comment = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientMsg_AddMarker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientMsg_AddMarker} CDOTAClientMsg_AddMarker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientMsg_AddMarker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientMsg_AddMarker message.
         * @function verify
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientMsg_AddMarker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                if (!$util.isInteger(message.target_player_id))
                    return "target_player_id: integer expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isInteger(message.reason))
                    return "reason: integer expected";
            if (message.comment != null && message.hasOwnProperty("comment"))
                if (!$util.isString(message.comment))
                    return "comment: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientMsg_AddMarker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientMsg_AddMarker} CDOTAClientMsg_AddMarker
         */
        CDOTAClientMsg_AddMarker.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientMsg_AddMarker)
                return object;
            var message = new $root.CDOTAClientMsg_AddMarker();
            if (object.target_player_id != null)
                message.target_player_id = object.target_player_id | 0;
            if (object.reason != null)
                message.reason = object.reason >>> 0;
            if (object.comment != null)
                message.comment = String(object.comment);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientMsg_AddMarker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientMsg_AddMarker
         * @static
         * @param {CDOTAClientMsg_AddMarker} message CDOTAClientMsg_AddMarker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientMsg_AddMarker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_player_id = 0;
                object.reason = 0;
                object.comment = "";
            }
            if (message.target_player_id != null && message.hasOwnProperty("target_player_id"))
                object.target_player_id = message.target_player_id;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.comment != null && message.hasOwnProperty("comment"))
                object.comment = message.comment;
            return object;
        };
    
        /**
         * Converts this CDOTAClientMsg_AddMarker to JSON.
         * @function toJSON
         * @memberof CDOTAClientMsg_AddMarker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientMsg_AddMarker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientMsg_AddMarker;
    })();
    
    /**
     * EDOTAStatPopupTypes enum.
     * @exports EDOTAStatPopupTypes
     * @enum {number}
     * @property {number} k_EDOTA_SPT_Textline=0 k_EDOTA_SPT_Textline value
     * @property {number} k_EDOTA_SPT_Basic=1 k_EDOTA_SPT_Basic value
     * @property {number} k_EDOTA_SPT_Poll=2 k_EDOTA_SPT_Poll value
     * @property {number} k_EDOTA_SPT_Grid=3 k_EDOTA_SPT_Grid value
     * @property {number} k_EDOTA_SPT_DualImage=4 k_EDOTA_SPT_DualImage value
     * @property {number} k_EDOTA_SPT_Movie=5 k_EDOTA_SPT_Movie value
     */
    $root.EDOTAStatPopupTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTA_SPT_Textline"] = 0;
        values[valuesById[1] = "k_EDOTA_SPT_Basic"] = 1;
        values[valuesById[2] = "k_EDOTA_SPT_Poll"] = 2;
        values[valuesById[3] = "k_EDOTA_SPT_Grid"] = 3;
        values[valuesById[4] = "k_EDOTA_SPT_DualImage"] = 4;
        values[valuesById[5] = "k_EDOTA_SPT_Movie"] = 5;
        return values;
    })();
    
    /**
     * dotaunitorder_t enum.
     * @exports dotaunitorder_t
     * @enum {number}
     * @property {number} DOTA_UNIT_ORDER_NONE=0 DOTA_UNIT_ORDER_NONE value
     * @property {number} DOTA_UNIT_ORDER_MOVE_TO_POSITION=1 DOTA_UNIT_ORDER_MOVE_TO_POSITION value
     * @property {number} DOTA_UNIT_ORDER_MOVE_TO_TARGET=2 DOTA_UNIT_ORDER_MOVE_TO_TARGET value
     * @property {number} DOTA_UNIT_ORDER_ATTACK_MOVE=3 DOTA_UNIT_ORDER_ATTACK_MOVE value
     * @property {number} DOTA_UNIT_ORDER_ATTACK_TARGET=4 DOTA_UNIT_ORDER_ATTACK_TARGET value
     * @property {number} DOTA_UNIT_ORDER_CAST_POSITION=5 DOTA_UNIT_ORDER_CAST_POSITION value
     * @property {number} DOTA_UNIT_ORDER_CAST_TARGET=6 DOTA_UNIT_ORDER_CAST_TARGET value
     * @property {number} DOTA_UNIT_ORDER_CAST_TARGET_TREE=7 DOTA_UNIT_ORDER_CAST_TARGET_TREE value
     * @property {number} DOTA_UNIT_ORDER_CAST_NO_TARGET=8 DOTA_UNIT_ORDER_CAST_NO_TARGET value
     * @property {number} DOTA_UNIT_ORDER_CAST_TOGGLE=9 DOTA_UNIT_ORDER_CAST_TOGGLE value
     * @property {number} DOTA_UNIT_ORDER_HOLD_POSITION=10 DOTA_UNIT_ORDER_HOLD_POSITION value
     * @property {number} DOTA_UNIT_ORDER_TRAIN_ABILITY=11 DOTA_UNIT_ORDER_TRAIN_ABILITY value
     * @property {number} DOTA_UNIT_ORDER_DROP_ITEM=12 DOTA_UNIT_ORDER_DROP_ITEM value
     * @property {number} DOTA_UNIT_ORDER_GIVE_ITEM=13 DOTA_UNIT_ORDER_GIVE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_PICKUP_ITEM=14 DOTA_UNIT_ORDER_PICKUP_ITEM value
     * @property {number} DOTA_UNIT_ORDER_PICKUP_RUNE=15 DOTA_UNIT_ORDER_PICKUP_RUNE value
     * @property {number} DOTA_UNIT_ORDER_PURCHASE_ITEM=16 DOTA_UNIT_ORDER_PURCHASE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_SELL_ITEM=17 DOTA_UNIT_ORDER_SELL_ITEM value
     * @property {number} DOTA_UNIT_ORDER_DISASSEMBLE_ITEM=18 DOTA_UNIT_ORDER_DISASSEMBLE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_MOVE_ITEM=19 DOTA_UNIT_ORDER_MOVE_ITEM value
     * @property {number} DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO=20 DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO value
     * @property {number} DOTA_UNIT_ORDER_STOP=21 DOTA_UNIT_ORDER_STOP value
     * @property {number} DOTA_UNIT_ORDER_TAUNT=22 DOTA_UNIT_ORDER_TAUNT value
     * @property {number} DOTA_UNIT_ORDER_BUYBACK=23 DOTA_UNIT_ORDER_BUYBACK value
     * @property {number} DOTA_UNIT_ORDER_GLYPH=24 DOTA_UNIT_ORDER_GLYPH value
     * @property {number} DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH=25 DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH value
     * @property {number} DOTA_UNIT_ORDER_CAST_RUNE=26 DOTA_UNIT_ORDER_CAST_RUNE value
     * @property {number} DOTA_UNIT_ORDER_PING_ABILITY=27 DOTA_UNIT_ORDER_PING_ABILITY value
     * @property {number} DOTA_UNIT_ORDER_MOVE_TO_DIRECTION=28 DOTA_UNIT_ORDER_MOVE_TO_DIRECTION value
     * @property {number} DOTA_UNIT_ORDER_PATROL=29 DOTA_UNIT_ORDER_PATROL value
     * @property {number} DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION=30 DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION value
     * @property {number} DOTA_UNIT_ORDER_RADAR=31 DOTA_UNIT_ORDER_RADAR value
     * @property {number} DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK=32 DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK value
     * @property {number} DOTA_UNIT_ORDER_CONTINUE=33 DOTA_UNIT_ORDER_CONTINUE value
     * @property {number} DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED=34 DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED value
     * @property {number} DOTA_UNIT_ORDER_CAST_RIVER_PAINT=35 DOTA_UNIT_ORDER_CAST_RIVER_PAINT value
     * @property {number} DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT=36 DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT value
     * @property {number} DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN=37 DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN value
     * @property {number} DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH=38 DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH value
     */
    $root.dotaunitorder_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_UNIT_ORDER_NONE"] = 0;
        values[valuesById[1] = "DOTA_UNIT_ORDER_MOVE_TO_POSITION"] = 1;
        values[valuesById[2] = "DOTA_UNIT_ORDER_MOVE_TO_TARGET"] = 2;
        values[valuesById[3] = "DOTA_UNIT_ORDER_ATTACK_MOVE"] = 3;
        values[valuesById[4] = "DOTA_UNIT_ORDER_ATTACK_TARGET"] = 4;
        values[valuesById[5] = "DOTA_UNIT_ORDER_CAST_POSITION"] = 5;
        values[valuesById[6] = "DOTA_UNIT_ORDER_CAST_TARGET"] = 6;
        values[valuesById[7] = "DOTA_UNIT_ORDER_CAST_TARGET_TREE"] = 7;
        values[valuesById[8] = "DOTA_UNIT_ORDER_CAST_NO_TARGET"] = 8;
        values[valuesById[9] = "DOTA_UNIT_ORDER_CAST_TOGGLE"] = 9;
        values[valuesById[10] = "DOTA_UNIT_ORDER_HOLD_POSITION"] = 10;
        values[valuesById[11] = "DOTA_UNIT_ORDER_TRAIN_ABILITY"] = 11;
        values[valuesById[12] = "DOTA_UNIT_ORDER_DROP_ITEM"] = 12;
        values[valuesById[13] = "DOTA_UNIT_ORDER_GIVE_ITEM"] = 13;
        values[valuesById[14] = "DOTA_UNIT_ORDER_PICKUP_ITEM"] = 14;
        values[valuesById[15] = "DOTA_UNIT_ORDER_PICKUP_RUNE"] = 15;
        values[valuesById[16] = "DOTA_UNIT_ORDER_PURCHASE_ITEM"] = 16;
        values[valuesById[17] = "DOTA_UNIT_ORDER_SELL_ITEM"] = 17;
        values[valuesById[18] = "DOTA_UNIT_ORDER_DISASSEMBLE_ITEM"] = 18;
        values[valuesById[19] = "DOTA_UNIT_ORDER_MOVE_ITEM"] = 19;
        values[valuesById[20] = "DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO"] = 20;
        values[valuesById[21] = "DOTA_UNIT_ORDER_STOP"] = 21;
        values[valuesById[22] = "DOTA_UNIT_ORDER_TAUNT"] = 22;
        values[valuesById[23] = "DOTA_UNIT_ORDER_BUYBACK"] = 23;
        values[valuesById[24] = "DOTA_UNIT_ORDER_GLYPH"] = 24;
        values[valuesById[25] = "DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH"] = 25;
        values[valuesById[26] = "DOTA_UNIT_ORDER_CAST_RUNE"] = 26;
        values[valuesById[27] = "DOTA_UNIT_ORDER_PING_ABILITY"] = 27;
        values[valuesById[28] = "DOTA_UNIT_ORDER_MOVE_TO_DIRECTION"] = 28;
        values[valuesById[29] = "DOTA_UNIT_ORDER_PATROL"] = 29;
        values[valuesById[30] = "DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION"] = 30;
        values[valuesById[31] = "DOTA_UNIT_ORDER_RADAR"] = 31;
        values[valuesById[32] = "DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK"] = 32;
        values[valuesById[33] = "DOTA_UNIT_ORDER_CONTINUE"] = 33;
        values[valuesById[34] = "DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED"] = 34;
        values[valuesById[35] = "DOTA_UNIT_ORDER_CAST_RIVER_PAINT"] = 35;
        values[valuesById[36] = "DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT"] = 36;
        values[valuesById[37] = "DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN"] = 37;
        values[valuesById[38] = "DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH"] = 38;
        return values;
    })();
    
    /**
     * EDOTAVersusScenePlayerBehavior enum.
     * @exports EDOTAVersusScenePlayerBehavior
     * @enum {number}
     * @property {number} VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY=1 VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY value
     * @property {number} VS_PLAYER_BEHAVIOR_CHAT_WHEEL=2 VS_PLAYER_BEHAVIOR_CHAT_WHEEL value
     * @property {number} VS_PLAYER_BEHAVIOR_PLAYBACK_RATE=3 VS_PLAYER_BEHAVIOR_PLAYBACK_RATE value
     */
    $root.EDOTAVersusScenePlayerBehavior = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY"] = 1;
        values[valuesById[2] = "VS_PLAYER_BEHAVIOR_CHAT_WHEEL"] = 2;
        values[valuesById[3] = "VS_PLAYER_BEHAVIOR_PLAYBACK_RATE"] = 3;
        return values;
    })();
    
    $root.CDOTAMsg_LocationPing = (function() {
    
        /**
         * Properties of a CDOTAMsg_LocationPing.
         * @exports ICDOTAMsg_LocationPing
         * @interface ICDOTAMsg_LocationPing
         * @property {number|null} [x] CDOTAMsg_LocationPing x
         * @property {number|null} [y] CDOTAMsg_LocationPing y
         * @property {number|null} [target] CDOTAMsg_LocationPing target
         * @property {boolean|null} [direct_ping] CDOTAMsg_LocationPing direct_ping
         * @property {number|null} [type] CDOTAMsg_LocationPing type
         */
    
        /**
         * Constructs a new CDOTAMsg_LocationPing.
         * @exports CDOTAMsg_LocationPing
         * @classdesc Represents a CDOTAMsg_LocationPing.
         * @implements ICDOTAMsg_LocationPing
         * @constructor
         * @param {ICDOTAMsg_LocationPing=} [properties] Properties to set
         */
        function CDOTAMsg_LocationPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_LocationPing x.
         * @member {number} x
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.x = 0;
    
        /**
         * CDOTAMsg_LocationPing y.
         * @member {number} y
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.y = 0;
    
        /**
         * CDOTAMsg_LocationPing target.
         * @member {number} target
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.target = 0;
    
        /**
         * CDOTAMsg_LocationPing direct_ping.
         * @member {boolean} direct_ping
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.direct_ping = false;
    
        /**
         * CDOTAMsg_LocationPing type.
         * @member {number} type
         * @memberof CDOTAMsg_LocationPing
         * @instance
         */
        CDOTAMsg_LocationPing.prototype.type = 0;
    
        /**
         * Creates a new CDOTAMsg_LocationPing instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {ICDOTAMsg_LocationPing=} [properties] Properties to set
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing instance
         */
        CDOTAMsg_LocationPing.create = function create(properties) {
            return new CDOTAMsg_LocationPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_LocationPing message. Does not implicitly {@link CDOTAMsg_LocationPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {ICDOTAMsg_LocationPing} message CDOTAMsg_LocationPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_LocationPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.target);
            if (message.direct_ping != null && Object.hasOwnProperty.call(message, "direct_ping"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.direct_ping);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_LocationPing message, length delimited. Does not implicitly {@link CDOTAMsg_LocationPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {ICDOTAMsg_LocationPing} message CDOTAMsg_LocationPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_LocationPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_LocationPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_LocationPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_LocationPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.target = reader.int32();
                    break;
                case 4:
                    message.direct_ping = reader.bool();
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_LocationPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_LocationPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_LocationPing message.
         * @function verify
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_LocationPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!$util.isInteger(message.target))
                    return "target: integer expected";
            if (message.direct_ping != null && message.hasOwnProperty("direct_ping"))
                if (typeof message.direct_ping !== "boolean")
                    return "direct_ping: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_LocationPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_LocationPing} CDOTAMsg_LocationPing
         */
        CDOTAMsg_LocationPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_LocationPing)
                return object;
            var message = new $root.CDOTAMsg_LocationPing();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.target != null)
                message.target = object.target | 0;
            if (object.direct_ping != null)
                message.direct_ping = Boolean(object.direct_ping);
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_LocationPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_LocationPing
         * @static
         * @param {CDOTAMsg_LocationPing} message CDOTAMsg_LocationPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_LocationPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.target = 0;
                object.direct_ping = false;
                object.type = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = message.target;
            if (message.direct_ping != null && message.hasOwnProperty("direct_ping"))
                object.direct_ping = message.direct_ping;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_LocationPing to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_LocationPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_LocationPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_LocationPing;
    })();
    
    $root.CDOTAMsg_ItemAlert = (function() {
    
        /**
         * Properties of a CDOTAMsg_ItemAlert.
         * @exports ICDOTAMsg_ItemAlert
         * @interface ICDOTAMsg_ItemAlert
         * @property {number|null} [x] CDOTAMsg_ItemAlert x
         * @property {number|null} [y] CDOTAMsg_ItemAlert y
         * @property {number|null} [item_ability_id] CDOTAMsg_ItemAlert item_ability_id
         */
    
        /**
         * Constructs a new CDOTAMsg_ItemAlert.
         * @exports CDOTAMsg_ItemAlert
         * @classdesc Represents a CDOTAMsg_ItemAlert.
         * @implements ICDOTAMsg_ItemAlert
         * @constructor
         * @param {ICDOTAMsg_ItemAlert=} [properties] Properties to set
         */
        function CDOTAMsg_ItemAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_ItemAlert x.
         * @member {number} x
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         */
        CDOTAMsg_ItemAlert.prototype.x = 0;
    
        /**
         * CDOTAMsg_ItemAlert y.
         * @member {number} y
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         */
        CDOTAMsg_ItemAlert.prototype.y = 0;
    
        /**
         * CDOTAMsg_ItemAlert item_ability_id.
         * @member {number} item_ability_id
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         */
        CDOTAMsg_ItemAlert.prototype.item_ability_id = 0;
    
        /**
         * Creates a new CDOTAMsg_ItemAlert instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {ICDOTAMsg_ItemAlert=} [properties] Properties to set
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert instance
         */
        CDOTAMsg_ItemAlert.create = function create(properties) {
            return new CDOTAMsg_ItemAlert(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_ItemAlert message. Does not implicitly {@link CDOTAMsg_ItemAlert.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {ICDOTAMsg_ItemAlert} message CDOTAMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_ItemAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.item_ability_id != null && Object.hasOwnProperty.call(message, "item_ability_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.item_ability_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_ItemAlert message, length delimited. Does not implicitly {@link CDOTAMsg_ItemAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {ICDOTAMsg_ItemAlert} message CDOTAMsg_ItemAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_ItemAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_ItemAlert message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_ItemAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_ItemAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.item_ability_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_ItemAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_ItemAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_ItemAlert message.
         * @function verify
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_ItemAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                if (!$util.isInteger(message.item_ability_id))
                    return "item_ability_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_ItemAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_ItemAlert} CDOTAMsg_ItemAlert
         */
        CDOTAMsg_ItemAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_ItemAlert)
                return object;
            var message = new $root.CDOTAMsg_ItemAlert();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.item_ability_id != null)
                message.item_ability_id = object.item_ability_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_ItemAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_ItemAlert
         * @static
         * @param {CDOTAMsg_ItemAlert} message CDOTAMsg_ItemAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_ItemAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.item_ability_id = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.item_ability_id != null && message.hasOwnProperty("item_ability_id"))
                object.item_ability_id = message.item_ability_id;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_ItemAlert to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_ItemAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_ItemAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_ItemAlert;
    })();
    
    $root.CDOTAMsg_MapLine = (function() {
    
        /**
         * Properties of a CDOTAMsg_MapLine.
         * @exports ICDOTAMsg_MapLine
         * @interface ICDOTAMsg_MapLine
         * @property {number|null} [x] CDOTAMsg_MapLine x
         * @property {number|null} [y] CDOTAMsg_MapLine y
         * @property {boolean|null} [initial] CDOTAMsg_MapLine initial
         */
    
        /**
         * Constructs a new CDOTAMsg_MapLine.
         * @exports CDOTAMsg_MapLine
         * @classdesc Represents a CDOTAMsg_MapLine.
         * @implements ICDOTAMsg_MapLine
         * @constructor
         * @param {ICDOTAMsg_MapLine=} [properties] Properties to set
         */
        function CDOTAMsg_MapLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_MapLine x.
         * @member {number} x
         * @memberof CDOTAMsg_MapLine
         * @instance
         */
        CDOTAMsg_MapLine.prototype.x = 0;
    
        /**
         * CDOTAMsg_MapLine y.
         * @member {number} y
         * @memberof CDOTAMsg_MapLine
         * @instance
         */
        CDOTAMsg_MapLine.prototype.y = 0;
    
        /**
         * CDOTAMsg_MapLine initial.
         * @member {boolean} initial
         * @memberof CDOTAMsg_MapLine
         * @instance
         */
        CDOTAMsg_MapLine.prototype.initial = false;
    
        /**
         * Creates a new CDOTAMsg_MapLine instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {ICDOTAMsg_MapLine=} [properties] Properties to set
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine instance
         */
        CDOTAMsg_MapLine.create = function create(properties) {
            return new CDOTAMsg_MapLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_MapLine message. Does not implicitly {@link CDOTAMsg_MapLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {ICDOTAMsg_MapLine} message CDOTAMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_MapLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.initial != null && Object.hasOwnProperty.call(message, "initial"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.initial);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_MapLine message, length delimited. Does not implicitly {@link CDOTAMsg_MapLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {ICDOTAMsg_MapLine} message CDOTAMsg_MapLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_MapLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_MapLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_MapLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_MapLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.initial = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_MapLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_MapLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_MapLine message.
         * @function verify
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_MapLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.initial != null && message.hasOwnProperty("initial"))
                if (typeof message.initial !== "boolean")
                    return "initial: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_MapLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_MapLine} CDOTAMsg_MapLine
         */
        CDOTAMsg_MapLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_MapLine)
                return object;
            var message = new $root.CDOTAMsg_MapLine();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.initial != null)
                message.initial = Boolean(object.initial);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_MapLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_MapLine
         * @static
         * @param {CDOTAMsg_MapLine} message CDOTAMsg_MapLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_MapLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.initial = false;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.initial != null && message.hasOwnProperty("initial"))
                object.initial = message.initial;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_MapLine to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_MapLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_MapLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_MapLine;
    })();
    
    $root.CDOTAMsg_WorldLine = (function() {
    
        /**
         * Properties of a CDOTAMsg_WorldLine.
         * @exports ICDOTAMsg_WorldLine
         * @interface ICDOTAMsg_WorldLine
         * @property {number|null} [x] CDOTAMsg_WorldLine x
         * @property {number|null} [y] CDOTAMsg_WorldLine y
         * @property {number|null} [z] CDOTAMsg_WorldLine z
         * @property {boolean|null} [initial] CDOTAMsg_WorldLine initial
         * @property {boolean|null} [end] CDOTAMsg_WorldLine end
         */
    
        /**
         * Constructs a new CDOTAMsg_WorldLine.
         * @exports CDOTAMsg_WorldLine
         * @classdesc Represents a CDOTAMsg_WorldLine.
         * @implements ICDOTAMsg_WorldLine
         * @constructor
         * @param {ICDOTAMsg_WorldLine=} [properties] Properties to set
         */
        function CDOTAMsg_WorldLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_WorldLine x.
         * @member {number} x
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.x = 0;
    
        /**
         * CDOTAMsg_WorldLine y.
         * @member {number} y
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.y = 0;
    
        /**
         * CDOTAMsg_WorldLine z.
         * @member {number} z
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.z = 0;
    
        /**
         * CDOTAMsg_WorldLine initial.
         * @member {boolean} initial
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.initial = false;
    
        /**
         * CDOTAMsg_WorldLine end.
         * @member {boolean} end
         * @memberof CDOTAMsg_WorldLine
         * @instance
         */
        CDOTAMsg_WorldLine.prototype.end = false;
    
        /**
         * Creates a new CDOTAMsg_WorldLine instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {ICDOTAMsg_WorldLine=} [properties] Properties to set
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine instance
         */
        CDOTAMsg_WorldLine.create = function create(properties) {
            return new CDOTAMsg_WorldLine(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_WorldLine message. Does not implicitly {@link CDOTAMsg_WorldLine.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {ICDOTAMsg_WorldLine} message CDOTAMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_WorldLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.z);
            if (message.initial != null && Object.hasOwnProperty.call(message, "initial"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.initial);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.end);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_WorldLine message, length delimited. Does not implicitly {@link CDOTAMsg_WorldLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {ICDOTAMsg_WorldLine} message CDOTAMsg_WorldLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_WorldLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_WorldLine message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_WorldLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_WorldLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.int32();
                    break;
                case 2:
                    message.y = reader.int32();
                    break;
                case 3:
                    message.z = reader.int32();
                    break;
                case 4:
                    message.initial = reader.bool();
                    break;
                case 5:
                    message.end = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_WorldLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_WorldLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_WorldLine message.
         * @function verify
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_WorldLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            if (message.initial != null && message.hasOwnProperty("initial"))
                if (typeof message.initial !== "boolean")
                    return "initial: boolean expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end !== "boolean")
                    return "end: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_WorldLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_WorldLine} CDOTAMsg_WorldLine
         */
        CDOTAMsg_WorldLine.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_WorldLine)
                return object;
            var message = new $root.CDOTAMsg_WorldLine();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            if (object.z != null)
                message.z = object.z | 0;
            if (object.initial != null)
                message.initial = Boolean(object.initial);
            if (object.end != null)
                message.end = Boolean(object.end);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_WorldLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_WorldLine
         * @static
         * @param {CDOTAMsg_WorldLine} message CDOTAMsg_WorldLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_WorldLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.initial = false;
                object.end = false;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            if (message.initial != null && message.hasOwnProperty("initial"))
                object.initial = message.initial;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = message.end;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_WorldLine to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_WorldLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_WorldLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_WorldLine;
    })();
    
    $root.CDOTAMsg_SendStatPopup = (function() {
    
        /**
         * Properties of a CDOTAMsg_SendStatPopup.
         * @exports ICDOTAMsg_SendStatPopup
         * @interface ICDOTAMsg_SendStatPopup
         * @property {EDOTAStatPopupTypes|null} [style] CDOTAMsg_SendStatPopup style
         * @property {Array.<string>|null} [stat_strings] CDOTAMsg_SendStatPopup stat_strings
         * @property {Array.<number>|null} [stat_images] CDOTAMsg_SendStatPopup stat_images
         * @property {Array.<number>|null} [stat_image_types] CDOTAMsg_SendStatPopup stat_image_types
         * @property {number|null} [duration] CDOTAMsg_SendStatPopup duration
         * @property {boolean|null} [use_html] CDOTAMsg_SendStatPopup use_html
         * @property {string|null} [movie_name] CDOTAMsg_SendStatPopup movie_name
         */
    
        /**
         * Constructs a new CDOTAMsg_SendStatPopup.
         * @exports CDOTAMsg_SendStatPopup
         * @classdesc Represents a CDOTAMsg_SendStatPopup.
         * @implements ICDOTAMsg_SendStatPopup
         * @constructor
         * @param {ICDOTAMsg_SendStatPopup=} [properties] Properties to set
         */
        function CDOTAMsg_SendStatPopup(properties) {
            this.stat_strings = [];
            this.stat_images = [];
            this.stat_image_types = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_SendStatPopup style.
         * @member {EDOTAStatPopupTypes} style
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.style = 0;
    
        /**
         * CDOTAMsg_SendStatPopup stat_strings.
         * @member {Array.<string>} stat_strings
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.stat_strings = $util.emptyArray;
    
        /**
         * CDOTAMsg_SendStatPopup stat_images.
         * @member {Array.<number>} stat_images
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.stat_images = $util.emptyArray;
    
        /**
         * CDOTAMsg_SendStatPopup stat_image_types.
         * @member {Array.<number>} stat_image_types
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.stat_image_types = $util.emptyArray;
    
        /**
         * CDOTAMsg_SendStatPopup duration.
         * @member {number} duration
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.duration = 0;
    
        /**
         * CDOTAMsg_SendStatPopup use_html.
         * @member {boolean} use_html
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.use_html = false;
    
        /**
         * CDOTAMsg_SendStatPopup movie_name.
         * @member {string} movie_name
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         */
        CDOTAMsg_SendStatPopup.prototype.movie_name = "";
    
        /**
         * Creates a new CDOTAMsg_SendStatPopup instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {ICDOTAMsg_SendStatPopup=} [properties] Properties to set
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup instance
         */
        CDOTAMsg_SendStatPopup.create = function create(properties) {
            return new CDOTAMsg_SendStatPopup(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_SendStatPopup message. Does not implicitly {@link CDOTAMsg_SendStatPopup.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {ICDOTAMsg_SendStatPopup} message CDOTAMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_SendStatPopup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
            if (message.stat_strings != null && message.stat_strings.length)
                for (var i = 0; i < message.stat_strings.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.stat_strings[i]);
            if (message.stat_images != null && message.stat_images.length)
                for (var i = 0; i < message.stat_images.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.stat_images[i]);
            if (message.stat_image_types != null && message.stat_image_types.length)
                for (var i = 0; i < message.stat_image_types.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.stat_image_types[i]);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.duration);
            if (message.use_html != null && Object.hasOwnProperty.call(message, "use_html"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.use_html);
            if (message.movie_name != null && Object.hasOwnProperty.call(message, "movie_name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.movie_name);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_SendStatPopup message, length delimited. Does not implicitly {@link CDOTAMsg_SendStatPopup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {ICDOTAMsg_SendStatPopup} message CDOTAMsg_SendStatPopup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_SendStatPopup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_SendStatPopup message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_SendStatPopup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_SendStatPopup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.style = reader.int32();
                    break;
                case 2:
                    if (!(message.stat_strings && message.stat_strings.length))
                        message.stat_strings = [];
                    message.stat_strings.push(reader.string());
                    break;
                case 3:
                    if (!(message.stat_images && message.stat_images.length))
                        message.stat_images = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stat_images.push(reader.int32());
                    } else
                        message.stat_images.push(reader.int32());
                    break;
                case 4:
                    if (!(message.stat_image_types && message.stat_image_types.length))
                        message.stat_image_types = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stat_image_types.push(reader.int32());
                    } else
                        message.stat_image_types.push(reader.int32());
                    break;
                case 5:
                    message.duration = reader.float();
                    break;
                case 6:
                    message.use_html = reader.bool();
                    break;
                case 7:
                    message.movie_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_SendStatPopup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_SendStatPopup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_SendStatPopup message.
         * @function verify
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_SendStatPopup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.style != null && message.hasOwnProperty("style"))
                switch (message.style) {
                default:
                    return "style: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.stat_strings != null && message.hasOwnProperty("stat_strings")) {
                if (!Array.isArray(message.stat_strings))
                    return "stat_strings: array expected";
                for (var i = 0; i < message.stat_strings.length; ++i)
                    if (!$util.isString(message.stat_strings[i]))
                        return "stat_strings: string[] expected";
            }
            if (message.stat_images != null && message.hasOwnProperty("stat_images")) {
                if (!Array.isArray(message.stat_images))
                    return "stat_images: array expected";
                for (var i = 0; i < message.stat_images.length; ++i)
                    if (!$util.isInteger(message.stat_images[i]))
                        return "stat_images: integer[] expected";
            }
            if (message.stat_image_types != null && message.hasOwnProperty("stat_image_types")) {
                if (!Array.isArray(message.stat_image_types))
                    return "stat_image_types: array expected";
                for (var i = 0; i < message.stat_image_types.length; ++i)
                    if (!$util.isInteger(message.stat_image_types[i]))
                        return "stat_image_types: integer[] expected";
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.use_html != null && message.hasOwnProperty("use_html"))
                if (typeof message.use_html !== "boolean")
                    return "use_html: boolean expected";
            if (message.movie_name != null && message.hasOwnProperty("movie_name"))
                if (!$util.isString(message.movie_name))
                    return "movie_name: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_SendStatPopup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_SendStatPopup} CDOTAMsg_SendStatPopup
         */
        CDOTAMsg_SendStatPopup.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_SendStatPopup)
                return object;
            var message = new $root.CDOTAMsg_SendStatPopup();
            switch (object.style) {
            case "k_EDOTA_SPT_Textline":
            case 0:
                message.style = 0;
                break;
            case "k_EDOTA_SPT_Basic":
            case 1:
                message.style = 1;
                break;
            case "k_EDOTA_SPT_Poll":
            case 2:
                message.style = 2;
                break;
            case "k_EDOTA_SPT_Grid":
            case 3:
                message.style = 3;
                break;
            case "k_EDOTA_SPT_DualImage":
            case 4:
                message.style = 4;
                break;
            case "k_EDOTA_SPT_Movie":
            case 5:
                message.style = 5;
                break;
            }
            if (object.stat_strings) {
                if (!Array.isArray(object.stat_strings))
                    throw TypeError(".CDOTAMsg_SendStatPopup.stat_strings: array expected");
                message.stat_strings = [];
                for (var i = 0; i < object.stat_strings.length; ++i)
                    message.stat_strings[i] = String(object.stat_strings[i]);
            }
            if (object.stat_images) {
                if (!Array.isArray(object.stat_images))
                    throw TypeError(".CDOTAMsg_SendStatPopup.stat_images: array expected");
                message.stat_images = [];
                for (var i = 0; i < object.stat_images.length; ++i)
                    message.stat_images[i] = object.stat_images[i] | 0;
            }
            if (object.stat_image_types) {
                if (!Array.isArray(object.stat_image_types))
                    throw TypeError(".CDOTAMsg_SendStatPopup.stat_image_types: array expected");
                message.stat_image_types = [];
                for (var i = 0; i < object.stat_image_types.length; ++i)
                    message.stat_image_types[i] = object.stat_image_types[i] | 0;
            }
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.use_html != null)
                message.use_html = Boolean(object.use_html);
            if (object.movie_name != null)
                message.movie_name = String(object.movie_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_SendStatPopup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_SendStatPopup
         * @static
         * @param {CDOTAMsg_SendStatPopup} message CDOTAMsg_SendStatPopup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_SendStatPopup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stat_strings = [];
                object.stat_images = [];
                object.stat_image_types = [];
            }
            if (options.defaults) {
                object.style = options.enums === String ? "k_EDOTA_SPT_Textline" : 0;
                object.duration = 0;
                object.use_html = false;
                object.movie_name = "";
            }
            if (message.style != null && message.hasOwnProperty("style"))
                object.style = options.enums === String ? $root.EDOTAStatPopupTypes[message.style] : message.style;
            if (message.stat_strings && message.stat_strings.length) {
                object.stat_strings = [];
                for (var j = 0; j < message.stat_strings.length; ++j)
                    object.stat_strings[j] = message.stat_strings[j];
            }
            if (message.stat_images && message.stat_images.length) {
                object.stat_images = [];
                for (var j = 0; j < message.stat_images.length; ++j)
                    object.stat_images[j] = message.stat_images[j];
            }
            if (message.stat_image_types && message.stat_image_types.length) {
                object.stat_image_types = [];
                for (var j = 0; j < message.stat_image_types.length; ++j)
                    object.stat_image_types[j] = message.stat_image_types[j];
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.use_html != null && message.hasOwnProperty("use_html"))
                object.use_html = message.use_html;
            if (message.movie_name != null && message.hasOwnProperty("movie_name"))
                object.movie_name = message.movie_name;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_SendStatPopup to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_SendStatPopup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_SendStatPopup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_SendStatPopup;
    })();
    
    $root.CDOTAMsg_DismissAllStatPopups = (function() {
    
        /**
         * Properties of a CDOTAMsg_DismissAllStatPopups.
         * @exports ICDOTAMsg_DismissAllStatPopups
         * @interface ICDOTAMsg_DismissAllStatPopups
         * @property {number|null} [time_delay] CDOTAMsg_DismissAllStatPopups time_delay
         */
    
        /**
         * Constructs a new CDOTAMsg_DismissAllStatPopups.
         * @exports CDOTAMsg_DismissAllStatPopups
         * @classdesc Represents a CDOTAMsg_DismissAllStatPopups.
         * @implements ICDOTAMsg_DismissAllStatPopups
         * @constructor
         * @param {ICDOTAMsg_DismissAllStatPopups=} [properties] Properties to set
         */
        function CDOTAMsg_DismissAllStatPopups(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_DismissAllStatPopups time_delay.
         * @member {number} time_delay
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @instance
         */
        CDOTAMsg_DismissAllStatPopups.prototype.time_delay = 0;
    
        /**
         * Creates a new CDOTAMsg_DismissAllStatPopups instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAMsg_DismissAllStatPopups=} [properties] Properties to set
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups instance
         */
        CDOTAMsg_DismissAllStatPopups.create = function create(properties) {
            return new CDOTAMsg_DismissAllStatPopups(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_DismissAllStatPopups message. Does not implicitly {@link CDOTAMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAMsg_DismissAllStatPopups} message CDOTAMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_DismissAllStatPopups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time_delay != null && Object.hasOwnProperty.call(message, "time_delay"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.time_delay);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_DismissAllStatPopups message, length delimited. Does not implicitly {@link CDOTAMsg_DismissAllStatPopups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {ICDOTAMsg_DismissAllStatPopups} message CDOTAMsg_DismissAllStatPopups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_DismissAllStatPopups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_DismissAllStatPopups message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_DismissAllStatPopups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_DismissAllStatPopups();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time_delay = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_DismissAllStatPopups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_DismissAllStatPopups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_DismissAllStatPopups message.
         * @function verify
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_DismissAllStatPopups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time_delay != null && message.hasOwnProperty("time_delay"))
                if (typeof message.time_delay !== "number")
                    return "time_delay: number expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_DismissAllStatPopups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_DismissAllStatPopups} CDOTAMsg_DismissAllStatPopups
         */
        CDOTAMsg_DismissAllStatPopups.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_DismissAllStatPopups)
                return object;
            var message = new $root.CDOTAMsg_DismissAllStatPopups();
            if (object.time_delay != null)
                message.time_delay = Number(object.time_delay);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_DismissAllStatPopups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @static
         * @param {CDOTAMsg_DismissAllStatPopups} message CDOTAMsg_DismissAllStatPopups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_DismissAllStatPopups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.time_delay = 0;
            if (message.time_delay != null && message.hasOwnProperty("time_delay"))
                object.time_delay = options.json && !isFinite(message.time_delay) ? String(message.time_delay) : message.time_delay;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_DismissAllStatPopups to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_DismissAllStatPopups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_DismissAllStatPopups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_DismissAllStatPopups;
    })();
    
    $root.CDOTAMsg_CoachHUDPing = (function() {
    
        /**
         * Properties of a CDOTAMsg_CoachHUDPing.
         * @exports ICDOTAMsg_CoachHUDPing
         * @interface ICDOTAMsg_CoachHUDPing
         * @property {number|null} [x] CDOTAMsg_CoachHUDPing x
         * @property {number|null} [y] CDOTAMsg_CoachHUDPing y
         * @property {string|null} [tgtpath] CDOTAMsg_CoachHUDPing tgtpath
         */
    
        /**
         * Constructs a new CDOTAMsg_CoachHUDPing.
         * @exports CDOTAMsg_CoachHUDPing
         * @classdesc Represents a CDOTAMsg_CoachHUDPing.
         * @implements ICDOTAMsg_CoachHUDPing
         * @constructor
         * @param {ICDOTAMsg_CoachHUDPing=} [properties] Properties to set
         */
        function CDOTAMsg_CoachHUDPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_CoachHUDPing x.
         * @member {number} x
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         */
        CDOTAMsg_CoachHUDPing.prototype.x = 0;
    
        /**
         * CDOTAMsg_CoachHUDPing y.
         * @member {number} y
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         */
        CDOTAMsg_CoachHUDPing.prototype.y = 0;
    
        /**
         * CDOTAMsg_CoachHUDPing tgtpath.
         * @member {string} tgtpath
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         */
        CDOTAMsg_CoachHUDPing.prototype.tgtpath = "";
    
        /**
         * Creates a new CDOTAMsg_CoachHUDPing instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {ICDOTAMsg_CoachHUDPing=} [properties] Properties to set
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing instance
         */
        CDOTAMsg_CoachHUDPing.create = function create(properties) {
            return new CDOTAMsg_CoachHUDPing(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_CoachHUDPing message. Does not implicitly {@link CDOTAMsg_CoachHUDPing.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {ICDOTAMsg_CoachHUDPing} message CDOTAMsg_CoachHUDPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_CoachHUDPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
            if (message.tgtpath != null && Object.hasOwnProperty.call(message, "tgtpath"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.tgtpath);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_CoachHUDPing message, length delimited. Does not implicitly {@link CDOTAMsg_CoachHUDPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {ICDOTAMsg_CoachHUDPing} message CDOTAMsg_CoachHUDPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_CoachHUDPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_CoachHUDPing message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_CoachHUDPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_CoachHUDPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                case 3:
                    message.tgtpath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_CoachHUDPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_CoachHUDPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_CoachHUDPing message.
         * @function verify
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_CoachHUDPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.tgtpath != null && message.hasOwnProperty("tgtpath"))
                if (!$util.isString(message.tgtpath))
                    return "tgtpath: string expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_CoachHUDPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_CoachHUDPing} CDOTAMsg_CoachHUDPing
         */
        CDOTAMsg_CoachHUDPing.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_CoachHUDPing)
                return object;
            var message = new $root.CDOTAMsg_CoachHUDPing();
            if (object.x != null)
                message.x = object.x >>> 0;
            if (object.y != null)
                message.y = object.y >>> 0;
            if (object.tgtpath != null)
                message.tgtpath = String(object.tgtpath);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_CoachHUDPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_CoachHUDPing
         * @static
         * @param {CDOTAMsg_CoachHUDPing} message CDOTAMsg_CoachHUDPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_CoachHUDPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.tgtpath = "";
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.tgtpath != null && message.hasOwnProperty("tgtpath"))
                object.tgtpath = message.tgtpath;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_CoachHUDPing to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_CoachHUDPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_CoachHUDPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_CoachHUDPing;
    })();
    
    $root.CDOTAMsg_UnitOrder = (function() {
    
        /**
         * Properties of a CDOTAMsg_UnitOrder.
         * @exports ICDOTAMsg_UnitOrder
         * @interface ICDOTAMsg_UnitOrder
         * @property {number|null} [issuer] CDOTAMsg_UnitOrder issuer
         * @property {dotaunitorder_t|null} [order_type] CDOTAMsg_UnitOrder order_type
         * @property {Array.<number>|null} [units] CDOTAMsg_UnitOrder units
         * @property {number|null} [target_index] CDOTAMsg_UnitOrder target_index
         * @property {number|null} [ability_index] CDOTAMsg_UnitOrder ability_index
         * @property {ICMsgVector|null} [position] CDOTAMsg_UnitOrder position
         * @property {boolean|null} [queue] CDOTAMsg_UnitOrder queue
         * @property {number|null} [sequence_number] CDOTAMsg_UnitOrder sequence_number
         * @property {number|null} [flags] CDOTAMsg_UnitOrder flags
         */
    
        /**
         * Constructs a new CDOTAMsg_UnitOrder.
         * @exports CDOTAMsg_UnitOrder
         * @classdesc Represents a CDOTAMsg_UnitOrder.
         * @implements ICDOTAMsg_UnitOrder
         * @constructor
         * @param {ICDOTAMsg_UnitOrder=} [properties] Properties to set
         */
        function CDOTAMsg_UnitOrder(properties) {
            this.units = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAMsg_UnitOrder issuer.
         * @member {number} issuer
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.issuer = -1;
    
        /**
         * CDOTAMsg_UnitOrder order_type.
         * @member {dotaunitorder_t} order_type
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.order_type = 0;
    
        /**
         * CDOTAMsg_UnitOrder units.
         * @member {Array.<number>} units
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.units = $util.emptyArray;
    
        /**
         * CDOTAMsg_UnitOrder target_index.
         * @member {number} target_index
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.target_index = 0;
    
        /**
         * CDOTAMsg_UnitOrder ability_index.
         * @member {number} ability_index
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.ability_index = 0;
    
        /**
         * CDOTAMsg_UnitOrder position.
         * @member {ICMsgVector|null|undefined} position
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.position = null;
    
        /**
         * CDOTAMsg_UnitOrder queue.
         * @member {boolean} queue
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.queue = false;
    
        /**
         * CDOTAMsg_UnitOrder sequence_number.
         * @member {number} sequence_number
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.sequence_number = 0;
    
        /**
         * CDOTAMsg_UnitOrder flags.
         * @member {number} flags
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         */
        CDOTAMsg_UnitOrder.prototype.flags = 0;
    
        /**
         * Creates a new CDOTAMsg_UnitOrder instance using the specified properties.
         * @function create
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {ICDOTAMsg_UnitOrder=} [properties] Properties to set
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder instance
         */
        CDOTAMsg_UnitOrder.create = function create(properties) {
            return new CDOTAMsg_UnitOrder(properties);
        };
    
        /**
         * Encodes the specified CDOTAMsg_UnitOrder message. Does not implicitly {@link CDOTAMsg_UnitOrder.verify|verify} messages.
         * @function encode
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {ICDOTAMsg_UnitOrder} message CDOTAMsg_UnitOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_UnitOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.issuer != null && Object.hasOwnProperty.call(message, "issuer"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.issuer);
            if (message.order_type != null && Object.hasOwnProperty.call(message, "order_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.order_type);
            if (message.units != null && message.units.length)
                for (var i = 0; i < message.units.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.units[i]);
            if (message.target_index != null && Object.hasOwnProperty.call(message, "target_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.target_index);
            if (message.ability_index != null && Object.hasOwnProperty.call(message, "ability_index"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ability_index);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.CMsgVector.encode(message.position, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.queue);
            if (message.sequence_number != null && Object.hasOwnProperty.call(message, "sequence_number"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.sequence_number);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAMsg_UnitOrder message, length delimited. Does not implicitly {@link CDOTAMsg_UnitOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {ICDOTAMsg_UnitOrder} message CDOTAMsg_UnitOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAMsg_UnitOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAMsg_UnitOrder message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_UnitOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAMsg_UnitOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.issuer = reader.sint32();
                    break;
                case 2:
                    message.order_type = reader.int32();
                    break;
                case 3:
                    if (!(message.units && message.units.length))
                        message.units = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.units.push(reader.int32());
                    } else
                        message.units.push(reader.int32());
                    break;
                case 4:
                    message.target_index = reader.int32();
                    break;
                case 5:
                    message.ability_index = reader.int32();
                    break;
                case 6:
                    message.position = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.queue = reader.bool();
                    break;
                case 8:
                    message.sequence_number = reader.int32();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAMsg_UnitOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAMsg_UnitOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAMsg_UnitOrder message.
         * @function verify
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAMsg_UnitOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.issuer != null && message.hasOwnProperty("issuer"))
                if (!$util.isInteger(message.issuer))
                    return "issuer: integer expected";
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                switch (message.order_type) {
                default:
                    return "order_type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                    break;
                }
            if (message.units != null && message.hasOwnProperty("units")) {
                if (!Array.isArray(message.units))
                    return "units: array expected";
                for (var i = 0; i < message.units.length; ++i)
                    if (!$util.isInteger(message.units[i]))
                        return "units: integer[] expected";
            }
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                if (!$util.isInteger(message.target_index))
                    return "target_index: integer expected";
            if (message.ability_index != null && message.hasOwnProperty("ability_index"))
                if (!$util.isInteger(message.ability_index))
                    return "ability_index: integer expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.CMsgVector.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.queue != null && message.hasOwnProperty("queue"))
                if (typeof message.queue !== "boolean")
                    return "queue: boolean expected";
            if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                if (!$util.isInteger(message.sequence_number))
                    return "sequence_number: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CDOTAMsg_UnitOrder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAMsg_UnitOrder} CDOTAMsg_UnitOrder
         */
        CDOTAMsg_UnitOrder.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAMsg_UnitOrder)
                return object;
            var message = new $root.CDOTAMsg_UnitOrder();
            if (object.issuer != null)
                message.issuer = object.issuer | 0;
            switch (object.order_type) {
            case "DOTA_UNIT_ORDER_NONE":
            case 0:
                message.order_type = 0;
                break;
            case "DOTA_UNIT_ORDER_MOVE_TO_POSITION":
            case 1:
                message.order_type = 1;
                break;
            case "DOTA_UNIT_ORDER_MOVE_TO_TARGET":
            case 2:
                message.order_type = 2;
                break;
            case "DOTA_UNIT_ORDER_ATTACK_MOVE":
            case 3:
                message.order_type = 3;
                break;
            case "DOTA_UNIT_ORDER_ATTACK_TARGET":
            case 4:
                message.order_type = 4;
                break;
            case "DOTA_UNIT_ORDER_CAST_POSITION":
            case 5:
                message.order_type = 5;
                break;
            case "DOTA_UNIT_ORDER_CAST_TARGET":
            case 6:
                message.order_type = 6;
                break;
            case "DOTA_UNIT_ORDER_CAST_TARGET_TREE":
            case 7:
                message.order_type = 7;
                break;
            case "DOTA_UNIT_ORDER_CAST_NO_TARGET":
            case 8:
                message.order_type = 8;
                break;
            case "DOTA_UNIT_ORDER_CAST_TOGGLE":
            case 9:
                message.order_type = 9;
                break;
            case "DOTA_UNIT_ORDER_HOLD_POSITION":
            case 10:
                message.order_type = 10;
                break;
            case "DOTA_UNIT_ORDER_TRAIN_ABILITY":
            case 11:
                message.order_type = 11;
                break;
            case "DOTA_UNIT_ORDER_DROP_ITEM":
            case 12:
                message.order_type = 12;
                break;
            case "DOTA_UNIT_ORDER_GIVE_ITEM":
            case 13:
                message.order_type = 13;
                break;
            case "DOTA_UNIT_ORDER_PICKUP_ITEM":
            case 14:
                message.order_type = 14;
                break;
            case "DOTA_UNIT_ORDER_PICKUP_RUNE":
            case 15:
                message.order_type = 15;
                break;
            case "DOTA_UNIT_ORDER_PURCHASE_ITEM":
            case 16:
                message.order_type = 16;
                break;
            case "DOTA_UNIT_ORDER_SELL_ITEM":
            case 17:
                message.order_type = 17;
                break;
            case "DOTA_UNIT_ORDER_DISASSEMBLE_ITEM":
            case 18:
                message.order_type = 18;
                break;
            case "DOTA_UNIT_ORDER_MOVE_ITEM":
            case 19:
                message.order_type = 19;
                break;
            case "DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO":
            case 20:
                message.order_type = 20;
                break;
            case "DOTA_UNIT_ORDER_STOP":
            case 21:
                message.order_type = 21;
                break;
            case "DOTA_UNIT_ORDER_TAUNT":
            case 22:
                message.order_type = 22;
                break;
            case "DOTA_UNIT_ORDER_BUYBACK":
            case 23:
                message.order_type = 23;
                break;
            case "DOTA_UNIT_ORDER_GLYPH":
            case 24:
                message.order_type = 24;
                break;
            case "DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH":
            case 25:
                message.order_type = 25;
                break;
            case "DOTA_UNIT_ORDER_CAST_RUNE":
            case 26:
                message.order_type = 26;
                break;
            case "DOTA_UNIT_ORDER_PING_ABILITY":
            case 27:
                message.order_type = 27;
                break;
            case "DOTA_UNIT_ORDER_MOVE_TO_DIRECTION":
            case 28:
                message.order_type = 28;
                break;
            case "DOTA_UNIT_ORDER_PATROL":
            case 29:
                message.order_type = 29;
                break;
            case "DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION":
            case 30:
                message.order_type = 30;
                break;
            case "DOTA_UNIT_ORDER_RADAR":
            case 31:
                message.order_type = 31;
                break;
            case "DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK":
            case 32:
                message.order_type = 32;
                break;
            case "DOTA_UNIT_ORDER_CONTINUE":
            case 33:
                message.order_type = 33;
                break;
            case "DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED":
            case 34:
                message.order_type = 34;
                break;
            case "DOTA_UNIT_ORDER_CAST_RIVER_PAINT":
            case 35:
                message.order_type = 35;
                break;
            case "DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT":
            case 36:
                message.order_type = 36;
                break;
            case "DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN":
            case 37:
                message.order_type = 37;
                break;
            case "DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH":
            case 38:
                message.order_type = 38;
                break;
            }
            if (object.units) {
                if (!Array.isArray(object.units))
                    throw TypeError(".CDOTAMsg_UnitOrder.units: array expected");
                message.units = [];
                for (var i = 0; i < object.units.length; ++i)
                    message.units[i] = object.units[i] | 0;
            }
            if (object.target_index != null)
                message.target_index = object.target_index | 0;
            if (object.ability_index != null)
                message.ability_index = object.ability_index | 0;
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".CDOTAMsg_UnitOrder.position: object expected");
                message.position = $root.CMsgVector.fromObject(object.position);
            }
            if (object.queue != null)
                message.queue = Boolean(object.queue);
            if (object.sequence_number != null)
                message.sequence_number = object.sequence_number | 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAMsg_UnitOrder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAMsg_UnitOrder
         * @static
         * @param {CDOTAMsg_UnitOrder} message CDOTAMsg_UnitOrder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAMsg_UnitOrder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.units = [];
            if (options.defaults) {
                object.issuer = -1;
                object.order_type = options.enums === String ? "DOTA_UNIT_ORDER_NONE" : 0;
                object.target_index = 0;
                object.ability_index = 0;
                object.position = null;
                object.queue = false;
                object.sequence_number = 0;
                object.flags = 0;
            }
            if (message.issuer != null && message.hasOwnProperty("issuer"))
                object.issuer = message.issuer;
            if (message.order_type != null && message.hasOwnProperty("order_type"))
                object.order_type = options.enums === String ? $root.dotaunitorder_t[message.order_type] : message.order_type;
            if (message.units && message.units.length) {
                object.units = [];
                for (var j = 0; j < message.units.length; ++j)
                    object.units[j] = message.units[j];
            }
            if (message.target_index != null && message.hasOwnProperty("target_index"))
                object.target_index = message.target_index;
            if (message.ability_index != null && message.hasOwnProperty("ability_index"))
                object.ability_index = message.ability_index;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.CMsgVector.toObject(message.position, options);
            if (message.queue != null && message.hasOwnProperty("queue"))
                object.queue = message.queue;
            if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                object.sequence_number = message.sequence_number;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };
    
        /**
         * Converts this CDOTAMsg_UnitOrder to JSON.
         * @function toJSON
         * @memberof CDOTAMsg_UnitOrder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAMsg_UnitOrder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAMsg_UnitOrder;
    })();
    
    $root.VersusScene_PlayActivity = (function() {
    
        /**
         * Properties of a VersusScene_PlayActivity.
         * @exports IVersusScene_PlayActivity
         * @interface IVersusScene_PlayActivity
         * @property {Array.<VersusScene_PlayActivity.IActivityInfo>|null} [activities] VersusScene_PlayActivity activities
         * @property {number|null} [playback_rate] VersusScene_PlayActivity playback_rate
         */
    
        /**
         * Constructs a new VersusScene_PlayActivity.
         * @exports VersusScene_PlayActivity
         * @classdesc Represents a VersusScene_PlayActivity.
         * @implements IVersusScene_PlayActivity
         * @constructor
         * @param {IVersusScene_PlayActivity=} [properties] Properties to set
         */
        function VersusScene_PlayActivity(properties) {
            this.activities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersusScene_PlayActivity activities.
         * @member {Array.<VersusScene_PlayActivity.IActivityInfo>} activities
         * @memberof VersusScene_PlayActivity
         * @instance
         */
        VersusScene_PlayActivity.prototype.activities = $util.emptyArray;
    
        /**
         * VersusScene_PlayActivity playback_rate.
         * @member {number} playback_rate
         * @memberof VersusScene_PlayActivity
         * @instance
         */
        VersusScene_PlayActivity.prototype.playback_rate = 0;
    
        /**
         * Creates a new VersusScene_PlayActivity instance using the specified properties.
         * @function create
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {IVersusScene_PlayActivity=} [properties] Properties to set
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity instance
         */
        VersusScene_PlayActivity.create = function create(properties) {
            return new VersusScene_PlayActivity(properties);
        };
    
        /**
         * Encodes the specified VersusScene_PlayActivity message. Does not implicitly {@link VersusScene_PlayActivity.verify|verify} messages.
         * @function encode
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {IVersusScene_PlayActivity} message VersusScene_PlayActivity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlayActivity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activities != null && message.activities.length)
                for (var i = 0; i < message.activities.length; ++i)
                    $root.VersusScene_PlayActivity.ActivityInfo.encode(message.activities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.playback_rate != null && Object.hasOwnProperty.call(message, "playback_rate"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.playback_rate);
            return writer;
        };
    
        /**
         * Encodes the specified VersusScene_PlayActivity message, length delimited. Does not implicitly {@link VersusScene_PlayActivity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {IVersusScene_PlayActivity} message VersusScene_PlayActivity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlayActivity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersusScene_PlayActivity message from the specified reader or buffer.
         * @function decode
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlayActivity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_PlayActivity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.activities && message.activities.length))
                        message.activities = [];
                    message.activities.push($root.VersusScene_PlayActivity.ActivityInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.playback_rate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersusScene_PlayActivity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlayActivity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersusScene_PlayActivity message.
         * @function verify
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersusScene_PlayActivity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activities != null && message.hasOwnProperty("activities")) {
                if (!Array.isArray(message.activities))
                    return "activities: array expected";
                for (var i = 0; i < message.activities.length; ++i) {
                    var error = $root.VersusScene_PlayActivity.ActivityInfo.verify(message.activities[i]);
                    if (error)
                        return "activities." + error;
                }
            }
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                if (typeof message.playback_rate !== "number")
                    return "playback_rate: number expected";
            return null;
        };
    
        /**
         * Creates a VersusScene_PlayActivity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersusScene_PlayActivity} VersusScene_PlayActivity
         */
        VersusScene_PlayActivity.fromObject = function fromObject(object) {
            if (object instanceof $root.VersusScene_PlayActivity)
                return object;
            var message = new $root.VersusScene_PlayActivity();
            if (object.activities) {
                if (!Array.isArray(object.activities))
                    throw TypeError(".VersusScene_PlayActivity.activities: array expected");
                message.activities = [];
                for (var i = 0; i < object.activities.length; ++i) {
                    if (typeof object.activities[i] !== "object")
                        throw TypeError(".VersusScene_PlayActivity.activities: object expected");
                    message.activities[i] = $root.VersusScene_PlayActivity.ActivityInfo.fromObject(object.activities[i]);
                }
            }
            if (object.playback_rate != null)
                message.playback_rate = Number(object.playback_rate);
            return message;
        };
    
        /**
         * Creates a plain object from a VersusScene_PlayActivity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersusScene_PlayActivity
         * @static
         * @param {VersusScene_PlayActivity} message VersusScene_PlayActivity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersusScene_PlayActivity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.activities = [];
            if (options.defaults)
                object.playback_rate = 0;
            if (message.activities && message.activities.length) {
                object.activities = [];
                for (var j = 0; j < message.activities.length; ++j)
                    object.activities[j] = $root.VersusScene_PlayActivity.ActivityInfo.toObject(message.activities[j], options);
            }
            if (message.playback_rate != null && message.hasOwnProperty("playback_rate"))
                object.playback_rate = options.json && !isFinite(message.playback_rate) ? String(message.playback_rate) : message.playback_rate;
            return object;
        };
    
        /**
         * Converts this VersusScene_PlayActivity to JSON.
         * @function toJSON
         * @memberof VersusScene_PlayActivity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersusScene_PlayActivity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        VersusScene_PlayActivity.ActivityInfo = (function() {
    
            /**
             * Properties of an ActivityInfo.
             * @memberof VersusScene_PlayActivity
             * @interface IActivityInfo
             * @property {string|null} [activity] ActivityInfo activity
             * @property {boolean|null} [disable_auto_kill] ActivityInfo disable_auto_kill
             * @property {boolean|null} [force_looping] ActivityInfo force_looping
             */
    
            /**
             * Constructs a new ActivityInfo.
             * @memberof VersusScene_PlayActivity
             * @classdesc Represents an ActivityInfo.
             * @implements IActivityInfo
             * @constructor
             * @param {VersusScene_PlayActivity.IActivityInfo=} [properties] Properties to set
             */
            function ActivityInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ActivityInfo activity.
             * @member {string} activity
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             */
            ActivityInfo.prototype.activity = "";
    
            /**
             * ActivityInfo disable_auto_kill.
             * @member {boolean} disable_auto_kill
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             */
            ActivityInfo.prototype.disable_auto_kill = false;
    
            /**
             * ActivityInfo force_looping.
             * @member {boolean} force_looping
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             */
            ActivityInfo.prototype.force_looping = false;
    
            /**
             * Creates a new ActivityInfo instance using the specified properties.
             * @function create
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.IActivityInfo=} [properties] Properties to set
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo instance
             */
            ActivityInfo.create = function create(properties) {
                return new ActivityInfo(properties);
            };
    
            /**
             * Encodes the specified ActivityInfo message. Does not implicitly {@link VersusScene_PlayActivity.ActivityInfo.verify|verify} messages.
             * @function encode
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.IActivityInfo} message ActivityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.activity != null && Object.hasOwnProperty.call(message, "activity"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.activity);
                if (message.disable_auto_kill != null && Object.hasOwnProperty.call(message, "disable_auto_kill"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.disable_auto_kill);
                if (message.force_looping != null && Object.hasOwnProperty.call(message, "force_looping"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force_looping);
                return writer;
            };
    
            /**
             * Encodes the specified ActivityInfo message, length delimited. Does not implicitly {@link VersusScene_PlayActivity.ActivityInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.IActivityInfo} message ActivityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ActivityInfo message from the specified reader or buffer.
             * @function decode
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_PlayActivity.ActivityInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activity = reader.string();
                        break;
                    case 2:
                        message.disable_auto_kill = reader.bool();
                        break;
                    case 3:
                        message.force_looping = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ActivityInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ActivityInfo message.
             * @function verify
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.activity != null && message.hasOwnProperty("activity"))
                    if (!$util.isString(message.activity))
                        return "activity: string expected";
                if (message.disable_auto_kill != null && message.hasOwnProperty("disable_auto_kill"))
                    if (typeof message.disable_auto_kill !== "boolean")
                        return "disable_auto_kill: boolean expected";
                if (message.force_looping != null && message.hasOwnProperty("force_looping"))
                    if (typeof message.force_looping !== "boolean")
                        return "force_looping: boolean expected";
                return null;
            };
    
            /**
             * Creates an ActivityInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {VersusScene_PlayActivity.ActivityInfo} ActivityInfo
             */
            ActivityInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.VersusScene_PlayActivity.ActivityInfo)
                    return object;
                var message = new $root.VersusScene_PlayActivity.ActivityInfo();
                if (object.activity != null)
                    message.activity = String(object.activity);
                if (object.disable_auto_kill != null)
                    message.disable_auto_kill = Boolean(object.disable_auto_kill);
                if (object.force_looping != null)
                    message.force_looping = Boolean(object.force_looping);
                return message;
            };
    
            /**
             * Creates a plain object from an ActivityInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @static
             * @param {VersusScene_PlayActivity.ActivityInfo} message ActivityInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActivityInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.activity = "";
                    object.disable_auto_kill = false;
                    object.force_looping = false;
                }
                if (message.activity != null && message.hasOwnProperty("activity"))
                    object.activity = message.activity;
                if (message.disable_auto_kill != null && message.hasOwnProperty("disable_auto_kill"))
                    object.disable_auto_kill = message.disable_auto_kill;
                if (message.force_looping != null && message.hasOwnProperty("force_looping"))
                    object.force_looping = message.force_looping;
                return object;
            };
    
            /**
             * Converts this ActivityInfo to JSON.
             * @function toJSON
             * @memberof VersusScene_PlayActivity.ActivityInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActivityInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ActivityInfo;
        })();
    
        return VersusScene_PlayActivity;
    })();
    
    $root.VersusScene_ChatWheel = (function() {
    
        /**
         * Properties of a VersusScene_ChatWheel.
         * @exports IVersusScene_ChatWheel
         * @interface IVersusScene_ChatWheel
         * @property {number|null} [chat_message_id] VersusScene_ChatWheel chat_message_id
         * @property {number|null} [emoticon_id] VersusScene_ChatWheel emoticon_id
         */
    
        /**
         * Constructs a new VersusScene_ChatWheel.
         * @exports VersusScene_ChatWheel
         * @classdesc Represents a VersusScene_ChatWheel.
         * @implements IVersusScene_ChatWheel
         * @constructor
         * @param {IVersusScene_ChatWheel=} [properties] Properties to set
         */
        function VersusScene_ChatWheel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersusScene_ChatWheel chat_message_id.
         * @member {number} chat_message_id
         * @memberof VersusScene_ChatWheel
         * @instance
         */
        VersusScene_ChatWheel.prototype.chat_message_id = 0;
    
        /**
         * VersusScene_ChatWheel emoticon_id.
         * @member {number} emoticon_id
         * @memberof VersusScene_ChatWheel
         * @instance
         */
        VersusScene_ChatWheel.prototype.emoticon_id = 0;
    
        /**
         * Creates a new VersusScene_ChatWheel instance using the specified properties.
         * @function create
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {IVersusScene_ChatWheel=} [properties] Properties to set
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel instance
         */
        VersusScene_ChatWheel.create = function create(properties) {
            return new VersusScene_ChatWheel(properties);
        };
    
        /**
         * Encodes the specified VersusScene_ChatWheel message. Does not implicitly {@link VersusScene_ChatWheel.verify|verify} messages.
         * @function encode
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {IVersusScene_ChatWheel} message VersusScene_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_ChatWheel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chat_message_id != null && Object.hasOwnProperty.call(message, "chat_message_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chat_message_id);
            if (message.emoticon_id != null && Object.hasOwnProperty.call(message, "emoticon_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.emoticon_id);
            return writer;
        };
    
        /**
         * Encodes the specified VersusScene_ChatWheel message, length delimited. Does not implicitly {@link VersusScene_ChatWheel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {IVersusScene_ChatWheel} message VersusScene_ChatWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_ChatWheel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersusScene_ChatWheel message from the specified reader or buffer.
         * @function decode
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_ChatWheel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_ChatWheel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chat_message_id = reader.uint32();
                    break;
                case 2:
                    message.emoticon_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersusScene_ChatWheel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_ChatWheel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersusScene_ChatWheel message.
         * @function verify
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersusScene_ChatWheel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                if (!$util.isInteger(message.chat_message_id))
                    return "chat_message_id: integer expected";
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                if (!$util.isInteger(message.emoticon_id))
                    return "emoticon_id: integer expected";
            return null;
        };
    
        /**
         * Creates a VersusScene_ChatWheel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersusScene_ChatWheel} VersusScene_ChatWheel
         */
        VersusScene_ChatWheel.fromObject = function fromObject(object) {
            if (object instanceof $root.VersusScene_ChatWheel)
                return object;
            var message = new $root.VersusScene_ChatWheel();
            if (object.chat_message_id != null)
                message.chat_message_id = object.chat_message_id >>> 0;
            if (object.emoticon_id != null)
                message.emoticon_id = object.emoticon_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a VersusScene_ChatWheel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersusScene_ChatWheel
         * @static
         * @param {VersusScene_ChatWheel} message VersusScene_ChatWheel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersusScene_ChatWheel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chat_message_id = 0;
                object.emoticon_id = 0;
            }
            if (message.chat_message_id != null && message.hasOwnProperty("chat_message_id"))
                object.chat_message_id = message.chat_message_id;
            if (message.emoticon_id != null && message.hasOwnProperty("emoticon_id"))
                object.emoticon_id = message.emoticon_id;
            return object;
        };
    
        /**
         * Converts this VersusScene_ChatWheel to JSON.
         * @function toJSON
         * @memberof VersusScene_ChatWheel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersusScene_ChatWheel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return VersusScene_ChatWheel;
    })();
    
    $root.VersusScene_PlaybackRate = (function() {
    
        /**
         * Properties of a VersusScene_PlaybackRate.
         * @exports IVersusScene_PlaybackRate
         * @interface IVersusScene_PlaybackRate
         * @property {number|null} [rate] VersusScene_PlaybackRate rate
         */
    
        /**
         * Constructs a new VersusScene_PlaybackRate.
         * @exports VersusScene_PlaybackRate
         * @classdesc Represents a VersusScene_PlaybackRate.
         * @implements IVersusScene_PlaybackRate
         * @constructor
         * @param {IVersusScene_PlaybackRate=} [properties] Properties to set
         */
        function VersusScene_PlaybackRate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * VersusScene_PlaybackRate rate.
         * @member {number} rate
         * @memberof VersusScene_PlaybackRate
         * @instance
         */
        VersusScene_PlaybackRate.prototype.rate = 0;
    
        /**
         * Creates a new VersusScene_PlaybackRate instance using the specified properties.
         * @function create
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {IVersusScene_PlaybackRate=} [properties] Properties to set
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate instance
         */
        VersusScene_PlaybackRate.create = function create(properties) {
            return new VersusScene_PlaybackRate(properties);
        };
    
        /**
         * Encodes the specified VersusScene_PlaybackRate message. Does not implicitly {@link VersusScene_PlaybackRate.verify|verify} messages.
         * @function encode
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {IVersusScene_PlaybackRate} message VersusScene_PlaybackRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlaybackRate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.rate);
            return writer;
        };
    
        /**
         * Encodes the specified VersusScene_PlaybackRate message, length delimited. Does not implicitly {@link VersusScene_PlaybackRate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {IVersusScene_PlaybackRate} message VersusScene_PlaybackRate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersusScene_PlaybackRate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a VersusScene_PlaybackRate message from the specified reader or buffer.
         * @function decode
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlaybackRate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VersusScene_PlaybackRate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a VersusScene_PlaybackRate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersusScene_PlaybackRate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a VersusScene_PlaybackRate message.
         * @function verify
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersusScene_PlaybackRate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rate != null && message.hasOwnProperty("rate"))
                if (typeof message.rate !== "number")
                    return "rate: number expected";
            return null;
        };
    
        /**
         * Creates a VersusScene_PlaybackRate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {VersusScene_PlaybackRate} VersusScene_PlaybackRate
         */
        VersusScene_PlaybackRate.fromObject = function fromObject(object) {
            if (object instanceof $root.VersusScene_PlaybackRate)
                return object;
            var message = new $root.VersusScene_PlaybackRate();
            if (object.rate != null)
                message.rate = Number(object.rate);
            return message;
        };
    
        /**
         * Creates a plain object from a VersusScene_PlaybackRate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof VersusScene_PlaybackRate
         * @static
         * @param {VersusScene_PlaybackRate} message VersusScene_PlaybackRate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersusScene_PlaybackRate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rate = 0;
            if (message.rate != null && message.hasOwnProperty("rate"))
                object.rate = options.json && !isFinite(message.rate) ? String(message.rate) : message.rate;
            return object;
        };
    
        /**
         * Converts this VersusScene_PlaybackRate to JSON.
         * @function toJSON
         * @memberof VersusScene_PlaybackRate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersusScene_PlaybackRate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return VersusScene_PlaybackRate;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.userid = reader.int32();
                    break;
                case 4:
                    message.steamid = reader.fixed64();
                    break;
                case 5:
                    message.fakeplayer = reader.bool();
                    break;
                case 6:
                    message.ishltv = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [target_entity] CEntityMsg target_entity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg target_entity.
         * @member {number} target_entity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.target_entity = 0;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entity != null && Object.hasOwnProperty.call(message, "target_entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                if (!$util.isInteger(message.target_entity))
                    return "target_entity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.target_entity != null)
                message.target_entity = object.target_entity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.target_entity = 0;
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                object.target_entity = message.target_entity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW":
            case 70:
                message.reason = 70;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [host_frametime] CNETMsg_Tick host_frametime
         * @property {number|null} [host_frametime_std_deviation] CNETMsg_Tick host_frametime_std_deviation
         * @property {number|null} [host_computationtime] CNETMsg_Tick host_computationtime
         * @property {number|null} [host_computationtime_std_deviation] CNETMsg_Tick host_computationtime_std_deviation
         * @property {number|null} [host_framestarttime_std_deviation] CNETMsg_Tick host_framestarttime_std_deviation
         * @property {number|null} [host_loss] CNETMsg_Tick host_loss
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick host_frametime.
         * @member {number} host_frametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime = 0;
    
        /**
         * CNETMsg_Tick host_frametime_std_deviation.
         * @member {number} host_frametime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_computationtime.
         * @member {number} host_computationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime = 0;
    
        /**
         * CNETMsg_Tick host_computationtime_std_deviation.
         * @member {number} host_computationtime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_framestarttime_std_deviation.
         * @member {number} host_framestarttime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_framestarttime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_loss.
         * @member {number} host_loss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_loss = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.host_frametime != null && Object.hasOwnProperty.call(message, "host_frametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.host_frametime);
            if (message.host_frametime_std_deviation != null && Object.hasOwnProperty.call(message, "host_frametime_std_deviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.host_frametime_std_deviation);
            if (message.host_computationtime != null && Object.hasOwnProperty.call(message, "host_computationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.host_computationtime);
            if (message.host_computationtime_std_deviation != null && Object.hasOwnProperty.call(message, "host_computationtime_std_deviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.host_computationtime_std_deviation);
            if (message.host_framestarttime_std_deviation != null && Object.hasOwnProperty.call(message, "host_framestarttime_std_deviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.host_framestarttime_std_deviation);
            if (message.host_loss != null && Object.hasOwnProperty.call(message, "host_loss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.host_loss);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 2:
                    message.host_frametime = reader.uint32();
                    break;
                case 3:
                    message.host_frametime_std_deviation = reader.uint32();
                    break;
                case 4:
                    message.host_computationtime = reader.uint32();
                    break;
                case 5:
                    message.host_computationtime_std_deviation = reader.uint32();
                    break;
                case 6:
                    message.host_framestarttime_std_deviation = reader.uint32();
                    break;
                case 7:
                    message.host_loss = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                if (!$util.isInteger(message.host_frametime))
                    return "host_frametime: integer expected";
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                if (!$util.isInteger(message.host_frametime_std_deviation))
                    return "host_frametime_std_deviation: integer expected";
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                if (!$util.isInteger(message.host_computationtime))
                    return "host_computationtime: integer expected";
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                if (!$util.isInteger(message.host_computationtime_std_deviation))
                    return "host_computationtime_std_deviation: integer expected";
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                if (!$util.isInteger(message.host_framestarttime_std_deviation))
                    return "host_framestarttime_std_deviation: integer expected";
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                if (!$util.isInteger(message.host_loss))
                    return "host_loss: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.host_frametime != null)
                message.host_frametime = object.host_frametime >>> 0;
            if (object.host_frametime_std_deviation != null)
                message.host_frametime_std_deviation = object.host_frametime_std_deviation >>> 0;
            if (object.host_computationtime != null)
                message.host_computationtime = object.host_computationtime >>> 0;
            if (object.host_computationtime_std_deviation != null)
                message.host_computationtime_std_deviation = object.host_computationtime_std_deviation >>> 0;
            if (object.host_framestarttime_std_deviation != null)
                message.host_framestarttime_std_deviation = object.host_framestarttime_std_deviation >>> 0;
            if (object.host_loss != null)
                message.host_loss = object.host_loss >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.host_frametime = 0;
                object.host_frametime_std_deviation = 0;
                object.host_computationtime = 0;
                object.host_computationtime_std_deviation = 0;
                object.host_framestarttime_std_deviation = 0;
                object.host_loss = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                object.host_frametime = message.host_frametime;
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                object.host_frametime_std_deviation = message.host_frametime_std_deviation;
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                object.host_computationtime = message.host_computationtime;
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                object.host_computationtime_std_deviation = message.host_computationtime_std_deviation;
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                object.host_framestarttime_std_deviation = message.host_framestarttime_std_deviation;
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                object.host_loss = message.host_loss;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signon_state] CNETMsg_SignonState signon_state
         * @property {number|null} [spawn_count] CNETMsg_SignonState spawn_count
         * @property {number|null} [num_server_players] CNETMsg_SignonState num_server_players
         * @property {Array.<string>|null} [players_networkids] CNETMsg_SignonState players_networkids
         * @property {string|null} [map_name] CNETMsg_SignonState map_name
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.players_networkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signon_state.
         * @member {SignonState_t} signon_state
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signon_state = 0;
    
        /**
         * CNETMsg_SignonState spawn_count.
         * @member {number} spawn_count
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawn_count = 0;
    
        /**
         * CNETMsg_SignonState num_server_players.
         * @member {number} num_server_players
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.num_server_players = 0;
    
        /**
         * CNETMsg_SignonState players_networkids.
         * @member {Array.<string>} players_networkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.players_networkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState map_name.
         * @member {string} map_name
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.map_name = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signon_state != null && Object.hasOwnProperty.call(message, "signon_state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signon_state);
            if (message.spawn_count != null && Object.hasOwnProperty.call(message, "spawn_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawn_count);
            if (message.num_server_players != null && Object.hasOwnProperty.call(message, "num_server_players"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_server_players);
            if (message.players_networkids != null && message.players_networkids.length)
                for (var i = 0; i < message.players_networkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.players_networkids[i]);
            if (message.map_name != null && Object.hasOwnProperty.call(message, "map_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.map_name);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signon_state = reader.int32();
                    break;
                case 2:
                    message.spawn_count = reader.uint32();
                    break;
                case 3:
                    message.num_server_players = reader.uint32();
                    break;
                case 4:
                    if (!(message.players_networkids && message.players_networkids.length))
                        message.players_networkids = [];
                    message.players_networkids.push(reader.string());
                    break;
                case 5:
                    message.map_name = reader.string();
                    break;
                case 6:
                    message.addons = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                switch (message.signon_state) {
                default:
                    return "signon_state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                if (!$util.isInteger(message.num_server_players))
                    return "num_server_players: integer expected";
            if (message.players_networkids != null && message.hasOwnProperty("players_networkids")) {
                if (!Array.isArray(message.players_networkids))
                    return "players_networkids: array expected";
                for (var i = 0; i < message.players_networkids.length; ++i)
                    if (!$util.isString(message.players_networkids[i]))
                        return "players_networkids: string[] expected";
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signon_state) {
            case "SIGNONSTATE_NONE":
            case 0:
                message.signon_state = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signon_state = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signon_state = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signon_state = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signon_state = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signon_state = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signon_state = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signon_state = 7;
                break;
            }
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count >>> 0;
            if (object.num_server_players != null)
                message.num_server_players = object.num_server_players >>> 0;
            if (object.players_networkids) {
                if (!Array.isArray(object.players_networkids))
                    throw TypeError(".CNETMsg_SignonState.players_networkids: array expected");
                message.players_networkids = [];
                for (var i = 0; i < object.players_networkids.length; ++i)
                    message.players_networkids[i] = String(object.players_networkids[i]);
            }
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.players_networkids = [];
            if (options.defaults) {
                object.signon_state = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawn_count = 0;
                object.num_server_players = 0;
                object.map_name = "";
                object.addons = "";
            }
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                object.signon_state = options.enums === String ? $root.SignonState_t[message.signon_state] : message.signon_state;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                object.num_server_players = message.num_server_players;
            if (message.players_networkids && message.players_networkids.length) {
                object.players_networkids = [];
                for (var j = 0; j < message.players_networkids.length; ++j)
                    object.players_networkids[j] = message.players_networkids[j];
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [event_name] CSVCMsg_GameEvent event_name
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent event_name.
         * @member {string} event_name
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.event_name = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.event_name = "";
                object.eventid = 0;
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [val_string] key_t val_string
             * @property {number|null} [val_float] key_t val_float
             * @property {number|null} [val_long] key_t val_long
             * @property {number|null} [val_short] key_t val_short
             * @property {number|null} [val_byte] key_t val_byte
             * @property {boolean|null} [val_bool] key_t val_bool
             * @property {number|Long|null} [val_uint64] key_t val_uint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t val_string.
             * @member {string} val_string
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_string = "";
    
            /**
             * key_t val_float.
             * @member {number} val_float
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_float = 0;
    
            /**
             * key_t val_long.
             * @member {number} val_long
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_long = 0;
    
            /**
             * key_t val_short.
             * @member {number} val_short
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_short = 0;
    
            /**
             * key_t val_byte.
             * @member {number} val_byte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_byte = 0;
    
            /**
             * key_t val_bool.
             * @member {boolean} val_bool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_bool = false;
    
            /**
             * key_t val_uint64.
             * @member {number|Long} val_uint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_uint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.val_string != null && Object.hasOwnProperty.call(message, "val_string"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.val_string);
                if (message.val_float != null && Object.hasOwnProperty.call(message, "val_float"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_float);
                if (message.val_long != null && Object.hasOwnProperty.call(message, "val_long"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.val_long);
                if (message.val_short != null && Object.hasOwnProperty.call(message, "val_short"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_short);
                if (message.val_byte != null && Object.hasOwnProperty.call(message, "val_byte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.val_byte);
                if (message.val_bool != null && Object.hasOwnProperty.call(message, "val_bool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.val_bool);
                if (message.val_uint64 != null && Object.hasOwnProperty.call(message, "val_uint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.val_uint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.val_string = reader.string();
                        break;
                    case 3:
                        message.val_float = reader.float();
                        break;
                    case 4:
                        message.val_long = reader.int32();
                        break;
                    case 5:
                        message.val_short = reader.int32();
                        break;
                    case 6:
                        message.val_byte = reader.int32();
                        break;
                    case 7:
                        message.val_bool = reader.bool();
                        break;
                    case 8:
                        message.val_uint64 = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    if (typeof message.val_float !== "number")
                        return "val_float: number expected";
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    if (!$util.isInteger(message.val_long))
                        return "val_long: integer expected";
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    if (!$util.isInteger(message.val_short))
                        return "val_short: integer expected";
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    if (!$util.isInteger(message.val_byte))
                        return "val_byte: integer expected";
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    if (typeof message.val_bool !== "boolean")
                        return "val_bool: boolean expected";
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (!$util.isInteger(message.val_uint64) && !(message.val_uint64 && $util.isInteger(message.val_uint64.low) && $util.isInteger(message.val_uint64.high)))
                        return "val_uint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_float != null)
                    message.val_float = Number(object.val_float);
                if (object.val_long != null)
                    message.val_long = object.val_long | 0;
                if (object.val_short != null)
                    message.val_short = object.val_short | 0;
                if (object.val_byte != null)
                    message.val_byte = object.val_byte | 0;
                if (object.val_bool != null)
                    message.val_bool = Boolean(object.val_bool);
                if (object.val_uint64 != null)
                    if ($util.Long)
                        (message.val_uint64 = $util.Long.fromValue(object.val_uint64)).unsigned = true;
                    else if (typeof object.val_uint64 === "string")
                        message.val_uint64 = parseInt(object.val_uint64, 10);
                    else if (typeof object.val_uint64 === "number")
                        message.val_uint64 = object.val_uint64;
                    else if (typeof object.val_uint64 === "object")
                        message.val_uint64 = new $util.LongBits(object.val_uint64.low >>> 0, object.val_uint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.val_string = "";
                    object.val_float = 0;
                    object.val_long = 0;
                    object.val_short = 0;
                    object.val_byte = 0;
                    object.val_bool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.val_uint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val_uint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    object.val_float = options.json && !isFinite(message.val_float) ? String(message.val_float) : message.val_float;
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    object.val_long = message.val_long;
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    object.val_short = message.val_short;
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    object.val_byte = message.val_byte;
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    object.val_bool = message.val_bool;
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (typeof message.val_uint64 === "number")
                        object.val_uint64 = options.longs === String ? String(message.val_uint64) : message.val_uint64;
                    else
                        object.val_uint64 = options.longs === String ? $util.Long.prototype.toString.call(message.val_uint64) : options.longs === Number ? new $util.LongBits(message.val_uint64.low >>> 0, message.val_uint64.high >>> 0).toNumber(true) : message.val_uint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msg_type] CSVCMsg_UserMessage msg_type
         * @property {Uint8Array|null} [msg_data] CSVCMsg_UserMessage msg_data
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msg_type.
         * @member {number} msg_type
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_type = 0;
    
        /**
         * CSVCMsg_UserMessage msg_data.
         * @member {Uint8Array} msg_data
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.msg_data != null && Object.hasOwnProperty.call(message, "msg_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.msg_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                if (!(message.msg_data && typeof message.msg_data.length === "number" || $util.isString(message.msg_data)))
                    return "msg_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.msg_data != null)
                if (typeof object.msg_data === "string")
                    $util.base64.decode(object.msg_data, message.msg_data = $util.newBuffer($util.base64.length(object.msg_data)), 0);
                else if (object.msg_data.length)
                    message.msg_data = object.msg_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.msg_data = "";
                else {
                    object.msg_data = [];
                    if (options.bytes !== Array)
                        object.msg_data = $util.newBuffer(object.msg_data);
                }
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                object.msg_data = options.bytes === String ? $util.base64.encode(message.msg_data, 0, message.msg_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg_data) : message.msg_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsgList_UserMessages = (function() {
    
        /**
         * Properties of a CSVCMsgList_UserMessages.
         * @exports ICSVCMsgList_UserMessages
         * @interface ICSVCMsgList_UserMessages
         * @property {Array.<CSVCMsgList_UserMessages.Iusermsg_t>|null} [usermsgs] CSVCMsgList_UserMessages usermsgs
         */
    
        /**
         * Constructs a new CSVCMsgList_UserMessages.
         * @exports CSVCMsgList_UserMessages
         * @classdesc Represents a CSVCMsgList_UserMessages.
         * @implements ICSVCMsgList_UserMessages
         * @constructor
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         */
        function CSVCMsgList_UserMessages(properties) {
            this.usermsgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_UserMessages usermsgs.
         * @member {Array.<CSVCMsgList_UserMessages.Iusermsg_t>} usermsgs
         * @memberof CSVCMsgList_UserMessages
         * @instance
         */
        CSVCMsgList_UserMessages.prototype.usermsgs = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_UserMessages instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages instance
         */
        CSVCMsgList_UserMessages.create = function create(properties) {
            return new CSVCMsgList_UserMessages(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usermsgs != null && message.usermsgs.length)
                for (var i = 0; i < message.usermsgs.length; ++i)
                    $root.CSVCMsgList_UserMessages.usermsg_t.encode(message.usermsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.usermsgs && message.usermsgs.length))
                        message.usermsgs = [];
                    message.usermsgs.push($root.CSVCMsgList_UserMessages.usermsg_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_UserMessages message.
         * @function verify
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_UserMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usermsgs != null && message.hasOwnProperty("usermsgs")) {
                if (!Array.isArray(message.usermsgs))
                    return "usermsgs: array expected";
                for (var i = 0; i < message.usermsgs.length; ++i) {
                    var error = $root.CSVCMsgList_UserMessages.usermsg_t.verify(message.usermsgs[i]);
                    if (error)
                        return "usermsgs." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_UserMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         */
        CSVCMsgList_UserMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_UserMessages)
                return object;
            var message = new $root.CSVCMsgList_UserMessages();
            if (object.usermsgs) {
                if (!Array.isArray(object.usermsgs))
                    throw TypeError(".CSVCMsgList_UserMessages.usermsgs: array expected");
                message.usermsgs = [];
                for (var i = 0; i < object.usermsgs.length; ++i) {
                    if (typeof object.usermsgs[i] !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsgs: object expected");
                    message.usermsgs[i] = $root.CSVCMsgList_UserMessages.usermsg_t.fromObject(object.usermsgs[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_UserMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {CSVCMsgList_UserMessages} message CSVCMsgList_UserMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_UserMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.usermsgs = [];
            if (message.usermsgs && message.usermsgs.length) {
                object.usermsgs = [];
                for (var j = 0; j < message.usermsgs.length; ++j)
                    object.usermsgs[j] = $root.CSVCMsgList_UserMessages.usermsg_t.toObject(message.usermsgs[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_UserMessages to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_UserMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_UserMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_UserMessages.usermsg_t = (function() {
    
            /**
             * Properties of a usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @interface Iusermsg_t
             * @property {number|null} [tick] usermsg_t tick
             * @property {ICSVCMsg_UserMessage|null} [msg] usermsg_t msg
             */
    
            /**
             * Constructs a new usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @classdesc Represents a usermsg_t.
             * @implements Iusermsg_t
             * @constructor
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             */
            function usermsg_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * usermsg_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.tick = 0;
    
            /**
             * usermsg_t msg.
             * @member {ICSVCMsg_UserMessage|null|undefined} msg
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.msg = null;
    
            /**
             * Creates a new usermsg_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t instance
             */
            usermsg_t.create = function create(properties) {
                return new usermsg_t(properties);
            };
    
            /**
             * Encodes the specified usermsg_t message. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.CSVCMsg_UserMessage.encode(message.msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified usermsg_t message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.msg = $root.CSVCMsg_UserMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a usermsg_t message.
             * @function verify
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            usermsg_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    var error = $root.CSVCMsg_UserMessage.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                return null;
            };
    
            /**
             * Creates a usermsg_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             */
            usermsg_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_UserMessages.usermsg_t)
                    return object;
                var message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsg_t.msg: object expected");
                    message.msg = $root.CSVCMsg_UserMessage.fromObject(object.msg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a usermsg_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.usermsg_t} message usermsg_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            usermsg_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.msg = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.CSVCMsg_UserMessage.toObject(message.msg, options);
                return object;
            };
    
            /**
             * Converts this usermsg_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            usermsg_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return usermsg_t;
        })();
    
        return CSVCMsgList_UserMessages;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [world_offset_pos] CNETMsg_SpawnGroup_Load world_offset_pos
         * @property {ICMsgQAngle|null} [world_offset_angle] CNETMsg_SpawnGroup_Load world_offset_angle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_pos.
         * @member {ICMsgVector|null|undefined} world_offset_pos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_pos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_angle.
         * @member {ICMsgQAngle|null|undefined} world_offset_angle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_angle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.world_offset_pos != null && Object.hasOwnProperty.call(message, "world_offset_pos"))
                $root.CMsgVector.encode(message.world_offset_pos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.world_offset_angle != null && Object.hasOwnProperty.call(message, "world_offset_angle"))
                $root.CMsgQAngle.encode(message.world_offset_angle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldname = reader.string();
                    break;
                case 2:
                    message.entitylumpname = reader.string();
                    break;
                case 3:
                    message.entityfiltername = reader.string();
                    break;
                case 4:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 5:
                    message.spawngroupownerhandle = reader.uint32();
                    break;
                case 6:
                    message.world_offset_pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.world_offset_angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                case 10:
                    message.tickcount = reader.int32();
                    break;
                case 11:
                    message.manifestincomplete = reader.bool();
                    break;
                case 12:
                    message.localnamefixup = reader.string();
                    break;
                case 13:
                    message.parentnamefixup = reader.string();
                    break;
                case 14:
                    message.manifestloadpriority = reader.int32();
                    break;
                case 15:
                    message.worldgroupid = reader.uint32();
                    break;
                case 16:
                    message.creationsequence = reader.uint32();
                    break;
                case 17:
                    message.savegamefilename = reader.string();
                    break;
                case 18:
                    message.spawngroupparenthandle = reader.uint32();
                    break;
                case 19:
                    message.leveltransition = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos")) {
                var error = $root.CMsgVector.verify(message.world_offset_pos);
                if (error)
                    return "world_offset_pos." + error;
            }
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle")) {
                var error = $root.CMsgQAngle.verify(message.world_offset_angle);
                if (error)
                    return "world_offset_angle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.world_offset_pos != null) {
                if (typeof object.world_offset_pos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_pos: object expected");
                message.world_offset_pos = $root.CMsgVector.fromObject(object.world_offset_pos);
            }
            if (object.world_offset_angle != null) {
                if (typeof object.world_offset_angle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_angle: object expected");
                message.world_offset_angle = $root.CMsgQAngle.fromObject(object.world_offset_angle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.world_offset_pos = null;
                object.world_offset_angle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos"))
                object.world_offset_pos = $root.CMsgVector.toObject(message.world_offset_pos, options);
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle"))
                object.world_offset_angle = $root.CMsgQAngle.toObject(message.world_offset_angle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 3:
                    message.manifestincomplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.tickcount = reader.int32();
                    break;
                case 3:
                    message.creationsequence = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.flags = reader.uint32();
                    break;
                case 3:
                    message.tickcount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [is_multiplayer] CSVCMsg_GameSessionConfiguration is_multiplayer
         * @property {boolean|null} [is_loadsavegame] CSVCMsg_GameSessionConfiguration is_loadsavegame
         * @property {boolean|null} [is_background_map] CSVCMsg_GameSessionConfiguration is_background_map
         * @property {boolean|null} [is_headless] CSVCMsg_GameSessionConfiguration is_headless
         * @property {number|null} [min_client_limit] CSVCMsg_GameSessionConfiguration min_client_limit
         * @property {number|null} [max_client_limit] CSVCMsg_GameSessionConfiguration max_client_limit
         * @property {number|null} [max_clients] CSVCMsg_GameSessionConfiguration max_clients
         * @property {number|null} [tick_interval] CSVCMsg_GameSessionConfiguration tick_interval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1_mapname] CSVCMsg_GameSessionConfiguration s1_mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [server_ip_address] CSVCMsg_GameSessionConfiguration server_ip_address
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [is_localonly] CSVCMsg_GameSessionConfiguration is_localonly
         * @property {boolean|null} [no_steam_server] CSVCMsg_GameSessionConfiguration no_steam_server
         * @property {boolean|null} [is_transition] CSVCMsg_GameSessionConfiguration is_transition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration is_multiplayer.
         * @member {boolean} is_multiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_multiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_loadsavegame.
         * @member {boolean} is_loadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_loadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_background_map.
         * @member {boolean} is_background_map
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_background_map = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_headless.
         * @member {boolean} is_headless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_headless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration min_client_limit.
         * @member {number} min_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.min_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_client_limit.
         * @member {number} max_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1_mapname.
         * @member {string} s1_mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1_mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration server_ip_address.
         * @member {string} server_ip_address
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.server_ip_address = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration is_localonly.
         * @member {boolean} is_localonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_localonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration no_steam_server.
         * @member {boolean} no_steam_server
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.no_steam_server = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_transition.
         * @member {boolean} is_transition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_transition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_multiplayer != null && Object.hasOwnProperty.call(message, "is_multiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_multiplayer);
            if (message.is_loadsavegame != null && Object.hasOwnProperty.call(message, "is_loadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_loadsavegame);
            if (message.is_background_map != null && Object.hasOwnProperty.call(message, "is_background_map"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_background_map);
            if (message.is_headless != null && Object.hasOwnProperty.call(message, "is_headless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_headless);
            if (message.min_client_limit != null && Object.hasOwnProperty.call(message, "min_client_limit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.min_client_limit);
            if (message.max_client_limit != null && Object.hasOwnProperty.call(message, "max_client_limit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.max_client_limit);
            if (message.max_clients != null && Object.hasOwnProperty.call(message, "max_clients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.max_clients);
            if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tick_interval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1_mapname != null && Object.hasOwnProperty.call(message, "s1_mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1_mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.server_ip_address != null && Object.hasOwnProperty.call(message, "server_ip_address"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.server_ip_address);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.is_localonly != null && Object.hasOwnProperty.call(message, "is_localonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.is_localonly);
            if (message.is_transition != null && Object.hasOwnProperty.call(message, "is_transition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_transition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.no_steam_server != null && Object.hasOwnProperty.call(message, "no_steam_server"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.no_steam_server);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_multiplayer = reader.bool();
                    break;
                case 2:
                    message.is_loadsavegame = reader.bool();
                    break;
                case 3:
                    message.is_background_map = reader.bool();
                    break;
                case 4:
                    message.is_headless = reader.bool();
                    break;
                case 5:
                    message.min_client_limit = reader.uint32();
                    break;
                case 6:
                    message.max_client_limit = reader.uint32();
                    break;
                case 7:
                    message.max_clients = reader.uint32();
                    break;
                case 8:
                    message.tick_interval = reader.fixed32();
                    break;
                case 9:
                    message.hostname = reader.string();
                    break;
                case 10:
                    message.savegamename = reader.string();
                    break;
                case 11:
                    message.s1_mapname = reader.string();
                    break;
                case 12:
                    message.gamemode = reader.string();
                    break;
                case 13:
                    message.server_ip_address = reader.string();
                    break;
                case 14:
                    message.data = reader.bytes();
                    break;
                case 15:
                    message.is_localonly = reader.bool();
                    break;
                case 19:
                    message.no_steam_server = reader.bool();
                    break;
                case 16:
                    message.is_transition = reader.bool();
                    break;
                case 17:
                    message.previouslevel = reader.string();
                    break;
                case 18:
                    message.landmarkname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                if (typeof message.is_multiplayer !== "boolean")
                    return "is_multiplayer: boolean expected";
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                if (typeof message.is_loadsavegame !== "boolean")
                    return "is_loadsavegame: boolean expected";
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                if (typeof message.is_background_map !== "boolean")
                    return "is_background_map: boolean expected";
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                if (typeof message.is_headless !== "boolean")
                    return "is_headless: boolean expected";
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                if (!$util.isInteger(message.min_client_limit))
                    return "min_client_limit: integer expected";
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                if (!$util.isInteger(message.max_client_limit))
                    return "max_client_limit: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (!$util.isInteger(message.tick_interval))
                    return "tick_interval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                if (!$util.isString(message.s1_mapname))
                    return "s1_mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                if (!$util.isString(message.server_ip_address))
                    return "server_ip_address: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                if (typeof message.is_localonly !== "boolean")
                    return "is_localonly: boolean expected";
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                if (typeof message.no_steam_server !== "boolean")
                    return "no_steam_server: boolean expected";
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                if (typeof message.is_transition !== "boolean")
                    return "is_transition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.is_multiplayer != null)
                message.is_multiplayer = Boolean(object.is_multiplayer);
            if (object.is_loadsavegame != null)
                message.is_loadsavegame = Boolean(object.is_loadsavegame);
            if (object.is_background_map != null)
                message.is_background_map = Boolean(object.is_background_map);
            if (object.is_headless != null)
                message.is_headless = Boolean(object.is_headless);
            if (object.min_client_limit != null)
                message.min_client_limit = object.min_client_limit >>> 0;
            if (object.max_client_limit != null)
                message.max_client_limit = object.max_client_limit >>> 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients >>> 0;
            if (object.tick_interval != null)
                message.tick_interval = object.tick_interval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1_mapname != null)
                message.s1_mapname = String(object.s1_mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.server_ip_address != null)
                message.server_ip_address = String(object.server_ip_address);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.is_localonly != null)
                message.is_localonly = Boolean(object.is_localonly);
            if (object.no_steam_server != null)
                message.no_steam_server = Boolean(object.no_steam_server);
            if (object.is_transition != null)
                message.is_transition = Boolean(object.is_transition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.is_multiplayer = false;
                object.is_loadsavegame = false;
                object.is_background_map = false;
                object.is_headless = false;
                object.min_client_limit = 0;
                object.max_client_limit = 0;
                object.max_clients = 0;
                object.tick_interval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1_mapname = "";
                object.gamemode = "";
                object.server_ip_address = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.is_localonly = false;
                object.is_transition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.no_steam_server = false;
            }
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                object.is_multiplayer = message.is_multiplayer;
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                object.is_loadsavegame = message.is_loadsavegame;
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                object.is_background_map = message.is_background_map;
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                object.is_headless = message.is_headless;
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                object.min_client_limit = message.min_client_limit;
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                object.max_client_limit = message.max_client_limit;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = message.tick_interval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                object.s1_mapname = message.s1_mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                object.server_ip_address = message.server_ip_address;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                object.is_localonly = message.is_localonly;
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                object.is_transition = message.is_transition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                object.no_steam_server = message.no_steam_server;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW=70 NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[70] = "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW"] = 70;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {string|null} [experimental_map_key] FieldOptions experimental_map_key
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions experimental_map_key.
                 * @member {string} experimental_map_key
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.experimental_map_key = "";
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.experimental_map_key != null && Object.hasOwnProperty.call(message, "experimental_map_key"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.experimental_map_key);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 9:
                            message.experimental_map_key = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        if (!$util.isString(message.experimental_map_key))
                            return "experimental_map_key: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.experimental_map_key != null)
                        message.experimental_map_key = String(object.experimental_map_key);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.experimental_map_key = "";
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        object.experimental_map_key = message.experimental_map_key;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 * @property {string|null} [".network_connection_token"] EnumValueOptions .network_connection_token
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * EnumValueOptions .network_connection_token.
                 * @member {string} .network_connection_token
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".network_connection_token"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".network_connection_token"] != null && Object.hasOwnProperty.call(message, ".network_connection_token"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".network_connection_token"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50500:
                            message[".network_connection_token"] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        if (!$util.isString(message[".network_connection_token"]))
                            return ".network_connection_token: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".network_connection_token"] != null)
                        message[".network_connection_token"] = String(object[".network_connection_token"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object[".network_connection_token"] = "";
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        object[".network_connection_token"] = message[".network_connection_token"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();
    
    /**
     * DOTA_GameMode enum.
     * @exports DOTA_GameMode
     * @enum {number}
     * @property {number} DOTA_GAMEMODE_NONE=0 DOTA_GAMEMODE_NONE value
     * @property {number} DOTA_GAMEMODE_AP=1 DOTA_GAMEMODE_AP value
     * @property {number} DOTA_GAMEMODE_CM=2 DOTA_GAMEMODE_CM value
     * @property {number} DOTA_GAMEMODE_RD=3 DOTA_GAMEMODE_RD value
     * @property {number} DOTA_GAMEMODE_SD=4 DOTA_GAMEMODE_SD value
     * @property {number} DOTA_GAMEMODE_AR=5 DOTA_GAMEMODE_AR value
     * @property {number} DOTA_GAMEMODE_INTRO=6 DOTA_GAMEMODE_INTRO value
     * @property {number} DOTA_GAMEMODE_HW=7 DOTA_GAMEMODE_HW value
     * @property {number} DOTA_GAMEMODE_REVERSE_CM=8 DOTA_GAMEMODE_REVERSE_CM value
     * @property {number} DOTA_GAMEMODE_XMAS=9 DOTA_GAMEMODE_XMAS value
     * @property {number} DOTA_GAMEMODE_TUTORIAL=10 DOTA_GAMEMODE_TUTORIAL value
     * @property {number} DOTA_GAMEMODE_MO=11 DOTA_GAMEMODE_MO value
     * @property {number} DOTA_GAMEMODE_LP=12 DOTA_GAMEMODE_LP value
     * @property {number} DOTA_GAMEMODE_POOL1=13 DOTA_GAMEMODE_POOL1 value
     * @property {number} DOTA_GAMEMODE_FH=14 DOTA_GAMEMODE_FH value
     * @property {number} DOTA_GAMEMODE_CUSTOM=15 DOTA_GAMEMODE_CUSTOM value
     * @property {number} DOTA_GAMEMODE_CD=16 DOTA_GAMEMODE_CD value
     * @property {number} DOTA_GAMEMODE_BD=17 DOTA_GAMEMODE_BD value
     * @property {number} DOTA_GAMEMODE_ABILITY_DRAFT=18 DOTA_GAMEMODE_ABILITY_DRAFT value
     * @property {number} DOTA_GAMEMODE_EVENT=19 DOTA_GAMEMODE_EVENT value
     * @property {number} DOTA_GAMEMODE_ARDM=20 DOTA_GAMEMODE_ARDM value
     * @property {number} DOTA_GAMEMODE_1V1MID=21 DOTA_GAMEMODE_1V1MID value
     * @property {number} DOTA_GAMEMODE_ALL_DRAFT=22 DOTA_GAMEMODE_ALL_DRAFT value
     * @property {number} DOTA_GAMEMODE_TURBO=23 DOTA_GAMEMODE_TURBO value
     * @property {number} DOTA_GAMEMODE_MUTATION=24 DOTA_GAMEMODE_MUTATION value
     * @property {number} DOTA_GAMEMODE_COACHES_CHALLENGE=25 DOTA_GAMEMODE_COACHES_CHALLENGE value
     */
    $root.DOTA_GameMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GAMEMODE_NONE"] = 0;
        values[valuesById[1] = "DOTA_GAMEMODE_AP"] = 1;
        values[valuesById[2] = "DOTA_GAMEMODE_CM"] = 2;
        values[valuesById[3] = "DOTA_GAMEMODE_RD"] = 3;
        values[valuesById[4] = "DOTA_GAMEMODE_SD"] = 4;
        values[valuesById[5] = "DOTA_GAMEMODE_AR"] = 5;
        values[valuesById[6] = "DOTA_GAMEMODE_INTRO"] = 6;
        values[valuesById[7] = "DOTA_GAMEMODE_HW"] = 7;
        values[valuesById[8] = "DOTA_GAMEMODE_REVERSE_CM"] = 8;
        values[valuesById[9] = "DOTA_GAMEMODE_XMAS"] = 9;
        values[valuesById[10] = "DOTA_GAMEMODE_TUTORIAL"] = 10;
        values[valuesById[11] = "DOTA_GAMEMODE_MO"] = 11;
        values[valuesById[12] = "DOTA_GAMEMODE_LP"] = 12;
        values[valuesById[13] = "DOTA_GAMEMODE_POOL1"] = 13;
        values[valuesById[14] = "DOTA_GAMEMODE_FH"] = 14;
        values[valuesById[15] = "DOTA_GAMEMODE_CUSTOM"] = 15;
        values[valuesById[16] = "DOTA_GAMEMODE_CD"] = 16;
        values[valuesById[17] = "DOTA_GAMEMODE_BD"] = 17;
        values[valuesById[18] = "DOTA_GAMEMODE_ABILITY_DRAFT"] = 18;
        values[valuesById[19] = "DOTA_GAMEMODE_EVENT"] = 19;
        values[valuesById[20] = "DOTA_GAMEMODE_ARDM"] = 20;
        values[valuesById[21] = "DOTA_GAMEMODE_1V1MID"] = 21;
        values[valuesById[22] = "DOTA_GAMEMODE_ALL_DRAFT"] = 22;
        values[valuesById[23] = "DOTA_GAMEMODE_TURBO"] = 23;
        values[valuesById[24] = "DOTA_GAMEMODE_MUTATION"] = 24;
        values[valuesById[25] = "DOTA_GAMEMODE_COACHES_CHALLENGE"] = 25;
        return values;
    })();
    
    /**
     * DOTA_GameState enum.
     * @exports DOTA_GameState
     * @enum {number}
     * @property {number} DOTA_GAMERULES_STATE_INIT=0 DOTA_GAMERULES_STATE_INIT value
     * @property {number} DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD=1 DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD value
     * @property {number} DOTA_GAMERULES_STATE_HERO_SELECTION=2 DOTA_GAMERULES_STATE_HERO_SELECTION value
     * @property {number} DOTA_GAMERULES_STATE_STRATEGY_TIME=3 DOTA_GAMERULES_STATE_STRATEGY_TIME value
     * @property {number} DOTA_GAMERULES_STATE_PRE_GAME=4 DOTA_GAMERULES_STATE_PRE_GAME value
     * @property {number} DOTA_GAMERULES_STATE_GAME_IN_PROGRESS=5 DOTA_GAMERULES_STATE_GAME_IN_PROGRESS value
     * @property {number} DOTA_GAMERULES_STATE_POST_GAME=6 DOTA_GAMERULES_STATE_POST_GAME value
     * @property {number} DOTA_GAMERULES_STATE_DISCONNECT=7 DOTA_GAMERULES_STATE_DISCONNECT value
     * @property {number} DOTA_GAMERULES_STATE_TEAM_SHOWCASE=8 DOTA_GAMERULES_STATE_TEAM_SHOWCASE value
     * @property {number} DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP=9 DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP value
     * @property {number} DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD=10 DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD value
     * @property {number} DOTA_GAMERULES_STATE_LAST=11 DOTA_GAMERULES_STATE_LAST value
     */
    $root.DOTA_GameState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GAMERULES_STATE_INIT"] = 0;
        values[valuesById[1] = "DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD"] = 1;
        values[valuesById[2] = "DOTA_GAMERULES_STATE_HERO_SELECTION"] = 2;
        values[valuesById[3] = "DOTA_GAMERULES_STATE_STRATEGY_TIME"] = 3;
        values[valuesById[4] = "DOTA_GAMERULES_STATE_PRE_GAME"] = 4;
        values[valuesById[5] = "DOTA_GAMERULES_STATE_GAME_IN_PROGRESS"] = 5;
        values[valuesById[6] = "DOTA_GAMERULES_STATE_POST_GAME"] = 6;
        values[valuesById[7] = "DOTA_GAMERULES_STATE_DISCONNECT"] = 7;
        values[valuesById[8] = "DOTA_GAMERULES_STATE_TEAM_SHOWCASE"] = 8;
        values[valuesById[9] = "DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP"] = 9;
        values[valuesById[10] = "DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD"] = 10;
        values[valuesById[11] = "DOTA_GAMERULES_STATE_LAST"] = 11;
        return values;
    })();
    
    /**
     * DOTA_GC_TEAM enum.
     * @exports DOTA_GC_TEAM
     * @enum {number}
     * @property {number} DOTA_GC_TEAM_GOOD_GUYS=0 DOTA_GC_TEAM_GOOD_GUYS value
     * @property {number} DOTA_GC_TEAM_BAD_GUYS=1 DOTA_GC_TEAM_BAD_GUYS value
     * @property {number} DOTA_GC_TEAM_BROADCASTER=2 DOTA_GC_TEAM_BROADCASTER value
     * @property {number} DOTA_GC_TEAM_SPECTATOR=3 DOTA_GC_TEAM_SPECTATOR value
     * @property {number} DOTA_GC_TEAM_PLAYER_POOL=4 DOTA_GC_TEAM_PLAYER_POOL value
     * @property {number} DOTA_GC_TEAM_NOTEAM=5 DOTA_GC_TEAM_NOTEAM value
     */
    $root.DOTA_GC_TEAM = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GC_TEAM_GOOD_GUYS"] = 0;
        values[valuesById[1] = "DOTA_GC_TEAM_BAD_GUYS"] = 1;
        values[valuesById[2] = "DOTA_GC_TEAM_BROADCASTER"] = 2;
        values[valuesById[3] = "DOTA_GC_TEAM_SPECTATOR"] = 3;
        values[valuesById[4] = "DOTA_GC_TEAM_PLAYER_POOL"] = 4;
        values[valuesById[5] = "DOTA_GC_TEAM_NOTEAM"] = 5;
        return values;
    })();
    
    /**
     * EEvent enum.
     * @exports EEvent
     * @enum {number}
     * @property {number} EVENT_ID_NONE=0 EVENT_ID_NONE value
     * @property {number} EVENT_ID_DIRETIDE=1 EVENT_ID_DIRETIDE value
     * @property {number} EVENT_ID_SPRING_FESTIVAL=2 EVENT_ID_SPRING_FESTIVAL value
     * @property {number} EVENT_ID_FROSTIVUS_2013=3 EVENT_ID_FROSTIVUS_2013 value
     * @property {number} EVENT_ID_COMPENDIUM_2014=4 EVENT_ID_COMPENDIUM_2014 value
     * @property {number} EVENT_ID_NEXON_PC_BANG=5 EVENT_ID_NEXON_PC_BANG value
     * @property {number} EVENT_ID_PWRD_DAC_2015=6 EVENT_ID_PWRD_DAC_2015 value
     * @property {number} EVENT_ID_NEW_BLOOM_2015=7 EVENT_ID_NEW_BLOOM_2015 value
     * @property {number} EVENT_ID_INTERNATIONAL_2015=8 EVENT_ID_INTERNATIONAL_2015 value
     * @property {number} EVENT_ID_FALL_MAJOR_2015=9 EVENT_ID_FALL_MAJOR_2015 value
     * @property {number} EVENT_ID_ORACLE_PA=10 EVENT_ID_ORACLE_PA value
     * @property {number} EVENT_ID_NEW_BLOOM_2015_PREBEAST=11 EVENT_ID_NEW_BLOOM_2015_PREBEAST value
     * @property {number} EVENT_ID_FROSTIVUS=12 EVENT_ID_FROSTIVUS value
     * @property {number} EVENT_ID_WINTER_MAJOR_2016=13 EVENT_ID_WINTER_MAJOR_2016 value
     * @property {number} EVENT_ID_INTERNATIONAL_2016=14 EVENT_ID_INTERNATIONAL_2016 value
     * @property {number} EVENT_ID_FALL_MAJOR_2016=15 EVENT_ID_FALL_MAJOR_2016 value
     * @property {number} EVENT_ID_WINTER_MAJOR_2017=16 EVENT_ID_WINTER_MAJOR_2017 value
     * @property {number} EVENT_ID_NEW_BLOOM_2017=17 EVENT_ID_NEW_BLOOM_2017 value
     * @property {number} EVENT_ID_INTERNATIONAL_2017=18 EVENT_ID_INTERNATIONAL_2017 value
     * @property {number} EVENT_ID_PLUS_SUBSCRIPTION=19 EVENT_ID_PLUS_SUBSCRIPTION value
     * @property {number} EVENT_ID_SINGLES_DAY_2017=20 EVENT_ID_SINGLES_DAY_2017 value
     * @property {number} EVENT_ID_FROSTIVUS_2017=21 EVENT_ID_FROSTIVUS_2017 value
     * @property {number} EVENT_ID_INTERNATIONAL_2018=22 EVENT_ID_INTERNATIONAL_2018 value
     * @property {number} EVENT_ID_FROSTIVUS_2018=23 EVENT_ID_FROSTIVUS_2018 value
     * @property {number} EVENT_ID_NEW_BLOOM_2019=24 EVENT_ID_NEW_BLOOM_2019 value
     * @property {number} EVENT_ID_INTERNATIONAL_2019=25 EVENT_ID_INTERNATIONAL_2019 value
     * @property {number} EVENT_ID_NEW_PLAYER_EXPERIENCE=26 EVENT_ID_NEW_PLAYER_EXPERIENCE value
     * @property {number} EVENT_ID_FROSTIVUS_2019=27 EVENT_ID_FROSTIVUS_2019 value
     * @property {number} EVENT_ID_NEW_BLOOM_2020=28 EVENT_ID_NEW_BLOOM_2020 value
     * @property {number} EVENT_ID_INTERNATIONAL_2020=29 EVENT_ID_INTERNATIONAL_2020 value
     * @property {number} EVENT_ID_TEAM_FANDOM=30 EVENT_ID_TEAM_FANDOM value
     * @property {number} EVENT_ID_DIRETIDE_2020=31 EVENT_ID_DIRETIDE_2020 value
     * @property {number} EVENT_ID_COUNT=32 EVENT_ID_COUNT value
     */
    $root.EEvent = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EVENT_ID_NONE"] = 0;
        values[valuesById[1] = "EVENT_ID_DIRETIDE"] = 1;
        values[valuesById[2] = "EVENT_ID_SPRING_FESTIVAL"] = 2;
        values[valuesById[3] = "EVENT_ID_FROSTIVUS_2013"] = 3;
        values[valuesById[4] = "EVENT_ID_COMPENDIUM_2014"] = 4;
        values[valuesById[5] = "EVENT_ID_NEXON_PC_BANG"] = 5;
        values[valuesById[6] = "EVENT_ID_PWRD_DAC_2015"] = 6;
        values[valuesById[7] = "EVENT_ID_NEW_BLOOM_2015"] = 7;
        values[valuesById[8] = "EVENT_ID_INTERNATIONAL_2015"] = 8;
        values[valuesById[9] = "EVENT_ID_FALL_MAJOR_2015"] = 9;
        values[valuesById[10] = "EVENT_ID_ORACLE_PA"] = 10;
        values[valuesById[11] = "EVENT_ID_NEW_BLOOM_2015_PREBEAST"] = 11;
        values[valuesById[12] = "EVENT_ID_FROSTIVUS"] = 12;
        values[valuesById[13] = "EVENT_ID_WINTER_MAJOR_2016"] = 13;
        values[valuesById[14] = "EVENT_ID_INTERNATIONAL_2016"] = 14;
        values[valuesById[15] = "EVENT_ID_FALL_MAJOR_2016"] = 15;
        values[valuesById[16] = "EVENT_ID_WINTER_MAJOR_2017"] = 16;
        values[valuesById[17] = "EVENT_ID_NEW_BLOOM_2017"] = 17;
        values[valuesById[18] = "EVENT_ID_INTERNATIONAL_2017"] = 18;
        values[valuesById[19] = "EVENT_ID_PLUS_SUBSCRIPTION"] = 19;
        values[valuesById[20] = "EVENT_ID_SINGLES_DAY_2017"] = 20;
        values[valuesById[21] = "EVENT_ID_FROSTIVUS_2017"] = 21;
        values[valuesById[22] = "EVENT_ID_INTERNATIONAL_2018"] = 22;
        values[valuesById[23] = "EVENT_ID_FROSTIVUS_2018"] = 23;
        values[valuesById[24] = "EVENT_ID_NEW_BLOOM_2019"] = 24;
        values[valuesById[25] = "EVENT_ID_INTERNATIONAL_2019"] = 25;
        values[valuesById[26] = "EVENT_ID_NEW_PLAYER_EXPERIENCE"] = 26;
        values[valuesById[27] = "EVENT_ID_FROSTIVUS_2019"] = 27;
        values[valuesById[28] = "EVENT_ID_NEW_BLOOM_2020"] = 28;
        values[valuesById[29] = "EVENT_ID_INTERNATIONAL_2020"] = 29;
        values[valuesById[30] = "EVENT_ID_TEAM_FANDOM"] = 30;
        values[valuesById[31] = "EVENT_ID_DIRETIDE_2020"] = 31;
        values[valuesById[32] = "EVENT_ID_COUNT"] = 32;
        return values;
    })();
    
    /**
     * DOTALeaverStatus_t enum.
     * @exports DOTALeaverStatus_t
     * @enum {number}
     * @property {number} DOTA_LEAVER_NONE=0 DOTA_LEAVER_NONE value
     * @property {number} DOTA_LEAVER_DISCONNECTED=1 DOTA_LEAVER_DISCONNECTED value
     * @property {number} DOTA_LEAVER_DISCONNECTED_TOO_LONG=2 DOTA_LEAVER_DISCONNECTED_TOO_LONG value
     * @property {number} DOTA_LEAVER_ABANDONED=3 DOTA_LEAVER_ABANDONED value
     * @property {number} DOTA_LEAVER_AFK=4 DOTA_LEAVER_AFK value
     * @property {number} DOTA_LEAVER_NEVER_CONNECTED=5 DOTA_LEAVER_NEVER_CONNECTED value
     * @property {number} DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG=6 DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG value
     * @property {number} DOTA_LEAVER_FAILED_TO_READY_UP=7 DOTA_LEAVER_FAILED_TO_READY_UP value
     * @property {number} DOTA_LEAVER_DECLINED=8 DOTA_LEAVER_DECLINED value
     */
    $root.DOTALeaverStatus_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_LEAVER_NONE"] = 0;
        values[valuesById[1] = "DOTA_LEAVER_DISCONNECTED"] = 1;
        values[valuesById[2] = "DOTA_LEAVER_DISCONNECTED_TOO_LONG"] = 2;
        values[valuesById[3] = "DOTA_LEAVER_ABANDONED"] = 3;
        values[valuesById[4] = "DOTA_LEAVER_AFK"] = 4;
        values[valuesById[5] = "DOTA_LEAVER_NEVER_CONNECTED"] = 5;
        values[valuesById[6] = "DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG"] = 6;
        values[valuesById[7] = "DOTA_LEAVER_FAILED_TO_READY_UP"] = 7;
        values[valuesById[8] = "DOTA_LEAVER_DECLINED"] = 8;
        return values;
    })();
    
    /**
     * DOTAConnectionState_t enum.
     * @exports DOTAConnectionState_t
     * @enum {number}
     * @property {number} DOTA_CONNECTION_STATE_UNKNOWN=0 DOTA_CONNECTION_STATE_UNKNOWN value
     * @property {number} DOTA_CONNECTION_STATE_NOT_YET_CONNECTED=1 DOTA_CONNECTION_STATE_NOT_YET_CONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_CONNECTED=2 DOTA_CONNECTION_STATE_CONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_DISCONNECTED=3 DOTA_CONNECTION_STATE_DISCONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_ABANDONED=4 DOTA_CONNECTION_STATE_ABANDONED value
     * @property {number} DOTA_CONNECTION_STATE_LOADING=5 DOTA_CONNECTION_STATE_LOADING value
     * @property {number} DOTA_CONNECTION_STATE_FAILED=6 DOTA_CONNECTION_STATE_FAILED value
     */
    $root.DOTAConnectionState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_CONNECTION_STATE_UNKNOWN"] = 0;
        values[valuesById[1] = "DOTA_CONNECTION_STATE_NOT_YET_CONNECTED"] = 1;
        values[valuesById[2] = "DOTA_CONNECTION_STATE_CONNECTED"] = 2;
        values[valuesById[3] = "DOTA_CONNECTION_STATE_DISCONNECTED"] = 3;
        values[valuesById[4] = "DOTA_CONNECTION_STATE_ABANDONED"] = 4;
        values[valuesById[5] = "DOTA_CONNECTION_STATE_LOADING"] = 5;
        values[valuesById[6] = "DOTA_CONNECTION_STATE_FAILED"] = 6;
        return values;
    })();
    
    /**
     * Fantasy_Roles enum.
     * @exports Fantasy_Roles
     * @enum {number}
     * @property {number} FANTASY_ROLE_UNDEFINED=0 FANTASY_ROLE_UNDEFINED value
     * @property {number} FANTASY_ROLE_CORE=1 FANTASY_ROLE_CORE value
     * @property {number} FANTASY_ROLE_SUPPORT=2 FANTASY_ROLE_SUPPORT value
     * @property {number} FANTASY_ROLE_OFFLANE=3 FANTASY_ROLE_OFFLANE value
     * @property {number} FANTASY_ROLE_MID=4 FANTASY_ROLE_MID value
     */
    $root.Fantasy_Roles = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_ROLE_UNDEFINED"] = 0;
        values[valuesById[1] = "FANTASY_ROLE_CORE"] = 1;
        values[valuesById[2] = "FANTASY_ROLE_SUPPORT"] = 2;
        values[valuesById[3] = "FANTASY_ROLE_OFFLANE"] = 3;
        values[valuesById[4] = "FANTASY_ROLE_MID"] = 4;
        return values;
    })();
    
    /**
     * Fantasy_Team_Slots enum.
     * @exports Fantasy_Team_Slots
     * @enum {number}
     * @property {number} FANTASY_SLOT_NONE=0 FANTASY_SLOT_NONE value
     * @property {number} FANTASY_SLOT_CORE=1 FANTASY_SLOT_CORE value
     * @property {number} FANTASY_SLOT_SUPPORT=2 FANTASY_SLOT_SUPPORT value
     * @property {number} FANTASY_SLOT_ANY=3 FANTASY_SLOT_ANY value
     * @property {number} FANTASY_SLOT_BENCH=4 FANTASY_SLOT_BENCH value
     */
    $root.Fantasy_Team_Slots = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_SLOT_NONE"] = 0;
        values[valuesById[1] = "FANTASY_SLOT_CORE"] = 1;
        values[valuesById[2] = "FANTASY_SLOT_SUPPORT"] = 2;
        values[valuesById[3] = "FANTASY_SLOT_ANY"] = 3;
        values[valuesById[4] = "FANTASY_SLOT_BENCH"] = 4;
        return values;
    })();
    
    /**
     * Fantasy_Selection_Mode enum.
     * @exports Fantasy_Selection_Mode
     * @enum {number}
     * @property {number} FANTASY_SELECTION_INVALID=0 FANTASY_SELECTION_INVALID value
     * @property {number} FANTASY_SELECTION_LOCKED=1 FANTASY_SELECTION_LOCKED value
     * @property {number} FANTASY_SELECTION_SHUFFLE=2 FANTASY_SELECTION_SHUFFLE value
     * @property {number} FANTASY_SELECTION_FREE_PICK=3 FANTASY_SELECTION_FREE_PICK value
     * @property {number} FANTASY_SELECTION_ENDED=4 FANTASY_SELECTION_ENDED value
     * @property {number} FANTASY_SELECTION_PRE_SEASON=5 FANTASY_SELECTION_PRE_SEASON value
     * @property {number} FANTASY_SELECTION_PRE_DRAFT=6 FANTASY_SELECTION_PRE_DRAFT value
     * @property {number} FANTASY_SELECTION_DRAFTING=7 FANTASY_SELECTION_DRAFTING value
     * @property {number} FANTASY_SELECTION_REGULAR_SEASON=8 FANTASY_SELECTION_REGULAR_SEASON value
     * @property {number} FANTASY_SELECTION_CARD_BASED=9 FANTASY_SELECTION_CARD_BASED value
     */
    $root.Fantasy_Selection_Mode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_SELECTION_INVALID"] = 0;
        values[valuesById[1] = "FANTASY_SELECTION_LOCKED"] = 1;
        values[valuesById[2] = "FANTASY_SELECTION_SHUFFLE"] = 2;
        values[valuesById[3] = "FANTASY_SELECTION_FREE_PICK"] = 3;
        values[valuesById[4] = "FANTASY_SELECTION_ENDED"] = 4;
        values[valuesById[5] = "FANTASY_SELECTION_PRE_SEASON"] = 5;
        values[valuesById[6] = "FANTASY_SELECTION_PRE_DRAFT"] = 6;
        values[valuesById[7] = "FANTASY_SELECTION_DRAFTING"] = 7;
        values[valuesById[8] = "FANTASY_SELECTION_REGULAR_SEASON"] = 8;
        values[valuesById[9] = "FANTASY_SELECTION_CARD_BASED"] = 9;
        return values;
    })();
    
    /**
     * DOTAChatChannelType_t enum.
     * @exports DOTAChatChannelType_t
     * @enum {number}
     * @property {number} DOTAChannelType_Regional=0 DOTAChannelType_Regional value
     * @property {number} DOTAChannelType_Custom=1 DOTAChannelType_Custom value
     * @property {number} DOTAChannelType_Party=2 DOTAChannelType_Party value
     * @property {number} DOTAChannelType_Lobby=3 DOTAChannelType_Lobby value
     * @property {number} DOTAChannelType_Team=4 DOTAChannelType_Team value
     * @property {number} DOTAChannelType_Guild=5 DOTAChannelType_Guild value
     * @property {number} DOTAChannelType_Fantasy=6 DOTAChannelType_Fantasy value
     * @property {number} DOTAChannelType_Whisper=7 DOTAChannelType_Whisper value
     * @property {number} DOTAChannelType_Console=8 DOTAChannelType_Console value
     * @property {number} DOTAChannelType_Tab=9 DOTAChannelType_Tab value
     * @property {number} DOTAChannelType_Invalid=10 DOTAChannelType_Invalid value
     * @property {number} DOTAChannelType_GameAll=11 DOTAChannelType_GameAll value
     * @property {number} DOTAChannelType_GameAllies=12 DOTAChannelType_GameAllies value
     * @property {number} DOTAChannelType_GameSpectator=13 DOTAChannelType_GameSpectator value
     * @property {number} DOTAChannelType_Cafe=15 DOTAChannelType_Cafe value
     * @property {number} DOTAChannelType_CustomGame=16 DOTAChannelType_CustomGame value
     * @property {number} DOTAChannelType_Private=17 DOTAChannelType_Private value
     * @property {number} DOTAChannelType_PostGame=18 DOTAChannelType_PostGame value
     * @property {number} DOTAChannelType_BattleCup=19 DOTAChannelType_BattleCup value
     * @property {number} DOTAChannelType_HLTVSpectator=20 DOTAChannelType_HLTVSpectator value
     * @property {number} DOTAChannelType_GameEvents=21 DOTAChannelType_GameEvents value
     * @property {number} DOTAChannelType_Trivia=22 DOTAChannelType_Trivia value
     */
    $root.DOTAChatChannelType_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTAChannelType_Regional"] = 0;
        values[valuesById[1] = "DOTAChannelType_Custom"] = 1;
        values[valuesById[2] = "DOTAChannelType_Party"] = 2;
        values[valuesById[3] = "DOTAChannelType_Lobby"] = 3;
        values[valuesById[4] = "DOTAChannelType_Team"] = 4;
        values[valuesById[5] = "DOTAChannelType_Guild"] = 5;
        values[valuesById[6] = "DOTAChannelType_Fantasy"] = 6;
        values[valuesById[7] = "DOTAChannelType_Whisper"] = 7;
        values[valuesById[8] = "DOTAChannelType_Console"] = 8;
        values[valuesById[9] = "DOTAChannelType_Tab"] = 9;
        values[valuesById[10] = "DOTAChannelType_Invalid"] = 10;
        values[valuesById[11] = "DOTAChannelType_GameAll"] = 11;
        values[valuesById[12] = "DOTAChannelType_GameAllies"] = 12;
        values[valuesById[13] = "DOTAChannelType_GameSpectator"] = 13;
        values[valuesById[15] = "DOTAChannelType_Cafe"] = 15;
        values[valuesById[16] = "DOTAChannelType_CustomGame"] = 16;
        values[valuesById[17] = "DOTAChannelType_Private"] = 17;
        values[valuesById[18] = "DOTAChannelType_PostGame"] = 18;
        values[valuesById[19] = "DOTAChannelType_BattleCup"] = 19;
        values[valuesById[20] = "DOTAChannelType_HLTVSpectator"] = 20;
        values[valuesById[21] = "DOTAChannelType_GameEvents"] = 21;
        values[valuesById[22] = "DOTAChannelType_Trivia"] = 22;
        return values;
    })();
    
    /**
     * EProfileCardSlotType enum.
     * @exports EProfileCardSlotType
     * @enum {number}
     * @property {number} k_EProfileCardSlotType_Empty=0 k_EProfileCardSlotType_Empty value
     * @property {number} k_EProfileCardSlotType_Stat=1 k_EProfileCardSlotType_Stat value
     * @property {number} k_EProfileCardSlotType_Trophy=2 k_EProfileCardSlotType_Trophy value
     * @property {number} k_EProfileCardSlotType_Item=3 k_EProfileCardSlotType_Item value
     * @property {number} k_EProfileCardSlotType_Hero=4 k_EProfileCardSlotType_Hero value
     * @property {number} k_EProfileCardSlotType_Emoticon=5 k_EProfileCardSlotType_Emoticon value
     * @property {number} k_EProfileCardSlotType_Team=6 k_EProfileCardSlotType_Team value
     */
    $root.EProfileCardSlotType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EProfileCardSlotType_Empty"] = 0;
        values[valuesById[1] = "k_EProfileCardSlotType_Stat"] = 1;
        values[valuesById[2] = "k_EProfileCardSlotType_Trophy"] = 2;
        values[valuesById[3] = "k_EProfileCardSlotType_Item"] = 3;
        values[valuesById[4] = "k_EProfileCardSlotType_Hero"] = 4;
        values[valuesById[5] = "k_EProfileCardSlotType_Emoticon"] = 5;
        values[valuesById[6] = "k_EProfileCardSlotType_Team"] = 6;
        return values;
    })();
    
    /**
     * EMatchGroupServerStatus enum.
     * @exports EMatchGroupServerStatus
     * @enum {number}
     * @property {number} k_EMatchGroupServerStatus_OK=0 k_EMatchGroupServerStatus_OK value
     * @property {number} k_EMatchGroupServerStatus_LimitedAvailability=1 k_EMatchGroupServerStatus_LimitedAvailability value
     * @property {number} k_EMatchGroupServerStatus_Offline=2 k_EMatchGroupServerStatus_Offline value
     */
    $root.EMatchGroupServerStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EMatchGroupServerStatus_OK"] = 0;
        values[valuesById[1] = "k_EMatchGroupServerStatus_LimitedAvailability"] = 1;
        values[valuesById[2] = "k_EMatchGroupServerStatus_Offline"] = 2;
        return values;
    })();
    
    /**
     * DOTA_CM_PICK enum.
     * @exports DOTA_CM_PICK
     * @enum {number}
     * @property {number} DOTA_CM_RANDOM=0 DOTA_CM_RANDOM value
     * @property {number} DOTA_CM_GOOD_GUYS=1 DOTA_CM_GOOD_GUYS value
     * @property {number} DOTA_CM_BAD_GUYS=2 DOTA_CM_BAD_GUYS value
     */
    $root.DOTA_CM_PICK = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_CM_RANDOM"] = 0;
        values[valuesById[1] = "DOTA_CM_GOOD_GUYS"] = 1;
        values[valuesById[2] = "DOTA_CM_BAD_GUYS"] = 2;
        return values;
    })();
    
    /**
     * DOTALowPriorityBanType enum.
     * @exports DOTALowPriorityBanType
     * @enum {number}
     * @property {number} DOTA_LOW_PRIORITY_BAN_ABANDON=0 DOTA_LOW_PRIORITY_BAN_ABANDON value
     * @property {number} DOTA_LOW_PRIORITY_BAN_REPORTS=1 DOTA_LOW_PRIORITY_BAN_REPORTS value
     * @property {number} DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON=2 DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON value
     * @property {number} DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE=3 DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE value
     */
    $root.DOTALowPriorityBanType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_LOW_PRIORITY_BAN_ABANDON"] = 0;
        values[valuesById[1] = "DOTA_LOW_PRIORITY_BAN_REPORTS"] = 1;
        values[valuesById[2] = "DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON"] = 2;
        values[valuesById[3] = "DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE"] = 3;
        return values;
    })();
    
    /**
     * DOTALobbyReadyState enum.
     * @exports DOTALobbyReadyState
     * @enum {number}
     * @property {number} DOTALobbyReadyState_UNDECLARED=0 DOTALobbyReadyState_UNDECLARED value
     * @property {number} DOTALobbyReadyState_ACCEPTED=1 DOTALobbyReadyState_ACCEPTED value
     * @property {number} DOTALobbyReadyState_DECLINED=2 DOTALobbyReadyState_DECLINED value
     */
    $root.DOTALobbyReadyState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTALobbyReadyState_UNDECLARED"] = 0;
        values[valuesById[1] = "DOTALobbyReadyState_ACCEPTED"] = 1;
        values[valuesById[2] = "DOTALobbyReadyState_DECLINED"] = 2;
        return values;
    })();
    
    /**
     * DOTAGameVersion enum.
     * @exports DOTAGameVersion
     * @enum {number}
     * @property {number} GAME_VERSION_CURRENT=0 GAME_VERSION_CURRENT value
     * @property {number} GAME_VERSION_STABLE=1 GAME_VERSION_STABLE value
     */
    $root.DOTAGameVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GAME_VERSION_CURRENT"] = 0;
        values[valuesById[1] = "GAME_VERSION_STABLE"] = 1;
        return values;
    })();
    
    /**
     * DOTAJoinLobbyResult enum.
     * @exports DOTAJoinLobbyResult
     * @enum {number}
     * @property {number} DOTA_JOIN_RESULT_SUCCESS=0 DOTA_JOIN_RESULT_SUCCESS value
     * @property {number} DOTA_JOIN_RESULT_ALREADY_IN_GAME=1 DOTA_JOIN_RESULT_ALREADY_IN_GAME value
     * @property {number} DOTA_JOIN_RESULT_INVALID_LOBBY=2 DOTA_JOIN_RESULT_INVALID_LOBBY value
     * @property {number} DOTA_JOIN_RESULT_INCORRECT_PASSWORD=3 DOTA_JOIN_RESULT_INCORRECT_PASSWORD value
     * @property {number} DOTA_JOIN_RESULT_ACCESS_DENIED=4 DOTA_JOIN_RESULT_ACCESS_DENIED value
     * @property {number} DOTA_JOIN_RESULT_GENERIC_ERROR=5 DOTA_JOIN_RESULT_GENERIC_ERROR value
     * @property {number} DOTA_JOIN_RESULT_INCORRECT_VERSION=6 DOTA_JOIN_RESULT_INCORRECT_VERSION value
     * @property {number} DOTA_JOIN_RESULT_IN_TEAM_PARTY=7 DOTA_JOIN_RESULT_IN_TEAM_PARTY value
     * @property {number} DOTA_JOIN_RESULT_NO_LOBBY_FOUND=8 DOTA_JOIN_RESULT_NO_LOBBY_FOUND value
     * @property {number} DOTA_JOIN_RESULT_LOBBY_FULL=9 DOTA_JOIN_RESULT_LOBBY_FULL value
     * @property {number} DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION=10 DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION value
     * @property {number} DOTA_JOIN_RESULT_TIMEOUT=11 DOTA_JOIN_RESULT_TIMEOUT value
     * @property {number} DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN=12 DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN value
     * @property {number} DOTA_JOIN_RESULT_BUSY=13 DOTA_JOIN_RESULT_BUSY value
     * @property {number} DOTA_JOIN_RESULT_NO_PLAYTIME=14 DOTA_JOIN_RESULT_NO_PLAYTIME value
     */
    $root.DOTAJoinLobbyResult = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_JOIN_RESULT_SUCCESS"] = 0;
        values[valuesById[1] = "DOTA_JOIN_RESULT_ALREADY_IN_GAME"] = 1;
        values[valuesById[2] = "DOTA_JOIN_RESULT_INVALID_LOBBY"] = 2;
        values[valuesById[3] = "DOTA_JOIN_RESULT_INCORRECT_PASSWORD"] = 3;
        values[valuesById[4] = "DOTA_JOIN_RESULT_ACCESS_DENIED"] = 4;
        values[valuesById[5] = "DOTA_JOIN_RESULT_GENERIC_ERROR"] = 5;
        values[valuesById[6] = "DOTA_JOIN_RESULT_INCORRECT_VERSION"] = 6;
        values[valuesById[7] = "DOTA_JOIN_RESULT_IN_TEAM_PARTY"] = 7;
        values[valuesById[8] = "DOTA_JOIN_RESULT_NO_LOBBY_FOUND"] = 8;
        values[valuesById[9] = "DOTA_JOIN_RESULT_LOBBY_FULL"] = 9;
        values[valuesById[10] = "DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION"] = 10;
        values[valuesById[11] = "DOTA_JOIN_RESULT_TIMEOUT"] = 11;
        values[valuesById[12] = "DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN"] = 12;
        values[valuesById[13] = "DOTA_JOIN_RESULT_BUSY"] = 13;
        values[valuesById[14] = "DOTA_JOIN_RESULT_NO_PLAYTIME"] = 14;
        return values;
    })();
    
    /**
     * DOTASelectionPriorityRules enum.
     * @exports DOTASelectionPriorityRules
     * @enum {number}
     * @property {number} k_DOTASelectionPriorityRules_Manual=0 k_DOTASelectionPriorityRules_Manual value
     * @property {number} k_DOTASelectionPriorityRules_Automatic=1 k_DOTASelectionPriorityRules_Automatic value
     */
    $root.DOTASelectionPriorityRules = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_DOTASelectionPriorityRules_Manual"] = 0;
        values[valuesById[1] = "k_DOTASelectionPriorityRules_Automatic"] = 1;
        return values;
    })();
    
    /**
     * DOTASelectionPriorityChoice enum.
     * @exports DOTASelectionPriorityChoice
     * @enum {number}
     * @property {number} k_DOTASelectionPriorityChoice_Invalid=0 k_DOTASelectionPriorityChoice_Invalid value
     * @property {number} k_DOTASelectionPriorityChoice_FirstPick=1 k_DOTASelectionPriorityChoice_FirstPick value
     * @property {number} k_DOTASelectionPriorityChoice_SecondPick=2 k_DOTASelectionPriorityChoice_SecondPick value
     * @property {number} k_DOTASelectionPriorityChoice_Radiant=3 k_DOTASelectionPriorityChoice_Radiant value
     * @property {number} k_DOTASelectionPriorityChoice_Dire=4 k_DOTASelectionPriorityChoice_Dire value
     */
    $root.DOTASelectionPriorityChoice = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_DOTASelectionPriorityChoice_Invalid"] = 0;
        values[valuesById[1] = "k_DOTASelectionPriorityChoice_FirstPick"] = 1;
        values[valuesById[2] = "k_DOTASelectionPriorityChoice_SecondPick"] = 2;
        values[valuesById[3] = "k_DOTASelectionPriorityChoice_Radiant"] = 3;
        values[valuesById[4] = "k_DOTASelectionPriorityChoice_Dire"] = 4;
        return values;
    })();
    
    /**
     * DOTAMatchVote enum.
     * @exports DOTAMatchVote
     * @enum {number}
     * @property {number} DOTAMatchVote_INVALID=0 DOTAMatchVote_INVALID value
     * @property {number} DOTAMatchVote_POSITIVE=1 DOTAMatchVote_POSITIVE value
     * @property {number} DOTAMatchVote_NEGATIVE=2 DOTAMatchVote_NEGATIVE value
     */
    $root.DOTAMatchVote = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTAMatchVote_INVALID"] = 0;
        values[valuesById[1] = "DOTAMatchVote_POSITIVE"] = 1;
        values[valuesById[2] = "DOTAMatchVote_NEGATIVE"] = 2;
        return values;
    })();
    
    /**
     * DOTALobbyVisibility enum.
     * @exports DOTALobbyVisibility
     * @enum {number}
     * @property {number} DOTALobbyVisibility_Public=0 DOTALobbyVisibility_Public value
     * @property {number} DOTALobbyVisibility_Friends=1 DOTALobbyVisibility_Friends value
     * @property {number} DOTALobbyVisibility_Unlisted=2 DOTALobbyVisibility_Unlisted value
     */
    $root.DOTALobbyVisibility = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTALobbyVisibility_Public"] = 0;
        values[valuesById[1] = "DOTALobbyVisibility_Friends"] = 1;
        values[valuesById[2] = "DOTALobbyVisibility_Unlisted"] = 2;
        return values;
    })();
    
    /**
     * EDOTAPlayerMMRType enum.
     * @exports EDOTAPlayerMMRType
     * @enum {number}
     * @property {number} k_EDOTAPlayerMMRType_Invalid=0 k_EDOTAPlayerMMRType_Invalid value
     * @property {number} k_EDOTAPlayerMMRType_GeneralHidden=1 k_EDOTAPlayerMMRType_GeneralHidden value
     * @property {number} k_EDOTAPlayerMMRType_GeneralCompetitive=3 k_EDOTAPlayerMMRType_GeneralCompetitive value
     * @property {number} k_EDOTAPlayerMMRType_SoloCompetitive2019=4 k_EDOTAPlayerMMRType_SoloCompetitive2019 value
     * @property {number} k_EDOTAPlayerMMRType_1v1Competitive_UNUSED=5 k_EDOTAPlayerMMRType_1v1Competitive_UNUSED value
     * @property {number} k_EDOTAPlayerMMRType_GeneralSeasonalRanked=6 k_EDOTAPlayerMMRType_GeneralSeasonalRanked value
     * @property {number} k_EDOTAPlayerMMRType_SoloSeasonalRanked=7 k_EDOTAPlayerMMRType_SoloSeasonalRanked value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Core=8 k_EDOTAPlayerMMRType_Competitive_Core value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Support=9 k_EDOTAPlayerMMRType_Competitive_Support value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Classic=10 k_EDOTAPlayerMMRType_Competitive_Classic value
     */
    $root.EDOTAPlayerMMRType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTAPlayerMMRType_Invalid"] = 0;
        values[valuesById[1] = "k_EDOTAPlayerMMRType_GeneralHidden"] = 1;
        values[valuesById[3] = "k_EDOTAPlayerMMRType_GeneralCompetitive"] = 3;
        values[valuesById[4] = "k_EDOTAPlayerMMRType_SoloCompetitive2019"] = 4;
        values[valuesById[5] = "k_EDOTAPlayerMMRType_1v1Competitive_UNUSED"] = 5;
        values[valuesById[6] = "k_EDOTAPlayerMMRType_GeneralSeasonalRanked"] = 6;
        values[valuesById[7] = "k_EDOTAPlayerMMRType_SoloSeasonalRanked"] = 7;
        values[valuesById[8] = "k_EDOTAPlayerMMRType_Competitive_Core"] = 8;
        values[valuesById[9] = "k_EDOTAPlayerMMRType_Competitive_Support"] = 9;
        values[valuesById[10] = "k_EDOTAPlayerMMRType_Competitive_Classic"] = 10;
        return values;
    })();
    
    /**
     * EDOTAMMRBoostType enum.
     * @exports EDOTAMMRBoostType
     * @enum {number}
     * @property {number} k_EDOTAMMRBoostType_None=0 k_EDOTAMMRBoostType_None value
     * @property {number} k_EDOTAMMRBoostType_Leader=1 k_EDOTAMMRBoostType_Leader value
     * @property {number} k_EDOTAMMRBoostType_Follower=2 k_EDOTAMMRBoostType_Follower value
     */
    $root.EDOTAMMRBoostType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTAMMRBoostType_None"] = 0;
        values[valuesById[1] = "k_EDOTAMMRBoostType_Leader"] = 1;
        values[valuesById[2] = "k_EDOTAMMRBoostType_Follower"] = 2;
        return values;
    })();
    
    /**
     * MatchType enum.
     * @exports MatchType
     * @enum {number}
     * @property {number} MATCH_TYPE_CASUAL=0 MATCH_TYPE_CASUAL value
     * @property {number} MATCH_TYPE_COOP_BOTS=1 MATCH_TYPE_COOP_BOTS value
     * @property {number} MATCH_TYPE_LEGACY_TEAM_RANKED=2 MATCH_TYPE_LEGACY_TEAM_RANKED value
     * @property {number} MATCH_TYPE_LEGACY_SOLO_QUEUE=3 MATCH_TYPE_LEGACY_SOLO_QUEUE value
     * @property {number} MATCH_TYPE_COMPETITIVE=4 MATCH_TYPE_COMPETITIVE value
     * @property {number} MATCH_TYPE_WEEKEND_TOURNEY=5 MATCH_TYPE_WEEKEND_TOURNEY value
     * @property {number} MATCH_TYPE_CASUAL_1V1=6 MATCH_TYPE_CASUAL_1V1 value
     * @property {number} MATCH_TYPE_EVENT=7 MATCH_TYPE_EVENT value
     * @property {number} MATCH_TYPE_SEASONAL_RANKED=8 MATCH_TYPE_SEASONAL_RANKED value
     * @property {number} MATCH_TYPE_LOWPRI_DEPRECATED=9 MATCH_TYPE_LOWPRI_DEPRECATED value
     * @property {number} MATCH_TYPE_STEAM_GROUP=10 MATCH_TYPE_STEAM_GROUP value
     * @property {number} MATCH_TYPE_MUTATION=11 MATCH_TYPE_MUTATION value
     * @property {number} MATCH_TYPE_COACHES_CHALLENGE=12 MATCH_TYPE_COACHES_CHALLENGE value
     * @property {number} MATCH_TYPE_GAUNTLET=13 MATCH_TYPE_GAUNTLET value
     */
    $root.MatchType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MATCH_TYPE_CASUAL"] = 0;
        values[valuesById[1] = "MATCH_TYPE_COOP_BOTS"] = 1;
        values[valuesById[2] = "MATCH_TYPE_LEGACY_TEAM_RANKED"] = 2;
        values[valuesById[3] = "MATCH_TYPE_LEGACY_SOLO_QUEUE"] = 3;
        values[valuesById[4] = "MATCH_TYPE_COMPETITIVE"] = 4;
        values[valuesById[5] = "MATCH_TYPE_WEEKEND_TOURNEY"] = 5;
        values[valuesById[6] = "MATCH_TYPE_CASUAL_1V1"] = 6;
        values[valuesById[7] = "MATCH_TYPE_EVENT"] = 7;
        values[valuesById[8] = "MATCH_TYPE_SEASONAL_RANKED"] = 8;
        values[valuesById[9] = "MATCH_TYPE_LOWPRI_DEPRECATED"] = 9;
        values[valuesById[10] = "MATCH_TYPE_STEAM_GROUP"] = 10;
        values[valuesById[11] = "MATCH_TYPE_MUTATION"] = 11;
        values[valuesById[12] = "MATCH_TYPE_COACHES_CHALLENGE"] = 12;
        values[valuesById[13] = "MATCH_TYPE_GAUNTLET"] = 13;
        return values;
    })();
    
    /**
     * DOTABotDifficulty enum.
     * @exports DOTABotDifficulty
     * @enum {number}
     * @property {number} BOT_DIFFICULTY_PASSIVE=0 BOT_DIFFICULTY_PASSIVE value
     * @property {number} BOT_DIFFICULTY_EASY=1 BOT_DIFFICULTY_EASY value
     * @property {number} BOT_DIFFICULTY_MEDIUM=2 BOT_DIFFICULTY_MEDIUM value
     * @property {number} BOT_DIFFICULTY_HARD=3 BOT_DIFFICULTY_HARD value
     * @property {number} BOT_DIFFICULTY_UNFAIR=4 BOT_DIFFICULTY_UNFAIR value
     * @property {number} BOT_DIFFICULTY_INVALID=5 BOT_DIFFICULTY_INVALID value
     * @property {number} BOT_DIFFICULTY_EXTRA1=6 BOT_DIFFICULTY_EXTRA1 value
     * @property {number} BOT_DIFFICULTY_EXTRA2=7 BOT_DIFFICULTY_EXTRA2 value
     * @property {number} BOT_DIFFICULTY_EXTRA3=8 BOT_DIFFICULTY_EXTRA3 value
     */
    $root.DOTABotDifficulty = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BOT_DIFFICULTY_PASSIVE"] = 0;
        values[valuesById[1] = "BOT_DIFFICULTY_EASY"] = 1;
        values[valuesById[2] = "BOT_DIFFICULTY_MEDIUM"] = 2;
        values[valuesById[3] = "BOT_DIFFICULTY_HARD"] = 3;
        values[valuesById[4] = "BOT_DIFFICULTY_UNFAIR"] = 4;
        values[valuesById[5] = "BOT_DIFFICULTY_INVALID"] = 5;
        values[valuesById[6] = "BOT_DIFFICULTY_EXTRA1"] = 6;
        values[valuesById[7] = "BOT_DIFFICULTY_EXTRA2"] = 7;
        values[valuesById[8] = "BOT_DIFFICULTY_EXTRA3"] = 8;
        return values;
    })();
    
    /**
     * DOTA_BOT_MODE enum.
     * @exports DOTA_BOT_MODE
     * @enum {number}
     * @property {number} DOTA_BOT_MODE_NONE=0 DOTA_BOT_MODE_NONE value
     * @property {number} DOTA_BOT_MODE_LANING=1 DOTA_BOT_MODE_LANING value
     * @property {number} DOTA_BOT_MODE_ATTACK=2 DOTA_BOT_MODE_ATTACK value
     * @property {number} DOTA_BOT_MODE_ROAM=3 DOTA_BOT_MODE_ROAM value
     * @property {number} DOTA_BOT_MODE_RETREAT=4 DOTA_BOT_MODE_RETREAT value
     * @property {number} DOTA_BOT_MODE_SECRET_SHOP=5 DOTA_BOT_MODE_SECRET_SHOP value
     * @property {number} DOTA_BOT_MODE_SIDE_SHOP=6 DOTA_BOT_MODE_SIDE_SHOP value
     * @property {number} DOTA_BOT_MODE_RUNE=7 DOTA_BOT_MODE_RUNE value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_TOP=8 DOTA_BOT_MODE_PUSH_TOWER_TOP value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_MID=9 DOTA_BOT_MODE_PUSH_TOWER_MID value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_BOT=10 DOTA_BOT_MODE_PUSH_TOWER_BOT value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_TOP=11 DOTA_BOT_MODE_DEFEND_TOWER_TOP value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_MID=12 DOTA_BOT_MODE_DEFEND_TOWER_MID value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_BOT=13 DOTA_BOT_MODE_DEFEND_TOWER_BOT value
     * @property {number} DOTA_BOT_MODE_ASSEMBLE=14 DOTA_BOT_MODE_ASSEMBLE value
     * @property {number} DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS=15 DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS value
     * @property {number} DOTA_BOT_MODE_TEAM_ROAM=16 DOTA_BOT_MODE_TEAM_ROAM value
     * @property {number} DOTA_BOT_MODE_FARM=17 DOTA_BOT_MODE_FARM value
     * @property {number} DOTA_BOT_MODE_DEFEND_ALLY=18 DOTA_BOT_MODE_DEFEND_ALLY value
     * @property {number} DOTA_BOT_MODE_EVASIVE_MANEUVERS=19 DOTA_BOT_MODE_EVASIVE_MANEUVERS value
     * @property {number} DOTA_BOT_MODE_ROSHAN=20 DOTA_BOT_MODE_ROSHAN value
     * @property {number} DOTA_BOT_MODE_ITEM=21 DOTA_BOT_MODE_ITEM value
     * @property {number} DOTA_BOT_MODE_WARD=22 DOTA_BOT_MODE_WARD value
     * @property {number} DOTA_BOT_MODE_COMPANION=23 DOTA_BOT_MODE_COMPANION value
     * @property {number} DOTA_BOT_MODE_TUTORIAL_BOSS=24 DOTA_BOT_MODE_TUTORIAL_BOSS value
     * @property {number} DOTA_BOT_MODE_MINION=25 DOTA_BOT_MODE_MINION value
     */
    $root.DOTA_BOT_MODE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_BOT_MODE_NONE"] = 0;
        values[valuesById[1] = "DOTA_BOT_MODE_LANING"] = 1;
        values[valuesById[2] = "DOTA_BOT_MODE_ATTACK"] = 2;
        values[valuesById[3] = "DOTA_BOT_MODE_ROAM"] = 3;
        values[valuesById[4] = "DOTA_BOT_MODE_RETREAT"] = 4;
        values[valuesById[5] = "DOTA_BOT_MODE_SECRET_SHOP"] = 5;
        values[valuesById[6] = "DOTA_BOT_MODE_SIDE_SHOP"] = 6;
        values[valuesById[7] = "DOTA_BOT_MODE_RUNE"] = 7;
        values[valuesById[8] = "DOTA_BOT_MODE_PUSH_TOWER_TOP"] = 8;
        values[valuesById[9] = "DOTA_BOT_MODE_PUSH_TOWER_MID"] = 9;
        values[valuesById[10] = "DOTA_BOT_MODE_PUSH_TOWER_BOT"] = 10;
        values[valuesById[11] = "DOTA_BOT_MODE_DEFEND_TOWER_TOP"] = 11;
        values[valuesById[12] = "DOTA_BOT_MODE_DEFEND_TOWER_MID"] = 12;
        values[valuesById[13] = "DOTA_BOT_MODE_DEFEND_TOWER_BOT"] = 13;
        values[valuesById[14] = "DOTA_BOT_MODE_ASSEMBLE"] = 14;
        values[valuesById[15] = "DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS"] = 15;
        values[valuesById[16] = "DOTA_BOT_MODE_TEAM_ROAM"] = 16;
        values[valuesById[17] = "DOTA_BOT_MODE_FARM"] = 17;
        values[valuesById[18] = "DOTA_BOT_MODE_DEFEND_ALLY"] = 18;
        values[valuesById[19] = "DOTA_BOT_MODE_EVASIVE_MANEUVERS"] = 19;
        values[valuesById[20] = "DOTA_BOT_MODE_ROSHAN"] = 20;
        values[valuesById[21] = "DOTA_BOT_MODE_ITEM"] = 21;
        values[valuesById[22] = "DOTA_BOT_MODE_WARD"] = 22;
        values[valuesById[23] = "DOTA_BOT_MODE_COMPANION"] = 23;
        values[valuesById[24] = "DOTA_BOT_MODE_TUTORIAL_BOSS"] = 24;
        values[valuesById[25] = "DOTA_BOT_MODE_MINION"] = 25;
        return values;
    })();
    
    /**
     * MatchLanguages enum.
     * @exports MatchLanguages
     * @enum {number}
     * @property {number} MATCH_LANGUAGE_INVALID=0 MATCH_LANGUAGE_INVALID value
     * @property {number} MATCH_LANGUAGE_ENGLISH=1 MATCH_LANGUAGE_ENGLISH value
     * @property {number} MATCH_LANGUAGE_RUSSIAN=2 MATCH_LANGUAGE_RUSSIAN value
     * @property {number} MATCH_LANGUAGE_CHINESE=3 MATCH_LANGUAGE_CHINESE value
     * @property {number} MATCH_LANGUAGE_KOREAN=4 MATCH_LANGUAGE_KOREAN value
     * @property {number} MATCH_LANGUAGE_SPANISH=5 MATCH_LANGUAGE_SPANISH value
     * @property {number} MATCH_LANGUAGE_PORTUGUESE=6 MATCH_LANGUAGE_PORTUGUESE value
     * @property {number} MATCH_LANGUAGE_ENGLISH2=7 MATCH_LANGUAGE_ENGLISH2 value
     */
    $root.MatchLanguages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MATCH_LANGUAGE_INVALID"] = 0;
        values[valuesById[1] = "MATCH_LANGUAGE_ENGLISH"] = 1;
        values[valuesById[2] = "MATCH_LANGUAGE_RUSSIAN"] = 2;
        values[valuesById[3] = "MATCH_LANGUAGE_CHINESE"] = 3;
        values[valuesById[4] = "MATCH_LANGUAGE_KOREAN"] = 4;
        values[valuesById[5] = "MATCH_LANGUAGE_SPANISH"] = 5;
        values[valuesById[6] = "MATCH_LANGUAGE_PORTUGUESE"] = 6;
        values[valuesById[7] = "MATCH_LANGUAGE_ENGLISH2"] = 7;
        return values;
    })();
    
    /**
     * ETourneyQueueDeadlineState enum.
     * @exports ETourneyQueueDeadlineState
     * @enum {number}
     * @property {number} k_ETourneyQueueDeadlineState_Normal=0 k_ETourneyQueueDeadlineState_Normal value
     * @property {number} k_ETourneyQueueDeadlineState_Missed=1 k_ETourneyQueueDeadlineState_Missed value
     * @property {number} k_ETourneyQueueDeadlineState_ExpiredOK=2 k_ETourneyQueueDeadlineState_ExpiredOK value
     * @property {number} k_ETourneyQueueDeadlineState_SeekingBye=3 k_ETourneyQueueDeadlineState_SeekingBye value
     * @property {number} k_ETourneyQueueDeadlineState_EligibleForRefund=4 k_ETourneyQueueDeadlineState_EligibleForRefund value
     * @property {number} k_ETourneyQueueDeadlineState_NA=-1 k_ETourneyQueueDeadlineState_NA value
     * @property {number} k_ETourneyQueueDeadlineState_ExpiringSoon=101 k_ETourneyQueueDeadlineState_ExpiringSoon value
     */
    $root.ETourneyQueueDeadlineState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_ETourneyQueueDeadlineState_Normal"] = 0;
        values[valuesById[1] = "k_ETourneyQueueDeadlineState_Missed"] = 1;
        values[valuesById[2] = "k_ETourneyQueueDeadlineState_ExpiredOK"] = 2;
        values[valuesById[3] = "k_ETourneyQueueDeadlineState_SeekingBye"] = 3;
        values[valuesById[4] = "k_ETourneyQueueDeadlineState_EligibleForRefund"] = 4;
        values[valuesById[-1] = "k_ETourneyQueueDeadlineState_NA"] = -1;
        values[valuesById[101] = "k_ETourneyQueueDeadlineState_ExpiringSoon"] = 101;
        return values;
    })();
    
    /**
     * EMatchOutcome enum.
     * @exports EMatchOutcome
     * @enum {number}
     * @property {number} k_EMatchOutcome_Unknown=0 k_EMatchOutcome_Unknown value
     * @property {number} k_EMatchOutcome_RadVictory=2 k_EMatchOutcome_RadVictory value
     * @property {number} k_EMatchOutcome_DireVictory=3 k_EMatchOutcome_DireVictory value
     * @property {number} k_EMatchOutcome_NotScored_PoorNetworkConditions=64 k_EMatchOutcome_NotScored_PoorNetworkConditions value
     * @property {number} k_EMatchOutcome_NotScored_Leaver=65 k_EMatchOutcome_NotScored_Leaver value
     * @property {number} k_EMatchOutcome_NotScored_ServerCrash=66 k_EMatchOutcome_NotScored_ServerCrash value
     * @property {number} k_EMatchOutcome_NotScored_NeverStarted=67 k_EMatchOutcome_NotScored_NeverStarted value
     * @property {number} k_EMatchOutcome_NotScored_Canceled=68 k_EMatchOutcome_NotScored_Canceled value
     * @property {number} k_EMatchOutcome_NotScored_Suspicious=69 k_EMatchOutcome_NotScored_Suspicious value
     */
    $root.EMatchOutcome = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EMatchOutcome_Unknown"] = 0;
        values[valuesById[2] = "k_EMatchOutcome_RadVictory"] = 2;
        values[valuesById[3] = "k_EMatchOutcome_DireVictory"] = 3;
        values[valuesById[64] = "k_EMatchOutcome_NotScored_PoorNetworkConditions"] = 64;
        values[valuesById[65] = "k_EMatchOutcome_NotScored_Leaver"] = 65;
        values[valuesById[66] = "k_EMatchOutcome_NotScored_ServerCrash"] = 66;
        values[valuesById[67] = "k_EMatchOutcome_NotScored_NeverStarted"] = 67;
        values[valuesById[68] = "k_EMatchOutcome_NotScored_Canceled"] = 68;
        values[valuesById[69] = "k_EMatchOutcome_NotScored_Suspicious"] = 69;
        return values;
    })();
    
    /**
     * ELaneType enum.
     * @exports ELaneType
     * @enum {number}
     * @property {number} LANE_TYPE_UNKNOWN=0 LANE_TYPE_UNKNOWN value
     * @property {number} LANE_TYPE_SAFE=1 LANE_TYPE_SAFE value
     * @property {number} LANE_TYPE_OFF=2 LANE_TYPE_OFF value
     * @property {number} LANE_TYPE_MID=3 LANE_TYPE_MID value
     * @property {number} LANE_TYPE_JUNGLE=4 LANE_TYPE_JUNGLE value
     * @property {number} LANE_TYPE_ROAM=5 LANE_TYPE_ROAM value
     */
    $root.ELaneType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LANE_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "LANE_TYPE_SAFE"] = 1;
        values[valuesById[2] = "LANE_TYPE_OFF"] = 2;
        values[valuesById[3] = "LANE_TYPE_MID"] = 3;
        values[valuesById[4] = "LANE_TYPE_JUNGLE"] = 4;
        values[valuesById[5] = "LANE_TYPE_ROAM"] = 5;
        return values;
    })();
    
    /**
     * EBadgeType enum.
     * @exports EBadgeType
     * @enum {number}
     * @property {number} k_EBadgeType_TI7_Midweek=1 k_EBadgeType_TI7_Midweek value
     * @property {number} k_EBadgeType_TI7_Finals=2 k_EBadgeType_TI7_Finals value
     * @property {number} k_EBadgeType_TI7_AllEvent=3 k_EBadgeType_TI7_AllEvent value
     * @property {number} k_EBadgeType_TI8_Midweek=4 k_EBadgeType_TI8_Midweek value
     * @property {number} k_EBadgeType_TI8_Finals=5 k_EBadgeType_TI8_Finals value
     * @property {number} k_EBadgeType_TI8_AllEvent=6 k_EBadgeType_TI8_AllEvent value
     */
    $root.EBadgeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "k_EBadgeType_TI7_Midweek"] = 1;
        values[valuesById[2] = "k_EBadgeType_TI7_Finals"] = 2;
        values[valuesById[3] = "k_EBadgeType_TI7_AllEvent"] = 3;
        values[valuesById[4] = "k_EBadgeType_TI8_Midweek"] = 4;
        values[valuesById[5] = "k_EBadgeType_TI8_Finals"] = 5;
        values[valuesById[6] = "k_EBadgeType_TI8_AllEvent"] = 6;
        return values;
    })();
    
    /**
     * ELeagueStatus enum.
     * @exports ELeagueStatus
     * @enum {number}
     * @property {number} LEAGUE_STATUS_UNSET=0 LEAGUE_STATUS_UNSET value
     * @property {number} LEAGUE_STATUS_UNSUBMITTED=1 LEAGUE_STATUS_UNSUBMITTED value
     * @property {number} LEAGUE_STATUS_SUBMITTED=2 LEAGUE_STATUS_SUBMITTED value
     * @property {number} LEAGUE_STATUS_ACCEPTED=3 LEAGUE_STATUS_ACCEPTED value
     * @property {number} LEAGUE_STATUS_REJECTED=4 LEAGUE_STATUS_REJECTED value
     * @property {number} LEAGUE_STATUS_CONCLUDED=5 LEAGUE_STATUS_CONCLUDED value
     * @property {number} LEAGUE_STATUS_DELETED=6 LEAGUE_STATUS_DELETED value
     */
    $root.ELeagueStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_STATUS_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_STATUS_UNSUBMITTED"] = 1;
        values[valuesById[2] = "LEAGUE_STATUS_SUBMITTED"] = 2;
        values[valuesById[3] = "LEAGUE_STATUS_ACCEPTED"] = 3;
        values[valuesById[4] = "LEAGUE_STATUS_REJECTED"] = 4;
        values[valuesById[5] = "LEAGUE_STATUS_CONCLUDED"] = 5;
        values[valuesById[6] = "LEAGUE_STATUS_DELETED"] = 6;
        return values;
    })();
    
    /**
     * ELeagueRegion enum.
     * @exports ELeagueRegion
     * @enum {number}
     * @property {number} LEAGUE_REGION_UNSET=0 LEAGUE_REGION_UNSET value
     * @property {number} LEAGUE_REGION_NA=1 LEAGUE_REGION_NA value
     * @property {number} LEAGUE_REGION_SA=2 LEAGUE_REGION_SA value
     * @property {number} LEAGUE_REGION_EUROPE=3 LEAGUE_REGION_EUROPE value
     * @property {number} LEAGUE_REGION_CIS=4 LEAGUE_REGION_CIS value
     * @property {number} LEAGUE_REGION_CHINA=5 LEAGUE_REGION_CHINA value
     * @property {number} LEAGUE_REGION_SEA=6 LEAGUE_REGION_SEA value
     */
    $root.ELeagueRegion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_REGION_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_REGION_NA"] = 1;
        values[valuesById[2] = "LEAGUE_REGION_SA"] = 2;
        values[valuesById[3] = "LEAGUE_REGION_EUROPE"] = 3;
        values[valuesById[4] = "LEAGUE_REGION_CIS"] = 4;
        values[valuesById[5] = "LEAGUE_REGION_CHINA"] = 5;
        values[valuesById[6] = "LEAGUE_REGION_SEA"] = 6;
        return values;
    })();
    
    /**
     * ELeagueTier enum.
     * @exports ELeagueTier
     * @enum {number}
     * @property {number} LEAGUE_TIER_UNSET=0 LEAGUE_TIER_UNSET value
     * @property {number} LEAGUE_TIER_AMATEUR=1 LEAGUE_TIER_AMATEUR value
     * @property {number} LEAGUE_TIER_PROFESSIONAL=2 LEAGUE_TIER_PROFESSIONAL value
     * @property {number} LEAGUE_TIER_MINOR=3 LEAGUE_TIER_MINOR value
     * @property {number} LEAGUE_TIER_MAJOR=4 LEAGUE_TIER_MAJOR value
     * @property {number} LEAGUE_TIER_INTERNATIONAL=5 LEAGUE_TIER_INTERNATIONAL value
     * @property {number} LEAGUE_TIER_DPC_QUALIFIER=6 LEAGUE_TIER_DPC_QUALIFIER value
     */
    $root.ELeagueTier = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_TIER_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_TIER_AMATEUR"] = 1;
        values[valuesById[2] = "LEAGUE_TIER_PROFESSIONAL"] = 2;
        values[valuesById[3] = "LEAGUE_TIER_MINOR"] = 3;
        values[valuesById[4] = "LEAGUE_TIER_MAJOR"] = 4;
        values[valuesById[5] = "LEAGUE_TIER_INTERNATIONAL"] = 5;
        values[valuesById[6] = "LEAGUE_TIER_DPC_QUALIFIER"] = 6;
        return values;
    })();
    
    /**
     * ELeagueTierCategory enum.
     * @exports ELeagueTierCategory
     * @enum {number}
     * @property {number} LEAGUE_TIER_CATEGORY_AMATEUR=1 LEAGUE_TIER_CATEGORY_AMATEUR value
     * @property {number} LEAGUE_TIER_CATEGORY_PROFESSIONAL=2 LEAGUE_TIER_CATEGORY_PROFESSIONAL value
     * @property {number} LEAGUE_TIER_CATEGORY_DPC=3 LEAGUE_TIER_CATEGORY_DPC value
     */
    $root.ELeagueTierCategory = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "LEAGUE_TIER_CATEGORY_AMATEUR"] = 1;
        values[valuesById[2] = "LEAGUE_TIER_CATEGORY_PROFESSIONAL"] = 2;
        values[valuesById[3] = "LEAGUE_TIER_CATEGORY_DPC"] = 3;
        return values;
    })();
    
    /**
     * ELeagueFlags enum.
     * @exports ELeagueFlags
     * @enum {number}
     * @property {number} LEAGUE_FLAGS_NONE=0 LEAGUE_FLAGS_NONE value
     * @property {number} LEAGUE_ACCEPTED_AGREEMENT=1 LEAGUE_ACCEPTED_AGREEMENT value
     * @property {number} LEAGUE_PAYMENT_EMAIL_SENT=2 LEAGUE_PAYMENT_EMAIL_SENT value
     * @property {number} LEAGUE_COMPENDIUM_ALLOWED=4 LEAGUE_COMPENDIUM_ALLOWED value
     * @property {number} LEAGUE_COMPENDIUM_PUBLIC=8 LEAGUE_COMPENDIUM_PUBLIC value
     */
    $root.ELeagueFlags = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_FLAGS_NONE"] = 0;
        values[valuesById[1] = "LEAGUE_ACCEPTED_AGREEMENT"] = 1;
        values[valuesById[2] = "LEAGUE_PAYMENT_EMAIL_SENT"] = 2;
        values[valuesById[4] = "LEAGUE_COMPENDIUM_ALLOWED"] = 4;
        values[valuesById[8] = "LEAGUE_COMPENDIUM_PUBLIC"] = 8;
        return values;
    })();
    
    /**
     * ELeagueBroadcastProvider enum.
     * @exports ELeagueBroadcastProvider
     * @enum {number}
     * @property {number} LEAGUE_BROADCAST_UNKNOWN=0 LEAGUE_BROADCAST_UNKNOWN value
     * @property {number} LEAGUE_BROADCAST_STEAM=1 LEAGUE_BROADCAST_STEAM value
     * @property {number} LEAGUE_BROADCAST_TWITCH=2 LEAGUE_BROADCAST_TWITCH value
     * @property {number} LEAGUE_BROADCAST_YOUTUBE=3 LEAGUE_BROADCAST_YOUTUBE value
     * @property {number} LEAGUE_BROADCAST_OTHER=100 LEAGUE_BROADCAST_OTHER value
     */
    $root.ELeagueBroadcastProvider = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_BROADCAST_UNKNOWN"] = 0;
        values[valuesById[1] = "LEAGUE_BROADCAST_STEAM"] = 1;
        values[valuesById[2] = "LEAGUE_BROADCAST_TWITCH"] = 2;
        values[valuesById[3] = "LEAGUE_BROADCAST_YOUTUBE"] = 3;
        values[valuesById[100] = "LEAGUE_BROADCAST_OTHER"] = 100;
        return values;
    })();
    
    /**
     * ELeaguePhase enum.
     * @exports ELeaguePhase
     * @enum {number}
     * @property {number} LEAGUE_PHASE_UNSET=0 LEAGUE_PHASE_UNSET value
     * @property {number} LEAGUE_PHASE_REGIONAL_QUALIFIER=1 LEAGUE_PHASE_REGIONAL_QUALIFIER value
     * @property {number} LEAGUE_PHASE_GROUP_STAGE=2 LEAGUE_PHASE_GROUP_STAGE value
     * @property {number} LEAGUE_PHASE_MAIN_EVENT=3 LEAGUE_PHASE_MAIN_EVENT value
     */
    $root.ELeaguePhase = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_PHASE_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_PHASE_REGIONAL_QUALIFIER"] = 1;
        values[valuesById[2] = "LEAGUE_PHASE_GROUP_STAGE"] = 2;
        values[valuesById[3] = "LEAGUE_PHASE_MAIN_EVENT"] = 3;
        return values;
    })();
    
    /**
     * ELeagueAuditAction enum.
     * @exports ELeagueAuditAction
     * @enum {number}
     * @property {number} LEAGUE_AUDIT_ACTION_INVALID=0 LEAGUE_AUDIT_ACTION_INVALID value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_CREATE=1 LEAGUE_AUDIT_ACTION_LEAGUE_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_EDIT=2 LEAGUE_AUDIT_ACTION_LEAGUE_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_DELETE=3 LEAGUE_AUDIT_ACTION_LEAGUE_DELETE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD=4 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE=5 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE=6 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD=7 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE=8 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED=9 LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED=10 LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED=11 LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL=12 LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM=13 LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM=14 LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START=15 LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END=16 LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM=17 LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM=18 LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED=19 LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT=20 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE=100 LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY=101 LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM=102 LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM=103 LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING=104 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT=105 LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE=106 LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED=107 LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING=108 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING=109 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_CREATE=200 LEAGUE_AUDIT_ACTION_NODE_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_DESTROY=201 LEAGUE_AUDIT_ACTION_NODE_DESTROY value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE=202 LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_TEAM=203 LEAGUE_AUDIT_ACTION_NODE_SET_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID=204 LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING=205 LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_TIME=206 LEAGUE_AUDIT_ACTION_NODE_SET_TIME value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED=207 LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_COMPLETED=208 LEAGUE_AUDIT_ACTION_NODE_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_EDIT=209 LEAGUE_AUDIT_ACTION_NODE_EDIT value
     */
    $root.ELeagueAuditAction = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_AUDIT_ACTION_INVALID"] = 0;
        values[valuesById[1] = "LEAGUE_AUDIT_ACTION_LEAGUE_CREATE"] = 1;
        values[valuesById[2] = "LEAGUE_AUDIT_ACTION_LEAGUE_EDIT"] = 2;
        values[valuesById[3] = "LEAGUE_AUDIT_ACTION_LEAGUE_DELETE"] = 3;
        values[valuesById[4] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD"] = 4;
        values[valuesById[5] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE"] = 5;
        values[valuesById[6] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE"] = 6;
        values[valuesById[7] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD"] = 7;
        values[valuesById[8] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE"] = 8;
        values[valuesById[9] = "LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED"] = 9;
        values[valuesById[10] = "LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED"] = 10;
        values[valuesById[11] = "LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED"] = 11;
        values[valuesById[12] = "LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL"] = 12;
        values[valuesById[13] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM"] = 13;
        values[valuesById[14] = "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM"] = 14;
        values[valuesById[15] = "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START"] = 15;
        values[valuesById[16] = "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END"] = 16;
        values[valuesById[17] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM"] = 17;
        values[valuesById[18] = "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM"] = 18;
        values[valuesById[19] = "LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED"] = 19;
        values[valuesById[20] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT"] = 20;
        values[valuesById[100] = "LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE"] = 100;
        values[valuesById[101] = "LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY"] = 101;
        values[valuesById[102] = "LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM"] = 102;
        values[valuesById[103] = "LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM"] = 103;
        values[valuesById[104] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING"] = 104;
        values[valuesById[105] = "LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT"] = 105;
        values[valuesById[106] = "LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE"] = 106;
        values[valuesById[107] = "LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED"] = 107;
        values[valuesById[108] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING"] = 108;
        values[valuesById[109] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING"] = 109;
        values[valuesById[200] = "LEAGUE_AUDIT_ACTION_NODE_CREATE"] = 200;
        values[valuesById[201] = "LEAGUE_AUDIT_ACTION_NODE_DESTROY"] = 201;
        values[valuesById[202] = "LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE"] = 202;
        values[valuesById[203] = "LEAGUE_AUDIT_ACTION_NODE_SET_TEAM"] = 203;
        values[valuesById[204] = "LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID"] = 204;
        values[valuesById[205] = "LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING"] = 205;
        values[valuesById[206] = "LEAGUE_AUDIT_ACTION_NODE_SET_TIME"] = 206;
        values[valuesById[207] = "LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED"] = 207;
        values[valuesById[208] = "LEAGUE_AUDIT_ACTION_NODE_COMPLETED"] = 208;
        values[valuesById[209] = "LEAGUE_AUDIT_ACTION_NODE_EDIT"] = 209;
        return values;
    })();
    
    /**
     * DOTA_COMBATLOG_TYPES enum.
     * @exports DOTA_COMBATLOG_TYPES
     * @enum {number}
     * @property {number} DOTA_COMBATLOG_INVALID=-1 DOTA_COMBATLOG_INVALID value
     * @property {number} DOTA_COMBATLOG_DAMAGE=0 DOTA_COMBATLOG_DAMAGE value
     * @property {number} DOTA_COMBATLOG_HEAL=1 DOTA_COMBATLOG_HEAL value
     * @property {number} DOTA_COMBATLOG_MODIFIER_ADD=2 DOTA_COMBATLOG_MODIFIER_ADD value
     * @property {number} DOTA_COMBATLOG_MODIFIER_REMOVE=3 DOTA_COMBATLOG_MODIFIER_REMOVE value
     * @property {number} DOTA_COMBATLOG_DEATH=4 DOTA_COMBATLOG_DEATH value
     * @property {number} DOTA_COMBATLOG_ABILITY=5 DOTA_COMBATLOG_ABILITY value
     * @property {number} DOTA_COMBATLOG_ITEM=6 DOTA_COMBATLOG_ITEM value
     * @property {number} DOTA_COMBATLOG_LOCATION=7 DOTA_COMBATLOG_LOCATION value
     * @property {number} DOTA_COMBATLOG_GOLD=8 DOTA_COMBATLOG_GOLD value
     * @property {number} DOTA_COMBATLOG_GAME_STATE=9 DOTA_COMBATLOG_GAME_STATE value
     * @property {number} DOTA_COMBATLOG_XP=10 DOTA_COMBATLOG_XP value
     * @property {number} DOTA_COMBATLOG_PURCHASE=11 DOTA_COMBATLOG_PURCHASE value
     * @property {number} DOTA_COMBATLOG_BUYBACK=12 DOTA_COMBATLOG_BUYBACK value
     * @property {number} DOTA_COMBATLOG_ABILITY_TRIGGER=13 DOTA_COMBATLOG_ABILITY_TRIGGER value
     * @property {number} DOTA_COMBATLOG_PLAYERSTATS=14 DOTA_COMBATLOG_PLAYERSTATS value
     * @property {number} DOTA_COMBATLOG_MULTIKILL=15 DOTA_COMBATLOG_MULTIKILL value
     * @property {number} DOTA_COMBATLOG_KILLSTREAK=16 DOTA_COMBATLOG_KILLSTREAK value
     * @property {number} DOTA_COMBATLOG_TEAM_BUILDING_KILL=17 DOTA_COMBATLOG_TEAM_BUILDING_KILL value
     * @property {number} DOTA_COMBATLOG_FIRST_BLOOD=18 DOTA_COMBATLOG_FIRST_BLOOD value
     * @property {number} DOTA_COMBATLOG_MODIFIER_STACK_EVENT=19 DOTA_COMBATLOG_MODIFIER_STACK_EVENT value
     * @property {number} DOTA_COMBATLOG_NEUTRAL_CAMP_STACK=20 DOTA_COMBATLOG_NEUTRAL_CAMP_STACK value
     * @property {number} DOTA_COMBATLOG_PICKUP_RUNE=21 DOTA_COMBATLOG_PICKUP_RUNE value
     * @property {number} DOTA_COMBATLOG_REVEALED_INVISIBLE=22 DOTA_COMBATLOG_REVEALED_INVISIBLE value
     * @property {number} DOTA_COMBATLOG_HERO_SAVED=23 DOTA_COMBATLOG_HERO_SAVED value
     * @property {number} DOTA_COMBATLOG_MANA_RESTORED=24 DOTA_COMBATLOG_MANA_RESTORED value
     * @property {number} DOTA_COMBATLOG_HERO_LEVELUP=25 DOTA_COMBATLOG_HERO_LEVELUP value
     * @property {number} DOTA_COMBATLOG_BOTTLE_HEAL_ALLY=26 DOTA_COMBATLOG_BOTTLE_HEAL_ALLY value
     * @property {number} DOTA_COMBATLOG_ENDGAME_STATS=27 DOTA_COMBATLOG_ENDGAME_STATS value
     * @property {number} DOTA_COMBATLOG_INTERRUPT_CHANNEL=28 DOTA_COMBATLOG_INTERRUPT_CHANNEL value
     * @property {number} DOTA_COMBATLOG_ALLIED_GOLD=29 DOTA_COMBATLOG_ALLIED_GOLD value
     * @property {number} DOTA_COMBATLOG_AEGIS_TAKEN=30 DOTA_COMBATLOG_AEGIS_TAKEN value
     * @property {number} DOTA_COMBATLOG_MANA_DAMAGE=31 DOTA_COMBATLOG_MANA_DAMAGE value
     * @property {number} DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED=32 DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED value
     * @property {number} DOTA_COMBATLOG_UNIT_SUMMONED=33 DOTA_COMBATLOG_UNIT_SUMMONED value
     * @property {number} DOTA_COMBATLOG_ATTACK_EVADE=34 DOTA_COMBATLOG_ATTACK_EVADE value
     * @property {number} DOTA_COMBATLOG_TREE_CUT=35 DOTA_COMBATLOG_TREE_CUT value
     * @property {number} DOTA_COMBATLOG_SUCCESSFUL_SCAN=36 DOTA_COMBATLOG_SUCCESSFUL_SCAN value
     * @property {number} DOTA_COMBATLOG_END_KILLSTREAK=37 DOTA_COMBATLOG_END_KILLSTREAK value
     * @property {number} DOTA_COMBATLOG_BLOODSTONE_CHARGE=38 DOTA_COMBATLOG_BLOODSTONE_CHARGE value
     * @property {number} DOTA_COMBATLOG_CRITICAL_DAMAGE=39 DOTA_COMBATLOG_CRITICAL_DAMAGE value
     * @property {number} DOTA_COMBATLOG_SPELL_ABSORB=40 DOTA_COMBATLOG_SPELL_ABSORB value
     * @property {number} DOTA_COMBATLOG_UNIT_TELEPORTED=41 DOTA_COMBATLOG_UNIT_TELEPORTED value
     * @property {number} DOTA_COMBATLOG_KILL_EATER_EVENT=42 DOTA_COMBATLOG_KILL_EATER_EVENT value
     */
    $root.DOTA_COMBATLOG_TYPES = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "DOTA_COMBATLOG_INVALID"] = -1;
        values[valuesById[0] = "DOTA_COMBATLOG_DAMAGE"] = 0;
        values[valuesById[1] = "DOTA_COMBATLOG_HEAL"] = 1;
        values[valuesById[2] = "DOTA_COMBATLOG_MODIFIER_ADD"] = 2;
        values[valuesById[3] = "DOTA_COMBATLOG_MODIFIER_REMOVE"] = 3;
        values[valuesById[4] = "DOTA_COMBATLOG_DEATH"] = 4;
        values[valuesById[5] = "DOTA_COMBATLOG_ABILITY"] = 5;
        values[valuesById[6] = "DOTA_COMBATLOG_ITEM"] = 6;
        values[valuesById[7] = "DOTA_COMBATLOG_LOCATION"] = 7;
        values[valuesById[8] = "DOTA_COMBATLOG_GOLD"] = 8;
        values[valuesById[9] = "DOTA_COMBATLOG_GAME_STATE"] = 9;
        values[valuesById[10] = "DOTA_COMBATLOG_XP"] = 10;
        values[valuesById[11] = "DOTA_COMBATLOG_PURCHASE"] = 11;
        values[valuesById[12] = "DOTA_COMBATLOG_BUYBACK"] = 12;
        values[valuesById[13] = "DOTA_COMBATLOG_ABILITY_TRIGGER"] = 13;
        values[valuesById[14] = "DOTA_COMBATLOG_PLAYERSTATS"] = 14;
        values[valuesById[15] = "DOTA_COMBATLOG_MULTIKILL"] = 15;
        values[valuesById[16] = "DOTA_COMBATLOG_KILLSTREAK"] = 16;
        values[valuesById[17] = "DOTA_COMBATLOG_TEAM_BUILDING_KILL"] = 17;
        values[valuesById[18] = "DOTA_COMBATLOG_FIRST_BLOOD"] = 18;
        values[valuesById[19] = "DOTA_COMBATLOG_MODIFIER_STACK_EVENT"] = 19;
        values[valuesById[20] = "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK"] = 20;
        values[valuesById[21] = "DOTA_COMBATLOG_PICKUP_RUNE"] = 21;
        values[valuesById[22] = "DOTA_COMBATLOG_REVEALED_INVISIBLE"] = 22;
        values[valuesById[23] = "DOTA_COMBATLOG_HERO_SAVED"] = 23;
        values[valuesById[24] = "DOTA_COMBATLOG_MANA_RESTORED"] = 24;
        values[valuesById[25] = "DOTA_COMBATLOG_HERO_LEVELUP"] = 25;
        values[valuesById[26] = "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY"] = 26;
        values[valuesById[27] = "DOTA_COMBATLOG_ENDGAME_STATS"] = 27;
        values[valuesById[28] = "DOTA_COMBATLOG_INTERRUPT_CHANNEL"] = 28;
        values[valuesById[29] = "DOTA_COMBATLOG_ALLIED_GOLD"] = 29;
        values[valuesById[30] = "DOTA_COMBATLOG_AEGIS_TAKEN"] = 30;
        values[valuesById[31] = "DOTA_COMBATLOG_MANA_DAMAGE"] = 31;
        values[valuesById[32] = "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED"] = 32;
        values[valuesById[33] = "DOTA_COMBATLOG_UNIT_SUMMONED"] = 33;
        values[valuesById[34] = "DOTA_COMBATLOG_ATTACK_EVADE"] = 34;
        values[valuesById[35] = "DOTA_COMBATLOG_TREE_CUT"] = 35;
        values[valuesById[36] = "DOTA_COMBATLOG_SUCCESSFUL_SCAN"] = 36;
        values[valuesById[37] = "DOTA_COMBATLOG_END_KILLSTREAK"] = 37;
        values[valuesById[38] = "DOTA_COMBATLOG_BLOODSTONE_CHARGE"] = 38;
        values[valuesById[39] = "DOTA_COMBATLOG_CRITICAL_DAMAGE"] = 39;
        values[valuesById[40] = "DOTA_COMBATLOG_SPELL_ABSORB"] = 40;
        values[valuesById[41] = "DOTA_COMBATLOG_UNIT_TELEPORTED"] = 41;
        values[valuesById[42] = "DOTA_COMBATLOG_KILL_EATER_EVENT"] = 42;
        return values;
    })();
    
    /**
     * EDPCFavoriteType enum.
     * @exports EDPCFavoriteType
     * @enum {number}
     * @property {number} FAVORITE_TYPE_ALL=0 FAVORITE_TYPE_ALL value
     * @property {number} FAVORITE_TYPE_PLAYER=1 FAVORITE_TYPE_PLAYER value
     * @property {number} FAVORITE_TYPE_TEAM=2 FAVORITE_TYPE_TEAM value
     * @property {number} FAVORITE_TYPE_LEAGUE=3 FAVORITE_TYPE_LEAGUE value
     */
    $root.EDPCFavoriteType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FAVORITE_TYPE_ALL"] = 0;
        values[valuesById[1] = "FAVORITE_TYPE_PLAYER"] = 1;
        values[valuesById[2] = "FAVORITE_TYPE_TEAM"] = 2;
        values[valuesById[3] = "FAVORITE_TYPE_LEAGUE"] = 3;
        return values;
    })();
    
    /**
     * EDPCPushNotification enum.
     * @exports EDPCPushNotification
     * @enum {number}
     * @property {number} DPC_PUSH_NOTIFICATION_MATCH_STARTING=1 DPC_PUSH_NOTIFICATION_MATCH_STARTING value
     * @property {number} DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM=10 DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM value
     * @property {number} DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM=11 DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM value
     * @property {number} DPC_PUSH_NOTIFICATION_LEAGUE_RESULT=20 DPC_PUSH_NOTIFICATION_LEAGUE_RESULT value
     * @property {number} DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE=30 DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE value
     * @property {number} DPC_PUSH_NOTIFICATION_PREDICTION_RESULT=31 DPC_PUSH_NOTIFICATION_PREDICTION_RESULT value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED=40 DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY=41 DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS=42 DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS value
     */
    $root.EDPCPushNotification = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "DPC_PUSH_NOTIFICATION_MATCH_STARTING"] = 1;
        values[valuesById[10] = "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM"] = 10;
        values[valuesById[11] = "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM"] = 11;
        values[valuesById[20] = "DPC_PUSH_NOTIFICATION_LEAGUE_RESULT"] = 20;
        values[valuesById[30] = "DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE"] = 30;
        values[valuesById[31] = "DPC_PUSH_NOTIFICATION_PREDICTION_RESULT"] = 31;
        values[valuesById[40] = "DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED"] = 40;
        values[valuesById[41] = "DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY"] = 41;
        values[valuesById[42] = "DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS"] = 42;
        return values;
    })();
    
    /**
     * EEventActionScoreMode enum.
     * @exports EEventActionScoreMode
     * @enum {number}
     * @property {number} k_eEventActionScoreMode_Add=0 k_eEventActionScoreMode_Add value
     * @property {number} k_eEventActionScoreMode_Min=1 k_eEventActionScoreMode_Min value
     */
    $root.EEventActionScoreMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_eEventActionScoreMode_Add"] = 0;
        values[valuesById[1] = "k_eEventActionScoreMode_Min"] = 1;
        return values;
    })();
    
    $root.CDOTAClientHardwareSpecs = (function() {
    
        /**
         * Properties of a CDOTAClientHardwareSpecs.
         * @exports ICDOTAClientHardwareSpecs
         * @interface ICDOTAClientHardwareSpecs
         * @property {number|null} [logical_processors] CDOTAClientHardwareSpecs logical_processors
         * @property {number|Long|null} [cpu_cycles_per_second] CDOTAClientHardwareSpecs cpu_cycles_per_second
         * @property {number|Long|null} [total_physical_memory] CDOTAClientHardwareSpecs total_physical_memory
         * @property {boolean|null} [is_64_bit_os] CDOTAClientHardwareSpecs is_64_bit_os
         * @property {number|Long|null} [upload_measurement] CDOTAClientHardwareSpecs upload_measurement
         * @property {boolean|null} [prefer_not_host] CDOTAClientHardwareSpecs prefer_not_host
         */
    
        /**
         * Constructs a new CDOTAClientHardwareSpecs.
         * @exports CDOTAClientHardwareSpecs
         * @classdesc Represents a CDOTAClientHardwareSpecs.
         * @implements ICDOTAClientHardwareSpecs
         * @constructor
         * @param {ICDOTAClientHardwareSpecs=} [properties] Properties to set
         */
        function CDOTAClientHardwareSpecs(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientHardwareSpecs logical_processors.
         * @member {number} logical_processors
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.logical_processors = 0;
    
        /**
         * CDOTAClientHardwareSpecs cpu_cycles_per_second.
         * @member {number|Long} cpu_cycles_per_second
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.cpu_cycles_per_second = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAClientHardwareSpecs total_physical_memory.
         * @member {number|Long} total_physical_memory
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.total_physical_memory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAClientHardwareSpecs is_64_bit_os.
         * @member {boolean} is_64_bit_os
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.is_64_bit_os = false;
    
        /**
         * CDOTAClientHardwareSpecs upload_measurement.
         * @member {number|Long} upload_measurement
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.upload_measurement = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAClientHardwareSpecs prefer_not_host.
         * @member {boolean} prefer_not_host
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.prefer_not_host = false;
    
        /**
         * Creates a new CDOTAClientHardwareSpecs instance using the specified properties.
         * @function create
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs=} [properties] Properties to set
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs instance
         */
        CDOTAClientHardwareSpecs.create = function create(properties) {
            return new CDOTAClientHardwareSpecs(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientHardwareSpecs message. Does not implicitly {@link CDOTAClientHardwareSpecs.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientHardwareSpecs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logical_processors != null && Object.hasOwnProperty.call(message, "logical_processors"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.logical_processors);
            if (message.cpu_cycles_per_second != null && Object.hasOwnProperty.call(message, "cpu_cycles_per_second"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.cpu_cycles_per_second);
            if (message.total_physical_memory != null && Object.hasOwnProperty.call(message, "total_physical_memory"))
                writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.total_physical_memory);
            if (message.is_64_bit_os != null && Object.hasOwnProperty.call(message, "is_64_bit_os"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_64_bit_os);
            if (message.upload_measurement != null && Object.hasOwnProperty.call(message, "upload_measurement"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.upload_measurement);
            if (message.prefer_not_host != null && Object.hasOwnProperty.call(message, "prefer_not_host"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.prefer_not_host);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientHardwareSpecs message, length delimited. Does not implicitly {@link CDOTAClientHardwareSpecs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientHardwareSpecs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientHardwareSpecs message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientHardwareSpecs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientHardwareSpecs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logical_processors = reader.uint32();
                    break;
                case 2:
                    message.cpu_cycles_per_second = reader.fixed64();
                    break;
                case 3:
                    message.total_physical_memory = reader.fixed64();
                    break;
                case 4:
                    message.is_64_bit_os = reader.bool();
                    break;
                case 5:
                    message.upload_measurement = reader.uint64();
                    break;
                case 6:
                    message.prefer_not_host = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientHardwareSpecs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientHardwareSpecs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientHardwareSpecs message.
         * @function verify
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientHardwareSpecs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logical_processors != null && message.hasOwnProperty("logical_processors"))
                if (!$util.isInteger(message.logical_processors))
                    return "logical_processors: integer expected";
            if (message.cpu_cycles_per_second != null && message.hasOwnProperty("cpu_cycles_per_second"))
                if (!$util.isInteger(message.cpu_cycles_per_second) && !(message.cpu_cycles_per_second && $util.isInteger(message.cpu_cycles_per_second.low) && $util.isInteger(message.cpu_cycles_per_second.high)))
                    return "cpu_cycles_per_second: integer|Long expected";
            if (message.total_physical_memory != null && message.hasOwnProperty("total_physical_memory"))
                if (!$util.isInteger(message.total_physical_memory) && !(message.total_physical_memory && $util.isInteger(message.total_physical_memory.low) && $util.isInteger(message.total_physical_memory.high)))
                    return "total_physical_memory: integer|Long expected";
            if (message.is_64_bit_os != null && message.hasOwnProperty("is_64_bit_os"))
                if (typeof message.is_64_bit_os !== "boolean")
                    return "is_64_bit_os: boolean expected";
            if (message.upload_measurement != null && message.hasOwnProperty("upload_measurement"))
                if (!$util.isInteger(message.upload_measurement) && !(message.upload_measurement && $util.isInteger(message.upload_measurement.low) && $util.isInteger(message.upload_measurement.high)))
                    return "upload_measurement: integer|Long expected";
            if (message.prefer_not_host != null && message.hasOwnProperty("prefer_not_host"))
                if (typeof message.prefer_not_host !== "boolean")
                    return "prefer_not_host: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientHardwareSpecs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         */
        CDOTAClientHardwareSpecs.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientHardwareSpecs)
                return object;
            var message = new $root.CDOTAClientHardwareSpecs();
            if (object.logical_processors != null)
                message.logical_processors = object.logical_processors >>> 0;
            if (object.cpu_cycles_per_second != null)
                if ($util.Long)
                    (message.cpu_cycles_per_second = $util.Long.fromValue(object.cpu_cycles_per_second)).unsigned = false;
                else if (typeof object.cpu_cycles_per_second === "string")
                    message.cpu_cycles_per_second = parseInt(object.cpu_cycles_per_second, 10);
                else if (typeof object.cpu_cycles_per_second === "number")
                    message.cpu_cycles_per_second = object.cpu_cycles_per_second;
                else if (typeof object.cpu_cycles_per_second === "object")
                    message.cpu_cycles_per_second = new $util.LongBits(object.cpu_cycles_per_second.low >>> 0, object.cpu_cycles_per_second.high >>> 0).toNumber();
            if (object.total_physical_memory != null)
                if ($util.Long)
                    (message.total_physical_memory = $util.Long.fromValue(object.total_physical_memory)).unsigned = false;
                else if (typeof object.total_physical_memory === "string")
                    message.total_physical_memory = parseInt(object.total_physical_memory, 10);
                else if (typeof object.total_physical_memory === "number")
                    message.total_physical_memory = object.total_physical_memory;
                else if (typeof object.total_physical_memory === "object")
                    message.total_physical_memory = new $util.LongBits(object.total_physical_memory.low >>> 0, object.total_physical_memory.high >>> 0).toNumber();
            if (object.is_64_bit_os != null)
                message.is_64_bit_os = Boolean(object.is_64_bit_os);
            if (object.upload_measurement != null)
                if ($util.Long)
                    (message.upload_measurement = $util.Long.fromValue(object.upload_measurement)).unsigned = true;
                else if (typeof object.upload_measurement === "string")
                    message.upload_measurement = parseInt(object.upload_measurement, 10);
                else if (typeof object.upload_measurement === "number")
                    message.upload_measurement = object.upload_measurement;
                else if (typeof object.upload_measurement === "object")
                    message.upload_measurement = new $util.LongBits(object.upload_measurement.low >>> 0, object.upload_measurement.high >>> 0).toNumber(true);
            if (object.prefer_not_host != null)
                message.prefer_not_host = Boolean(object.prefer_not_host);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientHardwareSpecs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {CDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientHardwareSpecs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logical_processors = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.cpu_cycles_per_second = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cpu_cycles_per_second = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.total_physical_memory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_physical_memory = options.longs === String ? "0" : 0;
                object.is_64_bit_os = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.upload_measurement = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.upload_measurement = options.longs === String ? "0" : 0;
                object.prefer_not_host = false;
            }
            if (message.logical_processors != null && message.hasOwnProperty("logical_processors"))
                object.logical_processors = message.logical_processors;
            if (message.cpu_cycles_per_second != null && message.hasOwnProperty("cpu_cycles_per_second"))
                if (typeof message.cpu_cycles_per_second === "number")
                    object.cpu_cycles_per_second = options.longs === String ? String(message.cpu_cycles_per_second) : message.cpu_cycles_per_second;
                else
                    object.cpu_cycles_per_second = options.longs === String ? $util.Long.prototype.toString.call(message.cpu_cycles_per_second) : options.longs === Number ? new $util.LongBits(message.cpu_cycles_per_second.low >>> 0, message.cpu_cycles_per_second.high >>> 0).toNumber() : message.cpu_cycles_per_second;
            if (message.total_physical_memory != null && message.hasOwnProperty("total_physical_memory"))
                if (typeof message.total_physical_memory === "number")
                    object.total_physical_memory = options.longs === String ? String(message.total_physical_memory) : message.total_physical_memory;
                else
                    object.total_physical_memory = options.longs === String ? $util.Long.prototype.toString.call(message.total_physical_memory) : options.longs === Number ? new $util.LongBits(message.total_physical_memory.low >>> 0, message.total_physical_memory.high >>> 0).toNumber() : message.total_physical_memory;
            if (message.is_64_bit_os != null && message.hasOwnProperty("is_64_bit_os"))
                object.is_64_bit_os = message.is_64_bit_os;
            if (message.upload_measurement != null && message.hasOwnProperty("upload_measurement"))
                if (typeof message.upload_measurement === "number")
                    object.upload_measurement = options.longs === String ? String(message.upload_measurement) : message.upload_measurement;
                else
                    object.upload_measurement = options.longs === String ? $util.Long.prototype.toString.call(message.upload_measurement) : options.longs === Number ? new $util.LongBits(message.upload_measurement.low >>> 0, message.upload_measurement.high >>> 0).toNumber(true) : message.upload_measurement;
            if (message.prefer_not_host != null && message.hasOwnProperty("prefer_not_host"))
                object.prefer_not_host = message.prefer_not_host;
            return object;
        };
    
        /**
         * Converts this CDOTAClientHardwareSpecs to JSON.
         * @function toJSON
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientHardwareSpecs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientHardwareSpecs;
    })();
    
    $root.CDOTASaveGame = (function() {
    
        /**
         * Properties of a CDOTASaveGame.
         * @exports ICDOTASaveGame
         * @interface ICDOTASaveGame
         * @property {number|Long|null} [match_id] CDOTASaveGame match_id
         * @property {number|null} [save_time] CDOTASaveGame save_time
         * @property {Array.<CDOTASaveGame.IPlayer>|null} [players] CDOTASaveGame players
         * @property {Array.<CDOTASaveGame.ISaveInstance>|null} [save_instances] CDOTASaveGame save_instances
         */
    
        /**
         * Constructs a new CDOTASaveGame.
         * @exports CDOTASaveGame
         * @classdesc Represents a CDOTASaveGame.
         * @implements ICDOTASaveGame
         * @constructor
         * @param {ICDOTASaveGame=} [properties] Properties to set
         */
        function CDOTASaveGame(properties) {
            this.players = [];
            this.save_instances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTASaveGame match_id.
         * @member {number|Long} match_id
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTASaveGame save_time.
         * @member {number} save_time
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.save_time = 0;
    
        /**
         * CDOTASaveGame players.
         * @member {Array.<CDOTASaveGame.IPlayer>} players
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.players = $util.emptyArray;
    
        /**
         * CDOTASaveGame save_instances.
         * @member {Array.<CDOTASaveGame.ISaveInstance>} save_instances
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.save_instances = $util.emptyArray;
    
        /**
         * Creates a new CDOTASaveGame instance using the specified properties.
         * @function create
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame=} [properties] Properties to set
         * @returns {CDOTASaveGame} CDOTASaveGame instance
         */
        CDOTASaveGame.create = function create(properties) {
            return new CDOTASaveGame(properties);
        };
    
        /**
         * Encodes the specified CDOTASaveGame message. Does not implicitly {@link CDOTASaveGame.verify|verify} messages.
         * @function encode
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame} message CDOTASaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASaveGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.save_time != null && Object.hasOwnProperty.call(message, "save_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.save_time);
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    $root.CDOTASaveGame.Player.encode(message.players[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.save_instances != null && message.save_instances.length)
                for (var i = 0; i < message.save_instances.length; ++i)
                    $root.CDOTASaveGame.SaveInstance.encode(message.save_instances[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.match_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTASaveGame message, length delimited. Does not implicitly {@link CDOTASaveGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame} message CDOTASaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASaveGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTASaveGame message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTASaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTASaveGame} CDOTASaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASaveGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.match_id = reader.uint64();
                    break;
                case 2:
                    message.save_time = reader.uint32();
                    break;
                case 3:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.CDOTASaveGame.Player.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.save_instances && message.save_instances.length))
                        message.save_instances = [];
                    message.save_instances.push($root.CDOTASaveGame.SaveInstance.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTASaveGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTASaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTASaveGame} CDOTASaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASaveGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTASaveGame message.
         * @function verify
         * @memberof CDOTASaveGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTASaveGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.save_time != null && message.hasOwnProperty("save_time"))
                if (!$util.isInteger(message.save_time))
                    return "save_time: integer expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i) {
                    var error = $root.CDOTASaveGame.Player.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            if (message.save_instances != null && message.hasOwnProperty("save_instances")) {
                if (!Array.isArray(message.save_instances))
                    return "save_instances: array expected";
                for (var i = 0; i < message.save_instances.length; ++i) {
                    var error = $root.CDOTASaveGame.SaveInstance.verify(message.save_instances[i]);
                    if (error)
                        return "save_instances." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTASaveGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTASaveGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTASaveGame} CDOTASaveGame
         */
        CDOTASaveGame.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTASaveGame)
                return object;
            var message = new $root.CDOTASaveGame();
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.save_time != null)
                message.save_time = object.save_time >>> 0;
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".CDOTASaveGame.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".CDOTASaveGame.players: object expected");
                    message.players[i] = $root.CDOTASaveGame.Player.fromObject(object.players[i]);
                }
            }
            if (object.save_instances) {
                if (!Array.isArray(object.save_instances))
                    throw TypeError(".CDOTASaveGame.save_instances: array expected");
                message.save_instances = [];
                for (var i = 0; i < object.save_instances.length; ++i) {
                    if (typeof object.save_instances[i] !== "object")
                        throw TypeError(".CDOTASaveGame.save_instances: object expected");
                    message.save_instances[i] = $root.CDOTASaveGame.SaveInstance.fromObject(object.save_instances[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTASaveGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTASaveGame
         * @static
         * @param {CDOTASaveGame} message CDOTASaveGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTASaveGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.players = [];
                object.save_instances = [];
            }
            if (options.defaults) {
                object.save_time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
            }
            if (message.save_time != null && message.hasOwnProperty("save_time"))
                object.save_time = message.save_time;
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.CDOTASaveGame.Player.toObject(message.players[j], options);
            }
            if (message.save_instances && message.save_instances.length) {
                object.save_instances = [];
                for (var j = 0; j < message.save_instances.length; ++j)
                    object.save_instances[j] = $root.CDOTASaveGame.SaveInstance.toObject(message.save_instances[j], options);
            }
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            return object;
        };
    
        /**
         * Converts this CDOTASaveGame to JSON.
         * @function toJSON
         * @memberof CDOTASaveGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTASaveGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTASaveGame.Player = (function() {
    
            /**
             * Properties of a Player.
             * @memberof CDOTASaveGame
             * @interface IPlayer
             * @property {DOTA_GC_TEAM|null} [team] Player team
             * @property {string|null} [name] Player name
             * @property {string|null} [hero] Player hero
             */
    
            /**
             * Constructs a new Player.
             * @memberof CDOTASaveGame
             * @classdesc Represents a Player.
             * @implements IPlayer
             * @constructor
             * @param {CDOTASaveGame.IPlayer=} [properties] Properties to set
             */
            function Player(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Player team.
             * @member {DOTA_GC_TEAM} team
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.team = 0;
    
            /**
             * Player name.
             * @member {string} name
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.name = "";
    
            /**
             * Player hero.
             * @member {string} hero
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.hero = "";
    
            /**
             * Creates a new Player instance using the specified properties.
             * @function create
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer=} [properties] Properties to set
             * @returns {CDOTASaveGame.Player} Player instance
             */
            Player.create = function create(properties) {
                return new Player(properties);
            };
    
            /**
             * Encodes the specified Player message. Does not implicitly {@link CDOTASaveGame.Player.verify|verify} messages.
             * @function encode
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.team);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.hero != null && Object.hasOwnProperty.call(message, "hero"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.hero);
                return writer;
            };
    
            /**
             * Encodes the specified Player message, length delimited. Does not implicitly {@link CDOTASaveGame.Player.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTASaveGame.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.Player();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.team = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.hero = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTASaveGame.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Player message.
             * @function verify
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Player.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.team != null && message.hasOwnProperty("team"))
                    switch (message.team) {
                    default:
                        return "team: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.hero != null && message.hasOwnProperty("hero"))
                    if (!$util.isString(message.hero))
                        return "hero: string expected";
                return null;
            };
    
            /**
             * Creates a Player message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTASaveGame.Player} Player
             */
            Player.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTASaveGame.Player)
                    return object;
                var message = new $root.CDOTASaveGame.Player();
                switch (object.team) {
                case "DOTA_GC_TEAM_GOOD_GUYS":
                case 0:
                    message.team = 0;
                    break;
                case "DOTA_GC_TEAM_BAD_GUYS":
                case 1:
                    message.team = 1;
                    break;
                case "DOTA_GC_TEAM_BROADCASTER":
                case 2:
                    message.team = 2;
                    break;
                case "DOTA_GC_TEAM_SPECTATOR":
                case 3:
                    message.team = 3;
                    break;
                case "DOTA_GC_TEAM_PLAYER_POOL":
                case 4:
                    message.team = 4;
                    break;
                case "DOTA_GC_TEAM_NOTEAM":
                case 5:
                    message.team = 5;
                    break;
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.hero != null)
                    message.hero = String(object.hero);
                return message;
            };
    
            /**
             * Creates a plain object from a Player message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.Player} message Player
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Player.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.team = options.enums === String ? "DOTA_GC_TEAM_GOOD_GUYS" : 0;
                    object.name = "";
                    object.hero = "";
                }
                if (message.team != null && message.hasOwnProperty("team"))
                    object.team = options.enums === String ? $root.DOTA_GC_TEAM[message.team] : message.team;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.hero != null && message.hasOwnProperty("hero"))
                    object.hero = message.hero;
                return object;
            };
    
            /**
             * Converts this Player to JSON.
             * @function toJSON
             * @memberof CDOTASaveGame.Player
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Player.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Player;
        })();
    
        CDOTASaveGame.SaveInstance = (function() {
    
            /**
             * Properties of a SaveInstance.
             * @memberof CDOTASaveGame
             * @interface ISaveInstance
             * @property {number|null} [game_time] SaveInstance game_time
             * @property {number|null} [team1_score] SaveInstance team1_score
             * @property {number|null} [team2_score] SaveInstance team2_score
             * @property {Array.<CDOTASaveGame.SaveInstance.IPlayerPositions>|null} [player_positions] SaveInstance player_positions
             * @property {number|null} [save_id] SaveInstance save_id
             * @property {number|null} [save_time] SaveInstance save_time
             */
    
            /**
             * Constructs a new SaveInstance.
             * @memberof CDOTASaveGame
             * @classdesc Represents a SaveInstance.
             * @implements ISaveInstance
             * @constructor
             * @param {CDOTASaveGame.ISaveInstance=} [properties] Properties to set
             */
            function SaveInstance(properties) {
                this.player_positions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SaveInstance game_time.
             * @member {number} game_time
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.game_time = 0;
    
            /**
             * SaveInstance team1_score.
             * @member {number} team1_score
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.team1_score = 0;
    
            /**
             * SaveInstance team2_score.
             * @member {number} team2_score
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.team2_score = 0;
    
            /**
             * SaveInstance player_positions.
             * @member {Array.<CDOTASaveGame.SaveInstance.IPlayerPositions>} player_positions
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.player_positions = $util.emptyArray;
    
            /**
             * SaveInstance save_id.
             * @member {number} save_id
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.save_id = 0;
    
            /**
             * SaveInstance save_time.
             * @member {number} save_time
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.save_time = 0;
    
            /**
             * Creates a new SaveInstance instance using the specified properties.
             * @function create
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance=} [properties] Properties to set
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance instance
             */
            SaveInstance.create = function create(properties) {
                return new SaveInstance(properties);
            };
    
            /**
             * Encodes the specified SaveInstance message. Does not implicitly {@link CDOTASaveGame.SaveInstance.verify|verify} messages.
             * @function encode
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance} message SaveInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveInstance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.game_time != null && Object.hasOwnProperty.call(message, "game_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.game_time);
                if (message.team1_score != null && Object.hasOwnProperty.call(message, "team1_score"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team1_score);
                if (message.team2_score != null && Object.hasOwnProperty.call(message, "team2_score"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.team2_score);
                if (message.player_positions != null && message.player_positions.length)
                    for (var i = 0; i < message.player_positions.length; ++i)
                        $root.CDOTASaveGame.SaveInstance.PlayerPositions.encode(message.player_positions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.save_id != null && Object.hasOwnProperty.call(message, "save_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.save_id);
                if (message.save_time != null && Object.hasOwnProperty.call(message, "save_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.save_time);
                return writer;
            };
    
            /**
             * Encodes the specified SaveInstance message, length delimited. Does not implicitly {@link CDOTASaveGame.SaveInstance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance} message SaveInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveInstance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SaveInstance message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveInstance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.SaveInstance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.game_time = reader.uint32();
                        break;
                    case 3:
                        message.team1_score = reader.uint32();
                        break;
                    case 4:
                        message.team2_score = reader.uint32();
                        break;
                    case 5:
                        if (!(message.player_positions && message.player_positions.length))
                            message.player_positions = [];
                        message.player_positions.push($root.CDOTASaveGame.SaveInstance.PlayerPositions.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.save_id = reader.uint32();
                        break;
                    case 7:
                        message.save_time = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SaveInstance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveInstance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SaveInstance message.
             * @function verify
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveInstance.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.game_time != null && message.hasOwnProperty("game_time"))
                    if (!$util.isInteger(message.game_time))
                        return "game_time: integer expected";
                if (message.team1_score != null && message.hasOwnProperty("team1_score"))
                    if (!$util.isInteger(message.team1_score))
                        return "team1_score: integer expected";
                if (message.team2_score != null && message.hasOwnProperty("team2_score"))
                    if (!$util.isInteger(message.team2_score))
                        return "team2_score: integer expected";
                if (message.player_positions != null && message.hasOwnProperty("player_positions")) {
                    if (!Array.isArray(message.player_positions))
                        return "player_positions: array expected";
                    for (var i = 0; i < message.player_positions.length; ++i) {
                        var error = $root.CDOTASaveGame.SaveInstance.PlayerPositions.verify(message.player_positions[i]);
                        if (error)
                            return "player_positions." + error;
                    }
                }
                if (message.save_id != null && message.hasOwnProperty("save_id"))
                    if (!$util.isInteger(message.save_id))
                        return "save_id: integer expected";
                if (message.save_time != null && message.hasOwnProperty("save_time"))
                    if (!$util.isInteger(message.save_time))
                        return "save_time: integer expected";
                return null;
            };
    
            /**
             * Creates a SaveInstance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             */
            SaveInstance.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTASaveGame.SaveInstance)
                    return object;
                var message = new $root.CDOTASaveGame.SaveInstance();
                if (object.game_time != null)
                    message.game_time = object.game_time >>> 0;
                if (object.team1_score != null)
                    message.team1_score = object.team1_score >>> 0;
                if (object.team2_score != null)
                    message.team2_score = object.team2_score >>> 0;
                if (object.player_positions) {
                    if (!Array.isArray(object.player_positions))
                        throw TypeError(".CDOTASaveGame.SaveInstance.player_positions: array expected");
                    message.player_positions = [];
                    for (var i = 0; i < object.player_positions.length; ++i) {
                        if (typeof object.player_positions[i] !== "object")
                            throw TypeError(".CDOTASaveGame.SaveInstance.player_positions: object expected");
                        message.player_positions[i] = $root.CDOTASaveGame.SaveInstance.PlayerPositions.fromObject(object.player_positions[i]);
                    }
                }
                if (object.save_id != null)
                    message.save_id = object.save_id >>> 0;
                if (object.save_time != null)
                    message.save_time = object.save_time >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a SaveInstance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.SaveInstance} message SaveInstance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveInstance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.player_positions = [];
                if (options.defaults) {
                    object.game_time = 0;
                    object.team1_score = 0;
                    object.team2_score = 0;
                    object.save_id = 0;
                    object.save_time = 0;
                }
                if (message.game_time != null && message.hasOwnProperty("game_time"))
                    object.game_time = message.game_time;
                if (message.team1_score != null && message.hasOwnProperty("team1_score"))
                    object.team1_score = message.team1_score;
                if (message.team2_score != null && message.hasOwnProperty("team2_score"))
                    object.team2_score = message.team2_score;
                if (message.player_positions && message.player_positions.length) {
                    object.player_positions = [];
                    for (var j = 0; j < message.player_positions.length; ++j)
                        object.player_positions[j] = $root.CDOTASaveGame.SaveInstance.PlayerPositions.toObject(message.player_positions[j], options);
                }
                if (message.save_id != null && message.hasOwnProperty("save_id"))
                    object.save_id = message.save_id;
                if (message.save_time != null && message.hasOwnProperty("save_time"))
                    object.save_time = message.save_time;
                return object;
            };
    
            /**
             * Converts this SaveInstance to JSON.
             * @function toJSON
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveInstance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            SaveInstance.PlayerPositions = (function() {
    
                /**
                 * Properties of a PlayerPositions.
                 * @memberof CDOTASaveGame.SaveInstance
                 * @interface IPlayerPositions
                 * @property {number|null} [x] PlayerPositions x
                 * @property {number|null} [y] PlayerPositions y
                 */
    
                /**
                 * Constructs a new PlayerPositions.
                 * @memberof CDOTASaveGame.SaveInstance
                 * @classdesc Represents a PlayerPositions.
                 * @implements IPlayerPositions
                 * @constructor
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions=} [properties] Properties to set
                 */
                function PlayerPositions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PlayerPositions x.
                 * @member {number} x
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 */
                PlayerPositions.prototype.x = 0;
    
                /**
                 * PlayerPositions y.
                 * @member {number} y
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 */
                PlayerPositions.prototype.y = 0;
    
                /**
                 * Creates a new PlayerPositions instance using the specified properties.
                 * @function create
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions=} [properties] Properties to set
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions instance
                 */
                PlayerPositions.create = function create(properties) {
                    return new PlayerPositions(properties);
                };
    
                /**
                 * Encodes the specified PlayerPositions message. Does not implicitly {@link CDOTASaveGame.SaveInstance.PlayerPositions.verify|verify} messages.
                 * @function encode
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions} message PlayerPositions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayerPositions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                    return writer;
                };
    
                /**
                 * Encodes the specified PlayerPositions message, length delimited. Does not implicitly {@link CDOTASaveGame.SaveInstance.PlayerPositions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions} message PlayerPositions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayerPositions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PlayerPositions message from the specified reader or buffer.
                 * @function decode
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayerPositions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.SaveInstance.PlayerPositions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.x = reader.float();
                            break;
                        case 2:
                            message.y = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PlayerPositions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayerPositions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PlayerPositions message.
                 * @function verify
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayerPositions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    return null;
                };
    
                /**
                 * Creates a PlayerPositions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 */
                PlayerPositions.fromObject = function fromObject(object) {
                    if (object instanceof $root.CDOTASaveGame.SaveInstance.PlayerPositions)
                        return object;
                    var message = new $root.CDOTASaveGame.SaveInstance.PlayerPositions();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PlayerPositions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.PlayerPositions} message PlayerPositions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayerPositions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    return object;
                };
    
                /**
                 * Converts this PlayerPositions to JSON.
                 * @function toJSON
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayerPositions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PlayerPositions;
            })();
    
            return SaveInstance;
        })();
    
        return CDOTASaveGame;
    })();
    
    $root.CMsgDOTACombatLogEntry = (function() {
    
        /**
         * Properties of a CMsgDOTACombatLogEntry.
         * @exports ICMsgDOTACombatLogEntry
         * @interface ICMsgDOTACombatLogEntry
         * @property {DOTA_COMBATLOG_TYPES|null} [type] CMsgDOTACombatLogEntry type
         * @property {number|null} [target_name] CMsgDOTACombatLogEntry target_name
         * @property {number|null} [target_source_name] CMsgDOTACombatLogEntry target_source_name
         * @property {number|null} [attacker_name] CMsgDOTACombatLogEntry attacker_name
         * @property {number|null} [damage_source_name] CMsgDOTACombatLogEntry damage_source_name
         * @property {number|null} [inflictor_name] CMsgDOTACombatLogEntry inflictor_name
         * @property {boolean|null} [is_attacker_illusion] CMsgDOTACombatLogEntry is_attacker_illusion
         * @property {boolean|null} [is_attacker_hero] CMsgDOTACombatLogEntry is_attacker_hero
         * @property {boolean|null} [is_target_illusion] CMsgDOTACombatLogEntry is_target_illusion
         * @property {boolean|null} [is_target_hero] CMsgDOTACombatLogEntry is_target_hero
         * @property {boolean|null} [is_visible_radiant] CMsgDOTACombatLogEntry is_visible_radiant
         * @property {boolean|null} [is_visible_dire] CMsgDOTACombatLogEntry is_visible_dire
         * @property {number|null} [value] CMsgDOTACombatLogEntry value
         * @property {number|null} [health] CMsgDOTACombatLogEntry health
         * @property {number|null} [timestamp] CMsgDOTACombatLogEntry timestamp
         * @property {number|null} [stun_duration] CMsgDOTACombatLogEntry stun_duration
         * @property {number|null} [slow_duration] CMsgDOTACombatLogEntry slow_duration
         * @property {boolean|null} [is_ability_toggle_on] CMsgDOTACombatLogEntry is_ability_toggle_on
         * @property {boolean|null} [is_ability_toggle_off] CMsgDOTACombatLogEntry is_ability_toggle_off
         * @property {number|null} [ability_level] CMsgDOTACombatLogEntry ability_level
         * @property {number|null} [location_x] CMsgDOTACombatLogEntry location_x
         * @property {number|null} [location_y] CMsgDOTACombatLogEntry location_y
         * @property {number|null} [gold_reason] CMsgDOTACombatLogEntry gold_reason
         * @property {number|null} [timestamp_raw] CMsgDOTACombatLogEntry timestamp_raw
         * @property {number|null} [modifier_duration] CMsgDOTACombatLogEntry modifier_duration
         * @property {number|null} [xp_reason] CMsgDOTACombatLogEntry xp_reason
         * @property {number|null} [last_hits] CMsgDOTACombatLogEntry last_hits
         * @property {number|null} [attacker_team] CMsgDOTACombatLogEntry attacker_team
         * @property {number|null} [target_team] CMsgDOTACombatLogEntry target_team
         * @property {number|null} [obs_wards_placed] CMsgDOTACombatLogEntry obs_wards_placed
         * @property {number|null} [assist_player0] CMsgDOTACombatLogEntry assist_player0
         * @property {number|null} [assist_player1] CMsgDOTACombatLogEntry assist_player1
         * @property {number|null} [assist_player2] CMsgDOTACombatLogEntry assist_player2
         * @property {number|null} [assist_player3] CMsgDOTACombatLogEntry assist_player3
         * @property {number|null} [stack_count] CMsgDOTACombatLogEntry stack_count
         * @property {boolean|null} [hidden_modifier] CMsgDOTACombatLogEntry hidden_modifier
         * @property {boolean|null} [is_target_building] CMsgDOTACombatLogEntry is_target_building
         * @property {number|null} [neutral_camp_type] CMsgDOTACombatLogEntry neutral_camp_type
         * @property {number|null} [rune_type] CMsgDOTACombatLogEntry rune_type
         * @property {Array.<number>|null} [assist_players] CMsgDOTACombatLogEntry assist_players
         * @property {boolean|null} [is_heal_save] CMsgDOTACombatLogEntry is_heal_save
         * @property {boolean|null} [is_ultimate_ability] CMsgDOTACombatLogEntry is_ultimate_ability
         * @property {number|null} [attacker_hero_level] CMsgDOTACombatLogEntry attacker_hero_level
         * @property {number|null} [target_hero_level] CMsgDOTACombatLogEntry target_hero_level
         * @property {number|null} [xpm] CMsgDOTACombatLogEntry xpm
         * @property {number|null} [gpm] CMsgDOTACombatLogEntry gpm
         * @property {number|null} [event_location] CMsgDOTACombatLogEntry event_location
         * @property {boolean|null} [target_is_self] CMsgDOTACombatLogEntry target_is_self
         * @property {number|null} [damage_type] CMsgDOTACombatLogEntry damage_type
         * @property {boolean|null} [invisibility_modifier] CMsgDOTACombatLogEntry invisibility_modifier
         * @property {number|null} [damage_category] CMsgDOTACombatLogEntry damage_category
         * @property {number|null} [networth] CMsgDOTACombatLogEntry networth
         * @property {number|null} [building_type] CMsgDOTACombatLogEntry building_type
         * @property {number|null} [modifier_elapsed_duration] CMsgDOTACombatLogEntry modifier_elapsed_duration
         * @property {boolean|null} [silence_modifier] CMsgDOTACombatLogEntry silence_modifier
         * @property {boolean|null} [heal_from_lifesteal] CMsgDOTACombatLogEntry heal_from_lifesteal
         * @property {boolean|null} [modifier_purged] CMsgDOTACombatLogEntry modifier_purged
         * @property {boolean|null} [spell_evaded] CMsgDOTACombatLogEntry spell_evaded
         * @property {boolean|null} [motion_controller_modifier] CMsgDOTACombatLogEntry motion_controller_modifier
         * @property {boolean|null} [long_range_kill] CMsgDOTACombatLogEntry long_range_kill
         * @property {number|null} [modifier_purge_ability] CMsgDOTACombatLogEntry modifier_purge_ability
         * @property {number|null} [modifier_purge_npc] CMsgDOTACombatLogEntry modifier_purge_npc
         * @property {boolean|null} [root_modifier] CMsgDOTACombatLogEntry root_modifier
         * @property {number|null} [total_unit_death_count] CMsgDOTACombatLogEntry total_unit_death_count
         * @property {boolean|null} [aura_modifier] CMsgDOTACombatLogEntry aura_modifier
         * @property {boolean|null} [armor_debuff_modifier] CMsgDOTACombatLogEntry armor_debuff_modifier
         * @property {boolean|null} [no_physical_damage_modifier] CMsgDOTACombatLogEntry no_physical_damage_modifier
         * @property {number|null} [modifier_ability] CMsgDOTACombatLogEntry modifier_ability
         * @property {boolean|null} [modifier_hidden] CMsgDOTACombatLogEntry modifier_hidden
         * @property {boolean|null} [inflictor_is_stolen_ability] CMsgDOTACombatLogEntry inflictor_is_stolen_ability
         * @property {number|null} [kill_eater_event] CMsgDOTACombatLogEntry kill_eater_event
         * @property {number|null} [unit_status_label] CMsgDOTACombatLogEntry unit_status_label
         * @property {boolean|null} [spell_generated_attack] CMsgDOTACombatLogEntry spell_generated_attack
         * @property {boolean|null} [at_night_time] CMsgDOTACombatLogEntry at_night_time
         * @property {boolean|null} [attacker_has_scepter] CMsgDOTACombatLogEntry attacker_has_scepter
         */
    
        /**
         * Constructs a new CMsgDOTACombatLogEntry.
         * @exports CMsgDOTACombatLogEntry
         * @classdesc Represents a CMsgDOTACombatLogEntry.
         * @implements ICMsgDOTACombatLogEntry
         * @constructor
         * @param {ICMsgDOTACombatLogEntry=} [properties] Properties to set
         */
        function CMsgDOTACombatLogEntry(properties) {
            this.assist_players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTACombatLogEntry type.
         * @member {DOTA_COMBATLOG_TYPES} type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.type = -1;
    
        /**
         * CMsgDOTACombatLogEntry target_name.
         * @member {number} target_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_source_name.
         * @member {number} target_source_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_source_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry attacker_name.
         * @member {number} attacker_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry damage_source_name.
         * @member {number} damage_source_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_source_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry inflictor_name.
         * @member {number} inflictor_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.inflictor_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry is_attacker_illusion.
         * @member {boolean} is_attacker_illusion
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_attacker_illusion = false;
    
        /**
         * CMsgDOTACombatLogEntry is_attacker_hero.
         * @member {boolean} is_attacker_hero
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_attacker_hero = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_illusion.
         * @member {boolean} is_target_illusion
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_illusion = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_hero.
         * @member {boolean} is_target_hero
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_hero = false;
    
        /**
         * CMsgDOTACombatLogEntry is_visible_radiant.
         * @member {boolean} is_visible_radiant
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_visible_radiant = false;
    
        /**
         * CMsgDOTACombatLogEntry is_visible_dire.
         * @member {boolean} is_visible_dire
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_visible_dire = false;
    
        /**
         * CMsgDOTACombatLogEntry value.
         * @member {number} value
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.value = 0;
    
        /**
         * CMsgDOTACombatLogEntry health.
         * @member {number} health
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.health = 0;
    
        /**
         * CMsgDOTACombatLogEntry timestamp.
         * @member {number} timestamp
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.timestamp = 0;
    
        /**
         * CMsgDOTACombatLogEntry stun_duration.
         * @member {number} stun_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.stun_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry slow_duration.
         * @member {number} slow_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.slow_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry is_ability_toggle_on.
         * @member {boolean} is_ability_toggle_on
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ability_toggle_on = false;
    
        /**
         * CMsgDOTACombatLogEntry is_ability_toggle_off.
         * @member {boolean} is_ability_toggle_off
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ability_toggle_off = false;
    
        /**
         * CMsgDOTACombatLogEntry ability_level.
         * @member {number} ability_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.ability_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry location_x.
         * @member {number} location_x
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.location_x = 0;
    
        /**
         * CMsgDOTACombatLogEntry location_y.
         * @member {number} location_y
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.location_y = 0;
    
        /**
         * CMsgDOTACombatLogEntry gold_reason.
         * @member {number} gold_reason
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.gold_reason = 0;
    
        /**
         * CMsgDOTACombatLogEntry timestamp_raw.
         * @member {number} timestamp_raw
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.timestamp_raw = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_duration.
         * @member {number} modifier_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry xp_reason.
         * @member {number} xp_reason
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.xp_reason = 0;
    
        /**
         * CMsgDOTACombatLogEntry last_hits.
         * @member {number} last_hits
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.last_hits = 0;
    
        /**
         * CMsgDOTACombatLogEntry attacker_team.
         * @member {number} attacker_team
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_team = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_team.
         * @member {number} target_team
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_team = 0;
    
        /**
         * CMsgDOTACombatLogEntry obs_wards_placed.
         * @member {number} obs_wards_placed
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.obs_wards_placed = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player0.
         * @member {number} assist_player0
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player0 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player1.
         * @member {number} assist_player1
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player1 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player2.
         * @member {number} assist_player2
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player2 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player3.
         * @member {number} assist_player3
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player3 = 0;
    
        /**
         * CMsgDOTACombatLogEntry stack_count.
         * @member {number} stack_count
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.stack_count = 0;
    
        /**
         * CMsgDOTACombatLogEntry hidden_modifier.
         * @member {boolean} hidden_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.hidden_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_building.
         * @member {boolean} is_target_building
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_building = false;
    
        /**
         * CMsgDOTACombatLogEntry neutral_camp_type.
         * @member {number} neutral_camp_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.neutral_camp_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry rune_type.
         * @member {number} rune_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.rune_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_players.
         * @member {Array.<number>} assist_players
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_players = $util.emptyArray;
    
        /**
         * CMsgDOTACombatLogEntry is_heal_save.
         * @member {boolean} is_heal_save
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_heal_save = false;
    
        /**
         * CMsgDOTACombatLogEntry is_ultimate_ability.
         * @member {boolean} is_ultimate_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ultimate_ability = false;
    
        /**
         * CMsgDOTACombatLogEntry attacker_hero_level.
         * @member {number} attacker_hero_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_hero_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_hero_level.
         * @member {number} target_hero_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_hero_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry xpm.
         * @member {number} xpm
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.xpm = 0;
    
        /**
         * CMsgDOTACombatLogEntry gpm.
         * @member {number} gpm
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.gpm = 0;
    
        /**
         * CMsgDOTACombatLogEntry event_location.
         * @member {number} event_location
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.event_location = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_is_self.
         * @member {boolean} target_is_self
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_is_self = false;
    
        /**
         * CMsgDOTACombatLogEntry damage_type.
         * @member {number} damage_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry invisibility_modifier.
         * @member {boolean} invisibility_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.invisibility_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry damage_category.
         * @member {number} damage_category
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_category = 0;
    
        /**
         * CMsgDOTACombatLogEntry networth.
         * @member {number} networth
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.networth = 0;
    
        /**
         * CMsgDOTACombatLogEntry building_type.
         * @member {number} building_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.building_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_elapsed_duration.
         * @member {number} modifier_elapsed_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_elapsed_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry silence_modifier.
         * @member {boolean} silence_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.silence_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry heal_from_lifesteal.
         * @member {boolean} heal_from_lifesteal
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.heal_from_lifesteal = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purged.
         * @member {boolean} modifier_purged
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purged = false;
    
        /**
         * CMsgDOTACombatLogEntry spell_evaded.
         * @member {boolean} spell_evaded
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.spell_evaded = false;
    
        /**
         * CMsgDOTACombatLogEntry motion_controller_modifier.
         * @member {boolean} motion_controller_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.motion_controller_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry long_range_kill.
         * @member {boolean} long_range_kill
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.long_range_kill = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purge_ability.
         * @member {number} modifier_purge_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purge_ability = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purge_npc.
         * @member {number} modifier_purge_npc
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purge_npc = 0;
    
        /**
         * CMsgDOTACombatLogEntry root_modifier.
         * @member {boolean} root_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.root_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry total_unit_death_count.
         * @member {number} total_unit_death_count
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.total_unit_death_count = 0;
    
        /**
         * CMsgDOTACombatLogEntry aura_modifier.
         * @member {boolean} aura_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.aura_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry armor_debuff_modifier.
         * @member {boolean} armor_debuff_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.armor_debuff_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry no_physical_damage_modifier.
         * @member {boolean} no_physical_damage_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.no_physical_damage_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_ability.
         * @member {number} modifier_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_ability = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_hidden.
         * @member {boolean} modifier_hidden
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_hidden = false;
    
        /**
         * CMsgDOTACombatLogEntry inflictor_is_stolen_ability.
         * @member {boolean} inflictor_is_stolen_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.inflictor_is_stolen_ability = false;
    
        /**
         * CMsgDOTACombatLogEntry kill_eater_event.
         * @member {number} kill_eater_event
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.kill_eater_event = 0;
    
        /**
         * CMsgDOTACombatLogEntry unit_status_label.
         * @member {number} unit_status_label
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.unit_status_label = 0;
    
        /**
         * CMsgDOTACombatLogEntry spell_generated_attack.
         * @member {boolean} spell_generated_attack
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.spell_generated_attack = false;
    
        /**
         * CMsgDOTACombatLogEntry at_night_time.
         * @member {boolean} at_night_time
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.at_night_time = false;
    
        /**
         * CMsgDOTACombatLogEntry attacker_has_scepter.
         * @member {boolean} attacker_has_scepter
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_has_scepter = false;
    
        /**
         * Creates a new CMsgDOTACombatLogEntry instance using the specified properties.
         * @function create
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry=} [properties] Properties to set
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry instance
         */
        CMsgDOTACombatLogEntry.create = function create(properties) {
            return new CMsgDOTACombatLogEntry(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTACombatLogEntry message. Does not implicitly {@link CMsgDOTACombatLogEntry.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACombatLogEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.target_name != null && Object.hasOwnProperty.call(message, "target_name"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_name);
            if (message.target_source_name != null && Object.hasOwnProperty.call(message, "target_source_name"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.target_source_name);
            if (message.attacker_name != null && Object.hasOwnProperty.call(message, "attacker_name"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.attacker_name);
            if (message.damage_source_name != null && Object.hasOwnProperty.call(message, "damage_source_name"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.damage_source_name);
            if (message.inflictor_name != null && Object.hasOwnProperty.call(message, "inflictor_name"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.inflictor_name);
            if (message.is_attacker_illusion != null && Object.hasOwnProperty.call(message, "is_attacker_illusion"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.is_attacker_illusion);
            if (message.is_attacker_hero != null && Object.hasOwnProperty.call(message, "is_attacker_hero"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.is_attacker_hero);
            if (message.is_target_illusion != null && Object.hasOwnProperty.call(message, "is_target_illusion"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.is_target_illusion);
            if (message.is_target_hero != null && Object.hasOwnProperty.call(message, "is_target_hero"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.is_target_hero);
            if (message.is_visible_radiant != null && Object.hasOwnProperty.call(message, "is_visible_radiant"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.is_visible_radiant);
            if (message.is_visible_dire != null && Object.hasOwnProperty.call(message, "is_visible_dire"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.is_visible_dire);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.value);
            if (message.health != null && Object.hasOwnProperty.call(message, "health"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.health);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.timestamp);
            if (message.stun_duration != null && Object.hasOwnProperty.call(message, "stun_duration"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.stun_duration);
            if (message.slow_duration != null && Object.hasOwnProperty.call(message, "slow_duration"))
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.slow_duration);
            if (message.is_ability_toggle_on != null && Object.hasOwnProperty.call(message, "is_ability_toggle_on"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.is_ability_toggle_on);
            if (message.is_ability_toggle_off != null && Object.hasOwnProperty.call(message, "is_ability_toggle_off"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.is_ability_toggle_off);
            if (message.ability_level != null && Object.hasOwnProperty.call(message, "ability_level"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.ability_level);
            if (message.location_x != null && Object.hasOwnProperty.call(message, "location_x"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.location_x);
            if (message.location_y != null && Object.hasOwnProperty.call(message, "location_y"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.location_y);
            if (message.gold_reason != null && Object.hasOwnProperty.call(message, "gold_reason"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.gold_reason);
            if (message.timestamp_raw != null && Object.hasOwnProperty.call(message, "timestamp_raw"))
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.timestamp_raw);
            if (message.modifier_duration != null && Object.hasOwnProperty.call(message, "modifier_duration"))
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.modifier_duration);
            if (message.xp_reason != null && Object.hasOwnProperty.call(message, "xp_reason"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.xp_reason);
            if (message.last_hits != null && Object.hasOwnProperty.call(message, "last_hits"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.last_hits);
            if (message.attacker_team != null && Object.hasOwnProperty.call(message, "attacker_team"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.attacker_team);
            if (message.target_team != null && Object.hasOwnProperty.call(message, "target_team"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint32(message.target_team);
            if (message.obs_wards_placed != null && Object.hasOwnProperty.call(message, "obs_wards_placed"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.obs_wards_placed);
            if (message.assist_player0 != null && Object.hasOwnProperty.call(message, "assist_player0"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint32(message.assist_player0);
            if (message.assist_player1 != null && Object.hasOwnProperty.call(message, "assist_player1"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint32(message.assist_player1);
            if (message.assist_player2 != null && Object.hasOwnProperty.call(message, "assist_player2"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.assist_player2);
            if (message.assist_player3 != null && Object.hasOwnProperty.call(message, "assist_player3"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint32(message.assist_player3);
            if (message.stack_count != null && Object.hasOwnProperty.call(message, "stack_count"))
                writer.uint32(/* id 35, wireType 0 =*/280).uint32(message.stack_count);
            if (message.hidden_modifier != null && Object.hasOwnProperty.call(message, "hidden_modifier"))
                writer.uint32(/* id 36, wireType 0 =*/288).bool(message.hidden_modifier);
            if (message.is_target_building != null && Object.hasOwnProperty.call(message, "is_target_building"))
                writer.uint32(/* id 37, wireType 0 =*/296).bool(message.is_target_building);
            if (message.neutral_camp_type != null && Object.hasOwnProperty.call(message, "neutral_camp_type"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.neutral_camp_type);
            if (message.rune_type != null && Object.hasOwnProperty.call(message, "rune_type"))
                writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.rune_type);
            if (message.assist_players != null && message.assist_players.length)
                for (var i = 0; i < message.assist_players.length; ++i)
                    writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.assist_players[i]);
            if (message.is_heal_save != null && Object.hasOwnProperty.call(message, "is_heal_save"))
                writer.uint32(/* id 41, wireType 0 =*/328).bool(message.is_heal_save);
            if (message.is_ultimate_ability != null && Object.hasOwnProperty.call(message, "is_ultimate_ability"))
                writer.uint32(/* id 42, wireType 0 =*/336).bool(message.is_ultimate_ability);
            if (message.attacker_hero_level != null && Object.hasOwnProperty.call(message, "attacker_hero_level"))
                writer.uint32(/* id 43, wireType 0 =*/344).uint32(message.attacker_hero_level);
            if (message.target_hero_level != null && Object.hasOwnProperty.call(message, "target_hero_level"))
                writer.uint32(/* id 44, wireType 0 =*/352).uint32(message.target_hero_level);
            if (message.xpm != null && Object.hasOwnProperty.call(message, "xpm"))
                writer.uint32(/* id 45, wireType 0 =*/360).uint32(message.xpm);
            if (message.gpm != null && Object.hasOwnProperty.call(message, "gpm"))
                writer.uint32(/* id 46, wireType 0 =*/368).uint32(message.gpm);
            if (message.event_location != null && Object.hasOwnProperty.call(message, "event_location"))
                writer.uint32(/* id 47, wireType 0 =*/376).uint32(message.event_location);
            if (message.target_is_self != null && Object.hasOwnProperty.call(message, "target_is_self"))
                writer.uint32(/* id 48, wireType 0 =*/384).bool(message.target_is_self);
            if (message.damage_type != null && Object.hasOwnProperty.call(message, "damage_type"))
                writer.uint32(/* id 49, wireType 0 =*/392).uint32(message.damage_type);
            if (message.invisibility_modifier != null && Object.hasOwnProperty.call(message, "invisibility_modifier"))
                writer.uint32(/* id 50, wireType 0 =*/400).bool(message.invisibility_modifier);
            if (message.damage_category != null && Object.hasOwnProperty.call(message, "damage_category"))
                writer.uint32(/* id 51, wireType 0 =*/408).uint32(message.damage_category);
            if (message.networth != null && Object.hasOwnProperty.call(message, "networth"))
                writer.uint32(/* id 52, wireType 0 =*/416).uint32(message.networth);
            if (message.building_type != null && Object.hasOwnProperty.call(message, "building_type"))
                writer.uint32(/* id 53, wireType 0 =*/424).uint32(message.building_type);
            if (message.modifier_elapsed_duration != null && Object.hasOwnProperty.call(message, "modifier_elapsed_duration"))
                writer.uint32(/* id 54, wireType 5 =*/437).float(message.modifier_elapsed_duration);
            if (message.silence_modifier != null && Object.hasOwnProperty.call(message, "silence_modifier"))
                writer.uint32(/* id 55, wireType 0 =*/440).bool(message.silence_modifier);
            if (message.heal_from_lifesteal != null && Object.hasOwnProperty.call(message, "heal_from_lifesteal"))
                writer.uint32(/* id 56, wireType 0 =*/448).bool(message.heal_from_lifesteal);
            if (message.modifier_purged != null && Object.hasOwnProperty.call(message, "modifier_purged"))
                writer.uint32(/* id 57, wireType 0 =*/456).bool(message.modifier_purged);
            if (message.spell_evaded != null && Object.hasOwnProperty.call(message, "spell_evaded"))
                writer.uint32(/* id 58, wireType 0 =*/464).bool(message.spell_evaded);
            if (message.motion_controller_modifier != null && Object.hasOwnProperty.call(message, "motion_controller_modifier"))
                writer.uint32(/* id 59, wireType 0 =*/472).bool(message.motion_controller_modifier);
            if (message.long_range_kill != null && Object.hasOwnProperty.call(message, "long_range_kill"))
                writer.uint32(/* id 60, wireType 0 =*/480).bool(message.long_range_kill);
            if (message.modifier_purge_ability != null && Object.hasOwnProperty.call(message, "modifier_purge_ability"))
                writer.uint32(/* id 61, wireType 0 =*/488).uint32(message.modifier_purge_ability);
            if (message.modifier_purge_npc != null && Object.hasOwnProperty.call(message, "modifier_purge_npc"))
                writer.uint32(/* id 62, wireType 0 =*/496).uint32(message.modifier_purge_npc);
            if (message.root_modifier != null && Object.hasOwnProperty.call(message, "root_modifier"))
                writer.uint32(/* id 63, wireType 0 =*/504).bool(message.root_modifier);
            if (message.total_unit_death_count != null && Object.hasOwnProperty.call(message, "total_unit_death_count"))
                writer.uint32(/* id 64, wireType 0 =*/512).uint32(message.total_unit_death_count);
            if (message.aura_modifier != null && Object.hasOwnProperty.call(message, "aura_modifier"))
                writer.uint32(/* id 65, wireType 0 =*/520).bool(message.aura_modifier);
            if (message.armor_debuff_modifier != null && Object.hasOwnProperty.call(message, "armor_debuff_modifier"))
                writer.uint32(/* id 66, wireType 0 =*/528).bool(message.armor_debuff_modifier);
            if (message.no_physical_damage_modifier != null && Object.hasOwnProperty.call(message, "no_physical_damage_modifier"))
                writer.uint32(/* id 67, wireType 0 =*/536).bool(message.no_physical_damage_modifier);
            if (message.modifier_ability != null && Object.hasOwnProperty.call(message, "modifier_ability"))
                writer.uint32(/* id 68, wireType 0 =*/544).uint32(message.modifier_ability);
            if (message.modifier_hidden != null && Object.hasOwnProperty.call(message, "modifier_hidden"))
                writer.uint32(/* id 69, wireType 0 =*/552).bool(message.modifier_hidden);
            if (message.inflictor_is_stolen_ability != null && Object.hasOwnProperty.call(message, "inflictor_is_stolen_ability"))
                writer.uint32(/* id 70, wireType 0 =*/560).bool(message.inflictor_is_stolen_ability);
            if (message.kill_eater_event != null && Object.hasOwnProperty.call(message, "kill_eater_event"))
                writer.uint32(/* id 71, wireType 0 =*/568).uint32(message.kill_eater_event);
            if (message.unit_status_label != null && Object.hasOwnProperty.call(message, "unit_status_label"))
                writer.uint32(/* id 72, wireType 0 =*/576).uint32(message.unit_status_label);
            if (message.spell_generated_attack != null && Object.hasOwnProperty.call(message, "spell_generated_attack"))
                writer.uint32(/* id 73, wireType 0 =*/584).bool(message.spell_generated_attack);
            if (message.at_night_time != null && Object.hasOwnProperty.call(message, "at_night_time"))
                writer.uint32(/* id 74, wireType 0 =*/592).bool(message.at_night_time);
            if (message.attacker_has_scepter != null && Object.hasOwnProperty.call(message, "attacker_has_scepter"))
                writer.uint32(/* id 75, wireType 0 =*/600).bool(message.attacker_has_scepter);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTACombatLogEntry message, length delimited. Does not implicitly {@link CMsgDOTACombatLogEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACombatLogEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTACombatLogEntry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACombatLogEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTACombatLogEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.target_name = reader.uint32();
                    break;
                case 3:
                    message.target_source_name = reader.uint32();
                    break;
                case 4:
                    message.attacker_name = reader.uint32();
                    break;
                case 5:
                    message.damage_source_name = reader.uint32();
                    break;
                case 6:
                    message.inflictor_name = reader.uint32();
                    break;
                case 7:
                    message.is_attacker_illusion = reader.bool();
                    break;
                case 8:
                    message.is_attacker_hero = reader.bool();
                    break;
                case 9:
                    message.is_target_illusion = reader.bool();
                    break;
                case 10:
                    message.is_target_hero = reader.bool();
                    break;
                case 11:
                    message.is_visible_radiant = reader.bool();
                    break;
                case 12:
                    message.is_visible_dire = reader.bool();
                    break;
                case 13:
                    message.value = reader.uint32();
                    break;
                case 14:
                    message.health = reader.int32();
                    break;
                case 15:
                    message.timestamp = reader.float();
                    break;
                case 16:
                    message.stun_duration = reader.float();
                    break;
                case 17:
                    message.slow_duration = reader.float();
                    break;
                case 18:
                    message.is_ability_toggle_on = reader.bool();
                    break;
                case 19:
                    message.is_ability_toggle_off = reader.bool();
                    break;
                case 20:
                    message.ability_level = reader.uint32();
                    break;
                case 21:
                    message.location_x = reader.float();
                    break;
                case 22:
                    message.location_y = reader.float();
                    break;
                case 23:
                    message.gold_reason = reader.uint32();
                    break;
                case 24:
                    message.timestamp_raw = reader.float();
                    break;
                case 25:
                    message.modifier_duration = reader.float();
                    break;
                case 26:
                    message.xp_reason = reader.uint32();
                    break;
                case 27:
                    message.last_hits = reader.uint32();
                    break;
                case 28:
                    message.attacker_team = reader.uint32();
                    break;
                case 29:
                    message.target_team = reader.uint32();
                    break;
                case 30:
                    message.obs_wards_placed = reader.uint32();
                    break;
                case 31:
                    message.assist_player0 = reader.uint32();
                    break;
                case 32:
                    message.assist_player1 = reader.uint32();
                    break;
                case 33:
                    message.assist_player2 = reader.uint32();
                    break;
                case 34:
                    message.assist_player3 = reader.uint32();
                    break;
                case 35:
                    message.stack_count = reader.uint32();
                    break;
                case 36:
                    message.hidden_modifier = reader.bool();
                    break;
                case 37:
                    message.is_target_building = reader.bool();
                    break;
                case 38:
                    message.neutral_camp_type = reader.uint32();
                    break;
                case 39:
                    message.rune_type = reader.uint32();
                    break;
                case 40:
                    if (!(message.assist_players && message.assist_players.length))
                        message.assist_players = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.assist_players.push(reader.uint32());
                    } else
                        message.assist_players.push(reader.uint32());
                    break;
                case 41:
                    message.is_heal_save = reader.bool();
                    break;
                case 42:
                    message.is_ultimate_ability = reader.bool();
                    break;
                case 43:
                    message.attacker_hero_level = reader.uint32();
                    break;
                case 44:
                    message.target_hero_level = reader.uint32();
                    break;
                case 45:
                    message.xpm = reader.uint32();
                    break;
                case 46:
                    message.gpm = reader.uint32();
                    break;
                case 47:
                    message.event_location = reader.uint32();
                    break;
                case 48:
                    message.target_is_self = reader.bool();
                    break;
                case 49:
                    message.damage_type = reader.uint32();
                    break;
                case 50:
                    message.invisibility_modifier = reader.bool();
                    break;
                case 51:
                    message.damage_category = reader.uint32();
                    break;
                case 52:
                    message.networth = reader.uint32();
                    break;
                case 53:
                    message.building_type = reader.uint32();
                    break;
                case 54:
                    message.modifier_elapsed_duration = reader.float();
                    break;
                case 55:
                    message.silence_modifier = reader.bool();
                    break;
                case 56:
                    message.heal_from_lifesteal = reader.bool();
                    break;
                case 57:
                    message.modifier_purged = reader.bool();
                    break;
                case 58:
                    message.spell_evaded = reader.bool();
                    break;
                case 59:
                    message.motion_controller_modifier = reader.bool();
                    break;
                case 60:
                    message.long_range_kill = reader.bool();
                    break;
                case 61:
                    message.modifier_purge_ability = reader.uint32();
                    break;
                case 62:
                    message.modifier_purge_npc = reader.uint32();
                    break;
                case 63:
                    message.root_modifier = reader.bool();
                    break;
                case 64:
                    message.total_unit_death_count = reader.uint32();
                    break;
                case 65:
                    message.aura_modifier = reader.bool();
                    break;
                case 66:
                    message.armor_debuff_modifier = reader.bool();
                    break;
                case 67:
                    message.no_physical_damage_modifier = reader.bool();
                    break;
                case 68:
                    message.modifier_ability = reader.uint32();
                    break;
                case 69:
                    message.modifier_hidden = reader.bool();
                    break;
                case 70:
                    message.inflictor_is_stolen_ability = reader.bool();
                    break;
                case 71:
                    message.kill_eater_event = reader.uint32();
                    break;
                case 72:
                    message.unit_status_label = reader.uint32();
                    break;
                case 73:
                    message.spell_generated_attack = reader.bool();
                    break;
                case 74:
                    message.at_night_time = reader.bool();
                    break;
                case 75:
                    message.attacker_has_scepter = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTACombatLogEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACombatLogEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTACombatLogEntry message.
         * @function verify
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTACombatLogEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                    break;
                }
            if (message.target_name != null && message.hasOwnProperty("target_name"))
                if (!$util.isInteger(message.target_name))
                    return "target_name: integer expected";
            if (message.target_source_name != null && message.hasOwnProperty("target_source_name"))
                if (!$util.isInteger(message.target_source_name))
                    return "target_source_name: integer expected";
            if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                if (!$util.isInteger(message.attacker_name))
                    return "attacker_name: integer expected";
            if (message.damage_source_name != null && message.hasOwnProperty("damage_source_name"))
                if (!$util.isInteger(message.damage_source_name))
                    return "damage_source_name: integer expected";
            if (message.inflictor_name != null && message.hasOwnProperty("inflictor_name"))
                if (!$util.isInteger(message.inflictor_name))
                    return "inflictor_name: integer expected";
            if (message.is_attacker_illusion != null && message.hasOwnProperty("is_attacker_illusion"))
                if (typeof message.is_attacker_illusion !== "boolean")
                    return "is_attacker_illusion: boolean expected";
            if (message.is_attacker_hero != null && message.hasOwnProperty("is_attacker_hero"))
                if (typeof message.is_attacker_hero !== "boolean")
                    return "is_attacker_hero: boolean expected";
            if (message.is_target_illusion != null && message.hasOwnProperty("is_target_illusion"))
                if (typeof message.is_target_illusion !== "boolean")
                    return "is_target_illusion: boolean expected";
            if (message.is_target_hero != null && message.hasOwnProperty("is_target_hero"))
                if (typeof message.is_target_hero !== "boolean")
                    return "is_target_hero: boolean expected";
            if (message.is_visible_radiant != null && message.hasOwnProperty("is_visible_radiant"))
                if (typeof message.is_visible_radiant !== "boolean")
                    return "is_visible_radiant: boolean expected";
            if (message.is_visible_dire != null && message.hasOwnProperty("is_visible_dire"))
                if (typeof message.is_visible_dire !== "boolean")
                    return "is_visible_dire: boolean expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.health != null && message.hasOwnProperty("health"))
                if (!$util.isInteger(message.health))
                    return "health: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.stun_duration != null && message.hasOwnProperty("stun_duration"))
                if (typeof message.stun_duration !== "number")
                    return "stun_duration: number expected";
            if (message.slow_duration != null && message.hasOwnProperty("slow_duration"))
                if (typeof message.slow_duration !== "number")
                    return "slow_duration: number expected";
            if (message.is_ability_toggle_on != null && message.hasOwnProperty("is_ability_toggle_on"))
                if (typeof message.is_ability_toggle_on !== "boolean")
                    return "is_ability_toggle_on: boolean expected";
            if (message.is_ability_toggle_off != null && message.hasOwnProperty("is_ability_toggle_off"))
                if (typeof message.is_ability_toggle_off !== "boolean")
                    return "is_ability_toggle_off: boolean expected";
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                if (!$util.isInteger(message.ability_level))
                    return "ability_level: integer expected";
            if (message.location_x != null && message.hasOwnProperty("location_x"))
                if (typeof message.location_x !== "number")
                    return "location_x: number expected";
            if (message.location_y != null && message.hasOwnProperty("location_y"))
                if (typeof message.location_y !== "number")
                    return "location_y: number expected";
            if (message.gold_reason != null && message.hasOwnProperty("gold_reason"))
                if (!$util.isInteger(message.gold_reason))
                    return "gold_reason: integer expected";
            if (message.timestamp_raw != null && message.hasOwnProperty("timestamp_raw"))
                if (typeof message.timestamp_raw !== "number")
                    return "timestamp_raw: number expected";
            if (message.modifier_duration != null && message.hasOwnProperty("modifier_duration"))
                if (typeof message.modifier_duration !== "number")
                    return "modifier_duration: number expected";
            if (message.xp_reason != null && message.hasOwnProperty("xp_reason"))
                if (!$util.isInteger(message.xp_reason))
                    return "xp_reason: integer expected";
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                if (!$util.isInteger(message.last_hits))
                    return "last_hits: integer expected";
            if (message.attacker_team != null && message.hasOwnProperty("attacker_team"))
                if (!$util.isInteger(message.attacker_team))
                    return "attacker_team: integer expected";
            if (message.target_team != null && message.hasOwnProperty("target_team"))
                if (!$util.isInteger(message.target_team))
                    return "target_team: integer expected";
            if (message.obs_wards_placed != null && message.hasOwnProperty("obs_wards_placed"))
                if (!$util.isInteger(message.obs_wards_placed))
                    return "obs_wards_placed: integer expected";
            if (message.assist_player0 != null && message.hasOwnProperty("assist_player0"))
                if (!$util.isInteger(message.assist_player0))
                    return "assist_player0: integer expected";
            if (message.assist_player1 != null && message.hasOwnProperty("assist_player1"))
                if (!$util.isInteger(message.assist_player1))
                    return "assist_player1: integer expected";
            if (message.assist_player2 != null && message.hasOwnProperty("assist_player2"))
                if (!$util.isInteger(message.assist_player2))
                    return "assist_player2: integer expected";
            if (message.assist_player3 != null && message.hasOwnProperty("assist_player3"))
                if (!$util.isInteger(message.assist_player3))
                    return "assist_player3: integer expected";
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                if (!$util.isInteger(message.stack_count))
                    return "stack_count: integer expected";
            if (message.hidden_modifier != null && message.hasOwnProperty("hidden_modifier"))
                if (typeof message.hidden_modifier !== "boolean")
                    return "hidden_modifier: boolean expected";
            if (message.is_target_building != null && message.hasOwnProperty("is_target_building"))
                if (typeof message.is_target_building !== "boolean")
                    return "is_target_building: boolean expected";
            if (message.neutral_camp_type != null && message.hasOwnProperty("neutral_camp_type"))
                if (!$util.isInteger(message.neutral_camp_type))
                    return "neutral_camp_type: integer expected";
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                if (!$util.isInteger(message.rune_type))
                    return "rune_type: integer expected";
            if (message.assist_players != null && message.hasOwnProperty("assist_players")) {
                if (!Array.isArray(message.assist_players))
                    return "assist_players: array expected";
                for (var i = 0; i < message.assist_players.length; ++i)
                    if (!$util.isInteger(message.assist_players[i]))
                        return "assist_players: integer[] expected";
            }
            if (message.is_heal_save != null && message.hasOwnProperty("is_heal_save"))
                if (typeof message.is_heal_save !== "boolean")
                    return "is_heal_save: boolean expected";
            if (message.is_ultimate_ability != null && message.hasOwnProperty("is_ultimate_ability"))
                if (typeof message.is_ultimate_ability !== "boolean")
                    return "is_ultimate_ability: boolean expected";
            if (message.attacker_hero_level != null && message.hasOwnProperty("attacker_hero_level"))
                if (!$util.isInteger(message.attacker_hero_level))
                    return "attacker_hero_level: integer expected";
            if (message.target_hero_level != null && message.hasOwnProperty("target_hero_level"))
                if (!$util.isInteger(message.target_hero_level))
                    return "target_hero_level: integer expected";
            if (message.xpm != null && message.hasOwnProperty("xpm"))
                if (!$util.isInteger(message.xpm))
                    return "xpm: integer expected";
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                if (!$util.isInteger(message.gpm))
                    return "gpm: integer expected";
            if (message.event_location != null && message.hasOwnProperty("event_location"))
                if (!$util.isInteger(message.event_location))
                    return "event_location: integer expected";
            if (message.target_is_self != null && message.hasOwnProperty("target_is_self"))
                if (typeof message.target_is_self !== "boolean")
                    return "target_is_self: boolean expected";
            if (message.damage_type != null && message.hasOwnProperty("damage_type"))
                if (!$util.isInteger(message.damage_type))
                    return "damage_type: integer expected";
            if (message.invisibility_modifier != null && message.hasOwnProperty("invisibility_modifier"))
                if (typeof message.invisibility_modifier !== "boolean")
                    return "invisibility_modifier: boolean expected";
            if (message.damage_category != null && message.hasOwnProperty("damage_category"))
                if (!$util.isInteger(message.damage_category))
                    return "damage_category: integer expected";
            if (message.networth != null && message.hasOwnProperty("networth"))
                if (!$util.isInteger(message.networth))
                    return "networth: integer expected";
            if (message.building_type != null && message.hasOwnProperty("building_type"))
                if (!$util.isInteger(message.building_type))
                    return "building_type: integer expected";
            if (message.modifier_elapsed_duration != null && message.hasOwnProperty("modifier_elapsed_duration"))
                if (typeof message.modifier_elapsed_duration !== "number")
                    return "modifier_elapsed_duration: number expected";
            if (message.silence_modifier != null && message.hasOwnProperty("silence_modifier"))
                if (typeof message.silence_modifier !== "boolean")
                    return "silence_modifier: boolean expected";
            if (message.heal_from_lifesteal != null && message.hasOwnProperty("heal_from_lifesteal"))
                if (typeof message.heal_from_lifesteal !== "boolean")
                    return "heal_from_lifesteal: boolean expected";
            if (message.modifier_purged != null && message.hasOwnProperty("modifier_purged"))
                if (typeof message.modifier_purged !== "boolean")
                    return "modifier_purged: boolean expected";
            if (message.spell_evaded != null && message.hasOwnProperty("spell_evaded"))
                if (typeof message.spell_evaded !== "boolean")
                    return "spell_evaded: boolean expected";
            if (message.motion_controller_modifier != null && message.hasOwnProperty("motion_controller_modifier"))
                if (typeof message.motion_controller_modifier !== "boolean")
                    return "motion_controller_modifier: boolean expected";
            if (message.long_range_kill != null && message.hasOwnProperty("long_range_kill"))
                if (typeof message.long_range_kill !== "boolean")
                    return "long_range_kill: boolean expected";
            if (message.modifier_purge_ability != null && message.hasOwnProperty("modifier_purge_ability"))
                if (!$util.isInteger(message.modifier_purge_ability))
                    return "modifier_purge_ability: integer expected";
            if (message.modifier_purge_npc != null && message.hasOwnProperty("modifier_purge_npc"))
                if (!$util.isInteger(message.modifier_purge_npc))
                    return "modifier_purge_npc: integer expected";
            if (message.root_modifier != null && message.hasOwnProperty("root_modifier"))
                if (typeof message.root_modifier !== "boolean")
                    return "root_modifier: boolean expected";
            if (message.total_unit_death_count != null && message.hasOwnProperty("total_unit_death_count"))
                if (!$util.isInteger(message.total_unit_death_count))
                    return "total_unit_death_count: integer expected";
            if (message.aura_modifier != null && message.hasOwnProperty("aura_modifier"))
                if (typeof message.aura_modifier !== "boolean")
                    return "aura_modifier: boolean expected";
            if (message.armor_debuff_modifier != null && message.hasOwnProperty("armor_debuff_modifier"))
                if (typeof message.armor_debuff_modifier !== "boolean")
                    return "armor_debuff_modifier: boolean expected";
            if (message.no_physical_damage_modifier != null && message.hasOwnProperty("no_physical_damage_modifier"))
                if (typeof message.no_physical_damage_modifier !== "boolean")
                    return "no_physical_damage_modifier: boolean expected";
            if (message.modifier_ability != null && message.hasOwnProperty("modifier_ability"))
                if (!$util.isInteger(message.modifier_ability))
                    return "modifier_ability: integer expected";
            if (message.modifier_hidden != null && message.hasOwnProperty("modifier_hidden"))
                if (typeof message.modifier_hidden !== "boolean")
                    return "modifier_hidden: boolean expected";
            if (message.inflictor_is_stolen_ability != null && message.hasOwnProperty("inflictor_is_stolen_ability"))
                if (typeof message.inflictor_is_stolen_ability !== "boolean")
                    return "inflictor_is_stolen_ability: boolean expected";
            if (message.kill_eater_event != null && message.hasOwnProperty("kill_eater_event"))
                if (!$util.isInteger(message.kill_eater_event))
                    return "kill_eater_event: integer expected";
            if (message.unit_status_label != null && message.hasOwnProperty("unit_status_label"))
                if (!$util.isInteger(message.unit_status_label))
                    return "unit_status_label: integer expected";
            if (message.spell_generated_attack != null && message.hasOwnProperty("spell_generated_attack"))
                if (typeof message.spell_generated_attack !== "boolean")
                    return "spell_generated_attack: boolean expected";
            if (message.at_night_time != null && message.hasOwnProperty("at_night_time"))
                if (typeof message.at_night_time !== "boolean")
                    return "at_night_time: boolean expected";
            if (message.attacker_has_scepter != null && message.hasOwnProperty("attacker_has_scepter"))
                if (typeof message.attacker_has_scepter !== "boolean")
                    return "attacker_has_scepter: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTACombatLogEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         */
        CMsgDOTACombatLogEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTACombatLogEntry)
                return object;
            var message = new $root.CMsgDOTACombatLogEntry();
            switch (object.type) {
            case "DOTA_COMBATLOG_INVALID":
            case -1:
                message.type = -1;
                break;
            case "DOTA_COMBATLOG_DAMAGE":
            case 0:
                message.type = 0;
                break;
            case "DOTA_COMBATLOG_HEAL":
            case 1:
                message.type = 1;
                break;
            case "DOTA_COMBATLOG_MODIFIER_ADD":
            case 2:
                message.type = 2;
                break;
            case "DOTA_COMBATLOG_MODIFIER_REMOVE":
            case 3:
                message.type = 3;
                break;
            case "DOTA_COMBATLOG_DEATH":
            case 4:
                message.type = 4;
                break;
            case "DOTA_COMBATLOG_ABILITY":
            case 5:
                message.type = 5;
                break;
            case "DOTA_COMBATLOG_ITEM":
            case 6:
                message.type = 6;
                break;
            case "DOTA_COMBATLOG_LOCATION":
            case 7:
                message.type = 7;
                break;
            case "DOTA_COMBATLOG_GOLD":
            case 8:
                message.type = 8;
                break;
            case "DOTA_COMBATLOG_GAME_STATE":
            case 9:
                message.type = 9;
                break;
            case "DOTA_COMBATLOG_XP":
            case 10:
                message.type = 10;
                break;
            case "DOTA_COMBATLOG_PURCHASE":
            case 11:
                message.type = 11;
                break;
            case "DOTA_COMBATLOG_BUYBACK":
            case 12:
                message.type = 12;
                break;
            case "DOTA_COMBATLOG_ABILITY_TRIGGER":
            case 13:
                message.type = 13;
                break;
            case "DOTA_COMBATLOG_PLAYERSTATS":
            case 14:
                message.type = 14;
                break;
            case "DOTA_COMBATLOG_MULTIKILL":
            case 15:
                message.type = 15;
                break;
            case "DOTA_COMBATLOG_KILLSTREAK":
            case 16:
                message.type = 16;
                break;
            case "DOTA_COMBATLOG_TEAM_BUILDING_KILL":
            case 17:
                message.type = 17;
                break;
            case "DOTA_COMBATLOG_FIRST_BLOOD":
            case 18:
                message.type = 18;
                break;
            case "DOTA_COMBATLOG_MODIFIER_STACK_EVENT":
            case 19:
                message.type = 19;
                break;
            case "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK":
            case 20:
                message.type = 20;
                break;
            case "DOTA_COMBATLOG_PICKUP_RUNE":
            case 21:
                message.type = 21;
                break;
            case "DOTA_COMBATLOG_REVEALED_INVISIBLE":
            case 22:
                message.type = 22;
                break;
            case "DOTA_COMBATLOG_HERO_SAVED":
            case 23:
                message.type = 23;
                break;
            case "DOTA_COMBATLOG_MANA_RESTORED":
            case 24:
                message.type = 24;
                break;
            case "DOTA_COMBATLOG_HERO_LEVELUP":
            case 25:
                message.type = 25;
                break;
            case "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY":
            case 26:
                message.type = 26;
                break;
            case "DOTA_COMBATLOG_ENDGAME_STATS":
            case 27:
                message.type = 27;
                break;
            case "DOTA_COMBATLOG_INTERRUPT_CHANNEL":
            case 28:
                message.type = 28;
                break;
            case "DOTA_COMBATLOG_ALLIED_GOLD":
            case 29:
                message.type = 29;
                break;
            case "DOTA_COMBATLOG_AEGIS_TAKEN":
            case 30:
                message.type = 30;
                break;
            case "DOTA_COMBATLOG_MANA_DAMAGE":
            case 31:
                message.type = 31;
                break;
            case "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED":
            case 32:
                message.type = 32;
                break;
            case "DOTA_COMBATLOG_UNIT_SUMMONED":
            case 33:
                message.type = 33;
                break;
            case "DOTA_COMBATLOG_ATTACK_EVADE":
            case 34:
                message.type = 34;
                break;
            case "DOTA_COMBATLOG_TREE_CUT":
            case 35:
                message.type = 35;
                break;
            case "DOTA_COMBATLOG_SUCCESSFUL_SCAN":
            case 36:
                message.type = 36;
                break;
            case "DOTA_COMBATLOG_END_KILLSTREAK":
            case 37:
                message.type = 37;
                break;
            case "DOTA_COMBATLOG_BLOODSTONE_CHARGE":
            case 38:
                message.type = 38;
                break;
            case "DOTA_COMBATLOG_CRITICAL_DAMAGE":
            case 39:
                message.type = 39;
                break;
            case "DOTA_COMBATLOG_SPELL_ABSORB":
            case 40:
                message.type = 40;
                break;
            case "DOTA_COMBATLOG_UNIT_TELEPORTED":
            case 41:
                message.type = 41;
                break;
            case "DOTA_COMBATLOG_KILL_EATER_EVENT":
            case 42:
                message.type = 42;
                break;
            }
            if (object.target_name != null)
                message.target_name = object.target_name >>> 0;
            if (object.target_source_name != null)
                message.target_source_name = object.target_source_name >>> 0;
            if (object.attacker_name != null)
                message.attacker_name = object.attacker_name >>> 0;
            if (object.damage_source_name != null)
                message.damage_source_name = object.damage_source_name >>> 0;
            if (object.inflictor_name != null)
                message.inflictor_name = object.inflictor_name >>> 0;
            if (object.is_attacker_illusion != null)
                message.is_attacker_illusion = Boolean(object.is_attacker_illusion);
            if (object.is_attacker_hero != null)
                message.is_attacker_hero = Boolean(object.is_attacker_hero);
            if (object.is_target_illusion != null)
                message.is_target_illusion = Boolean(object.is_target_illusion);
            if (object.is_target_hero != null)
                message.is_target_hero = Boolean(object.is_target_hero);
            if (object.is_visible_radiant != null)
                message.is_visible_radiant = Boolean(object.is_visible_radiant);
            if (object.is_visible_dire != null)
                message.is_visible_dire = Boolean(object.is_visible_dire);
            if (object.value != null)
                message.value = object.value >>> 0;
            if (object.health != null)
                message.health = object.health | 0;
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.stun_duration != null)
                message.stun_duration = Number(object.stun_duration);
            if (object.slow_duration != null)
                message.slow_duration = Number(object.slow_duration);
            if (object.is_ability_toggle_on != null)
                message.is_ability_toggle_on = Boolean(object.is_ability_toggle_on);
            if (object.is_ability_toggle_off != null)
                message.is_ability_toggle_off = Boolean(object.is_ability_toggle_off);
            if (object.ability_level != null)
                message.ability_level = object.ability_level >>> 0;
            if (object.location_x != null)
                message.location_x = Number(object.location_x);
            if (object.location_y != null)
                message.location_y = Number(object.location_y);
            if (object.gold_reason != null)
                message.gold_reason = object.gold_reason >>> 0;
            if (object.timestamp_raw != null)
                message.timestamp_raw = Number(object.timestamp_raw);
            if (object.modifier_duration != null)
                message.modifier_duration = Number(object.modifier_duration);
            if (object.xp_reason != null)
                message.xp_reason = object.xp_reason >>> 0;
            if (object.last_hits != null)
                message.last_hits = object.last_hits >>> 0;
            if (object.attacker_team != null)
                message.attacker_team = object.attacker_team >>> 0;
            if (object.target_team != null)
                message.target_team = object.target_team >>> 0;
            if (object.obs_wards_placed != null)
                message.obs_wards_placed = object.obs_wards_placed >>> 0;
            if (object.assist_player0 != null)
                message.assist_player0 = object.assist_player0 >>> 0;
            if (object.assist_player1 != null)
                message.assist_player1 = object.assist_player1 >>> 0;
            if (object.assist_player2 != null)
                message.assist_player2 = object.assist_player2 >>> 0;
            if (object.assist_player3 != null)
                message.assist_player3 = object.assist_player3 >>> 0;
            if (object.stack_count != null)
                message.stack_count = object.stack_count >>> 0;
            if (object.hidden_modifier != null)
                message.hidden_modifier = Boolean(object.hidden_modifier);
            if (object.is_target_building != null)
                message.is_target_building = Boolean(object.is_target_building);
            if (object.neutral_camp_type != null)
                message.neutral_camp_type = object.neutral_camp_type >>> 0;
            if (object.rune_type != null)
                message.rune_type = object.rune_type >>> 0;
            if (object.assist_players) {
                if (!Array.isArray(object.assist_players))
                    throw TypeError(".CMsgDOTACombatLogEntry.assist_players: array expected");
                message.assist_players = [];
                for (var i = 0; i < object.assist_players.length; ++i)
                    message.assist_players[i] = object.assist_players[i] >>> 0;
            }
            if (object.is_heal_save != null)
                message.is_heal_save = Boolean(object.is_heal_save);
            if (object.is_ultimate_ability != null)
                message.is_ultimate_ability = Boolean(object.is_ultimate_ability);
            if (object.attacker_hero_level != null)
                message.attacker_hero_level = object.attacker_hero_level >>> 0;
            if (object.target_hero_level != null)
                message.target_hero_level = object.target_hero_level >>> 0;
            if (object.xpm != null)
                message.xpm = object.xpm >>> 0;
            if (object.gpm != null)
                message.gpm = object.gpm >>> 0;
            if (object.event_location != null)
                message.event_location = object.event_location >>> 0;
            if (object.target_is_self != null)
                message.target_is_self = Boolean(object.target_is_self);
            if (object.damage_type != null)
                message.damage_type = object.damage_type >>> 0;
            if (object.invisibility_modifier != null)
                message.invisibility_modifier = Boolean(object.invisibility_modifier);
            if (object.damage_category != null)
                message.damage_category = object.damage_category >>> 0;
            if (object.networth != null)
                message.networth = object.networth >>> 0;
            if (object.building_type != null)
                message.building_type = object.building_type >>> 0;
            if (object.modifier_elapsed_duration != null)
                message.modifier_elapsed_duration = Number(object.modifier_elapsed_duration);
            if (object.silence_modifier != null)
                message.silence_modifier = Boolean(object.silence_modifier);
            if (object.heal_from_lifesteal != null)
                message.heal_from_lifesteal = Boolean(object.heal_from_lifesteal);
            if (object.modifier_purged != null)
                message.modifier_purged = Boolean(object.modifier_purged);
            if (object.spell_evaded != null)
                message.spell_evaded = Boolean(object.spell_evaded);
            if (object.motion_controller_modifier != null)
                message.motion_controller_modifier = Boolean(object.motion_controller_modifier);
            if (object.long_range_kill != null)
                message.long_range_kill = Boolean(object.long_range_kill);
            if (object.modifier_purge_ability != null)
                message.modifier_purge_ability = object.modifier_purge_ability >>> 0;
            if (object.modifier_purge_npc != null)
                message.modifier_purge_npc = object.modifier_purge_npc >>> 0;
            if (object.root_modifier != null)
                message.root_modifier = Boolean(object.root_modifier);
            if (object.total_unit_death_count != null)
                message.total_unit_death_count = object.total_unit_death_count >>> 0;
            if (object.aura_modifier != null)
                message.aura_modifier = Boolean(object.aura_modifier);
            if (object.armor_debuff_modifier != null)
                message.armor_debuff_modifier = Boolean(object.armor_debuff_modifier);
            if (object.no_physical_damage_modifier != null)
                message.no_physical_damage_modifier = Boolean(object.no_physical_damage_modifier);
            if (object.modifier_ability != null)
                message.modifier_ability = object.modifier_ability >>> 0;
            if (object.modifier_hidden != null)
                message.modifier_hidden = Boolean(object.modifier_hidden);
            if (object.inflictor_is_stolen_ability != null)
                message.inflictor_is_stolen_ability = Boolean(object.inflictor_is_stolen_ability);
            if (object.kill_eater_event != null)
                message.kill_eater_event = object.kill_eater_event >>> 0;
            if (object.unit_status_label != null)
                message.unit_status_label = object.unit_status_label >>> 0;
            if (object.spell_generated_attack != null)
                message.spell_generated_attack = Boolean(object.spell_generated_attack);
            if (object.at_night_time != null)
                message.at_night_time = Boolean(object.at_night_time);
            if (object.attacker_has_scepter != null)
                message.attacker_has_scepter = Boolean(object.attacker_has_scepter);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTACombatLogEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {CMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTACombatLogEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.assist_players = [];
            if (options.defaults) {
                object.type = options.enums === String ? "DOTA_COMBATLOG_INVALID" : -1;
                object.target_name = 0;
                object.target_source_name = 0;
                object.attacker_name = 0;
                object.damage_source_name = 0;
                object.inflictor_name = 0;
                object.is_attacker_illusion = false;
                object.is_attacker_hero = false;
                object.is_target_illusion = false;
                object.is_target_hero = false;
                object.is_visible_radiant = false;
                object.is_visible_dire = false;
                object.value = 0;
                object.health = 0;
                object.timestamp = 0;
                object.stun_duration = 0;
                object.slow_duration = 0;
                object.is_ability_toggle_on = false;
                object.is_ability_toggle_off = false;
                object.ability_level = 0;
                object.location_x = 0;
                object.location_y = 0;
                object.gold_reason = 0;
                object.timestamp_raw = 0;
                object.modifier_duration = 0;
                object.xp_reason = 0;
                object.last_hits = 0;
                object.attacker_team = 0;
                object.target_team = 0;
                object.obs_wards_placed = 0;
                object.assist_player0 = 0;
                object.assist_player1 = 0;
                object.assist_player2 = 0;
                object.assist_player3 = 0;
                object.stack_count = 0;
                object.hidden_modifier = false;
                object.is_target_building = false;
                object.neutral_camp_type = 0;
                object.rune_type = 0;
                object.is_heal_save = false;
                object.is_ultimate_ability = false;
                object.attacker_hero_level = 0;
                object.target_hero_level = 0;
                object.xpm = 0;
                object.gpm = 0;
                object.event_location = 0;
                object.target_is_self = false;
                object.damage_type = 0;
                object.invisibility_modifier = false;
                object.damage_category = 0;
                object.networth = 0;
                object.building_type = 0;
                object.modifier_elapsed_duration = 0;
                object.silence_modifier = false;
                object.heal_from_lifesteal = false;
                object.modifier_purged = false;
                object.spell_evaded = false;
                object.motion_controller_modifier = false;
                object.long_range_kill = false;
                object.modifier_purge_ability = 0;
                object.modifier_purge_npc = 0;
                object.root_modifier = false;
                object.total_unit_death_count = 0;
                object.aura_modifier = false;
                object.armor_debuff_modifier = false;
                object.no_physical_damage_modifier = false;
                object.modifier_ability = 0;
                object.modifier_hidden = false;
                object.inflictor_is_stolen_ability = false;
                object.kill_eater_event = 0;
                object.unit_status_label = 0;
                object.spell_generated_attack = false;
                object.at_night_time = false;
                object.attacker_has_scepter = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.DOTA_COMBATLOG_TYPES[message.type] : message.type;
            if (message.target_name != null && message.hasOwnProperty("target_name"))
                object.target_name = message.target_name;
            if (message.target_source_name != null && message.hasOwnProperty("target_source_name"))
                object.target_source_name = message.target_source_name;
            if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                object.attacker_name = message.attacker_name;
            if (message.damage_source_name != null && message.hasOwnProperty("damage_source_name"))
                object.damage_source_name = message.damage_source_name;
            if (message.inflictor_name != null && message.hasOwnProperty("inflictor_name"))
                object.inflictor_name = message.inflictor_name;
            if (message.is_attacker_illusion != null && message.hasOwnProperty("is_attacker_illusion"))
                object.is_attacker_illusion = message.is_attacker_illusion;
            if (message.is_attacker_hero != null && message.hasOwnProperty("is_attacker_hero"))
                object.is_attacker_hero = message.is_attacker_hero;
            if (message.is_target_illusion != null && message.hasOwnProperty("is_target_illusion"))
                object.is_target_illusion = message.is_target_illusion;
            if (message.is_target_hero != null && message.hasOwnProperty("is_target_hero"))
                object.is_target_hero = message.is_target_hero;
            if (message.is_visible_radiant != null && message.hasOwnProperty("is_visible_radiant"))
                object.is_visible_radiant = message.is_visible_radiant;
            if (message.is_visible_dire != null && message.hasOwnProperty("is_visible_dire"))
                object.is_visible_dire = message.is_visible_dire;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = message.health;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.stun_duration != null && message.hasOwnProperty("stun_duration"))
                object.stun_duration = options.json && !isFinite(message.stun_duration) ? String(message.stun_duration) : message.stun_duration;
            if (message.slow_duration != null && message.hasOwnProperty("slow_duration"))
                object.slow_duration = options.json && !isFinite(message.slow_duration) ? String(message.slow_duration) : message.slow_duration;
            if (message.is_ability_toggle_on != null && message.hasOwnProperty("is_ability_toggle_on"))
                object.is_ability_toggle_on = message.is_ability_toggle_on;
            if (message.is_ability_toggle_off != null && message.hasOwnProperty("is_ability_toggle_off"))
                object.is_ability_toggle_off = message.is_ability_toggle_off;
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                object.ability_level = message.ability_level;
            if (message.location_x != null && message.hasOwnProperty("location_x"))
                object.location_x = options.json && !isFinite(message.location_x) ? String(message.location_x) : message.location_x;
            if (message.location_y != null && message.hasOwnProperty("location_y"))
                object.location_y = options.json && !isFinite(message.location_y) ? String(message.location_y) : message.location_y;
            if (message.gold_reason != null && message.hasOwnProperty("gold_reason"))
                object.gold_reason = message.gold_reason;
            if (message.timestamp_raw != null && message.hasOwnProperty("timestamp_raw"))
                object.timestamp_raw = options.json && !isFinite(message.timestamp_raw) ? String(message.timestamp_raw) : message.timestamp_raw;
            if (message.modifier_duration != null && message.hasOwnProperty("modifier_duration"))
                object.modifier_duration = options.json && !isFinite(message.modifier_duration) ? String(message.modifier_duration) : message.modifier_duration;
            if (message.xp_reason != null && message.hasOwnProperty("xp_reason"))
                object.xp_reason = message.xp_reason;
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                object.last_hits = message.last_hits;
            if (message.attacker_team != null && message.hasOwnProperty("attacker_team"))
                object.attacker_team = message.attacker_team;
            if (message.target_team != null && message.hasOwnProperty("target_team"))
                object.target_team = message.target_team;
            if (message.obs_wards_placed != null && message.hasOwnProperty("obs_wards_placed"))
                object.obs_wards_placed = message.obs_wards_placed;
            if (message.assist_player0 != null && message.hasOwnProperty("assist_player0"))
                object.assist_player0 = message.assist_player0;
            if (message.assist_player1 != null && message.hasOwnProperty("assist_player1"))
                object.assist_player1 = message.assist_player1;
            if (message.assist_player2 != null && message.hasOwnProperty("assist_player2"))
                object.assist_player2 = message.assist_player2;
            if (message.assist_player3 != null && message.hasOwnProperty("assist_player3"))
                object.assist_player3 = message.assist_player3;
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                object.stack_count = message.stack_count;
            if (message.hidden_modifier != null && message.hasOwnProperty("hidden_modifier"))
                object.hidden_modifier = message.hidden_modifier;
            if (message.is_target_building != null && message.hasOwnProperty("is_target_building"))
                object.is_target_building = message.is_target_building;
            if (message.neutral_camp_type != null && message.hasOwnProperty("neutral_camp_type"))
                object.neutral_camp_type = message.neutral_camp_type;
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                object.rune_type = message.rune_type;
            if (message.assist_players && message.assist_players.length) {
                object.assist_players = [];
                for (var j = 0; j < message.assist_players.length; ++j)
                    object.assist_players[j] = message.assist_players[j];
            }
            if (message.is_heal_save != null && message.hasOwnProperty("is_heal_save"))
                object.is_heal_save = message.is_heal_save;
            if (message.is_ultimate_ability != null && message.hasOwnProperty("is_ultimate_ability"))
                object.is_ultimate_ability = message.is_ultimate_ability;
            if (message.attacker_hero_level != null && message.hasOwnProperty("attacker_hero_level"))
                object.attacker_hero_level = message.attacker_hero_level;
            if (message.target_hero_level != null && message.hasOwnProperty("target_hero_level"))
                object.target_hero_level = message.target_hero_level;
            if (message.xpm != null && message.hasOwnProperty("xpm"))
                object.xpm = message.xpm;
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                object.gpm = message.gpm;
            if (message.event_location != null && message.hasOwnProperty("event_location"))
                object.event_location = message.event_location;
            if (message.target_is_self != null && message.hasOwnProperty("target_is_self"))
                object.target_is_self = message.target_is_self;
            if (message.damage_type != null && message.hasOwnProperty("damage_type"))
                object.damage_type = message.damage_type;
            if (message.invisibility_modifier != null && message.hasOwnProperty("invisibility_modifier"))
                object.invisibility_modifier = message.invisibility_modifier;
            if (message.damage_category != null && message.hasOwnProperty("damage_category"))
                object.damage_category = message.damage_category;
            if (message.networth != null && message.hasOwnProperty("networth"))
                object.networth = message.networth;
            if (message.building_type != null && message.hasOwnProperty("building_type"))
                object.building_type = message.building_type;
            if (message.modifier_elapsed_duration != null && message.hasOwnProperty("modifier_elapsed_duration"))
                object.modifier_elapsed_duration = options.json && !isFinite(message.modifier_elapsed_duration) ? String(message.modifier_elapsed_duration) : message.modifier_elapsed_duration;
            if (message.silence_modifier != null && message.hasOwnProperty("silence_modifier"))
                object.silence_modifier = message.silence_modifier;
            if (message.heal_from_lifesteal != null && message.hasOwnProperty("heal_from_lifesteal"))
                object.heal_from_lifesteal = message.heal_from_lifesteal;
            if (message.modifier_purged != null && message.hasOwnProperty("modifier_purged"))
                object.modifier_purged = message.modifier_purged;
            if (message.spell_evaded != null && message.hasOwnProperty("spell_evaded"))
                object.spell_evaded = message.spell_evaded;
            if (message.motion_controller_modifier != null && message.hasOwnProperty("motion_controller_modifier"))
                object.motion_controller_modifier = message.motion_controller_modifier;
            if (message.long_range_kill != null && message.hasOwnProperty("long_range_kill"))
                object.long_range_kill = message.long_range_kill;
            if (message.modifier_purge_ability != null && message.hasOwnProperty("modifier_purge_ability"))
                object.modifier_purge_ability = message.modifier_purge_ability;
            if (message.modifier_purge_npc != null && message.hasOwnProperty("modifier_purge_npc"))
                object.modifier_purge_npc = message.modifier_purge_npc;
            if (message.root_modifier != null && message.hasOwnProperty("root_modifier"))
                object.root_modifier = message.root_modifier;
            if (message.total_unit_death_count != null && message.hasOwnProperty("total_unit_death_count"))
                object.total_unit_death_count = message.total_unit_death_count;
            if (message.aura_modifier != null && message.hasOwnProperty("aura_modifier"))
                object.aura_modifier = message.aura_modifier;
            if (message.armor_debuff_modifier != null && message.hasOwnProperty("armor_debuff_modifier"))
                object.armor_debuff_modifier = message.armor_debuff_modifier;
            if (message.no_physical_damage_modifier != null && message.hasOwnProperty("no_physical_damage_modifier"))
                object.no_physical_damage_modifier = message.no_physical_damage_modifier;
            if (message.modifier_ability != null && message.hasOwnProperty("modifier_ability"))
                object.modifier_ability = message.modifier_ability;
            if (message.modifier_hidden != null && message.hasOwnProperty("modifier_hidden"))
                object.modifier_hidden = message.modifier_hidden;
            if (message.inflictor_is_stolen_ability != null && message.hasOwnProperty("inflictor_is_stolen_ability"))
                object.inflictor_is_stolen_ability = message.inflictor_is_stolen_ability;
            if (message.kill_eater_event != null && message.hasOwnProperty("kill_eater_event"))
                object.kill_eater_event = message.kill_eater_event;
            if (message.unit_status_label != null && message.hasOwnProperty("unit_status_label"))
                object.unit_status_label = message.unit_status_label;
            if (message.spell_generated_attack != null && message.hasOwnProperty("spell_generated_attack"))
                object.spell_generated_attack = message.spell_generated_attack;
            if (message.at_night_time != null && message.hasOwnProperty("at_night_time"))
                object.at_night_time = message.at_night_time;
            if (message.attacker_has_scepter != null && message.hasOwnProperty("attacker_has_scepter"))
                object.attacker_has_scepter = message.attacker_has_scepter;
            return object;
        };
    
        /**
         * Converts this CMsgDOTACombatLogEntry to JSON.
         * @function toJSON
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTACombatLogEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTACombatLogEntry;
    })();
    
    $root.CMsgPendingEventAward = (function() {
    
        /**
         * Properties of a CMsgPendingEventAward.
         * @exports ICMsgPendingEventAward
         * @interface ICMsgPendingEventAward
         * @property {EEvent|null} [event_id] CMsgPendingEventAward event_id
         * @property {number|null} [action_id] CMsgPendingEventAward action_id
         * @property {number|null} [num_to_grant] CMsgPendingEventAward num_to_grant
         * @property {EEventActionScoreMode|null} [score_mode] CMsgPendingEventAward score_mode
         * @property {number|null} [audit_action] CMsgPendingEventAward audit_action
         */
    
        /**
         * Constructs a new CMsgPendingEventAward.
         * @exports CMsgPendingEventAward
         * @classdesc Represents a CMsgPendingEventAward.
         * @implements ICMsgPendingEventAward
         * @constructor
         * @param {ICMsgPendingEventAward=} [properties] Properties to set
         */
        function CMsgPendingEventAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPendingEventAward event_id.
         * @member {EEvent} event_id
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.event_id = 0;
    
        /**
         * CMsgPendingEventAward action_id.
         * @member {number} action_id
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.action_id = 0;
    
        /**
         * CMsgPendingEventAward num_to_grant.
         * @member {number} num_to_grant
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.num_to_grant = 0;
    
        /**
         * CMsgPendingEventAward score_mode.
         * @member {EEventActionScoreMode} score_mode
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.score_mode = 0;
    
        /**
         * CMsgPendingEventAward audit_action.
         * @member {number} audit_action
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.audit_action = 0;
    
        /**
         * Creates a new CMsgPendingEventAward instance using the specified properties.
         * @function create
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward=} [properties] Properties to set
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward instance
         */
        CMsgPendingEventAward.create = function create(properties) {
            return new CMsgPendingEventAward(properties);
        };
    
        /**
         * Encodes the specified CMsgPendingEventAward message. Does not implicitly {@link CMsgPendingEventAward.verify|verify} messages.
         * @function encode
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward} message CMsgPendingEventAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPendingEventAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event_id);
            if (message.action_id != null && Object.hasOwnProperty.call(message, "action_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.action_id);
            if (message.num_to_grant != null && Object.hasOwnProperty.call(message, "num_to_grant"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_to_grant);
            if (message.score_mode != null && Object.hasOwnProperty.call(message, "score_mode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.score_mode);
            if (message.audit_action != null && Object.hasOwnProperty.call(message, "audit_action"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.audit_action);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPendingEventAward message, length delimited. Does not implicitly {@link CMsgPendingEventAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward} message CMsgPendingEventAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPendingEventAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPendingEventAward message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPendingEventAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPendingEventAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPendingEventAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_id = reader.int32();
                    break;
                case 2:
                    message.action_id = reader.uint32();
                    break;
                case 3:
                    message.num_to_grant = reader.uint32();
                    break;
                case 4:
                    message.score_mode = reader.int32();
                    break;
                case 5:
                    message.audit_action = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPendingEventAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPendingEventAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPendingEventAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPendingEventAward message.
         * @function verify
         * @memberof CMsgPendingEventAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPendingEventAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                switch (message.event_id) {
                default:
                    return "event_id: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                    break;
                }
            if (message.action_id != null && message.hasOwnProperty("action_id"))
                if (!$util.isInteger(message.action_id))
                    return "action_id: integer expected";
            if (message.num_to_grant != null && message.hasOwnProperty("num_to_grant"))
                if (!$util.isInteger(message.num_to_grant))
                    return "num_to_grant: integer expected";
            if (message.score_mode != null && message.hasOwnProperty("score_mode"))
                switch (message.score_mode) {
                default:
                    return "score_mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.audit_action != null && message.hasOwnProperty("audit_action"))
                if (!$util.isInteger(message.audit_action))
                    return "audit_action: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgPendingEventAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPendingEventAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         */
        CMsgPendingEventAward.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPendingEventAward)
                return object;
            var message = new $root.CMsgPendingEventAward();
            switch (object.event_id) {
            case "EVENT_ID_NONE":
            case 0:
                message.event_id = 0;
                break;
            case "EVENT_ID_DIRETIDE":
            case 1:
                message.event_id = 1;
                break;
            case "EVENT_ID_SPRING_FESTIVAL":
            case 2:
                message.event_id = 2;
                break;
            case "EVENT_ID_FROSTIVUS_2013":
            case 3:
                message.event_id = 3;
                break;
            case "EVENT_ID_COMPENDIUM_2014":
            case 4:
                message.event_id = 4;
                break;
            case "EVENT_ID_NEXON_PC_BANG":
            case 5:
                message.event_id = 5;
                break;
            case "EVENT_ID_PWRD_DAC_2015":
            case 6:
                message.event_id = 6;
                break;
            case "EVENT_ID_NEW_BLOOM_2015":
            case 7:
                message.event_id = 7;
                break;
            case "EVENT_ID_INTERNATIONAL_2015":
            case 8:
                message.event_id = 8;
                break;
            case "EVENT_ID_FALL_MAJOR_2015":
            case 9:
                message.event_id = 9;
                break;
            case "EVENT_ID_ORACLE_PA":
            case 10:
                message.event_id = 10;
                break;
            case "EVENT_ID_NEW_BLOOM_2015_PREBEAST":
            case 11:
                message.event_id = 11;
                break;
            case "EVENT_ID_FROSTIVUS":
            case 12:
                message.event_id = 12;
                break;
            case "EVENT_ID_WINTER_MAJOR_2016":
            case 13:
                message.event_id = 13;
                break;
            case "EVENT_ID_INTERNATIONAL_2016":
            case 14:
                message.event_id = 14;
                break;
            case "EVENT_ID_FALL_MAJOR_2016":
            case 15:
                message.event_id = 15;
                break;
            case "EVENT_ID_WINTER_MAJOR_2017":
            case 16:
                message.event_id = 16;
                break;
            case "EVENT_ID_NEW_BLOOM_2017":
            case 17:
                message.event_id = 17;
                break;
            case "EVENT_ID_INTERNATIONAL_2017":
            case 18:
                message.event_id = 18;
                break;
            case "EVENT_ID_PLUS_SUBSCRIPTION":
            case 19:
                message.event_id = 19;
                break;
            case "EVENT_ID_SINGLES_DAY_2017":
            case 20:
                message.event_id = 20;
                break;
            case "EVENT_ID_FROSTIVUS_2017":
            case 21:
                message.event_id = 21;
                break;
            case "EVENT_ID_INTERNATIONAL_2018":
            case 22:
                message.event_id = 22;
                break;
            case "EVENT_ID_FROSTIVUS_2018":
            case 23:
                message.event_id = 23;
                break;
            case "EVENT_ID_NEW_BLOOM_2019":
            case 24:
                message.event_id = 24;
                break;
            case "EVENT_ID_INTERNATIONAL_2019":
            case 25:
                message.event_id = 25;
                break;
            case "EVENT_ID_NEW_PLAYER_EXPERIENCE":
            case 26:
                message.event_id = 26;
                break;
            case "EVENT_ID_FROSTIVUS_2019":
            case 27:
                message.event_id = 27;
                break;
            case "EVENT_ID_NEW_BLOOM_2020":
            case 28:
                message.event_id = 28;
                break;
            case "EVENT_ID_INTERNATIONAL_2020":
            case 29:
                message.event_id = 29;
                break;
            case "EVENT_ID_TEAM_FANDOM":
            case 30:
                message.event_id = 30;
                break;
            case "EVENT_ID_DIRETIDE_2020":
            case 31:
                message.event_id = 31;
                break;
            case "EVENT_ID_COUNT":
            case 32:
                message.event_id = 32;
                break;
            }
            if (object.action_id != null)
                message.action_id = object.action_id >>> 0;
            if (object.num_to_grant != null)
                message.num_to_grant = object.num_to_grant >>> 0;
            switch (object.score_mode) {
            case "k_eEventActionScoreMode_Add":
            case 0:
                message.score_mode = 0;
                break;
            case "k_eEventActionScoreMode_Min":
            case 1:
                message.score_mode = 1;
                break;
            }
            if (object.audit_action != null)
                message.audit_action = object.audit_action >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPendingEventAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPendingEventAward
         * @static
         * @param {CMsgPendingEventAward} message CMsgPendingEventAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPendingEventAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_id = options.enums === String ? "EVENT_ID_NONE" : 0;
                object.action_id = 0;
                object.num_to_grant = 0;
                object.score_mode = options.enums === String ? "k_eEventActionScoreMode_Add" : 0;
                object.audit_action = 0;
            }
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = options.enums === String ? $root.EEvent[message.event_id] : message.event_id;
            if (message.action_id != null && message.hasOwnProperty("action_id"))
                object.action_id = message.action_id;
            if (message.num_to_grant != null && message.hasOwnProperty("num_to_grant"))
                object.num_to_grant = message.num_to_grant;
            if (message.score_mode != null && message.hasOwnProperty("score_mode"))
                object.score_mode = options.enums === String ? $root.EEventActionScoreMode[message.score_mode] : message.score_mode;
            if (message.audit_action != null && message.hasOwnProperty("audit_action"))
                object.audit_action = message.audit_action;
            return object;
        };
    
        /**
         * Converts this CMsgPendingEventAward to JSON.
         * @function toJSON
         * @memberof CMsgPendingEventAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPendingEventAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPendingEventAward;
    })();

    return $root;
});
