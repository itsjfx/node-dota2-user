/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * DOTA_2013PassportSelectionIndices enum.
     * @exports DOTA_2013PassportSelectionIndices
     * @enum {number}
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_0=0 PP13_SEL_ALLSTAR_PLAYER_0 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_1=1 PP13_SEL_ALLSTAR_PLAYER_1 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_2=2 PP13_SEL_ALLSTAR_PLAYER_2 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_3=3 PP13_SEL_ALLSTAR_PLAYER_3 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_4=4 PP13_SEL_ALLSTAR_PLAYER_4 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_5=5 PP13_SEL_ALLSTAR_PLAYER_5 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_6=6 PP13_SEL_ALLSTAR_PLAYER_6 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_7=7 PP13_SEL_ALLSTAR_PLAYER_7 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_8=8 PP13_SEL_ALLSTAR_PLAYER_8 value
     * @property {number} PP13_SEL_ALLSTAR_PLAYER_9=9 PP13_SEL_ALLSTAR_PLAYER_9 value
     * @property {number} PP13_SEL_QUALPRED_WEST_0=10 PP13_SEL_QUALPRED_WEST_0 value
     * @property {number} PP13_SEL_QUALPRED_WEST_1=11 PP13_SEL_QUALPRED_WEST_1 value
     * @property {number} PP13_SEL_QUALPRED_WEST_2=12 PP13_SEL_QUALPRED_WEST_2 value
     * @property {number} PP13_SEL_QUALPRED_WEST_3=13 PP13_SEL_QUALPRED_WEST_3 value
     * @property {number} PP13_SEL_QUALPRED_WEST_4=14 PP13_SEL_QUALPRED_WEST_4 value
     * @property {number} PP13_SEL_QUALPRED_WEST_5=15 PP13_SEL_QUALPRED_WEST_5 value
     * @property {number} PP13_SEL_QUALPRED_WEST_6=16 PP13_SEL_QUALPRED_WEST_6 value
     * @property {number} PP13_SEL_QUALPRED_WEST_7=17 PP13_SEL_QUALPRED_WEST_7 value
     * @property {number} PP13_SEL_QUALPRED_WEST_8=18 PP13_SEL_QUALPRED_WEST_8 value
     * @property {number} PP13_SEL_QUALPRED_WEST_9=19 PP13_SEL_QUALPRED_WEST_9 value
     * @property {number} PP13_SEL_QUALPRED_WEST_10=20 PP13_SEL_QUALPRED_WEST_10 value
     * @property {number} PP13_SEL_QUALPRED_WEST_11=21 PP13_SEL_QUALPRED_WEST_11 value
     * @property {number} PP13_SEL_QUALPRED_WEST_12=22 PP13_SEL_QUALPRED_WEST_12 value
     * @property {number} PP13_SEL_QUALPRED_WEST_13=23 PP13_SEL_QUALPRED_WEST_13 value
     * @property {number} PP13_SEL_QUALPRED_WEST_14=24 PP13_SEL_QUALPRED_WEST_14 value
     * @property {number} PP13_SEL_QUALPRED_EAST_0=25 PP13_SEL_QUALPRED_EAST_0 value
     * @property {number} PP13_SEL_QUALPRED_EAST_1=26 PP13_SEL_QUALPRED_EAST_1 value
     * @property {number} PP13_SEL_QUALPRED_EAST_2=27 PP13_SEL_QUALPRED_EAST_2 value
     * @property {number} PP13_SEL_QUALPRED_EAST_3=28 PP13_SEL_QUALPRED_EAST_3 value
     * @property {number} PP13_SEL_QUALPRED_EAST_4=29 PP13_SEL_QUALPRED_EAST_4 value
     * @property {number} PP13_SEL_QUALPRED_EAST_5=30 PP13_SEL_QUALPRED_EAST_5 value
     * @property {number} PP13_SEL_QUALPRED_EAST_6=31 PP13_SEL_QUALPRED_EAST_6 value
     * @property {number} PP13_SEL_QUALPRED_EAST_7=32 PP13_SEL_QUALPRED_EAST_7 value
     * @property {number} PP13_SEL_QUALPRED_EAST_8=33 PP13_SEL_QUALPRED_EAST_8 value
     * @property {number} PP13_SEL_QUALPRED_EAST_9=34 PP13_SEL_QUALPRED_EAST_9 value
     * @property {number} PP13_SEL_QUALPRED_EAST_10=35 PP13_SEL_QUALPRED_EAST_10 value
     * @property {number} PP13_SEL_QUALPRED_EAST_11=36 PP13_SEL_QUALPRED_EAST_11 value
     * @property {number} PP13_SEL_QUALPRED_EAST_12=37 PP13_SEL_QUALPRED_EAST_12 value
     * @property {number} PP13_SEL_QUALPRED_EAST_13=38 PP13_SEL_QUALPRED_EAST_13 value
     * @property {number} PP13_SEL_QUALPRED_EAST_14=39 PP13_SEL_QUALPRED_EAST_14 value
     * @property {number} PP13_SEL_TEAMCUP_TEAM=40 PP13_SEL_TEAMCUP_TEAM value
     * @property {number} PP13_SEL_TEAMCUP_PLAYER=41 PP13_SEL_TEAMCUP_PLAYER value
     * @property {number} PP13_SEL_TEAMCUP_TEAM_LOCK=42 PP13_SEL_TEAMCUP_TEAM_LOCK value
     * @property {number} PP13_SEL_TEAMCUP_PLAYER_LOCK=43 PP13_SEL_TEAMCUP_PLAYER_LOCK value
     * @property {number} PP13_SEL_EVENTPRED_0=44 PP13_SEL_EVENTPRED_0 value
     * @property {number} PP13_SEL_EVENTPRED_1=45 PP13_SEL_EVENTPRED_1 value
     * @property {number} PP13_SEL_EVENTPRED_2=46 PP13_SEL_EVENTPRED_2 value
     * @property {number} PP13_SEL_EVENTPRED_3=47 PP13_SEL_EVENTPRED_3 value
     * @property {number} PP13_SEL_EVENTPRED_4=48 PP13_SEL_EVENTPRED_4 value
     * @property {number} PP13_SEL_EVENTPRED_5=49 PP13_SEL_EVENTPRED_5 value
     * @property {number} PP13_SEL_EVENTPRED_6=50 PP13_SEL_EVENTPRED_6 value
     * @property {number} PP13_SEL_EVENTPRED_7=51 PP13_SEL_EVENTPRED_7 value
     * @property {number} PP13_SEL_EVENTPRED_8=52 PP13_SEL_EVENTPRED_8 value
     * @property {number} PP13_SEL_EVENTPRED_9=53 PP13_SEL_EVENTPRED_9 value
     * @property {number} PP13_SEL_EVENTPRED_10=54 PP13_SEL_EVENTPRED_10 value
     * @property {number} PP13_SEL_EVENTPRED_11=55 PP13_SEL_EVENTPRED_11 value
     * @property {number} PP13_SEL_EVENTPRED_12=56 PP13_SEL_EVENTPRED_12 value
     * @property {number} PP13_SEL_EVENTPRED_13=57 PP13_SEL_EVENTPRED_13 value
     * @property {number} PP13_SEL_EVENTPRED_14=58 PP13_SEL_EVENTPRED_14 value
     * @property {number} PP13_SEL_EVENTPRED_15=59 PP13_SEL_EVENTPRED_15 value
     * @property {number} PP13_SEL_EVENTPRED_16=60 PP13_SEL_EVENTPRED_16 value
     * @property {number} PP13_SEL_EVENTPRED_17=61 PP13_SEL_EVENTPRED_17 value
     * @property {number} PP13_SEL_EVENTPRED_18=62 PP13_SEL_EVENTPRED_18 value
     * @property {number} PP13_SEL_EVENTPRED_19=63 PP13_SEL_EVENTPRED_19 value
     * @property {number} PP13_SEL_EVENTPRED_20=64 PP13_SEL_EVENTPRED_20 value
     * @property {number} PP13_SEL_EVENTPRED_21=65 PP13_SEL_EVENTPRED_21 value
     * @property {number} PP13_SEL_EVENTPRED_22=66 PP13_SEL_EVENTPRED_22 value
     * @property {number} PP13_SEL_EVENTPRED_23=67 PP13_SEL_EVENTPRED_23 value
     * @property {number} PP13_SEL_EVENTPRED_24=68 PP13_SEL_EVENTPRED_24 value
     * @property {number} PP13_SEL_EVENTPRED_25=69 PP13_SEL_EVENTPRED_25 value
     * @property {number} PP13_SEL_EVENTPRED_26=70 PP13_SEL_EVENTPRED_26 value
     * @property {number} PP13_SEL_EVENTPRED_27=71 PP13_SEL_EVENTPRED_27 value
     * @property {number} PP13_SEL_EVENTPRED_28=72 PP13_SEL_EVENTPRED_28 value
     * @property {number} PP13_SEL_EVENTPRED_29=73 PP13_SEL_EVENTPRED_29 value
     * @property {number} PP13_SEL_EVENTPRED_30=74 PP13_SEL_EVENTPRED_30 value
     * @property {number} PP13_SEL_EVENTPRED_31=75 PP13_SEL_EVENTPRED_31 value
     * @property {number} PP13_SEL_EVENTPRED_32=76 PP13_SEL_EVENTPRED_32 value
     * @property {number} PP13_SEL_EVENTPRED_33=77 PP13_SEL_EVENTPRED_33 value
     * @property {number} PP13_SEL_EVENTPRED_34=78 PP13_SEL_EVENTPRED_34 value
     * @property {number} PP13_SEL_EVENTPRED_35=79 PP13_SEL_EVENTPRED_35 value
     * @property {number} PP13_SEL_EVENTPRED_36=80 PP13_SEL_EVENTPRED_36 value
     * @property {number} PP13_SEL_EVENTPRED_37=81 PP13_SEL_EVENTPRED_37 value
     * @property {number} PP13_SEL_EVENTPRED_38=82 PP13_SEL_EVENTPRED_38 value
     * @property {number} PP13_SEL_EVENTPRED_39=83 PP13_SEL_EVENTPRED_39 value
     * @property {number} PP13_SEL_EVENTPRED_40=84 PP13_SEL_EVENTPRED_40 value
     * @property {number} PP13_SEL_EVENTPRED_41=85 PP13_SEL_EVENTPRED_41 value
     * @property {number} PP13_SEL_EVENTPRED_42=86 PP13_SEL_EVENTPRED_42 value
     * @property {number} PP13_SEL_EVENTPRED_43=87 PP13_SEL_EVENTPRED_43 value
     * @property {number} PP13_SEL_SOLO_0=88 PP13_SEL_SOLO_0 value
     * @property {number} PP13_SEL_SOLO_1=89 PP13_SEL_SOLO_1 value
     * @property {number} PP13_SEL_SOLO_2=90 PP13_SEL_SOLO_2 value
     * @property {number} PP13_SEL_SOLO_3=91 PP13_SEL_SOLO_3 value
     * @property {number} PP13_SEL_SOLO_4=92 PP13_SEL_SOLO_4 value
     * @property {number} PP13_SEL_SOLO_5=93 PP13_SEL_SOLO_5 value
     * @property {number} PP13_SEL_SOLO_6=94 PP13_SEL_SOLO_6 value
     * @property {number} PP13_SEL_SOLO_7=95 PP13_SEL_SOLO_7 value
     */
    $root.DOTA_2013PassportSelectionIndices = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PP13_SEL_ALLSTAR_PLAYER_0"] = 0;
        values[valuesById[1] = "PP13_SEL_ALLSTAR_PLAYER_1"] = 1;
        values[valuesById[2] = "PP13_SEL_ALLSTAR_PLAYER_2"] = 2;
        values[valuesById[3] = "PP13_SEL_ALLSTAR_PLAYER_3"] = 3;
        values[valuesById[4] = "PP13_SEL_ALLSTAR_PLAYER_4"] = 4;
        values[valuesById[5] = "PP13_SEL_ALLSTAR_PLAYER_5"] = 5;
        values[valuesById[6] = "PP13_SEL_ALLSTAR_PLAYER_6"] = 6;
        values[valuesById[7] = "PP13_SEL_ALLSTAR_PLAYER_7"] = 7;
        values[valuesById[8] = "PP13_SEL_ALLSTAR_PLAYER_8"] = 8;
        values[valuesById[9] = "PP13_SEL_ALLSTAR_PLAYER_9"] = 9;
        values[valuesById[10] = "PP13_SEL_QUALPRED_WEST_0"] = 10;
        values[valuesById[11] = "PP13_SEL_QUALPRED_WEST_1"] = 11;
        values[valuesById[12] = "PP13_SEL_QUALPRED_WEST_2"] = 12;
        values[valuesById[13] = "PP13_SEL_QUALPRED_WEST_3"] = 13;
        values[valuesById[14] = "PP13_SEL_QUALPRED_WEST_4"] = 14;
        values[valuesById[15] = "PP13_SEL_QUALPRED_WEST_5"] = 15;
        values[valuesById[16] = "PP13_SEL_QUALPRED_WEST_6"] = 16;
        values[valuesById[17] = "PP13_SEL_QUALPRED_WEST_7"] = 17;
        values[valuesById[18] = "PP13_SEL_QUALPRED_WEST_8"] = 18;
        values[valuesById[19] = "PP13_SEL_QUALPRED_WEST_9"] = 19;
        values[valuesById[20] = "PP13_SEL_QUALPRED_WEST_10"] = 20;
        values[valuesById[21] = "PP13_SEL_QUALPRED_WEST_11"] = 21;
        values[valuesById[22] = "PP13_SEL_QUALPRED_WEST_12"] = 22;
        values[valuesById[23] = "PP13_SEL_QUALPRED_WEST_13"] = 23;
        values[valuesById[24] = "PP13_SEL_QUALPRED_WEST_14"] = 24;
        values[valuesById[25] = "PP13_SEL_QUALPRED_EAST_0"] = 25;
        values[valuesById[26] = "PP13_SEL_QUALPRED_EAST_1"] = 26;
        values[valuesById[27] = "PP13_SEL_QUALPRED_EAST_2"] = 27;
        values[valuesById[28] = "PP13_SEL_QUALPRED_EAST_3"] = 28;
        values[valuesById[29] = "PP13_SEL_QUALPRED_EAST_4"] = 29;
        values[valuesById[30] = "PP13_SEL_QUALPRED_EAST_5"] = 30;
        values[valuesById[31] = "PP13_SEL_QUALPRED_EAST_6"] = 31;
        values[valuesById[32] = "PP13_SEL_QUALPRED_EAST_7"] = 32;
        values[valuesById[33] = "PP13_SEL_QUALPRED_EAST_8"] = 33;
        values[valuesById[34] = "PP13_SEL_QUALPRED_EAST_9"] = 34;
        values[valuesById[35] = "PP13_SEL_QUALPRED_EAST_10"] = 35;
        values[valuesById[36] = "PP13_SEL_QUALPRED_EAST_11"] = 36;
        values[valuesById[37] = "PP13_SEL_QUALPRED_EAST_12"] = 37;
        values[valuesById[38] = "PP13_SEL_QUALPRED_EAST_13"] = 38;
        values[valuesById[39] = "PP13_SEL_QUALPRED_EAST_14"] = 39;
        values[valuesById[40] = "PP13_SEL_TEAMCUP_TEAM"] = 40;
        values[valuesById[41] = "PP13_SEL_TEAMCUP_PLAYER"] = 41;
        values[valuesById[42] = "PP13_SEL_TEAMCUP_TEAM_LOCK"] = 42;
        values[valuesById[43] = "PP13_SEL_TEAMCUP_PLAYER_LOCK"] = 43;
        values[valuesById[44] = "PP13_SEL_EVENTPRED_0"] = 44;
        values[valuesById[45] = "PP13_SEL_EVENTPRED_1"] = 45;
        values[valuesById[46] = "PP13_SEL_EVENTPRED_2"] = 46;
        values[valuesById[47] = "PP13_SEL_EVENTPRED_3"] = 47;
        values[valuesById[48] = "PP13_SEL_EVENTPRED_4"] = 48;
        values[valuesById[49] = "PP13_SEL_EVENTPRED_5"] = 49;
        values[valuesById[50] = "PP13_SEL_EVENTPRED_6"] = 50;
        values[valuesById[51] = "PP13_SEL_EVENTPRED_7"] = 51;
        values[valuesById[52] = "PP13_SEL_EVENTPRED_8"] = 52;
        values[valuesById[53] = "PP13_SEL_EVENTPRED_9"] = 53;
        values[valuesById[54] = "PP13_SEL_EVENTPRED_10"] = 54;
        values[valuesById[55] = "PP13_SEL_EVENTPRED_11"] = 55;
        values[valuesById[56] = "PP13_SEL_EVENTPRED_12"] = 56;
        values[valuesById[57] = "PP13_SEL_EVENTPRED_13"] = 57;
        values[valuesById[58] = "PP13_SEL_EVENTPRED_14"] = 58;
        values[valuesById[59] = "PP13_SEL_EVENTPRED_15"] = 59;
        values[valuesById[60] = "PP13_SEL_EVENTPRED_16"] = 60;
        values[valuesById[61] = "PP13_SEL_EVENTPRED_17"] = 61;
        values[valuesById[62] = "PP13_SEL_EVENTPRED_18"] = 62;
        values[valuesById[63] = "PP13_SEL_EVENTPRED_19"] = 63;
        values[valuesById[64] = "PP13_SEL_EVENTPRED_20"] = 64;
        values[valuesById[65] = "PP13_SEL_EVENTPRED_21"] = 65;
        values[valuesById[66] = "PP13_SEL_EVENTPRED_22"] = 66;
        values[valuesById[67] = "PP13_SEL_EVENTPRED_23"] = 67;
        values[valuesById[68] = "PP13_SEL_EVENTPRED_24"] = 68;
        values[valuesById[69] = "PP13_SEL_EVENTPRED_25"] = 69;
        values[valuesById[70] = "PP13_SEL_EVENTPRED_26"] = 70;
        values[valuesById[71] = "PP13_SEL_EVENTPRED_27"] = 71;
        values[valuesById[72] = "PP13_SEL_EVENTPRED_28"] = 72;
        values[valuesById[73] = "PP13_SEL_EVENTPRED_29"] = 73;
        values[valuesById[74] = "PP13_SEL_EVENTPRED_30"] = 74;
        values[valuesById[75] = "PP13_SEL_EVENTPRED_31"] = 75;
        values[valuesById[76] = "PP13_SEL_EVENTPRED_32"] = 76;
        values[valuesById[77] = "PP13_SEL_EVENTPRED_33"] = 77;
        values[valuesById[78] = "PP13_SEL_EVENTPRED_34"] = 78;
        values[valuesById[79] = "PP13_SEL_EVENTPRED_35"] = 79;
        values[valuesById[80] = "PP13_SEL_EVENTPRED_36"] = 80;
        values[valuesById[81] = "PP13_SEL_EVENTPRED_37"] = 81;
        values[valuesById[82] = "PP13_SEL_EVENTPRED_38"] = 82;
        values[valuesById[83] = "PP13_SEL_EVENTPRED_39"] = 83;
        values[valuesById[84] = "PP13_SEL_EVENTPRED_40"] = 84;
        values[valuesById[85] = "PP13_SEL_EVENTPRED_41"] = 85;
        values[valuesById[86] = "PP13_SEL_EVENTPRED_42"] = 86;
        values[valuesById[87] = "PP13_SEL_EVENTPRED_43"] = 87;
        values[valuesById[88] = "PP13_SEL_SOLO_0"] = 88;
        values[valuesById[89] = "PP13_SEL_SOLO_1"] = 89;
        values[valuesById[90] = "PP13_SEL_SOLO_2"] = 90;
        values[valuesById[91] = "PP13_SEL_SOLO_3"] = 91;
        values[valuesById[92] = "PP13_SEL_SOLO_4"] = 92;
        values[valuesById[93] = "PP13_SEL_SOLO_5"] = 93;
        values[valuesById[94] = "PP13_SEL_SOLO_6"] = 94;
        values[valuesById[95] = "PP13_SEL_SOLO_7"] = 95;
        return values;
    })();
    
    $root.CMsgDOTAPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgDOTAPlayerInfo.
         * @exports ICMsgDOTAPlayerInfo
         * @interface ICMsgDOTAPlayerInfo
         * @property {number|null} [account_id] CMsgDOTAPlayerInfo account_id
         * @property {string|null} [name] CMsgDOTAPlayerInfo name
         * @property {string|null} [country_code] CMsgDOTAPlayerInfo country_code
         * @property {Fantasy_Roles|null} [fantasy_role] CMsgDOTAPlayerInfo fantasy_role
         * @property {number|null} [team_id] CMsgDOTAPlayerInfo team_id
         * @property {string|null} [team_name] CMsgDOTAPlayerInfo team_name
         * @property {string|null} [team_tag] CMsgDOTAPlayerInfo team_tag
         * @property {string|null} [sponsor] CMsgDOTAPlayerInfo sponsor
         * @property {boolean|null} [is_locked] CMsgDOTAPlayerInfo is_locked
         * @property {boolean|null} [is_pro] CMsgDOTAPlayerInfo is_pro
         * @property {string|null} [real_name] CMsgDOTAPlayerInfo real_name
         * @property {number|null} [birthdate] CMsgDOTAPlayerInfo birthdate
         * @property {number|null} [total_earnings] CMsgDOTAPlayerInfo total_earnings
         * @property {Array.<CMsgDOTAPlayerInfo.IResults>|null} [results] CMsgDOTAPlayerInfo results
         * @property {string|null} [team_url_logo] CMsgDOTAPlayerInfo team_url_logo
         * @property {Array.<CMsgDOTAPlayerInfo.IAuditEntry>|null} [audit_entries] CMsgDOTAPlayerInfo audit_entries
         */
    
        /**
         * Constructs a new CMsgDOTAPlayerInfo.
         * @exports CMsgDOTAPlayerInfo
         * @classdesc Represents a CMsgDOTAPlayerInfo.
         * @implements ICMsgDOTAPlayerInfo
         * @constructor
         * @param {ICMsgDOTAPlayerInfo=} [properties] Properties to set
         */
        function CMsgDOTAPlayerInfo(properties) {
            this.results = [];
            this.audit_entries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPlayerInfo account_id.
         * @member {number} account_id
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.account_id = 0;
    
        /**
         * CMsgDOTAPlayerInfo name.
         * @member {string} name
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.name = "";
    
        /**
         * CMsgDOTAPlayerInfo country_code.
         * @member {string} country_code
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.country_code = "";
    
        /**
         * CMsgDOTAPlayerInfo fantasy_role.
         * @member {Fantasy_Roles} fantasy_role
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.fantasy_role = 0;
    
        /**
         * CMsgDOTAPlayerInfo team_id.
         * @member {number} team_id
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.team_id = 0;
    
        /**
         * CMsgDOTAPlayerInfo team_name.
         * @member {string} team_name
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.team_name = "";
    
        /**
         * CMsgDOTAPlayerInfo team_tag.
         * @member {string} team_tag
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.team_tag = "";
    
        /**
         * CMsgDOTAPlayerInfo sponsor.
         * @member {string} sponsor
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.sponsor = "";
    
        /**
         * CMsgDOTAPlayerInfo is_locked.
         * @member {boolean} is_locked
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.is_locked = false;
    
        /**
         * CMsgDOTAPlayerInfo is_pro.
         * @member {boolean} is_pro
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.is_pro = false;
    
        /**
         * CMsgDOTAPlayerInfo real_name.
         * @member {string} real_name
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.real_name = "";
    
        /**
         * CMsgDOTAPlayerInfo birthdate.
         * @member {number} birthdate
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.birthdate = 0;
    
        /**
         * CMsgDOTAPlayerInfo total_earnings.
         * @member {number} total_earnings
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.total_earnings = 0;
    
        /**
         * CMsgDOTAPlayerInfo results.
         * @member {Array.<CMsgDOTAPlayerInfo.IResults>} results
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.results = $util.emptyArray;
    
        /**
         * CMsgDOTAPlayerInfo team_url_logo.
         * @member {string} team_url_logo
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.team_url_logo = "";
    
        /**
         * CMsgDOTAPlayerInfo audit_entries.
         * @member {Array.<CMsgDOTAPlayerInfo.IAuditEntry>} audit_entries
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         */
        CMsgDOTAPlayerInfo.prototype.audit_entries = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {ICMsgDOTAPlayerInfo=} [properties] Properties to set
         * @returns {CMsgDOTAPlayerInfo} CMsgDOTAPlayerInfo instance
         */
        CMsgDOTAPlayerInfo.create = function create(properties) {
            return new CMsgDOTAPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPlayerInfo message. Does not implicitly {@link CMsgDOTAPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {ICMsgDOTAPlayerInfo} message CMsgDOTAPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.account_id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.country_code != null && Object.hasOwnProperty.call(message, "country_code"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.country_code);
            if (message.fantasy_role != null && Object.hasOwnProperty.call(message, "fantasy_role"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fantasy_role);
            if (message.team_id != null && Object.hasOwnProperty.call(message, "team_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.team_id);
            if (message.team_name != null && Object.hasOwnProperty.call(message, "team_name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.team_name);
            if (message.team_tag != null && Object.hasOwnProperty.call(message, "team_tag"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.team_tag);
            if (message.sponsor != null && Object.hasOwnProperty.call(message, "sponsor"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sponsor);
            if (message.is_locked != null && Object.hasOwnProperty.call(message, "is_locked"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.is_locked);
            if (message.is_pro != null && Object.hasOwnProperty.call(message, "is_pro"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.is_pro);
            if (message.real_name != null && Object.hasOwnProperty.call(message, "real_name"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.real_name);
            if (message.birthdate != null && Object.hasOwnProperty.call(message, "birthdate"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.birthdate);
            if (message.total_earnings != null && Object.hasOwnProperty.call(message, "total_earnings"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.total_earnings);
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    $root.CMsgDOTAPlayerInfo.Results.encode(message.results[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.team_url_logo != null && Object.hasOwnProperty.call(message, "team_url_logo"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.team_url_logo);
            if (message.audit_entries != null && message.audit_entries.length)
                for (var i = 0; i < message.audit_entries.length; ++i)
                    $root.CMsgDOTAPlayerInfo.AuditEntry.encode(message.audit_entries[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPlayerInfo message, length delimited. Does not implicitly {@link CMsgDOTAPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {ICMsgDOTAPlayerInfo} message CMsgDOTAPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPlayerInfo} CMsgDOTAPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account_id = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.country_code = reader.string();
                    break;
                case 4:
                    message.fantasy_role = reader.int32();
                    break;
                case 5:
                    message.team_id = reader.uint32();
                    break;
                case 6:
                    message.team_name = reader.string();
                    break;
                case 7:
                    message.team_tag = reader.string();
                    break;
                case 8:
                    message.sponsor = reader.string();
                    break;
                case 9:
                    message.is_locked = reader.bool();
                    break;
                case 10:
                    message.is_pro = reader.bool();
                    break;
                case 11:
                    message.real_name = reader.string();
                    break;
                case 12:
                    message.birthdate = reader.uint32();
                    break;
                case 13:
                    message.total_earnings = reader.uint32();
                    break;
                case 14:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.CMsgDOTAPlayerInfo.Results.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.team_url_logo = reader.string();
                    break;
                case 16:
                    if (!(message.audit_entries && message.audit_entries.length))
                        message.audit_entries = [];
                    message.audit_entries.push($root.CMsgDOTAPlayerInfo.AuditEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPlayerInfo} CMsgDOTAPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPlayerInfo message.
         * @function verify
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                if (!$util.isInteger(message.account_id))
                    return "account_id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.country_code != null && message.hasOwnProperty("country_code"))
                if (!$util.isString(message.country_code))
                    return "country_code: string expected";
            if (message.fantasy_role != null && message.hasOwnProperty("fantasy_role"))
                switch (message.fantasy_role) {
                default:
                    return "fantasy_role: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.team_id != null && message.hasOwnProperty("team_id"))
                if (!$util.isInteger(message.team_id))
                    return "team_id: integer expected";
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                if (!$util.isString(message.team_name))
                    return "team_name: string expected";
            if (message.team_tag != null && message.hasOwnProperty("team_tag"))
                if (!$util.isString(message.team_tag))
                    return "team_tag: string expected";
            if (message.sponsor != null && message.hasOwnProperty("sponsor"))
                if (!$util.isString(message.sponsor))
                    return "sponsor: string expected";
            if (message.is_locked != null && message.hasOwnProperty("is_locked"))
                if (typeof message.is_locked !== "boolean")
                    return "is_locked: boolean expected";
            if (message.is_pro != null && message.hasOwnProperty("is_pro"))
                if (typeof message.is_pro !== "boolean")
                    return "is_pro: boolean expected";
            if (message.real_name != null && message.hasOwnProperty("real_name"))
                if (!$util.isString(message.real_name))
                    return "real_name: string expected";
            if (message.birthdate != null && message.hasOwnProperty("birthdate"))
                if (!$util.isInteger(message.birthdate))
                    return "birthdate: integer expected";
            if (message.total_earnings != null && message.hasOwnProperty("total_earnings"))
                if (!$util.isInteger(message.total_earnings))
                    return "total_earnings: integer expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i) {
                    var error = $root.CMsgDOTAPlayerInfo.Results.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            if (message.team_url_logo != null && message.hasOwnProperty("team_url_logo"))
                if (!$util.isString(message.team_url_logo))
                    return "team_url_logo: string expected";
            if (message.audit_entries != null && message.hasOwnProperty("audit_entries")) {
                if (!Array.isArray(message.audit_entries))
                    return "audit_entries: array expected";
                for (var i = 0; i < message.audit_entries.length; ++i) {
                    var error = $root.CMsgDOTAPlayerInfo.AuditEntry.verify(message.audit_entries[i]);
                    if (error)
                        return "audit_entries." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPlayerInfo} CMsgDOTAPlayerInfo
         */
        CMsgDOTAPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPlayerInfo)
                return object;
            var message = new $root.CMsgDOTAPlayerInfo();
            if (object.account_id != null)
                message.account_id = object.account_id >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.country_code != null)
                message.country_code = String(object.country_code);
            switch (object.fantasy_role) {
            case "FANTASY_ROLE_UNDEFINED":
            case 0:
                message.fantasy_role = 0;
                break;
            case "FANTASY_ROLE_CORE":
            case 1:
                message.fantasy_role = 1;
                break;
            case "FANTASY_ROLE_SUPPORT":
            case 2:
                message.fantasy_role = 2;
                break;
            case "FANTASY_ROLE_OFFLANE":
            case 3:
                message.fantasy_role = 3;
                break;
            case "FANTASY_ROLE_MID":
            case 4:
                message.fantasy_role = 4;
                break;
            }
            if (object.team_id != null)
                message.team_id = object.team_id >>> 0;
            if (object.team_name != null)
                message.team_name = String(object.team_name);
            if (object.team_tag != null)
                message.team_tag = String(object.team_tag);
            if (object.sponsor != null)
                message.sponsor = String(object.sponsor);
            if (object.is_locked != null)
                message.is_locked = Boolean(object.is_locked);
            if (object.is_pro != null)
                message.is_pro = Boolean(object.is_pro);
            if (object.real_name != null)
                message.real_name = String(object.real_name);
            if (object.birthdate != null)
                message.birthdate = object.birthdate >>> 0;
            if (object.total_earnings != null)
                message.total_earnings = object.total_earnings >>> 0;
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".CMsgDOTAPlayerInfo.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".CMsgDOTAPlayerInfo.results: object expected");
                    message.results[i] = $root.CMsgDOTAPlayerInfo.Results.fromObject(object.results[i]);
                }
            }
            if (object.team_url_logo != null)
                message.team_url_logo = String(object.team_url_logo);
            if (object.audit_entries) {
                if (!Array.isArray(object.audit_entries))
                    throw TypeError(".CMsgDOTAPlayerInfo.audit_entries: array expected");
                message.audit_entries = [];
                for (var i = 0; i < object.audit_entries.length; ++i) {
                    if (typeof object.audit_entries[i] !== "object")
                        throw TypeError(".CMsgDOTAPlayerInfo.audit_entries: object expected");
                    message.audit_entries[i] = $root.CMsgDOTAPlayerInfo.AuditEntry.fromObject(object.audit_entries[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPlayerInfo
         * @static
         * @param {CMsgDOTAPlayerInfo} message CMsgDOTAPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.results = [];
                object.audit_entries = [];
            }
            if (options.defaults) {
                object.account_id = 0;
                object.name = "";
                object.country_code = "";
                object.fantasy_role = options.enums === String ? "FANTASY_ROLE_UNDEFINED" : 0;
                object.team_id = 0;
                object.team_name = "";
                object.team_tag = "";
                object.sponsor = "";
                object.is_locked = false;
                object.is_pro = false;
                object.real_name = "";
                object.birthdate = 0;
                object.total_earnings = 0;
                object.team_url_logo = "";
            }
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                object.account_id = message.account_id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.country_code != null && message.hasOwnProperty("country_code"))
                object.country_code = message.country_code;
            if (message.fantasy_role != null && message.hasOwnProperty("fantasy_role"))
                object.fantasy_role = options.enums === String ? $root.Fantasy_Roles[message.fantasy_role] : message.fantasy_role;
            if (message.team_id != null && message.hasOwnProperty("team_id"))
                object.team_id = message.team_id;
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                object.team_name = message.team_name;
            if (message.team_tag != null && message.hasOwnProperty("team_tag"))
                object.team_tag = message.team_tag;
            if (message.sponsor != null && message.hasOwnProperty("sponsor"))
                object.sponsor = message.sponsor;
            if (message.is_locked != null && message.hasOwnProperty("is_locked"))
                object.is_locked = message.is_locked;
            if (message.is_pro != null && message.hasOwnProperty("is_pro"))
                object.is_pro = message.is_pro;
            if (message.real_name != null && message.hasOwnProperty("real_name"))
                object.real_name = message.real_name;
            if (message.birthdate != null && message.hasOwnProperty("birthdate"))
                object.birthdate = message.birthdate;
            if (message.total_earnings != null && message.hasOwnProperty("total_earnings"))
                object.total_earnings = message.total_earnings;
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.CMsgDOTAPlayerInfo.Results.toObject(message.results[j], options);
            }
            if (message.team_url_logo != null && message.hasOwnProperty("team_url_logo"))
                object.team_url_logo = message.team_url_logo;
            if (message.audit_entries && message.audit_entries.length) {
                object.audit_entries = [];
                for (var j = 0; j < message.audit_entries.length; ++j)
                    object.audit_entries[j] = $root.CMsgDOTAPlayerInfo.AuditEntry.toObject(message.audit_entries[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAPlayerInfo.Results = (function() {
    
            /**
             * Properties of a Results.
             * @memberof CMsgDOTAPlayerInfo
             * @interface IResults
             * @property {number|null} [league_id] Results league_id
             * @property {number|null} [placement] Results placement
             * @property {number|null} [earnings] Results earnings
             */
    
            /**
             * Constructs a new Results.
             * @memberof CMsgDOTAPlayerInfo
             * @classdesc Represents a Results.
             * @implements IResults
             * @constructor
             * @param {CMsgDOTAPlayerInfo.IResults=} [properties] Properties to set
             */
            function Results(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Results league_id.
             * @member {number} league_id
             * @memberof CMsgDOTAPlayerInfo.Results
             * @instance
             */
            Results.prototype.league_id = 0;
    
            /**
             * Results placement.
             * @member {number} placement
             * @memberof CMsgDOTAPlayerInfo.Results
             * @instance
             */
            Results.prototype.placement = 0;
    
            /**
             * Results earnings.
             * @member {number} earnings
             * @memberof CMsgDOTAPlayerInfo.Results
             * @instance
             */
            Results.prototype.earnings = 0;
    
            /**
             * Creates a new Results instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {CMsgDOTAPlayerInfo.IResults=} [properties] Properties to set
             * @returns {CMsgDOTAPlayerInfo.Results} Results instance
             */
            Results.create = function create(properties) {
                return new Results(properties);
            };
    
            /**
             * Encodes the specified Results message. Does not implicitly {@link CMsgDOTAPlayerInfo.Results.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {CMsgDOTAPlayerInfo.IResults} message Results message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Results.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.league_id != null && Object.hasOwnProperty.call(message, "league_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.league_id);
                if (message.placement != null && Object.hasOwnProperty.call(message, "placement"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.placement);
                if (message.earnings != null && Object.hasOwnProperty.call(message, "earnings"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.earnings);
                return writer;
            };
    
            /**
             * Encodes the specified Results message, length delimited. Does not implicitly {@link CMsgDOTAPlayerInfo.Results.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {CMsgDOTAPlayerInfo.IResults} message Results message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Results.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Results message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAPlayerInfo.Results} Results
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Results.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPlayerInfo.Results();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.league_id = reader.uint32();
                        break;
                    case 2:
                        message.placement = reader.uint32();
                        break;
                    case 3:
                        message.earnings = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Results message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAPlayerInfo.Results} Results
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Results.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Results message.
             * @function verify
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Results.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.league_id != null && message.hasOwnProperty("league_id"))
                    if (!$util.isInteger(message.league_id))
                        return "league_id: integer expected";
                if (message.placement != null && message.hasOwnProperty("placement"))
                    if (!$util.isInteger(message.placement))
                        return "placement: integer expected";
                if (message.earnings != null && message.hasOwnProperty("earnings"))
                    if (!$util.isInteger(message.earnings))
                        return "earnings: integer expected";
                return null;
            };
    
            /**
             * Creates a Results message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAPlayerInfo.Results} Results
             */
            Results.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAPlayerInfo.Results)
                    return object;
                var message = new $root.CMsgDOTAPlayerInfo.Results();
                if (object.league_id != null)
                    message.league_id = object.league_id >>> 0;
                if (object.placement != null)
                    message.placement = object.placement >>> 0;
                if (object.earnings != null)
                    message.earnings = object.earnings >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Results message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAPlayerInfo.Results
             * @static
             * @param {CMsgDOTAPlayerInfo.Results} message Results
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Results.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.league_id = 0;
                    object.placement = 0;
                    object.earnings = 0;
                }
                if (message.league_id != null && message.hasOwnProperty("league_id"))
                    object.league_id = message.league_id;
                if (message.placement != null && message.hasOwnProperty("placement"))
                    object.placement = message.placement;
                if (message.earnings != null && message.hasOwnProperty("earnings"))
                    object.earnings = message.earnings;
                return object;
            };
    
            /**
             * Converts this Results to JSON.
             * @function toJSON
             * @memberof CMsgDOTAPlayerInfo.Results
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Results.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Results;
        })();
    
        CMsgDOTAPlayerInfo.AuditEntry = (function() {
    
            /**
             * Properties of an AuditEntry.
             * @memberof CMsgDOTAPlayerInfo
             * @interface IAuditEntry
             * @property {number|null} [start_timestamp] AuditEntry start_timestamp
             * @property {number|null} [end_timestamp] AuditEntry end_timestamp
             * @property {number|null} [team_id] AuditEntry team_id
             * @property {string|null} [team_name] AuditEntry team_name
             * @property {string|null} [team_tag] AuditEntry team_tag
             * @property {string|null} [team_url_logo] AuditEntry team_url_logo
             */
    
            /**
             * Constructs a new AuditEntry.
             * @memberof CMsgDOTAPlayerInfo
             * @classdesc Represents an AuditEntry.
             * @implements IAuditEntry
             * @constructor
             * @param {CMsgDOTAPlayerInfo.IAuditEntry=} [properties] Properties to set
             */
            function AuditEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AuditEntry start_timestamp.
             * @member {number} start_timestamp
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             */
            AuditEntry.prototype.start_timestamp = 0;
    
            /**
             * AuditEntry end_timestamp.
             * @member {number} end_timestamp
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             */
            AuditEntry.prototype.end_timestamp = 0;
    
            /**
             * AuditEntry team_id.
             * @member {number} team_id
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             */
            AuditEntry.prototype.team_id = 0;
    
            /**
             * AuditEntry team_name.
             * @member {string} team_name
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             */
            AuditEntry.prototype.team_name = "";
    
            /**
             * AuditEntry team_tag.
             * @member {string} team_tag
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             */
            AuditEntry.prototype.team_tag = "";
    
            /**
             * AuditEntry team_url_logo.
             * @member {string} team_url_logo
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             */
            AuditEntry.prototype.team_url_logo = "";
    
            /**
             * Creates a new AuditEntry instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {CMsgDOTAPlayerInfo.IAuditEntry=} [properties] Properties to set
             * @returns {CMsgDOTAPlayerInfo.AuditEntry} AuditEntry instance
             */
            AuditEntry.create = function create(properties) {
                return new AuditEntry(properties);
            };
    
            /**
             * Encodes the specified AuditEntry message. Does not implicitly {@link CMsgDOTAPlayerInfo.AuditEntry.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {CMsgDOTAPlayerInfo.IAuditEntry} message AuditEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuditEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start_timestamp != null && Object.hasOwnProperty.call(message, "start_timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.start_timestamp);
                if (message.end_timestamp != null && Object.hasOwnProperty.call(message, "end_timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.end_timestamp);
                if (message.team_id != null && Object.hasOwnProperty.call(message, "team_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team_id);
                if (message.team_name != null && Object.hasOwnProperty.call(message, "team_name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.team_name);
                if (message.team_tag != null && Object.hasOwnProperty.call(message, "team_tag"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.team_tag);
                if (message.team_url_logo != null && Object.hasOwnProperty.call(message, "team_url_logo"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.team_url_logo);
                return writer;
            };
    
            /**
             * Encodes the specified AuditEntry message, length delimited. Does not implicitly {@link CMsgDOTAPlayerInfo.AuditEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {CMsgDOTAPlayerInfo.IAuditEntry} message AuditEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuditEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AuditEntry message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAPlayerInfo.AuditEntry} AuditEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuditEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPlayerInfo.AuditEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start_timestamp = reader.uint32();
                        break;
                    case 2:
                        message.end_timestamp = reader.uint32();
                        break;
                    case 3:
                        message.team_id = reader.uint32();
                        break;
                    case 4:
                        message.team_name = reader.string();
                        break;
                    case 5:
                        message.team_tag = reader.string();
                        break;
                    case 6:
                        message.team_url_logo = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AuditEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAPlayerInfo.AuditEntry} AuditEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuditEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AuditEntry message.
             * @function verify
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuditEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start_timestamp != null && message.hasOwnProperty("start_timestamp"))
                    if (!$util.isInteger(message.start_timestamp))
                        return "start_timestamp: integer expected";
                if (message.end_timestamp != null && message.hasOwnProperty("end_timestamp"))
                    if (!$util.isInteger(message.end_timestamp))
                        return "end_timestamp: integer expected";
                if (message.team_id != null && message.hasOwnProperty("team_id"))
                    if (!$util.isInteger(message.team_id))
                        return "team_id: integer expected";
                if (message.team_name != null && message.hasOwnProperty("team_name"))
                    if (!$util.isString(message.team_name))
                        return "team_name: string expected";
                if (message.team_tag != null && message.hasOwnProperty("team_tag"))
                    if (!$util.isString(message.team_tag))
                        return "team_tag: string expected";
                if (message.team_url_logo != null && message.hasOwnProperty("team_url_logo"))
                    if (!$util.isString(message.team_url_logo))
                        return "team_url_logo: string expected";
                return null;
            };
    
            /**
             * Creates an AuditEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAPlayerInfo.AuditEntry} AuditEntry
             */
            AuditEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAPlayerInfo.AuditEntry)
                    return object;
                var message = new $root.CMsgDOTAPlayerInfo.AuditEntry();
                if (object.start_timestamp != null)
                    message.start_timestamp = object.start_timestamp >>> 0;
                if (object.end_timestamp != null)
                    message.end_timestamp = object.end_timestamp >>> 0;
                if (object.team_id != null)
                    message.team_id = object.team_id >>> 0;
                if (object.team_name != null)
                    message.team_name = String(object.team_name);
                if (object.team_tag != null)
                    message.team_tag = String(object.team_tag);
                if (object.team_url_logo != null)
                    message.team_url_logo = String(object.team_url_logo);
                return message;
            };
    
            /**
             * Creates a plain object from an AuditEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @static
             * @param {CMsgDOTAPlayerInfo.AuditEntry} message AuditEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuditEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start_timestamp = 0;
                    object.end_timestamp = 0;
                    object.team_id = 0;
                    object.team_name = "";
                    object.team_tag = "";
                    object.team_url_logo = "";
                }
                if (message.start_timestamp != null && message.hasOwnProperty("start_timestamp"))
                    object.start_timestamp = message.start_timestamp;
                if (message.end_timestamp != null && message.hasOwnProperty("end_timestamp"))
                    object.end_timestamp = message.end_timestamp;
                if (message.team_id != null && message.hasOwnProperty("team_id"))
                    object.team_id = message.team_id;
                if (message.team_name != null && message.hasOwnProperty("team_name"))
                    object.team_name = message.team_name;
                if (message.team_tag != null && message.hasOwnProperty("team_tag"))
                    object.team_tag = message.team_tag;
                if (message.team_url_logo != null && message.hasOwnProperty("team_url_logo"))
                    object.team_url_logo = message.team_url_logo;
                return object;
            };
    
            /**
             * Converts this AuditEntry to JSON.
             * @function toJSON
             * @memberof CMsgDOTAPlayerInfo.AuditEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuditEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AuditEntry;
        })();
    
        return CMsgDOTAPlayerInfo;
    })();
    
    $root.CMsgDOTAPlayerInfoList = (function() {
    
        /**
         * Properties of a CMsgDOTAPlayerInfoList.
         * @exports ICMsgDOTAPlayerInfoList
         * @interface ICMsgDOTAPlayerInfoList
         * @property {Array.<ICMsgDOTAPlayerInfo>|null} [player_infos] CMsgDOTAPlayerInfoList player_infos
         */
    
        /**
         * Constructs a new CMsgDOTAPlayerInfoList.
         * @exports CMsgDOTAPlayerInfoList
         * @classdesc Represents a CMsgDOTAPlayerInfoList.
         * @implements ICMsgDOTAPlayerInfoList
         * @constructor
         * @param {ICMsgDOTAPlayerInfoList=} [properties] Properties to set
         */
        function CMsgDOTAPlayerInfoList(properties) {
            this.player_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPlayerInfoList player_infos.
         * @member {Array.<ICMsgDOTAPlayerInfo>} player_infos
         * @memberof CMsgDOTAPlayerInfoList
         * @instance
         */
        CMsgDOTAPlayerInfoList.prototype.player_infos = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAPlayerInfoList instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {ICMsgDOTAPlayerInfoList=} [properties] Properties to set
         * @returns {CMsgDOTAPlayerInfoList} CMsgDOTAPlayerInfoList instance
         */
        CMsgDOTAPlayerInfoList.create = function create(properties) {
            return new CMsgDOTAPlayerInfoList(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPlayerInfoList message. Does not implicitly {@link CMsgDOTAPlayerInfoList.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {ICMsgDOTAPlayerInfoList} message CMsgDOTAPlayerInfoList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPlayerInfoList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_infos != null && message.player_infos.length)
                for (var i = 0; i < message.player_infos.length; ++i)
                    $root.CMsgDOTAPlayerInfo.encode(message.player_infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPlayerInfoList message, length delimited. Does not implicitly {@link CMsgDOTAPlayerInfoList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {ICMsgDOTAPlayerInfoList} message CMsgDOTAPlayerInfoList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPlayerInfoList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPlayerInfoList message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPlayerInfoList} CMsgDOTAPlayerInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPlayerInfoList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPlayerInfoList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.player_infos && message.player_infos.length))
                        message.player_infos = [];
                    message.player_infos.push($root.CMsgDOTAPlayerInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPlayerInfoList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPlayerInfoList} CMsgDOTAPlayerInfoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPlayerInfoList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPlayerInfoList message.
         * @function verify
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPlayerInfoList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_infos != null && message.hasOwnProperty("player_infos")) {
                if (!Array.isArray(message.player_infos))
                    return "player_infos: array expected";
                for (var i = 0; i < message.player_infos.length; ++i) {
                    var error = $root.CMsgDOTAPlayerInfo.verify(message.player_infos[i]);
                    if (error)
                        return "player_infos." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPlayerInfoList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPlayerInfoList} CMsgDOTAPlayerInfoList
         */
        CMsgDOTAPlayerInfoList.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPlayerInfoList)
                return object;
            var message = new $root.CMsgDOTAPlayerInfoList();
            if (object.player_infos) {
                if (!Array.isArray(object.player_infos))
                    throw TypeError(".CMsgDOTAPlayerInfoList.player_infos: array expected");
                message.player_infos = [];
                for (var i = 0; i < object.player_infos.length; ++i) {
                    if (typeof object.player_infos[i] !== "object")
                        throw TypeError(".CMsgDOTAPlayerInfoList.player_infos: object expected");
                    message.player_infos[i] = $root.CMsgDOTAPlayerInfo.fromObject(object.player_infos[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPlayerInfoList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPlayerInfoList
         * @static
         * @param {CMsgDOTAPlayerInfoList} message CMsgDOTAPlayerInfoList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPlayerInfoList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.player_infos = [];
            if (message.player_infos && message.player_infos.length) {
                object.player_infos = [];
                for (var j = 0; j < message.player_infos.length; ++j)
                    object.player_infos[j] = $root.CMsgDOTAPlayerInfo.toObject(message.player_infos[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPlayerInfoList to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPlayerInfoList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPlayerInfoList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAPlayerInfoList;
    })();
    
    $root.CMsgDOTADPCProfileInfo = (function() {
    
        /**
         * Properties of a CMsgDOTADPCProfileInfo.
         * @exports ICMsgDOTADPCProfileInfo
         * @interface ICMsgDOTADPCProfileInfo
         * @property {ICMsgDOTAPlayerInfo|null} [player_info] CMsgDOTADPCProfileInfo player_info
         * @property {CMsgDOTADPCProfileInfo.IPredictionInfo|null} [prediction_info] CMsgDOTADPCProfileInfo prediction_info
         * @property {CMsgDOTADPCProfileInfo.IFantasyInfo|null} [fantasy_info] CMsgDOTADPCProfileInfo fantasy_info
         * @property {Array.<number>|null} [disabled_notifications] CMsgDOTADPCProfileInfo disabled_notifications
         */
    
        /**
         * Constructs a new CMsgDOTADPCProfileInfo.
         * @exports CMsgDOTADPCProfileInfo
         * @classdesc Represents a CMsgDOTADPCProfileInfo.
         * @implements ICMsgDOTADPCProfileInfo
         * @constructor
         * @param {ICMsgDOTADPCProfileInfo=} [properties] Properties to set
         */
        function CMsgDOTADPCProfileInfo(properties) {
            this.disabled_notifications = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTADPCProfileInfo player_info.
         * @member {ICMsgDOTAPlayerInfo|null|undefined} player_info
         * @memberof CMsgDOTADPCProfileInfo
         * @instance
         */
        CMsgDOTADPCProfileInfo.prototype.player_info = null;
    
        /**
         * CMsgDOTADPCProfileInfo prediction_info.
         * @member {CMsgDOTADPCProfileInfo.IPredictionInfo|null|undefined} prediction_info
         * @memberof CMsgDOTADPCProfileInfo
         * @instance
         */
        CMsgDOTADPCProfileInfo.prototype.prediction_info = null;
    
        /**
         * CMsgDOTADPCProfileInfo fantasy_info.
         * @member {CMsgDOTADPCProfileInfo.IFantasyInfo|null|undefined} fantasy_info
         * @memberof CMsgDOTADPCProfileInfo
         * @instance
         */
        CMsgDOTADPCProfileInfo.prototype.fantasy_info = null;
    
        /**
         * CMsgDOTADPCProfileInfo disabled_notifications.
         * @member {Array.<number>} disabled_notifications
         * @memberof CMsgDOTADPCProfileInfo
         * @instance
         */
        CMsgDOTADPCProfileInfo.prototype.disabled_notifications = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTADPCProfileInfo instance using the specified properties.
         * @function create
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {ICMsgDOTADPCProfileInfo=} [properties] Properties to set
         * @returns {CMsgDOTADPCProfileInfo} CMsgDOTADPCProfileInfo instance
         */
        CMsgDOTADPCProfileInfo.create = function create(properties) {
            return new CMsgDOTADPCProfileInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTADPCProfileInfo message. Does not implicitly {@link CMsgDOTADPCProfileInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {ICMsgDOTADPCProfileInfo} message CMsgDOTADPCProfileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTADPCProfileInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player_info != null && Object.hasOwnProperty.call(message, "player_info"))
                $root.CMsgDOTAPlayerInfo.encode(message.player_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.prediction_info != null && Object.hasOwnProperty.call(message, "prediction_info"))
                $root.CMsgDOTADPCProfileInfo.PredictionInfo.encode(message.prediction_info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.fantasy_info != null && Object.hasOwnProperty.call(message, "fantasy_info"))
                $root.CMsgDOTADPCProfileInfo.FantasyInfo.encode(message.fantasy_info, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.disabled_notifications != null && message.disabled_notifications.length)
                for (var i = 0; i < message.disabled_notifications.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.disabled_notifications[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTADPCProfileInfo message, length delimited. Does not implicitly {@link CMsgDOTADPCProfileInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {ICMsgDOTADPCProfileInfo} message CMsgDOTADPCProfileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTADPCProfileInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTADPCProfileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTADPCProfileInfo} CMsgDOTADPCProfileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTADPCProfileInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTADPCProfileInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player_info = $root.CMsgDOTAPlayerInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.prediction_info = $root.CMsgDOTADPCProfileInfo.PredictionInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.fantasy_info = $root.CMsgDOTADPCProfileInfo.FantasyInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.disabled_notifications && message.disabled_notifications.length))
                        message.disabled_notifications = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.disabled_notifications.push(reader.uint32());
                    } else
                        message.disabled_notifications.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTADPCProfileInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTADPCProfileInfo} CMsgDOTADPCProfileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTADPCProfileInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTADPCProfileInfo message.
         * @function verify
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTADPCProfileInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player_info != null && message.hasOwnProperty("player_info")) {
                var error = $root.CMsgDOTAPlayerInfo.verify(message.player_info);
                if (error)
                    return "player_info." + error;
            }
            if (message.prediction_info != null && message.hasOwnProperty("prediction_info")) {
                var error = $root.CMsgDOTADPCProfileInfo.PredictionInfo.verify(message.prediction_info);
                if (error)
                    return "prediction_info." + error;
            }
            if (message.fantasy_info != null && message.hasOwnProperty("fantasy_info")) {
                var error = $root.CMsgDOTADPCProfileInfo.FantasyInfo.verify(message.fantasy_info);
                if (error)
                    return "fantasy_info." + error;
            }
            if (message.disabled_notifications != null && message.hasOwnProperty("disabled_notifications")) {
                if (!Array.isArray(message.disabled_notifications))
                    return "disabled_notifications: array expected";
                for (var i = 0; i < message.disabled_notifications.length; ++i)
                    if (!$util.isInteger(message.disabled_notifications[i]))
                        return "disabled_notifications: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTADPCProfileInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTADPCProfileInfo} CMsgDOTADPCProfileInfo
         */
        CMsgDOTADPCProfileInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTADPCProfileInfo)
                return object;
            var message = new $root.CMsgDOTADPCProfileInfo();
            if (object.player_info != null) {
                if (typeof object.player_info !== "object")
                    throw TypeError(".CMsgDOTADPCProfileInfo.player_info: object expected");
                message.player_info = $root.CMsgDOTAPlayerInfo.fromObject(object.player_info);
            }
            if (object.prediction_info != null) {
                if (typeof object.prediction_info !== "object")
                    throw TypeError(".CMsgDOTADPCProfileInfo.prediction_info: object expected");
                message.prediction_info = $root.CMsgDOTADPCProfileInfo.PredictionInfo.fromObject(object.prediction_info);
            }
            if (object.fantasy_info != null) {
                if (typeof object.fantasy_info !== "object")
                    throw TypeError(".CMsgDOTADPCProfileInfo.fantasy_info: object expected");
                message.fantasy_info = $root.CMsgDOTADPCProfileInfo.FantasyInfo.fromObject(object.fantasy_info);
            }
            if (object.disabled_notifications) {
                if (!Array.isArray(object.disabled_notifications))
                    throw TypeError(".CMsgDOTADPCProfileInfo.disabled_notifications: array expected");
                message.disabled_notifications = [];
                for (var i = 0; i < object.disabled_notifications.length; ++i)
                    message.disabled_notifications[i] = object.disabled_notifications[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTADPCProfileInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTADPCProfileInfo
         * @static
         * @param {CMsgDOTADPCProfileInfo} message CMsgDOTADPCProfileInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTADPCProfileInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.disabled_notifications = [];
            if (options.defaults) {
                object.player_info = null;
                object.prediction_info = null;
                object.fantasy_info = null;
            }
            if (message.player_info != null && message.hasOwnProperty("player_info"))
                object.player_info = $root.CMsgDOTAPlayerInfo.toObject(message.player_info, options);
            if (message.prediction_info != null && message.hasOwnProperty("prediction_info"))
                object.prediction_info = $root.CMsgDOTADPCProfileInfo.PredictionInfo.toObject(message.prediction_info, options);
            if (message.fantasy_info != null && message.hasOwnProperty("fantasy_info"))
                object.fantasy_info = $root.CMsgDOTADPCProfileInfo.FantasyInfo.toObject(message.fantasy_info, options);
            if (message.disabled_notifications && message.disabled_notifications.length) {
                object.disabled_notifications = [];
                for (var j = 0; j < message.disabled_notifications.length; ++j)
                    object.disabled_notifications[j] = message.disabled_notifications[j];
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTADPCProfileInfo to JSON.
         * @function toJSON
         * @memberof CMsgDOTADPCProfileInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTADPCProfileInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTADPCProfileInfo.PredictionInfo = (function() {
    
            /**
             * Properties of a PredictionInfo.
             * @memberof CMsgDOTADPCProfileInfo
             * @interface IPredictionInfo
             * @property {number|null} [percent] PredictionInfo percent
             * @property {number|null} [shard_winnings] PredictionInfo shard_winnings
             */
    
            /**
             * Constructs a new PredictionInfo.
             * @memberof CMsgDOTADPCProfileInfo
             * @classdesc Represents a PredictionInfo.
             * @implements IPredictionInfo
             * @constructor
             * @param {CMsgDOTADPCProfileInfo.IPredictionInfo=} [properties] Properties to set
             */
            function PredictionInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PredictionInfo percent.
             * @member {number} percent
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @instance
             */
            PredictionInfo.prototype.percent = 0;
    
            /**
             * PredictionInfo shard_winnings.
             * @member {number} shard_winnings
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @instance
             */
            PredictionInfo.prototype.shard_winnings = 0;
    
            /**
             * Creates a new PredictionInfo instance using the specified properties.
             * @function create
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.IPredictionInfo=} [properties] Properties to set
             * @returns {CMsgDOTADPCProfileInfo.PredictionInfo} PredictionInfo instance
             */
            PredictionInfo.create = function create(properties) {
                return new PredictionInfo(properties);
            };
    
            /**
             * Encodes the specified PredictionInfo message. Does not implicitly {@link CMsgDOTADPCProfileInfo.PredictionInfo.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.IPredictionInfo} message PredictionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PredictionInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.percent != null && Object.hasOwnProperty.call(message, "percent"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.percent);
                if (message.shard_winnings != null && Object.hasOwnProperty.call(message, "shard_winnings"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.shard_winnings);
                return writer;
            };
    
            /**
             * Encodes the specified PredictionInfo message, length delimited. Does not implicitly {@link CMsgDOTADPCProfileInfo.PredictionInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.IPredictionInfo} message PredictionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PredictionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PredictionInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTADPCProfileInfo.PredictionInfo} PredictionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PredictionInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTADPCProfileInfo.PredictionInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.percent = reader.uint32();
                        break;
                    case 2:
                        message.shard_winnings = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PredictionInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTADPCProfileInfo.PredictionInfo} PredictionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PredictionInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PredictionInfo message.
             * @function verify
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PredictionInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.percent != null && message.hasOwnProperty("percent"))
                    if (!$util.isInteger(message.percent))
                        return "percent: integer expected";
                if (message.shard_winnings != null && message.hasOwnProperty("shard_winnings"))
                    if (!$util.isInteger(message.shard_winnings))
                        return "shard_winnings: integer expected";
                return null;
            };
    
            /**
             * Creates a PredictionInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTADPCProfileInfo.PredictionInfo} PredictionInfo
             */
            PredictionInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTADPCProfileInfo.PredictionInfo)
                    return object;
                var message = new $root.CMsgDOTADPCProfileInfo.PredictionInfo();
                if (object.percent != null)
                    message.percent = object.percent >>> 0;
                if (object.shard_winnings != null)
                    message.shard_winnings = object.shard_winnings | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a PredictionInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.PredictionInfo} message PredictionInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PredictionInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.percent = 0;
                    object.shard_winnings = 0;
                }
                if (message.percent != null && message.hasOwnProperty("percent"))
                    object.percent = message.percent;
                if (message.shard_winnings != null && message.hasOwnProperty("shard_winnings"))
                    object.shard_winnings = message.shard_winnings;
                return object;
            };
    
            /**
             * Converts this PredictionInfo to JSON.
             * @function toJSON
             * @memberof CMsgDOTADPCProfileInfo.PredictionInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PredictionInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PredictionInfo;
        })();
    
        CMsgDOTADPCProfileInfo.FantasyInfo = (function() {
    
            /**
             * Properties of a FantasyInfo.
             * @memberof CMsgDOTADPCProfileInfo
             * @interface IFantasyInfo
             * @property {number|null} [top_90_finishes] FantasyInfo top_90_finishes
             * @property {number|null} [top_75_finishes] FantasyInfo top_75_finishes
             * @property {number|null} [top_50_finishes] FantasyInfo top_50_finishes
             * @property {number|null} [shard_winnings] FantasyInfo shard_winnings
             */
    
            /**
             * Constructs a new FantasyInfo.
             * @memberof CMsgDOTADPCProfileInfo
             * @classdesc Represents a FantasyInfo.
             * @implements IFantasyInfo
             * @constructor
             * @param {CMsgDOTADPCProfileInfo.IFantasyInfo=} [properties] Properties to set
             */
            function FantasyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FantasyInfo top_90_finishes.
             * @member {number} top_90_finishes
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @instance
             */
            FantasyInfo.prototype.top_90_finishes = 0;
    
            /**
             * FantasyInfo top_75_finishes.
             * @member {number} top_75_finishes
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @instance
             */
            FantasyInfo.prototype.top_75_finishes = 0;
    
            /**
             * FantasyInfo top_50_finishes.
             * @member {number} top_50_finishes
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @instance
             */
            FantasyInfo.prototype.top_50_finishes = 0;
    
            /**
             * FantasyInfo shard_winnings.
             * @member {number} shard_winnings
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @instance
             */
            FantasyInfo.prototype.shard_winnings = 0;
    
            /**
             * Creates a new FantasyInfo instance using the specified properties.
             * @function create
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.IFantasyInfo=} [properties] Properties to set
             * @returns {CMsgDOTADPCProfileInfo.FantasyInfo} FantasyInfo instance
             */
            FantasyInfo.create = function create(properties) {
                return new FantasyInfo(properties);
            };
    
            /**
             * Encodes the specified FantasyInfo message. Does not implicitly {@link CMsgDOTADPCProfileInfo.FantasyInfo.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.IFantasyInfo} message FantasyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FantasyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.top_90_finishes != null && Object.hasOwnProperty.call(message, "top_90_finishes"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.top_90_finishes);
                if (message.top_75_finishes != null && Object.hasOwnProperty.call(message, "top_75_finishes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.top_75_finishes);
                if (message.top_50_finishes != null && Object.hasOwnProperty.call(message, "top_50_finishes"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.top_50_finishes);
                if (message.shard_winnings != null && Object.hasOwnProperty.call(message, "shard_winnings"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.shard_winnings);
                return writer;
            };
    
            /**
             * Encodes the specified FantasyInfo message, length delimited. Does not implicitly {@link CMsgDOTADPCProfileInfo.FantasyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.IFantasyInfo} message FantasyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FantasyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FantasyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTADPCProfileInfo.FantasyInfo} FantasyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FantasyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTADPCProfileInfo.FantasyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.top_90_finishes = reader.uint32();
                        break;
                    case 2:
                        message.top_75_finishes = reader.uint32();
                        break;
                    case 3:
                        message.top_50_finishes = reader.uint32();
                        break;
                    case 4:
                        message.shard_winnings = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FantasyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTADPCProfileInfo.FantasyInfo} FantasyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FantasyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FantasyInfo message.
             * @function verify
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FantasyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.top_90_finishes != null && message.hasOwnProperty("top_90_finishes"))
                    if (!$util.isInteger(message.top_90_finishes))
                        return "top_90_finishes: integer expected";
                if (message.top_75_finishes != null && message.hasOwnProperty("top_75_finishes"))
                    if (!$util.isInteger(message.top_75_finishes))
                        return "top_75_finishes: integer expected";
                if (message.top_50_finishes != null && message.hasOwnProperty("top_50_finishes"))
                    if (!$util.isInteger(message.top_50_finishes))
                        return "top_50_finishes: integer expected";
                if (message.shard_winnings != null && message.hasOwnProperty("shard_winnings"))
                    if (!$util.isInteger(message.shard_winnings))
                        return "shard_winnings: integer expected";
                return null;
            };
    
            /**
             * Creates a FantasyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTADPCProfileInfo.FantasyInfo} FantasyInfo
             */
            FantasyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTADPCProfileInfo.FantasyInfo)
                    return object;
                var message = new $root.CMsgDOTADPCProfileInfo.FantasyInfo();
                if (object.top_90_finishes != null)
                    message.top_90_finishes = object.top_90_finishes >>> 0;
                if (object.top_75_finishes != null)
                    message.top_75_finishes = object.top_75_finishes >>> 0;
                if (object.top_50_finishes != null)
                    message.top_50_finishes = object.top_50_finishes >>> 0;
                if (object.shard_winnings != null)
                    message.shard_winnings = object.shard_winnings >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a FantasyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @static
             * @param {CMsgDOTADPCProfileInfo.FantasyInfo} message FantasyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FantasyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.top_90_finishes = 0;
                    object.top_75_finishes = 0;
                    object.top_50_finishes = 0;
                    object.shard_winnings = 0;
                }
                if (message.top_90_finishes != null && message.hasOwnProperty("top_90_finishes"))
                    object.top_90_finishes = message.top_90_finishes;
                if (message.top_75_finishes != null && message.hasOwnProperty("top_75_finishes"))
                    object.top_75_finishes = message.top_75_finishes;
                if (message.top_50_finishes != null && message.hasOwnProperty("top_50_finishes"))
                    object.top_50_finishes = message.top_50_finishes;
                if (message.shard_winnings != null && message.hasOwnProperty("shard_winnings"))
                    object.shard_winnings = message.shard_winnings;
                return object;
            };
    
            /**
             * Converts this FantasyInfo to JSON.
             * @function toJSON
             * @memberof CMsgDOTADPCProfileInfo.FantasyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FantasyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FantasyInfo;
        })();
    
        return CMsgDOTADPCProfileInfo;
    })();
    
    $root.CMsgDOTALeaderboards = (function() {
    
        /**
         * Properties of a CMsgDOTALeaderboards.
         * @exports ICMsgDOTALeaderboards
         * @interface ICMsgDOTALeaderboards
         * @property {Array.<CMsgDOTALeaderboards.IRegionLeaderboard>|null} [leaderboards] CMsgDOTALeaderboards leaderboards
         */
    
        /**
         * Constructs a new CMsgDOTALeaderboards.
         * @exports CMsgDOTALeaderboards
         * @classdesc Represents a CMsgDOTALeaderboards.
         * @implements ICMsgDOTALeaderboards
         * @constructor
         * @param {ICMsgDOTALeaderboards=} [properties] Properties to set
         */
        function CMsgDOTALeaderboards(properties) {
            this.leaderboards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTALeaderboards leaderboards.
         * @member {Array.<CMsgDOTALeaderboards.IRegionLeaderboard>} leaderboards
         * @memberof CMsgDOTALeaderboards
         * @instance
         */
        CMsgDOTALeaderboards.prototype.leaderboards = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTALeaderboards instance using the specified properties.
         * @function create
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {ICMsgDOTALeaderboards=} [properties] Properties to set
         * @returns {CMsgDOTALeaderboards} CMsgDOTALeaderboards instance
         */
        CMsgDOTALeaderboards.create = function create(properties) {
            return new CMsgDOTALeaderboards(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTALeaderboards message. Does not implicitly {@link CMsgDOTALeaderboards.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {ICMsgDOTALeaderboards} message CMsgDOTALeaderboards message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTALeaderboards.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.leaderboards != null && message.leaderboards.length)
                for (var i = 0; i < message.leaderboards.length; ++i)
                    $root.CMsgDOTALeaderboards.RegionLeaderboard.encode(message.leaderboards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTALeaderboards message, length delimited. Does not implicitly {@link CMsgDOTALeaderboards.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {ICMsgDOTALeaderboards} message CMsgDOTALeaderboards message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTALeaderboards.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTALeaderboards message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTALeaderboards} CMsgDOTALeaderboards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTALeaderboards.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTALeaderboards();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.leaderboards && message.leaderboards.length))
                        message.leaderboards = [];
                    message.leaderboards.push($root.CMsgDOTALeaderboards.RegionLeaderboard.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTALeaderboards message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTALeaderboards} CMsgDOTALeaderboards
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTALeaderboards.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTALeaderboards message.
         * @function verify
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTALeaderboards.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.leaderboards != null && message.hasOwnProperty("leaderboards")) {
                if (!Array.isArray(message.leaderboards))
                    return "leaderboards: array expected";
                for (var i = 0; i < message.leaderboards.length; ++i) {
                    var error = $root.CMsgDOTALeaderboards.RegionLeaderboard.verify(message.leaderboards[i]);
                    if (error)
                        return "leaderboards." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTALeaderboards message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTALeaderboards} CMsgDOTALeaderboards
         */
        CMsgDOTALeaderboards.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTALeaderboards)
                return object;
            var message = new $root.CMsgDOTALeaderboards();
            if (object.leaderboards) {
                if (!Array.isArray(object.leaderboards))
                    throw TypeError(".CMsgDOTALeaderboards.leaderboards: array expected");
                message.leaderboards = [];
                for (var i = 0; i < object.leaderboards.length; ++i) {
                    if (typeof object.leaderboards[i] !== "object")
                        throw TypeError(".CMsgDOTALeaderboards.leaderboards: object expected");
                    message.leaderboards[i] = $root.CMsgDOTALeaderboards.RegionLeaderboard.fromObject(object.leaderboards[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTALeaderboards message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTALeaderboards
         * @static
         * @param {CMsgDOTALeaderboards} message CMsgDOTALeaderboards
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTALeaderboards.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.leaderboards = [];
            if (message.leaderboards && message.leaderboards.length) {
                object.leaderboards = [];
                for (var j = 0; j < message.leaderboards.length; ++j)
                    object.leaderboards[j] = $root.CMsgDOTALeaderboards.RegionLeaderboard.toObject(message.leaderboards[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTALeaderboards to JSON.
         * @function toJSON
         * @memberof CMsgDOTALeaderboards
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTALeaderboards.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTALeaderboards.RegionLeaderboard = (function() {
    
            /**
             * Properties of a RegionLeaderboard.
             * @memberof CMsgDOTALeaderboards
             * @interface IRegionLeaderboard
             * @property {number|null} [division] RegionLeaderboard division
             * @property {Array.<number>|null} [account_ids] RegionLeaderboard account_ids
             */
    
            /**
             * Constructs a new RegionLeaderboard.
             * @memberof CMsgDOTALeaderboards
             * @classdesc Represents a RegionLeaderboard.
             * @implements IRegionLeaderboard
             * @constructor
             * @param {CMsgDOTALeaderboards.IRegionLeaderboard=} [properties] Properties to set
             */
            function RegionLeaderboard(properties) {
                this.account_ids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RegionLeaderboard division.
             * @member {number} division
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @instance
             */
            RegionLeaderboard.prototype.division = 0;
    
            /**
             * RegionLeaderboard account_ids.
             * @member {Array.<number>} account_ids
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @instance
             */
            RegionLeaderboard.prototype.account_ids = $util.emptyArray;
    
            /**
             * Creates a new RegionLeaderboard instance using the specified properties.
             * @function create
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {CMsgDOTALeaderboards.IRegionLeaderboard=} [properties] Properties to set
             * @returns {CMsgDOTALeaderboards.RegionLeaderboard} RegionLeaderboard instance
             */
            RegionLeaderboard.create = function create(properties) {
                return new RegionLeaderboard(properties);
            };
    
            /**
             * Encodes the specified RegionLeaderboard message. Does not implicitly {@link CMsgDOTALeaderboards.RegionLeaderboard.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {CMsgDOTALeaderboards.IRegionLeaderboard} message RegionLeaderboard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegionLeaderboard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.division != null && Object.hasOwnProperty.call(message, "division"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.division);
                if (message.account_ids != null && message.account_ids.length)
                    for (var i = 0; i < message.account_ids.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.account_ids[i]);
                return writer;
            };
    
            /**
             * Encodes the specified RegionLeaderboard message, length delimited. Does not implicitly {@link CMsgDOTALeaderboards.RegionLeaderboard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {CMsgDOTALeaderboards.IRegionLeaderboard} message RegionLeaderboard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegionLeaderboard.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RegionLeaderboard message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTALeaderboards.RegionLeaderboard} RegionLeaderboard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegionLeaderboard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTALeaderboards.RegionLeaderboard();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.division = reader.uint32();
                        break;
                    case 2:
                        if (!(message.account_ids && message.account_ids.length))
                            message.account_ids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.account_ids.push(reader.uint32());
                        } else
                            message.account_ids.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RegionLeaderboard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTALeaderboards.RegionLeaderboard} RegionLeaderboard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegionLeaderboard.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RegionLeaderboard message.
             * @function verify
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RegionLeaderboard.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.division != null && message.hasOwnProperty("division"))
                    if (!$util.isInteger(message.division))
                        return "division: integer expected";
                if (message.account_ids != null && message.hasOwnProperty("account_ids")) {
                    if (!Array.isArray(message.account_ids))
                        return "account_ids: array expected";
                    for (var i = 0; i < message.account_ids.length; ++i)
                        if (!$util.isInteger(message.account_ids[i]))
                            return "account_ids: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a RegionLeaderboard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTALeaderboards.RegionLeaderboard} RegionLeaderboard
             */
            RegionLeaderboard.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTALeaderboards.RegionLeaderboard)
                    return object;
                var message = new $root.CMsgDOTALeaderboards.RegionLeaderboard();
                if (object.division != null)
                    message.division = object.division >>> 0;
                if (object.account_ids) {
                    if (!Array.isArray(object.account_ids))
                        throw TypeError(".CMsgDOTALeaderboards.RegionLeaderboard.account_ids: array expected");
                    message.account_ids = [];
                    for (var i = 0; i < object.account_ids.length; ++i)
                        message.account_ids[i] = object.account_ids[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RegionLeaderboard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @static
             * @param {CMsgDOTALeaderboards.RegionLeaderboard} message RegionLeaderboard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RegionLeaderboard.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.account_ids = [];
                if (options.defaults)
                    object.division = 0;
                if (message.division != null && message.hasOwnProperty("division"))
                    object.division = message.division;
                if (message.account_ids && message.account_ids.length) {
                    object.account_ids = [];
                    for (var j = 0; j < message.account_ids.length; ++j)
                        object.account_ids[j] = message.account_ids[j];
                }
                return object;
            };
    
            /**
             * Converts this RegionLeaderboard to JSON.
             * @function toJSON
             * @memberof CMsgDOTALeaderboards.RegionLeaderboard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RegionLeaderboard.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RegionLeaderboard;
        })();
    
        return CMsgDOTALeaderboards;
    })();
    
    $root.CMsgDOTACreateFantasyLeagueRequest = (function() {
    
        /**
         * Properties of a CMsgDOTACreateFantasyLeagueRequest.
         * @exports ICMsgDOTACreateFantasyLeagueRequest
         * @interface ICMsgDOTACreateFantasyLeagueRequest
         * @property {string|null} [league_name] CMsgDOTACreateFantasyLeagueRequest league_name
         * @property {number|Long|null} [league_logo] CMsgDOTACreateFantasyLeagueRequest league_logo
         * @property {Fantasy_Selection_Mode|null} [selection_mode] CMsgDOTACreateFantasyLeagueRequest selection_mode
         * @property {number|null} [team_count] CMsgDOTACreateFantasyLeagueRequest team_count
         */
    
        /**
         * Constructs a new CMsgDOTACreateFantasyLeagueRequest.
         * @exports CMsgDOTACreateFantasyLeagueRequest
         * @classdesc Represents a CMsgDOTACreateFantasyLeagueRequest.
         * @implements ICMsgDOTACreateFantasyLeagueRequest
         * @constructor
         * @param {ICMsgDOTACreateFantasyLeagueRequest=} [properties] Properties to set
         */
        function CMsgDOTACreateFantasyLeagueRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTACreateFantasyLeagueRequest league_name.
         * @member {string} league_name
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @instance
         */
        CMsgDOTACreateFantasyLeagueRequest.prototype.league_name = "";
    
        /**
         * CMsgDOTACreateFantasyLeagueRequest league_logo.
         * @member {number|Long} league_logo
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @instance
         */
        CMsgDOTACreateFantasyLeagueRequest.prototype.league_logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTACreateFantasyLeagueRequest selection_mode.
         * @member {Fantasy_Selection_Mode} selection_mode
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @instance
         */
        CMsgDOTACreateFantasyLeagueRequest.prototype.selection_mode = 0;
    
        /**
         * CMsgDOTACreateFantasyLeagueRequest team_count.
         * @member {number} team_count
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @instance
         */
        CMsgDOTACreateFantasyLeagueRequest.prototype.team_count = 0;
    
        /**
         * Creates a new CMsgDOTACreateFantasyLeagueRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {ICMsgDOTACreateFantasyLeagueRequest=} [properties] Properties to set
         * @returns {CMsgDOTACreateFantasyLeagueRequest} CMsgDOTACreateFantasyLeagueRequest instance
         */
        CMsgDOTACreateFantasyLeagueRequest.create = function create(properties) {
            return new CMsgDOTACreateFantasyLeagueRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTACreateFantasyLeagueRequest message. Does not implicitly {@link CMsgDOTACreateFantasyLeagueRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {ICMsgDOTACreateFantasyLeagueRequest} message CMsgDOTACreateFantasyLeagueRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACreateFantasyLeagueRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.league_name != null && Object.hasOwnProperty.call(message, "league_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.league_name);
            if (message.league_logo != null && Object.hasOwnProperty.call(message, "league_logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.league_logo);
            if (message.selection_mode != null && Object.hasOwnProperty.call(message, "selection_mode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.selection_mode);
            if (message.team_count != null && Object.hasOwnProperty.call(message, "team_count"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.team_count);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTACreateFantasyLeagueRequest message, length delimited. Does not implicitly {@link CMsgDOTACreateFantasyLeagueRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {ICMsgDOTACreateFantasyLeagueRequest} message CMsgDOTACreateFantasyLeagueRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACreateFantasyLeagueRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTACreateFantasyLeagueRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTACreateFantasyLeagueRequest} CMsgDOTACreateFantasyLeagueRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACreateFantasyLeagueRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTACreateFantasyLeagueRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.league_name = reader.string();
                    break;
                case 2:
                    message.league_logo = reader.uint64();
                    break;
                case 3:
                    message.selection_mode = reader.int32();
                    break;
                case 4:
                    message.team_count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTACreateFantasyLeagueRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTACreateFantasyLeagueRequest} CMsgDOTACreateFantasyLeagueRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACreateFantasyLeagueRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTACreateFantasyLeagueRequest message.
         * @function verify
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTACreateFantasyLeagueRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.league_name != null && message.hasOwnProperty("league_name"))
                if (!$util.isString(message.league_name))
                    return "league_name: string expected";
            if (message.league_logo != null && message.hasOwnProperty("league_logo"))
                if (!$util.isInteger(message.league_logo) && !(message.league_logo && $util.isInteger(message.league_logo.low) && $util.isInteger(message.league_logo.high)))
                    return "league_logo: integer|Long expected";
            if (message.selection_mode != null && message.hasOwnProperty("selection_mode"))
                switch (message.selection_mode) {
                default:
                    return "selection_mode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.team_count != null && message.hasOwnProperty("team_count"))
                if (!$util.isInteger(message.team_count))
                    return "team_count: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTACreateFantasyLeagueRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTACreateFantasyLeagueRequest} CMsgDOTACreateFantasyLeagueRequest
         */
        CMsgDOTACreateFantasyLeagueRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTACreateFantasyLeagueRequest)
                return object;
            var message = new $root.CMsgDOTACreateFantasyLeagueRequest();
            if (object.league_name != null)
                message.league_name = String(object.league_name);
            if (object.league_logo != null)
                if ($util.Long)
                    (message.league_logo = $util.Long.fromValue(object.league_logo)).unsigned = true;
                else if (typeof object.league_logo === "string")
                    message.league_logo = parseInt(object.league_logo, 10);
                else if (typeof object.league_logo === "number")
                    message.league_logo = object.league_logo;
                else if (typeof object.league_logo === "object")
                    message.league_logo = new $util.LongBits(object.league_logo.low >>> 0, object.league_logo.high >>> 0).toNumber(true);
            switch (object.selection_mode) {
            case "FANTASY_SELECTION_INVALID":
            case 0:
                message.selection_mode = 0;
                break;
            case "FANTASY_SELECTION_LOCKED":
            case 1:
                message.selection_mode = 1;
                break;
            case "FANTASY_SELECTION_SHUFFLE":
            case 2:
                message.selection_mode = 2;
                break;
            case "FANTASY_SELECTION_FREE_PICK":
            case 3:
                message.selection_mode = 3;
                break;
            case "FANTASY_SELECTION_ENDED":
            case 4:
                message.selection_mode = 4;
                break;
            case "FANTASY_SELECTION_PRE_SEASON":
            case 5:
                message.selection_mode = 5;
                break;
            case "FANTASY_SELECTION_PRE_DRAFT":
            case 6:
                message.selection_mode = 6;
                break;
            case "FANTASY_SELECTION_DRAFTING":
            case 7:
                message.selection_mode = 7;
                break;
            case "FANTASY_SELECTION_REGULAR_SEASON":
            case 8:
                message.selection_mode = 8;
                break;
            case "FANTASY_SELECTION_CARD_BASED":
            case 9:
                message.selection_mode = 9;
                break;
            }
            if (object.team_count != null)
                message.team_count = object.team_count >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTACreateFantasyLeagueRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @static
         * @param {CMsgDOTACreateFantasyLeagueRequest} message CMsgDOTACreateFantasyLeagueRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTACreateFantasyLeagueRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.league_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.league_logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.league_logo = options.longs === String ? "0" : 0;
                object.selection_mode = options.enums === String ? "FANTASY_SELECTION_INVALID" : 0;
                object.team_count = 0;
            }
            if (message.league_name != null && message.hasOwnProperty("league_name"))
                object.league_name = message.league_name;
            if (message.league_logo != null && message.hasOwnProperty("league_logo"))
                if (typeof message.league_logo === "number")
                    object.league_logo = options.longs === String ? String(message.league_logo) : message.league_logo;
                else
                    object.league_logo = options.longs === String ? $util.Long.prototype.toString.call(message.league_logo) : options.longs === Number ? new $util.LongBits(message.league_logo.low >>> 0, message.league_logo.high >>> 0).toNumber(true) : message.league_logo;
            if (message.selection_mode != null && message.hasOwnProperty("selection_mode"))
                object.selection_mode = options.enums === String ? $root.Fantasy_Selection_Mode[message.selection_mode] : message.selection_mode;
            if (message.team_count != null && message.hasOwnProperty("team_count"))
                object.team_count = message.team_count;
            return object;
        };
    
        /**
         * Converts this CMsgDOTACreateFantasyLeagueRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTACreateFantasyLeagueRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTACreateFantasyLeagueRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTACreateFantasyLeagueRequest;
    })();
    
    $root.CMsgDOTACreateFantasyLeagueResponse = (function() {
    
        /**
         * Properties of a CMsgDOTACreateFantasyLeagueResponse.
         * @exports ICMsgDOTACreateFantasyLeagueResponse
         * @interface ICMsgDOTACreateFantasyLeagueResponse
         * @property {CMsgDOTACreateFantasyLeagueResponse.EResult|null} [result] CMsgDOTACreateFantasyLeagueResponse result
         */
    
        /**
         * Constructs a new CMsgDOTACreateFantasyLeagueResponse.
         * @exports CMsgDOTACreateFantasyLeagueResponse
         * @classdesc Represents a CMsgDOTACreateFantasyLeagueResponse.
         * @implements ICMsgDOTACreateFantasyLeagueResponse
         * @constructor
         * @param {ICMsgDOTACreateFantasyLeagueResponse=} [properties] Properties to set
         */
        function CMsgDOTACreateFantasyLeagueResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTACreateFantasyLeagueResponse result.
         * @member {CMsgDOTACreateFantasyLeagueResponse.EResult} result
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @instance
         */
        CMsgDOTACreateFantasyLeagueResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTACreateFantasyLeagueResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {ICMsgDOTACreateFantasyLeagueResponse=} [properties] Properties to set
         * @returns {CMsgDOTACreateFantasyLeagueResponse} CMsgDOTACreateFantasyLeagueResponse instance
         */
        CMsgDOTACreateFantasyLeagueResponse.create = function create(properties) {
            return new CMsgDOTACreateFantasyLeagueResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTACreateFantasyLeagueResponse message. Does not implicitly {@link CMsgDOTACreateFantasyLeagueResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {ICMsgDOTACreateFantasyLeagueResponse} message CMsgDOTACreateFantasyLeagueResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACreateFantasyLeagueResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTACreateFantasyLeagueResponse message, length delimited. Does not implicitly {@link CMsgDOTACreateFantasyLeagueResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {ICMsgDOTACreateFantasyLeagueResponse} message CMsgDOTACreateFantasyLeagueResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACreateFantasyLeagueResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTACreateFantasyLeagueResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTACreateFantasyLeagueResponse} CMsgDOTACreateFantasyLeagueResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACreateFantasyLeagueResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTACreateFantasyLeagueResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTACreateFantasyLeagueResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTACreateFantasyLeagueResponse} CMsgDOTACreateFantasyLeagueResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACreateFantasyLeagueResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTACreateFantasyLeagueResponse message.
         * @function verify
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTACreateFantasyLeagueResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTACreateFantasyLeagueResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTACreateFantasyLeagueResponse} CMsgDOTACreateFantasyLeagueResponse
         */
        CMsgDOTACreateFantasyLeagueResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTACreateFantasyLeagueResponse)
                return object;
            var message = new $root.CMsgDOTACreateFantasyLeagueResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_TOO_MANY_LEAGUES":
            case 2:
                message.result = 2;
                break;
            case "ERROR_INVALID_TEAM_COUNT":
            case 3:
                message.result = 3;
                break;
            case "ERROR_CREATION_DISABLED":
            case 4:
                message.result = 4;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTACreateFantasyLeagueResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @static
         * @param {CMsgDOTACreateFantasyLeagueResponse} message CMsgDOTACreateFantasyLeagueResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTACreateFantasyLeagueResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTACreateFantasyLeagueResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTACreateFantasyLeagueResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTACreateFantasyLeagueResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTACreateFantasyLeagueResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTACreateFantasyLeagueResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_TOO_MANY_LEAGUES=2 ERROR_TOO_MANY_LEAGUES value
         * @property {number} ERROR_INVALID_TEAM_COUNT=3 ERROR_INVALID_TEAM_COUNT value
         * @property {number} ERROR_CREATION_DISABLED=4 ERROR_CREATION_DISABLED value
         */
        CMsgDOTACreateFantasyLeagueResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_TOO_MANY_LEAGUES"] = 2;
            values[valuesById[3] = "ERROR_INVALID_TEAM_COUNT"] = 3;
            values[valuesById[4] = "ERROR_CREATION_DISABLED"] = 4;
            return values;
        })();
    
        return CMsgDOTACreateFantasyLeagueResponse;
    })();
    
    $root.CMsgFantasyLeagueScoring = (function() {
    
        /**
         * Properties of a CMsgFantasyLeagueScoring.
         * @exports ICMsgFantasyLeagueScoring
         * @interface ICMsgFantasyLeagueScoring
         * @property {number|null} [level] CMsgFantasyLeagueScoring level
         * @property {number|null} [kills] CMsgFantasyLeagueScoring kills
         * @property {number|null} [deaths] CMsgFantasyLeagueScoring deaths
         * @property {number|null} [assists] CMsgFantasyLeagueScoring assists
         * @property {number|null} [last_hits] CMsgFantasyLeagueScoring last_hits
         * @property {number|null} [denies] CMsgFantasyLeagueScoring denies
         * @property {number|null} [gpm] CMsgFantasyLeagueScoring gpm
         * @property {number|null} [xppm] CMsgFantasyLeagueScoring xppm
         * @property {number|null} [stuns] CMsgFantasyLeagueScoring stuns
         * @property {number|null} [healing] CMsgFantasyLeagueScoring healing
         * @property {number|null} [tower_kills] CMsgFantasyLeagueScoring tower_kills
         * @property {number|null} [roshan_kills] CMsgFantasyLeagueScoring roshan_kills
         * @property {number|null} [multiplier_premium] CMsgFantasyLeagueScoring multiplier_premium
         * @property {number|null} [multiplier_professional] CMsgFantasyLeagueScoring multiplier_professional
         */
    
        /**
         * Constructs a new CMsgFantasyLeagueScoring.
         * @exports CMsgFantasyLeagueScoring
         * @classdesc Represents a CMsgFantasyLeagueScoring.
         * @implements ICMsgFantasyLeagueScoring
         * @constructor
         * @param {ICMsgFantasyLeagueScoring=} [properties] Properties to set
         */
        function CMsgFantasyLeagueScoring(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgFantasyLeagueScoring level.
         * @member {number} level
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.level = 0;
    
        /**
         * CMsgFantasyLeagueScoring kills.
         * @member {number} kills
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.kills = 0;
    
        /**
         * CMsgFantasyLeagueScoring deaths.
         * @member {number} deaths
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.deaths = 0;
    
        /**
         * CMsgFantasyLeagueScoring assists.
         * @member {number} assists
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.assists = 0;
    
        /**
         * CMsgFantasyLeagueScoring last_hits.
         * @member {number} last_hits
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.last_hits = 0;
    
        /**
         * CMsgFantasyLeagueScoring denies.
         * @member {number} denies
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.denies = 0;
    
        /**
         * CMsgFantasyLeagueScoring gpm.
         * @member {number} gpm
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.gpm = 0;
    
        /**
         * CMsgFantasyLeagueScoring xppm.
         * @member {number} xppm
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.xppm = 0;
    
        /**
         * CMsgFantasyLeagueScoring stuns.
         * @member {number} stuns
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.stuns = 0;
    
        /**
         * CMsgFantasyLeagueScoring healing.
         * @member {number} healing
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.healing = 0;
    
        /**
         * CMsgFantasyLeagueScoring tower_kills.
         * @member {number} tower_kills
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.tower_kills = 0;
    
        /**
         * CMsgFantasyLeagueScoring roshan_kills.
         * @member {number} roshan_kills
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.roshan_kills = 0;
    
        /**
         * CMsgFantasyLeagueScoring multiplier_premium.
         * @member {number} multiplier_premium
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.multiplier_premium = 0;
    
        /**
         * CMsgFantasyLeagueScoring multiplier_professional.
         * @member {number} multiplier_professional
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         */
        CMsgFantasyLeagueScoring.prototype.multiplier_professional = 0;
    
        /**
         * Creates a new CMsgFantasyLeagueScoring instance using the specified properties.
         * @function create
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {ICMsgFantasyLeagueScoring=} [properties] Properties to set
         * @returns {CMsgFantasyLeagueScoring} CMsgFantasyLeagueScoring instance
         */
        CMsgFantasyLeagueScoring.create = function create(properties) {
            return new CMsgFantasyLeagueScoring(properties);
        };
    
        /**
         * Encodes the specified CMsgFantasyLeagueScoring message. Does not implicitly {@link CMsgFantasyLeagueScoring.verify|verify} messages.
         * @function encode
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {ICMsgFantasyLeagueScoring} message CMsgFantasyLeagueScoring message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgFantasyLeagueScoring.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.level);
            if (message.kills != null && Object.hasOwnProperty.call(message, "kills"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.kills);
            if (message.deaths != null && Object.hasOwnProperty.call(message, "deaths"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.deaths);
            if (message.assists != null && Object.hasOwnProperty.call(message, "assists"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.assists);
            if (message.last_hits != null && Object.hasOwnProperty.call(message, "last_hits"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.last_hits);
            if (message.denies != null && Object.hasOwnProperty.call(message, "denies"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.denies);
            if (message.gpm != null && Object.hasOwnProperty.call(message, "gpm"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.gpm);
            if (message.xppm != null && Object.hasOwnProperty.call(message, "xppm"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.xppm);
            if (message.stuns != null && Object.hasOwnProperty.call(message, "stuns"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.stuns);
            if (message.healing != null && Object.hasOwnProperty.call(message, "healing"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.healing);
            if (message.tower_kills != null && Object.hasOwnProperty.call(message, "tower_kills"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.tower_kills);
            if (message.roshan_kills != null && Object.hasOwnProperty.call(message, "roshan_kills"))
                writer.uint32(/* id 12, wireType 5 =*/101).float(message.roshan_kills);
            if (message.multiplier_premium != null && Object.hasOwnProperty.call(message, "multiplier_premium"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.multiplier_premium);
            if (message.multiplier_professional != null && Object.hasOwnProperty.call(message, "multiplier_professional"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.multiplier_professional);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgFantasyLeagueScoring message, length delimited. Does not implicitly {@link CMsgFantasyLeagueScoring.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {ICMsgFantasyLeagueScoring} message CMsgFantasyLeagueScoring message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgFantasyLeagueScoring.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgFantasyLeagueScoring message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgFantasyLeagueScoring} CMsgFantasyLeagueScoring
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgFantasyLeagueScoring.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgFantasyLeagueScoring();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.float();
                    break;
                case 2:
                    message.kills = reader.float();
                    break;
                case 3:
                    message.deaths = reader.float();
                    break;
                case 4:
                    message.assists = reader.float();
                    break;
                case 5:
                    message.last_hits = reader.float();
                    break;
                case 6:
                    message.denies = reader.float();
                    break;
                case 7:
                    message.gpm = reader.float();
                    break;
                case 8:
                    message.xppm = reader.float();
                    break;
                case 9:
                    message.stuns = reader.float();
                    break;
                case 10:
                    message.healing = reader.float();
                    break;
                case 11:
                    message.tower_kills = reader.float();
                    break;
                case 12:
                    message.roshan_kills = reader.float();
                    break;
                case 13:
                    message.multiplier_premium = reader.float();
                    break;
                case 14:
                    message.multiplier_professional = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgFantasyLeagueScoring message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgFantasyLeagueScoring} CMsgFantasyLeagueScoring
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgFantasyLeagueScoring.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgFantasyLeagueScoring message.
         * @function verify
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgFantasyLeagueScoring.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level !== "number")
                    return "level: number expected";
            if (message.kills != null && message.hasOwnProperty("kills"))
                if (typeof message.kills !== "number")
                    return "kills: number expected";
            if (message.deaths != null && message.hasOwnProperty("deaths"))
                if (typeof message.deaths !== "number")
                    return "deaths: number expected";
            if (message.assists != null && message.hasOwnProperty("assists"))
                if (typeof message.assists !== "number")
                    return "assists: number expected";
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                if (typeof message.last_hits !== "number")
                    return "last_hits: number expected";
            if (message.denies != null && message.hasOwnProperty("denies"))
                if (typeof message.denies !== "number")
                    return "denies: number expected";
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                if (typeof message.gpm !== "number")
                    return "gpm: number expected";
            if (message.xppm != null && message.hasOwnProperty("xppm"))
                if (typeof message.xppm !== "number")
                    return "xppm: number expected";
            if (message.stuns != null && message.hasOwnProperty("stuns"))
                if (typeof message.stuns !== "number")
                    return "stuns: number expected";
            if (message.healing != null && message.hasOwnProperty("healing"))
                if (typeof message.healing !== "number")
                    return "healing: number expected";
            if (message.tower_kills != null && message.hasOwnProperty("tower_kills"))
                if (typeof message.tower_kills !== "number")
                    return "tower_kills: number expected";
            if (message.roshan_kills != null && message.hasOwnProperty("roshan_kills"))
                if (typeof message.roshan_kills !== "number")
                    return "roshan_kills: number expected";
            if (message.multiplier_premium != null && message.hasOwnProperty("multiplier_premium"))
                if (typeof message.multiplier_premium !== "number")
                    return "multiplier_premium: number expected";
            if (message.multiplier_professional != null && message.hasOwnProperty("multiplier_professional"))
                if (typeof message.multiplier_professional !== "number")
                    return "multiplier_professional: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgFantasyLeagueScoring message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgFantasyLeagueScoring} CMsgFantasyLeagueScoring
         */
        CMsgFantasyLeagueScoring.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgFantasyLeagueScoring)
                return object;
            var message = new $root.CMsgFantasyLeagueScoring();
            if (object.level != null)
                message.level = Number(object.level);
            if (object.kills != null)
                message.kills = Number(object.kills);
            if (object.deaths != null)
                message.deaths = Number(object.deaths);
            if (object.assists != null)
                message.assists = Number(object.assists);
            if (object.last_hits != null)
                message.last_hits = Number(object.last_hits);
            if (object.denies != null)
                message.denies = Number(object.denies);
            if (object.gpm != null)
                message.gpm = Number(object.gpm);
            if (object.xppm != null)
                message.xppm = Number(object.xppm);
            if (object.stuns != null)
                message.stuns = Number(object.stuns);
            if (object.healing != null)
                message.healing = Number(object.healing);
            if (object.tower_kills != null)
                message.tower_kills = Number(object.tower_kills);
            if (object.roshan_kills != null)
                message.roshan_kills = Number(object.roshan_kills);
            if (object.multiplier_premium != null)
                message.multiplier_premium = Number(object.multiplier_premium);
            if (object.multiplier_professional != null)
                message.multiplier_professional = Number(object.multiplier_professional);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgFantasyLeagueScoring message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgFantasyLeagueScoring
         * @static
         * @param {CMsgFantasyLeagueScoring} message CMsgFantasyLeagueScoring
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgFantasyLeagueScoring.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.level = 0;
                object.kills = 0;
                object.deaths = 0;
                object.assists = 0;
                object.last_hits = 0;
                object.denies = 0;
                object.gpm = 0;
                object.xppm = 0;
                object.stuns = 0;
                object.healing = 0;
                object.tower_kills = 0;
                object.roshan_kills = 0;
                object.multiplier_premium = 0;
                object.multiplier_professional = 0;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = options.json && !isFinite(message.level) ? String(message.level) : message.level;
            if (message.kills != null && message.hasOwnProperty("kills"))
                object.kills = options.json && !isFinite(message.kills) ? String(message.kills) : message.kills;
            if (message.deaths != null && message.hasOwnProperty("deaths"))
                object.deaths = options.json && !isFinite(message.deaths) ? String(message.deaths) : message.deaths;
            if (message.assists != null && message.hasOwnProperty("assists"))
                object.assists = options.json && !isFinite(message.assists) ? String(message.assists) : message.assists;
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                object.last_hits = options.json && !isFinite(message.last_hits) ? String(message.last_hits) : message.last_hits;
            if (message.denies != null && message.hasOwnProperty("denies"))
                object.denies = options.json && !isFinite(message.denies) ? String(message.denies) : message.denies;
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                object.gpm = options.json && !isFinite(message.gpm) ? String(message.gpm) : message.gpm;
            if (message.xppm != null && message.hasOwnProperty("xppm"))
                object.xppm = options.json && !isFinite(message.xppm) ? String(message.xppm) : message.xppm;
            if (message.stuns != null && message.hasOwnProperty("stuns"))
                object.stuns = options.json && !isFinite(message.stuns) ? String(message.stuns) : message.stuns;
            if (message.healing != null && message.hasOwnProperty("healing"))
                object.healing = options.json && !isFinite(message.healing) ? String(message.healing) : message.healing;
            if (message.tower_kills != null && message.hasOwnProperty("tower_kills"))
                object.tower_kills = options.json && !isFinite(message.tower_kills) ? String(message.tower_kills) : message.tower_kills;
            if (message.roshan_kills != null && message.hasOwnProperty("roshan_kills"))
                object.roshan_kills = options.json && !isFinite(message.roshan_kills) ? String(message.roshan_kills) : message.roshan_kills;
            if (message.multiplier_premium != null && message.hasOwnProperty("multiplier_premium"))
                object.multiplier_premium = options.json && !isFinite(message.multiplier_premium) ? String(message.multiplier_premium) : message.multiplier_premium;
            if (message.multiplier_professional != null && message.hasOwnProperty("multiplier_professional"))
                object.multiplier_professional = options.json && !isFinite(message.multiplier_professional) ? String(message.multiplier_professional) : message.multiplier_professional;
            return object;
        };
    
        /**
         * Converts this CMsgFantasyLeagueScoring to JSON.
         * @function toJSON
         * @memberof CMsgFantasyLeagueScoring
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgFantasyLeagueScoring.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgFantasyLeagueScoring;
    })();
    
    $root.CMsgDOTAFantasyLeagueInfo = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueInfo.
         * @exports ICMsgDOTAFantasyLeagueInfo
         * @interface ICMsgDOTAFantasyLeagueInfo
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueInfo fantasy_league_id
         * @property {number|null} [commissioner_account_id] CMsgDOTAFantasyLeagueInfo commissioner_account_id
         * @property {string|null} [fantasy_league_name] CMsgDOTAFantasyLeagueInfo fantasy_league_name
         * @property {Fantasy_Selection_Mode|null} [selection_mode] CMsgDOTAFantasyLeagueInfo selection_mode
         * @property {number|null} [team_count] CMsgDOTAFantasyLeagueInfo team_count
         * @property {number|Long|null} [logo] CMsgDOTAFantasyLeagueInfo logo
         * @property {ICMsgFantasyLeagueScoring|null} [scoring] CMsgDOTAFantasyLeagueInfo scoring
         * @property {number|null} [draft_time] CMsgDOTAFantasyLeagueInfo draft_time
         * @property {number|null} [draft_pick_time] CMsgDOTAFantasyLeagueInfo draft_pick_time
         * @property {number|null} [season_start] CMsgDOTAFantasyLeagueInfo season_start
         * @property {number|null} [season_length] CMsgDOTAFantasyLeagueInfo season_length
         * @property {number|null} [veto_votes] CMsgDOTAFantasyLeagueInfo veto_votes
         * @property {number|null} [acquisitions] CMsgDOTAFantasyLeagueInfo acquisitions
         * @property {number|null} [slot_1] CMsgDOTAFantasyLeagueInfo slot_1
         * @property {number|null} [slot_2] CMsgDOTAFantasyLeagueInfo slot_2
         * @property {number|null} [slot_3] CMsgDOTAFantasyLeagueInfo slot_3
         * @property {number|null} [slot_4] CMsgDOTAFantasyLeagueInfo slot_4
         * @property {number|null} [slot_5] CMsgDOTAFantasyLeagueInfo slot_5
         * @property {number|null} [bench_slots] CMsgDOTAFantasyLeagueInfo bench_slots
         * @property {Array.<CMsgDOTAFantasyLeagueInfo.IOwnerInfo>|null} [owner_info] CMsgDOTAFantasyLeagueInfo owner_info
         * @property {Array.<number>|null} [players] CMsgDOTAFantasyLeagueInfo players
         * @property {number|null} [time_zone] CMsgDOTAFantasyLeagueInfo time_zone
         * @property {number|null} [season] CMsgDOTAFantasyLeagueInfo season
         * @property {string|null} [password] CMsgDOTAFantasyLeagueInfo password
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueInfo.
         * @exports CMsgDOTAFantasyLeagueInfo
         * @classdesc Represents a CMsgDOTAFantasyLeagueInfo.
         * @implements ICMsgDOTAFantasyLeagueInfo
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueInfo=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueInfo(properties) {
            this.owner_info = [];
            this.players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueInfo fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo commissioner_account_id.
         * @member {number} commissioner_account_id
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.commissioner_account_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo fantasy_league_name.
         * @member {string} fantasy_league_name
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.fantasy_league_name = "";
    
        /**
         * CMsgDOTAFantasyLeagueInfo selection_mode.
         * @member {Fantasy_Selection_Mode} selection_mode
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.selection_mode = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo team_count.
         * @member {number} team_count
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.team_count = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo logo.
         * @member {number|Long} logo
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo scoring.
         * @member {ICMsgFantasyLeagueScoring|null|undefined} scoring
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.scoring = null;
    
        /**
         * CMsgDOTAFantasyLeagueInfo draft_time.
         * @member {number} draft_time
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.draft_time = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo draft_pick_time.
         * @member {number} draft_pick_time
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.draft_pick_time = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo season_start.
         * @member {number} season_start
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.season_start = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo season_length.
         * @member {number} season_length
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.season_length = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo veto_votes.
         * @member {number} veto_votes
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.veto_votes = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo acquisitions.
         * @member {number} acquisitions
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.acquisitions = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo slot_1.
         * @member {number} slot_1
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.slot_1 = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo slot_2.
         * @member {number} slot_2
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.slot_2 = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo slot_3.
         * @member {number} slot_3
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.slot_3 = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo slot_4.
         * @member {number} slot_4
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.slot_4 = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo slot_5.
         * @member {number} slot_5
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.slot_5 = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo bench_slots.
         * @member {number} bench_slots
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.bench_slots = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo owner_info.
         * @member {Array.<CMsgDOTAFantasyLeagueInfo.IOwnerInfo>} owner_info
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.owner_info = $util.emptyArray;
    
        /**
         * CMsgDOTAFantasyLeagueInfo players.
         * @member {Array.<number>} players
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.players = $util.emptyArray;
    
        /**
         * CMsgDOTAFantasyLeagueInfo time_zone.
         * @member {number} time_zone
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.time_zone = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo season.
         * @member {number} season
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.season = 0;
    
        /**
         * CMsgDOTAFantasyLeagueInfo password.
         * @member {string} password
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         */
        CMsgDOTAFantasyLeagueInfo.prototype.password = "";
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueInfo instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfo=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueInfo} CMsgDOTAFantasyLeagueInfo instance
         */
        CMsgDOTAFantasyLeagueInfo.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueInfo message. Does not implicitly {@link CMsgDOTAFantasyLeagueInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfo} message CMsgDOTAFantasyLeagueInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.commissioner_account_id != null && Object.hasOwnProperty.call(message, "commissioner_account_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.commissioner_account_id);
            if (message.fantasy_league_name != null && Object.hasOwnProperty.call(message, "fantasy_league_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fantasy_league_name);
            if (message.selection_mode != null && Object.hasOwnProperty.call(message, "selection_mode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.selection_mode);
            if (message.team_count != null && Object.hasOwnProperty.call(message, "team_count"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.team_count);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.logo);
            if (message.scoring != null && Object.hasOwnProperty.call(message, "scoring"))
                $root.CMsgFantasyLeagueScoring.encode(message.scoring, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.draft_time != null && Object.hasOwnProperty.call(message, "draft_time"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.draft_time);
            if (message.draft_pick_time != null && Object.hasOwnProperty.call(message, "draft_pick_time"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.draft_pick_time);
            if (message.season_start != null && Object.hasOwnProperty.call(message, "season_start"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.season_start);
            if (message.season_length != null && Object.hasOwnProperty.call(message, "season_length"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.season_length);
            if (message.veto_votes != null && Object.hasOwnProperty.call(message, "veto_votes"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.veto_votes);
            if (message.acquisitions != null && Object.hasOwnProperty.call(message, "acquisitions"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.acquisitions);
            if (message.slot_1 != null && Object.hasOwnProperty.call(message, "slot_1"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.slot_1);
            if (message.slot_2 != null && Object.hasOwnProperty.call(message, "slot_2"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.slot_2);
            if (message.slot_3 != null && Object.hasOwnProperty.call(message, "slot_3"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.slot_3);
            if (message.slot_4 != null && Object.hasOwnProperty.call(message, "slot_4"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.slot_4);
            if (message.slot_5 != null && Object.hasOwnProperty.call(message, "slot_5"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.slot_5);
            if (message.bench_slots != null && Object.hasOwnProperty.call(message, "bench_slots"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.bench_slots);
            if (message.owner_info != null && message.owner_info.length)
                for (var i = 0; i < message.owner_info.length; ++i)
                    $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo.encode(message.owner_info[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.players[i]);
            if (message.time_zone != null && Object.hasOwnProperty.call(message, "time_zone"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.time_zone);
            if (message.season != null && Object.hasOwnProperty.call(message, "season"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.season);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 29, wireType 2 =*/234).string(message.password);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueInfo message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfo} message CMsgDOTAFantasyLeagueInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueInfo} CMsgDOTAFantasyLeagueInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.commissioner_account_id = reader.uint32();
                    break;
                case 3:
                    message.fantasy_league_name = reader.string();
                    break;
                case 4:
                    message.selection_mode = reader.int32();
                    break;
                case 5:
                    message.team_count = reader.uint32();
                    break;
                case 6:
                    message.logo = reader.uint64();
                    break;
                case 7:
                    message.scoring = $root.CMsgFantasyLeagueScoring.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.draft_time = reader.uint32();
                    break;
                case 13:
                    message.draft_pick_time = reader.uint32();
                    break;
                case 15:
                    message.season_start = reader.uint32();
                    break;
                case 16:
                    message.season_length = reader.uint32();
                    break;
                case 17:
                    message.veto_votes = reader.uint32();
                    break;
                case 18:
                    message.acquisitions = reader.uint32();
                    break;
                case 19:
                    message.slot_1 = reader.uint32();
                    break;
                case 20:
                    message.slot_2 = reader.uint32();
                    break;
                case 21:
                    message.slot_3 = reader.uint32();
                    break;
                case 22:
                    message.slot_4 = reader.uint32();
                    break;
                case 23:
                    message.slot_5 = reader.uint32();
                    break;
                case 24:
                    message.bench_slots = reader.uint32();
                    break;
                case 25:
                    if (!(message.owner_info && message.owner_info.length))
                        message.owner_info = [];
                    message.owner_info.push($root.CMsgDOTAFantasyLeagueInfo.OwnerInfo.decode(reader, reader.uint32()));
                    break;
                case 26:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.players.push(reader.uint32());
                    } else
                        message.players.push(reader.uint32());
                    break;
                case 27:
                    message.time_zone = reader.uint32();
                    break;
                case 28:
                    message.season = reader.uint32();
                    break;
                case 29:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueInfo} CMsgDOTAFantasyLeagueInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueInfo message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.commissioner_account_id != null && message.hasOwnProperty("commissioner_account_id"))
                if (!$util.isInteger(message.commissioner_account_id))
                    return "commissioner_account_id: integer expected";
            if (message.fantasy_league_name != null && message.hasOwnProperty("fantasy_league_name"))
                if (!$util.isString(message.fantasy_league_name))
                    return "fantasy_league_name: string expected";
            if (message.selection_mode != null && message.hasOwnProperty("selection_mode"))
                switch (message.selection_mode) {
                default:
                    return "selection_mode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.team_count != null && message.hasOwnProperty("team_count"))
                if (!$util.isInteger(message.team_count))
                    return "team_count: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo) && !(message.logo && $util.isInteger(message.logo.low) && $util.isInteger(message.logo.high)))
                    return "logo: integer|Long expected";
            if (message.scoring != null && message.hasOwnProperty("scoring")) {
                var error = $root.CMsgFantasyLeagueScoring.verify(message.scoring);
                if (error)
                    return "scoring." + error;
            }
            if (message.draft_time != null && message.hasOwnProperty("draft_time"))
                if (!$util.isInteger(message.draft_time))
                    return "draft_time: integer expected";
            if (message.draft_pick_time != null && message.hasOwnProperty("draft_pick_time"))
                if (!$util.isInteger(message.draft_pick_time))
                    return "draft_pick_time: integer expected";
            if (message.season_start != null && message.hasOwnProperty("season_start"))
                if (!$util.isInteger(message.season_start))
                    return "season_start: integer expected";
            if (message.season_length != null && message.hasOwnProperty("season_length"))
                if (!$util.isInteger(message.season_length))
                    return "season_length: integer expected";
            if (message.veto_votes != null && message.hasOwnProperty("veto_votes"))
                if (!$util.isInteger(message.veto_votes))
                    return "veto_votes: integer expected";
            if (message.acquisitions != null && message.hasOwnProperty("acquisitions"))
                if (!$util.isInteger(message.acquisitions))
                    return "acquisitions: integer expected";
            if (message.slot_1 != null && message.hasOwnProperty("slot_1"))
                if (!$util.isInteger(message.slot_1))
                    return "slot_1: integer expected";
            if (message.slot_2 != null && message.hasOwnProperty("slot_2"))
                if (!$util.isInteger(message.slot_2))
                    return "slot_2: integer expected";
            if (message.slot_3 != null && message.hasOwnProperty("slot_3"))
                if (!$util.isInteger(message.slot_3))
                    return "slot_3: integer expected";
            if (message.slot_4 != null && message.hasOwnProperty("slot_4"))
                if (!$util.isInteger(message.slot_4))
                    return "slot_4: integer expected";
            if (message.slot_5 != null && message.hasOwnProperty("slot_5"))
                if (!$util.isInteger(message.slot_5))
                    return "slot_5: integer expected";
            if (message.bench_slots != null && message.hasOwnProperty("bench_slots"))
                if (!$util.isInteger(message.bench_slots))
                    return "bench_slots: integer expected";
            if (message.owner_info != null && message.hasOwnProperty("owner_info")) {
                if (!Array.isArray(message.owner_info))
                    return "owner_info: array expected";
                for (var i = 0; i < message.owner_info.length; ++i) {
                    var error = $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo.verify(message.owner_info[i]);
                    if (error)
                        return "owner_info." + error;
                }
            }
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i)
                    if (!$util.isInteger(message.players[i]))
                        return "players: integer[] expected";
            }
            if (message.time_zone != null && message.hasOwnProperty("time_zone"))
                if (!$util.isInteger(message.time_zone))
                    return "time_zone: integer expected";
            if (message.season != null && message.hasOwnProperty("season"))
                if (!$util.isInteger(message.season))
                    return "season: integer expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueInfo} CMsgDOTAFantasyLeagueInfo
         */
        CMsgDOTAFantasyLeagueInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueInfo)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueInfo();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.commissioner_account_id != null)
                message.commissioner_account_id = object.commissioner_account_id >>> 0;
            if (object.fantasy_league_name != null)
                message.fantasy_league_name = String(object.fantasy_league_name);
            switch (object.selection_mode) {
            case "FANTASY_SELECTION_INVALID":
            case 0:
                message.selection_mode = 0;
                break;
            case "FANTASY_SELECTION_LOCKED":
            case 1:
                message.selection_mode = 1;
                break;
            case "FANTASY_SELECTION_SHUFFLE":
            case 2:
                message.selection_mode = 2;
                break;
            case "FANTASY_SELECTION_FREE_PICK":
            case 3:
                message.selection_mode = 3;
                break;
            case "FANTASY_SELECTION_ENDED":
            case 4:
                message.selection_mode = 4;
                break;
            case "FANTASY_SELECTION_PRE_SEASON":
            case 5:
                message.selection_mode = 5;
                break;
            case "FANTASY_SELECTION_PRE_DRAFT":
            case 6:
                message.selection_mode = 6;
                break;
            case "FANTASY_SELECTION_DRAFTING":
            case 7:
                message.selection_mode = 7;
                break;
            case "FANTASY_SELECTION_REGULAR_SEASON":
            case 8:
                message.selection_mode = 8;
                break;
            case "FANTASY_SELECTION_CARD_BASED":
            case 9:
                message.selection_mode = 9;
                break;
            }
            if (object.team_count != null)
                message.team_count = object.team_count >>> 0;
            if (object.logo != null)
                if ($util.Long)
                    (message.logo = $util.Long.fromValue(object.logo)).unsigned = true;
                else if (typeof object.logo === "string")
                    message.logo = parseInt(object.logo, 10);
                else if (typeof object.logo === "number")
                    message.logo = object.logo;
                else if (typeof object.logo === "object")
                    message.logo = new $util.LongBits(object.logo.low >>> 0, object.logo.high >>> 0).toNumber(true);
            if (object.scoring != null) {
                if (typeof object.scoring !== "object")
                    throw TypeError(".CMsgDOTAFantasyLeagueInfo.scoring: object expected");
                message.scoring = $root.CMsgFantasyLeagueScoring.fromObject(object.scoring);
            }
            if (object.draft_time != null)
                message.draft_time = object.draft_time >>> 0;
            if (object.draft_pick_time != null)
                message.draft_pick_time = object.draft_pick_time >>> 0;
            if (object.season_start != null)
                message.season_start = object.season_start >>> 0;
            if (object.season_length != null)
                message.season_length = object.season_length >>> 0;
            if (object.veto_votes != null)
                message.veto_votes = object.veto_votes >>> 0;
            if (object.acquisitions != null)
                message.acquisitions = object.acquisitions >>> 0;
            if (object.slot_1 != null)
                message.slot_1 = object.slot_1 >>> 0;
            if (object.slot_2 != null)
                message.slot_2 = object.slot_2 >>> 0;
            if (object.slot_3 != null)
                message.slot_3 = object.slot_3 >>> 0;
            if (object.slot_4 != null)
                message.slot_4 = object.slot_4 >>> 0;
            if (object.slot_5 != null)
                message.slot_5 = object.slot_5 >>> 0;
            if (object.bench_slots != null)
                message.bench_slots = object.bench_slots >>> 0;
            if (object.owner_info) {
                if (!Array.isArray(object.owner_info))
                    throw TypeError(".CMsgDOTAFantasyLeagueInfo.owner_info: array expected");
                message.owner_info = [];
                for (var i = 0; i < object.owner_info.length; ++i) {
                    if (typeof object.owner_info[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyLeagueInfo.owner_info: object expected");
                    message.owner_info[i] = $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo.fromObject(object.owner_info[i]);
                }
            }
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".CMsgDOTAFantasyLeagueInfo.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i)
                    message.players[i] = object.players[i] >>> 0;
            }
            if (object.time_zone != null)
                message.time_zone = object.time_zone >>> 0;
            if (object.season != null)
                message.season = object.season >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @static
         * @param {CMsgDOTAFantasyLeagueInfo} message CMsgDOTAFantasyLeagueInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.owner_info = [];
                object.players = [];
            }
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.commissioner_account_id = 0;
                object.fantasy_league_name = "";
                object.selection_mode = options.enums === String ? "FANTASY_SELECTION_INVALID" : 0;
                object.team_count = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.logo = options.longs === String ? "0" : 0;
                object.scoring = null;
                object.draft_time = 0;
                object.draft_pick_time = 0;
                object.season_start = 0;
                object.season_length = 0;
                object.veto_votes = 0;
                object.acquisitions = 0;
                object.slot_1 = 0;
                object.slot_2 = 0;
                object.slot_3 = 0;
                object.slot_4 = 0;
                object.slot_5 = 0;
                object.bench_slots = 0;
                object.time_zone = 0;
                object.season = 0;
                object.password = "";
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.commissioner_account_id != null && message.hasOwnProperty("commissioner_account_id"))
                object.commissioner_account_id = message.commissioner_account_id;
            if (message.fantasy_league_name != null && message.hasOwnProperty("fantasy_league_name"))
                object.fantasy_league_name = message.fantasy_league_name;
            if (message.selection_mode != null && message.hasOwnProperty("selection_mode"))
                object.selection_mode = options.enums === String ? $root.Fantasy_Selection_Mode[message.selection_mode] : message.selection_mode;
            if (message.team_count != null && message.hasOwnProperty("team_count"))
                object.team_count = message.team_count;
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (typeof message.logo === "number")
                    object.logo = options.longs === String ? String(message.logo) : message.logo;
                else
                    object.logo = options.longs === String ? $util.Long.prototype.toString.call(message.logo) : options.longs === Number ? new $util.LongBits(message.logo.low >>> 0, message.logo.high >>> 0).toNumber(true) : message.logo;
            if (message.scoring != null && message.hasOwnProperty("scoring"))
                object.scoring = $root.CMsgFantasyLeagueScoring.toObject(message.scoring, options);
            if (message.draft_time != null && message.hasOwnProperty("draft_time"))
                object.draft_time = message.draft_time;
            if (message.draft_pick_time != null && message.hasOwnProperty("draft_pick_time"))
                object.draft_pick_time = message.draft_pick_time;
            if (message.season_start != null && message.hasOwnProperty("season_start"))
                object.season_start = message.season_start;
            if (message.season_length != null && message.hasOwnProperty("season_length"))
                object.season_length = message.season_length;
            if (message.veto_votes != null && message.hasOwnProperty("veto_votes"))
                object.veto_votes = message.veto_votes;
            if (message.acquisitions != null && message.hasOwnProperty("acquisitions"))
                object.acquisitions = message.acquisitions;
            if (message.slot_1 != null && message.hasOwnProperty("slot_1"))
                object.slot_1 = message.slot_1;
            if (message.slot_2 != null && message.hasOwnProperty("slot_2"))
                object.slot_2 = message.slot_2;
            if (message.slot_3 != null && message.hasOwnProperty("slot_3"))
                object.slot_3 = message.slot_3;
            if (message.slot_4 != null && message.hasOwnProperty("slot_4"))
                object.slot_4 = message.slot_4;
            if (message.slot_5 != null && message.hasOwnProperty("slot_5"))
                object.slot_5 = message.slot_5;
            if (message.bench_slots != null && message.hasOwnProperty("bench_slots"))
                object.bench_slots = message.bench_slots;
            if (message.owner_info && message.owner_info.length) {
                object.owner_info = [];
                for (var j = 0; j < message.owner_info.length; ++j)
                    object.owner_info[j] = $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo.toObject(message.owner_info[j], options);
            }
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = message.players[j];
            }
            if (message.time_zone != null && message.hasOwnProperty("time_zone"))
                object.time_zone = message.time_zone;
            if (message.season != null && message.hasOwnProperty("season"))
                object.season = message.season;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueInfo to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyLeagueInfo.OwnerInfo = (function() {
    
            /**
             * Properties of an OwnerInfo.
             * @memberof CMsgDOTAFantasyLeagueInfo
             * @interface IOwnerInfo
             * @property {number|null} [owner_account_id] OwnerInfo owner_account_id
             * @property {boolean|null} [left_league] OwnerInfo left_league
             * @property {Array.<number>|null} [player_account_id] OwnerInfo player_account_id
             */
    
            /**
             * Constructs a new OwnerInfo.
             * @memberof CMsgDOTAFantasyLeagueInfo
             * @classdesc Represents an OwnerInfo.
             * @implements IOwnerInfo
             * @constructor
             * @param {CMsgDOTAFantasyLeagueInfo.IOwnerInfo=} [properties] Properties to set
             */
            function OwnerInfo(properties) {
                this.player_account_id = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OwnerInfo owner_account_id.
             * @member {number} owner_account_id
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @instance
             */
            OwnerInfo.prototype.owner_account_id = 0;
    
            /**
             * OwnerInfo left_league.
             * @member {boolean} left_league
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @instance
             */
            OwnerInfo.prototype.left_league = false;
    
            /**
             * OwnerInfo player_account_id.
             * @member {Array.<number>} player_account_id
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @instance
             */
            OwnerInfo.prototype.player_account_id = $util.emptyArray;
    
            /**
             * Creates a new OwnerInfo instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {CMsgDOTAFantasyLeagueInfo.IOwnerInfo=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyLeagueInfo.OwnerInfo} OwnerInfo instance
             */
            OwnerInfo.create = function create(properties) {
                return new OwnerInfo(properties);
            };
    
            /**
             * Encodes the specified OwnerInfo message. Does not implicitly {@link CMsgDOTAFantasyLeagueInfo.OwnerInfo.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {CMsgDOTAFantasyLeagueInfo.IOwnerInfo} message OwnerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OwnerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.owner_account_id);
                if (message.left_league != null && Object.hasOwnProperty.call(message, "left_league"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.left_league);
                if (message.player_account_id != null && message.player_account_id.length)
                    for (var i = 0; i < message.player_account_id.length; ++i)
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.player_account_id[i]);
                return writer;
            };
    
            /**
             * Encodes the specified OwnerInfo message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueInfo.OwnerInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {CMsgDOTAFantasyLeagueInfo.IOwnerInfo} message OwnerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OwnerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OwnerInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyLeagueInfo.OwnerInfo} OwnerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OwnerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.owner_account_id = reader.uint32();
                        break;
                    case 2:
                        message.left_league = reader.bool();
                        break;
                    case 3:
                        if (!(message.player_account_id && message.player_account_id.length))
                            message.player_account_id = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.player_account_id.push(reader.uint32());
                        } else
                            message.player_account_id.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OwnerInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyLeagueInfo.OwnerInfo} OwnerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OwnerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OwnerInfo message.
             * @function verify
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OwnerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                    if (!$util.isInteger(message.owner_account_id))
                        return "owner_account_id: integer expected";
                if (message.left_league != null && message.hasOwnProperty("left_league"))
                    if (typeof message.left_league !== "boolean")
                        return "left_league: boolean expected";
                if (message.player_account_id != null && message.hasOwnProperty("player_account_id")) {
                    if (!Array.isArray(message.player_account_id))
                        return "player_account_id: array expected";
                    for (var i = 0; i < message.player_account_id.length; ++i)
                        if (!$util.isInteger(message.player_account_id[i]))
                            return "player_account_id: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates an OwnerInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyLeagueInfo.OwnerInfo} OwnerInfo
             */
            OwnerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo)
                    return object;
                var message = new $root.CMsgDOTAFantasyLeagueInfo.OwnerInfo();
                if (object.owner_account_id != null)
                    message.owner_account_id = object.owner_account_id >>> 0;
                if (object.left_league != null)
                    message.left_league = Boolean(object.left_league);
                if (object.player_account_id) {
                    if (!Array.isArray(object.player_account_id))
                        throw TypeError(".CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id: array expected");
                    message.player_account_id = [];
                    for (var i = 0; i < object.player_account_id.length; ++i)
                        message.player_account_id[i] = object.player_account_id[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from an OwnerInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @static
             * @param {CMsgDOTAFantasyLeagueInfo.OwnerInfo} message OwnerInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OwnerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.player_account_id = [];
                if (options.defaults) {
                    object.owner_account_id = 0;
                    object.left_league = false;
                }
                if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                    object.owner_account_id = message.owner_account_id;
                if (message.left_league != null && message.hasOwnProperty("left_league"))
                    object.left_league = message.left_league;
                if (message.player_account_id && message.player_account_id.length) {
                    object.player_account_id = [];
                    for (var j = 0; j < message.player_account_id.length; ++j)
                        object.player_account_id[j] = message.player_account_id[j];
                }
                return object;
            };
    
            /**
             * Converts this OwnerInfo to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyLeagueInfo.OwnerInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OwnerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OwnerInfo;
        })();
    
        return CMsgDOTAFantasyLeagueInfo;
    })();
    
    $root.CMsgDOTAFantasyLeagueEditInfoRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueEditInfoRequest.
         * @exports ICMsgDOTAFantasyLeagueEditInfoRequest
         * @interface ICMsgDOTAFantasyLeagueEditInfoRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueEditInfoRequest fantasy_league_id
         * @property {ICMsgDOTAFantasyLeagueInfo|null} [edit_info] CMsgDOTAFantasyLeagueEditInfoRequest edit_info
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueEditInfoRequest.
         * @exports CMsgDOTAFantasyLeagueEditInfoRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueEditInfoRequest.
         * @implements ICMsgDOTAFantasyLeagueEditInfoRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueEditInfoRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueEditInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueEditInfoRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueEditInfoRequest edit_info.
         * @member {ICMsgDOTAFantasyLeagueInfo|null|undefined} edit_info
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.prototype.edit_info = null;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueEditInfoRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInfoRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueEditInfoRequest} CMsgDOTAFantasyLeagueEditInfoRequest instance
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueEditInfoRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInfoRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInfoRequest} message CMsgDOTAFantasyLeagueEditInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.edit_info != null && Object.hasOwnProperty.call(message, "edit_info"))
                $root.CMsgDOTAFantasyLeagueInfo.encode(message.edit_info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInfoRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInfoRequest} message CMsgDOTAFantasyLeagueEditInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueEditInfoRequest} CMsgDOTAFantasyLeagueEditInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueEditInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.edit_info = $root.CMsgDOTAFantasyLeagueInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueEditInfoRequest} CMsgDOTAFantasyLeagueEditInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueEditInfoRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.edit_info != null && message.hasOwnProperty("edit_info")) {
                var error = $root.CMsgDOTAFantasyLeagueInfo.verify(message.edit_info);
                if (error)
                    return "edit_info." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueEditInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueEditInfoRequest} CMsgDOTAFantasyLeagueEditInfoRequest
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueEditInfoRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueEditInfoRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.edit_info != null) {
                if (typeof object.edit_info !== "object")
                    throw TypeError(".CMsgDOTAFantasyLeagueEditInfoRequest.edit_info: object expected");
                message.edit_info = $root.CMsgDOTAFantasyLeagueInfo.fromObject(object.edit_info);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueEditInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueEditInfoRequest} message CMsgDOTAFantasyLeagueEditInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.edit_info = null;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.edit_info != null && message.hasOwnProperty("edit_info"))
                object.edit_info = $root.CMsgDOTAFantasyLeagueInfo.toObject(message.edit_info, options);
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueEditInfoRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueEditInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueEditInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueEditInfoRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueEditInfoResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueEditInfoResponse.
         * @exports ICMsgDOTAFantasyLeagueEditInfoResponse
         * @interface ICMsgDOTAFantasyLeagueEditInfoResponse
         * @property {CMsgDOTAFantasyLeagueEditInfoResponse.EResult|null} [result] CMsgDOTAFantasyLeagueEditInfoResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueEditInfoResponse.
         * @exports CMsgDOTAFantasyLeagueEditInfoResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueEditInfoResponse.
         * @implements ICMsgDOTAFantasyLeagueEditInfoResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueEditInfoResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueEditInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueEditInfoResponse result.
         * @member {CMsgDOTAFantasyLeagueEditInfoResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueEditInfoResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInfoResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueEditInfoResponse} CMsgDOTAFantasyLeagueEditInfoResponse instance
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueEditInfoResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInfoResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInfoResponse} message CMsgDOTAFantasyLeagueEditInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInfoResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInfoResponse} message CMsgDOTAFantasyLeagueEditInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueEditInfoResponse} CMsgDOTAFantasyLeagueEditInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueEditInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueEditInfoResponse} CMsgDOTAFantasyLeagueEditInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueEditInfoResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueEditInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueEditInfoResponse} CMsgDOTAFantasyLeagueEditInfoResponse
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueEditInfoResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueEditInfoResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueEditInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueEditInfoResponse} message CMsgDOTAFantasyLeagueEditInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueEditInfoResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueEditInfoResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueEditInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueEditInfoResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyLeagueEditInfoResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueEditInfoResponse;
    })();
    
    $root.CMsgDOTAFantasyLeagueFindRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueFindRequest.
         * @exports ICMsgDOTAFantasyLeagueFindRequest
         * @interface ICMsgDOTAFantasyLeagueFindRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueFindRequest fantasy_league_id
         * @property {string|null} [password] CMsgDOTAFantasyLeagueFindRequest password
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueFindRequest.
         * @exports CMsgDOTAFantasyLeagueFindRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueFindRequest.
         * @implements ICMsgDOTAFantasyLeagueFindRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueFindRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueFindRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueFindRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueFindRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueFindRequest password.
         * @member {string} password
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueFindRequest.prototype.password = "";
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueFindRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueFindRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueFindRequest} CMsgDOTAFantasyLeagueFindRequest instance
         */
        CMsgDOTAFantasyLeagueFindRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueFindRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueFindRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueFindRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueFindRequest} message CMsgDOTAFantasyLeagueFindRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueFindRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueFindRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueFindRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueFindRequest} message CMsgDOTAFantasyLeagueFindRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueFindRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueFindRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueFindRequest} CMsgDOTAFantasyLeagueFindRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueFindRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueFindRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueFindRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueFindRequest} CMsgDOTAFantasyLeagueFindRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueFindRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueFindRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueFindRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueFindRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueFindRequest} CMsgDOTAFantasyLeagueFindRequest
         */
        CMsgDOTAFantasyLeagueFindRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueFindRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueFindRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueFindRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueFindRequest} message CMsgDOTAFantasyLeagueFindRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueFindRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.password = "";
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueFindRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueFindRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueFindRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueFindRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueFindResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueFindResponse.
         * @exports ICMsgDOTAFantasyLeagueFindResponse
         * @interface ICMsgDOTAFantasyLeagueFindResponse
         * @property {CMsgDOTAFantasyLeagueFindResponse.EResult|null} [result] CMsgDOTAFantasyLeagueFindResponse result
         * @property {string|null} [fantasy_league_name] CMsgDOTAFantasyLeagueFindResponse fantasy_league_name
         * @property {string|null} [commissioner_name] CMsgDOTAFantasyLeagueFindResponse commissioner_name
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueFindResponse.
         * @exports CMsgDOTAFantasyLeagueFindResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueFindResponse.
         * @implements ICMsgDOTAFantasyLeagueFindResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueFindResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueFindResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueFindResponse result.
         * @member {CMsgDOTAFantasyLeagueFindResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueFindResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyLeagueFindResponse fantasy_league_name.
         * @member {string} fantasy_league_name
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueFindResponse.prototype.fantasy_league_name = "";
    
        /**
         * CMsgDOTAFantasyLeagueFindResponse commissioner_name.
         * @member {string} commissioner_name
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueFindResponse.prototype.commissioner_name = "";
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueFindResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueFindResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueFindResponse} CMsgDOTAFantasyLeagueFindResponse instance
         */
        CMsgDOTAFantasyLeagueFindResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueFindResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueFindResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueFindResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueFindResponse} message CMsgDOTAFantasyLeagueFindResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueFindResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_league_name != null && Object.hasOwnProperty.call(message, "fantasy_league_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fantasy_league_name);
            if (message.commissioner_name != null && Object.hasOwnProperty.call(message, "commissioner_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.commissioner_name);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueFindResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueFindResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueFindResponse} message CMsgDOTAFantasyLeagueFindResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueFindResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueFindResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueFindResponse} CMsgDOTAFantasyLeagueFindResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueFindResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueFindResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_league_name = reader.string();
                    break;
                case 3:
                    message.commissioner_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueFindResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueFindResponse} CMsgDOTAFantasyLeagueFindResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueFindResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueFindResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueFindResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.fantasy_league_name != null && message.hasOwnProperty("fantasy_league_name"))
                if (!$util.isString(message.fantasy_league_name))
                    return "fantasy_league_name: string expected";
            if (message.commissioner_name != null && message.hasOwnProperty("commissioner_name"))
                if (!$util.isString(message.commissioner_name))
                    return "commissioner_name: string expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueFindResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueFindResponse} CMsgDOTAFantasyLeagueFindResponse
         */
        CMsgDOTAFantasyLeagueFindResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueFindResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueFindResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_LEAGUE_NOT_FOUND":
            case 1:
                message.result = 1;
                break;
            case "ERROR_BAD_PASSWORD":
            case 2:
                message.result = 2;
                break;
            case "ERROR_UNSPECIFIED":
            case 3:
                message.result = 3;
                break;
            case "ERROR_FULL":
            case 4:
                message.result = 4;
                break;
            case "ERROR_ALREADY_MEMBER":
            case 5:
                message.result = 5;
                break;
            case "ERROR_LEAGUE_LOCKED":
            case 6:
                message.result = 6;
                break;
            }
            if (object.fantasy_league_name != null)
                message.fantasy_league_name = String(object.fantasy_league_name);
            if (object.commissioner_name != null)
                message.commissioner_name = String(object.commissioner_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueFindResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueFindResponse} message CMsgDOTAFantasyLeagueFindResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueFindResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_league_name = "";
                object.commissioner_name = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueFindResponse.EResult[message.result] : message.result;
            if (message.fantasy_league_name != null && message.hasOwnProperty("fantasy_league_name"))
                object.fantasy_league_name = message.fantasy_league_name;
            if (message.commissioner_name != null && message.hasOwnProperty("commissioner_name"))
                object.commissioner_name = message.commissioner_name;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueFindResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueFindResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueFindResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueFindResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_LEAGUE_NOT_FOUND=1 ERROR_LEAGUE_NOT_FOUND value
         * @property {number} ERROR_BAD_PASSWORD=2 ERROR_BAD_PASSWORD value
         * @property {number} ERROR_UNSPECIFIED=3 ERROR_UNSPECIFIED value
         * @property {number} ERROR_FULL=4 ERROR_FULL value
         * @property {number} ERROR_ALREADY_MEMBER=5 ERROR_ALREADY_MEMBER value
         * @property {number} ERROR_LEAGUE_LOCKED=6 ERROR_LEAGUE_LOCKED value
         */
        CMsgDOTAFantasyLeagueFindResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_LEAGUE_NOT_FOUND"] = 1;
            values[valuesById[2] = "ERROR_BAD_PASSWORD"] = 2;
            values[valuesById[3] = "ERROR_UNSPECIFIED"] = 3;
            values[valuesById[4] = "ERROR_FULL"] = 4;
            values[valuesById[5] = "ERROR_ALREADY_MEMBER"] = 5;
            values[valuesById[6] = "ERROR_LEAGUE_LOCKED"] = 6;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueFindResponse;
    })();
    
    $root.CMsgDOTAFantasyLeagueInfoRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueInfoRequest.
         * @exports ICMsgDOTAFantasyLeagueInfoRequest
         * @interface ICMsgDOTAFantasyLeagueInfoRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueInfoRequest fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueInfoRequest.
         * @exports CMsgDOTAFantasyLeagueInfoRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueInfoRequest.
         * @implements ICMsgDOTAFantasyLeagueInfoRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueInfoRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueInfoRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueInfoRequest.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueInfoRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfoRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueInfoRequest} CMsgDOTAFantasyLeagueInfoRequest instance
         */
        CMsgDOTAFantasyLeagueInfoRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueInfoRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueInfoRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfoRequest} message CMsgDOTAFantasyLeagueInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueInfoRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfoRequest} message CMsgDOTAFantasyLeagueInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueInfoRequest} CMsgDOTAFantasyLeagueInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueInfoRequest} CMsgDOTAFantasyLeagueInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueInfoRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueInfoRequest} CMsgDOTAFantasyLeagueInfoRequest
         */
        CMsgDOTAFantasyLeagueInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueInfoRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueInfoRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueInfoRequest} message CMsgDOTAFantasyLeagueInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueInfoRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueInfoRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueInfoResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueInfoResponse.
         * @exports ICMsgDOTAFantasyLeagueInfoResponse
         * @interface ICMsgDOTAFantasyLeagueInfoResponse
         * @property {CMsgDOTAFantasyLeagueInfoResponse.EResult|null} [result] CMsgDOTAFantasyLeagueInfoResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueInfoResponse.
         * @exports CMsgDOTAFantasyLeagueInfoResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueInfoResponse.
         * @implements ICMsgDOTAFantasyLeagueInfoResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueInfoResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueInfoResponse result.
         * @member {CMsgDOTAFantasyLeagueInfoResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueInfoResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueInfoResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfoResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueInfoResponse} CMsgDOTAFantasyLeagueInfoResponse instance
         */
        CMsgDOTAFantasyLeagueInfoResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueInfoResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueInfoResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfoResponse} message CMsgDOTAFantasyLeagueInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueInfoResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueInfoResponse} message CMsgDOTAFantasyLeagueInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueInfoResponse} CMsgDOTAFantasyLeagueInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueInfoResponse} CMsgDOTAFantasyLeagueInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueInfoResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueInfoResponse} CMsgDOTAFantasyLeagueInfoResponse
         */
        CMsgDOTAFantasyLeagueInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueInfoResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueInfoResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_BAD_LEAGUE_ID":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueInfoResponse} message CMsgDOTAFantasyLeagueInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueInfoResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueInfoResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueInfoResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_BAD_LEAGUE_ID=2 ERROR_BAD_LEAGUE_ID value
         */
        CMsgDOTAFantasyLeagueInfoResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_BAD_LEAGUE_ID"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueInfoResponse;
    })();
    
    $root.CMsgDOTAFantasyLeagueMatchupsRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueMatchupsRequest.
         * @exports ICMsgDOTAFantasyLeagueMatchupsRequest
         * @interface ICMsgDOTAFantasyLeagueMatchupsRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueMatchupsRequest fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueMatchupsRequest.
         * @exports CMsgDOTAFantasyLeagueMatchupsRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueMatchupsRequest.
         * @implements ICMsgDOTAFantasyLeagueMatchupsRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueMatchupsRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueMatchupsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueMatchupsRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueMatchupsRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueMatchupsRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueMatchupsRequest} CMsgDOTAFantasyLeagueMatchupsRequest instance
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueMatchupsRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueMatchupsRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueMatchupsRequest} message CMsgDOTAFantasyLeagueMatchupsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueMatchupsRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueMatchupsRequest} message CMsgDOTAFantasyLeagueMatchupsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueMatchupsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueMatchupsRequest} CMsgDOTAFantasyLeagueMatchupsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueMatchupsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueMatchupsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueMatchupsRequest} CMsgDOTAFantasyLeagueMatchupsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueMatchupsRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueMatchupsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueMatchupsRequest} CMsgDOTAFantasyLeagueMatchupsRequest
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueMatchupsRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueMatchupsRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueMatchupsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueMatchupsRequest} message CMsgDOTAFantasyLeagueMatchupsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueMatchupsRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueMatchupsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueMatchupsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueMatchupsRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueMatchupsResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueMatchupsResponse.
         * @exports ICMsgDOTAFantasyLeagueMatchupsResponse
         * @interface ICMsgDOTAFantasyLeagueMatchupsResponse
         * @property {CMsgDOTAFantasyLeagueMatchupsResponse.EResult|null} [result] CMsgDOTAFantasyLeagueMatchupsResponse result
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueMatchupsResponse fantasy_league_id
         * @property {Array.<CMsgDOTAFantasyLeagueMatchupsResponse.IWeeklyMatchups>|null} [weekly_matchups] CMsgDOTAFantasyLeagueMatchupsResponse weekly_matchups
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueMatchupsResponse.
         * @exports CMsgDOTAFantasyLeagueMatchupsResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueMatchupsResponse.
         * @implements ICMsgDOTAFantasyLeagueMatchupsResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueMatchupsResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueMatchupsResponse(properties) {
            this.weekly_matchups = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueMatchupsResponse result.
         * @member {CMsgDOTAFantasyLeagueMatchupsResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyLeagueMatchupsResponse fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueMatchupsResponse weekly_matchups.
         * @member {Array.<CMsgDOTAFantasyLeagueMatchupsResponse.IWeeklyMatchups>} weekly_matchups
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.prototype.weekly_matchups = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueMatchupsResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueMatchupsResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueMatchupsResponse} CMsgDOTAFantasyLeagueMatchupsResponse instance
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueMatchupsResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueMatchupsResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueMatchupsResponse} message CMsgDOTAFantasyLeagueMatchupsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fantasy_league_id);
            if (message.weekly_matchups != null && message.weekly_matchups.length)
                for (var i = 0; i < message.weekly_matchups.length; ++i)
                    $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.encode(message.weekly_matchups[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueMatchupsResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueMatchupsResponse} message CMsgDOTAFantasyLeagueMatchupsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueMatchupsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueMatchupsResponse} CMsgDOTAFantasyLeagueMatchupsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueMatchupsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 3:
                    if (!(message.weekly_matchups && message.weekly_matchups.length))
                        message.weekly_matchups = [];
                    message.weekly_matchups.push($root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueMatchupsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueMatchupsResponse} CMsgDOTAFantasyLeagueMatchupsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueMatchupsResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.weekly_matchups != null && message.hasOwnProperty("weekly_matchups")) {
                if (!Array.isArray(message.weekly_matchups))
                    return "weekly_matchups: array expected";
                for (var i = 0; i < message.weekly_matchups.length; ++i) {
                    var error = $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.verify(message.weekly_matchups[i]);
                    if (error)
                        return "weekly_matchups." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueMatchupsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueMatchupsResponse} CMsgDOTAFantasyLeagueMatchupsResponse
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueMatchupsResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueMatchupsResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_BAD_LEAGUE_ID":
            case 2:
                message.result = 2;
                break;
            case "ERROR_NO_PERMISSION":
            case 3:
                message.result = 3;
                break;
            }
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.weekly_matchups) {
                if (!Array.isArray(object.weekly_matchups))
                    throw TypeError(".CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups: array expected");
                message.weekly_matchups = [];
                for (var i = 0; i < object.weekly_matchups.length; ++i) {
                    if (typeof object.weekly_matchups[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups: object expected");
                    message.weekly_matchups[i] = $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.fromObject(object.weekly_matchups[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueMatchupsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueMatchupsResponse} message CMsgDOTAFantasyLeagueMatchupsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.weekly_matchups = [];
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_league_id = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueMatchupsResponse.EResult[message.result] : message.result;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.weekly_matchups && message.weekly_matchups.length) {
                object.weekly_matchups = [];
                for (var j = 0; j < message.weekly_matchups.length; ++j)
                    object.weekly_matchups[j] = $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.toObject(message.weekly_matchups[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueMatchupsResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyLeagueMatchupsResponse.Matchup = (function() {
    
            /**
             * Properties of a Matchup.
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
             * @interface IMatchup
             * @property {number|null} [owner_account_id_1] Matchup owner_account_id_1
             * @property {number|null} [owner_account_id_2] Matchup owner_account_id_2
             * @property {number|null} [score_1] Matchup score_1
             * @property {number|null} [score_2] Matchup score_2
             */
    
            /**
             * Constructs a new Matchup.
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
             * @classdesc Represents a Matchup.
             * @implements IMatchup
             * @constructor
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IMatchup=} [properties] Properties to set
             */
            function Matchup(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Matchup owner_account_id_1.
             * @member {number} owner_account_id_1
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @instance
             */
            Matchup.prototype.owner_account_id_1 = 0;
    
            /**
             * Matchup owner_account_id_2.
             * @member {number} owner_account_id_2
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @instance
             */
            Matchup.prototype.owner_account_id_2 = 0;
    
            /**
             * Matchup score_1.
             * @member {number} score_1
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @instance
             */
            Matchup.prototype.score_1 = 0;
    
            /**
             * Matchup score_2.
             * @member {number} score_2
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @instance
             */
            Matchup.prototype.score_2 = 0;
    
            /**
             * Creates a new Matchup instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IMatchup=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.Matchup} Matchup instance
             */
            Matchup.create = function create(properties) {
                return new Matchup(properties);
            };
    
            /**
             * Encodes the specified Matchup message. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IMatchup} message Matchup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Matchup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.owner_account_id_1 != null && Object.hasOwnProperty.call(message, "owner_account_id_1"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.owner_account_id_1);
                if (message.owner_account_id_2 != null && Object.hasOwnProperty.call(message, "owner_account_id_2"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.owner_account_id_2);
                if (message.score_1 != null && Object.hasOwnProperty.call(message, "score_1"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.score_1);
                if (message.score_2 != null && Object.hasOwnProperty.call(message, "score_2"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.score_2);
                return writer;
            };
    
            /**
             * Encodes the specified Matchup message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IMatchup} message Matchup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Matchup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Matchup message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.Matchup} Matchup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Matchup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.owner_account_id_1 = reader.uint32();
                        break;
                    case 2:
                        message.owner_account_id_2 = reader.uint32();
                        break;
                    case 3:
                        message.score_1 = reader.float();
                        break;
                    case 4:
                        message.score_2 = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Matchup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.Matchup} Matchup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Matchup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Matchup message.
             * @function verify
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Matchup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.owner_account_id_1 != null && message.hasOwnProperty("owner_account_id_1"))
                    if (!$util.isInteger(message.owner_account_id_1))
                        return "owner_account_id_1: integer expected";
                if (message.owner_account_id_2 != null && message.hasOwnProperty("owner_account_id_2"))
                    if (!$util.isInteger(message.owner_account_id_2))
                        return "owner_account_id_2: integer expected";
                if (message.score_1 != null && message.hasOwnProperty("score_1"))
                    if (typeof message.score_1 !== "number")
                        return "score_1: number expected";
                if (message.score_2 != null && message.hasOwnProperty("score_2"))
                    if (typeof message.score_2 !== "number")
                        return "score_2: number expected";
                return null;
            };
    
            /**
             * Creates a Matchup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.Matchup} Matchup
             */
            Matchup.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup)
                    return object;
                var message = new $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup();
                if (object.owner_account_id_1 != null)
                    message.owner_account_id_1 = object.owner_account_id_1 >>> 0;
                if (object.owner_account_id_2 != null)
                    message.owner_account_id_2 = object.owner_account_id_2 >>> 0;
                if (object.score_1 != null)
                    message.score_1 = Number(object.score_1);
                if (object.score_2 != null)
                    message.score_2 = Number(object.score_2);
                return message;
            };
    
            /**
             * Creates a plain object from a Matchup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.Matchup} message Matchup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Matchup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.owner_account_id_1 = 0;
                    object.owner_account_id_2 = 0;
                    object.score_1 = 0;
                    object.score_2 = 0;
                }
                if (message.owner_account_id_1 != null && message.hasOwnProperty("owner_account_id_1"))
                    object.owner_account_id_1 = message.owner_account_id_1;
                if (message.owner_account_id_2 != null && message.hasOwnProperty("owner_account_id_2"))
                    object.owner_account_id_2 = message.owner_account_id_2;
                if (message.score_1 != null && message.hasOwnProperty("score_1"))
                    object.score_1 = options.json && !isFinite(message.score_1) ? String(message.score_1) : message.score_1;
                if (message.score_2 != null && message.hasOwnProperty("score_2"))
                    object.score_2 = options.json && !isFinite(message.score_2) ? String(message.score_2) : message.score_2;
                return object;
            };
    
            /**
             * Converts this Matchup to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.Matchup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Matchup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Matchup;
        })();
    
        CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups = (function() {
    
            /**
             * Properties of a WeeklyMatchups.
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
             * @interface IWeeklyMatchups
             * @property {Array.<CMsgDOTAFantasyLeagueMatchupsResponse.IMatchup>|null} [matchup] WeeklyMatchups matchup
             * @property {number|null} [start_time] WeeklyMatchups start_time
             * @property {number|null} [end_time] WeeklyMatchups end_time
             */
    
            /**
             * Constructs a new WeeklyMatchups.
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse
             * @classdesc Represents a WeeklyMatchups.
             * @implements IWeeklyMatchups
             * @constructor
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IWeeklyMatchups=} [properties] Properties to set
             */
            function WeeklyMatchups(properties) {
                this.matchup = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * WeeklyMatchups matchup.
             * @member {Array.<CMsgDOTAFantasyLeagueMatchupsResponse.IMatchup>} matchup
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @instance
             */
            WeeklyMatchups.prototype.matchup = $util.emptyArray;
    
            /**
             * WeeklyMatchups start_time.
             * @member {number} start_time
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @instance
             */
            WeeklyMatchups.prototype.start_time = 0;
    
            /**
             * WeeklyMatchups end_time.
             * @member {number} end_time
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @instance
             */
            WeeklyMatchups.prototype.end_time = 0;
    
            /**
             * Creates a new WeeklyMatchups instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IWeeklyMatchups=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups} WeeklyMatchups instance
             */
            WeeklyMatchups.create = function create(properties) {
                return new WeeklyMatchups(properties);
            };
    
            /**
             * Encodes the specified WeeklyMatchups message. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IWeeklyMatchups} message WeeklyMatchups message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeeklyMatchups.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.matchup != null && message.matchup.length)
                    for (var i = 0; i < message.matchup.length; ++i)
                        $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.encode(message.matchup[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.start_time);
                if (message.end_time != null && Object.hasOwnProperty.call(message, "end_time"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.end_time);
                return writer;
            };
    
            /**
             * Encodes the specified WeeklyMatchups message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.IWeeklyMatchups} message WeeklyMatchups message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeeklyMatchups.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a WeeklyMatchups message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups} WeeklyMatchups
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeeklyMatchups.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.matchup && message.matchup.length))
                            message.matchup = [];
                        message.matchup.push($root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.start_time = reader.uint32();
                        break;
                    case 3:
                        message.end_time = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a WeeklyMatchups message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups} WeeklyMatchups
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeeklyMatchups.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a WeeklyMatchups message.
             * @function verify
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeeklyMatchups.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.matchup != null && message.hasOwnProperty("matchup")) {
                    if (!Array.isArray(message.matchup))
                        return "matchup: array expected";
                    for (var i = 0; i < message.matchup.length; ++i) {
                        var error = $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.verify(message.matchup[i]);
                        if (error)
                            return "matchup." + error;
                    }
                }
                if (message.start_time != null && message.hasOwnProperty("start_time"))
                    if (!$util.isInteger(message.start_time))
                        return "start_time: integer expected";
                if (message.end_time != null && message.hasOwnProperty("end_time"))
                    if (!$util.isInteger(message.end_time))
                        return "end_time: integer expected";
                return null;
            };
    
            /**
             * Creates a WeeklyMatchups message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups} WeeklyMatchups
             */
            WeeklyMatchups.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups)
                    return object;
                var message = new $root.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups();
                if (object.matchup) {
                    if (!Array.isArray(object.matchup))
                        throw TypeError(".CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup: array expected");
                    message.matchup = [];
                    for (var i = 0; i < object.matchup.length; ++i) {
                        if (typeof object.matchup[i] !== "object")
                            throw TypeError(".CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup: object expected");
                        message.matchup[i] = $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.fromObject(object.matchup[i]);
                    }
                }
                if (object.start_time != null)
                    message.start_time = object.start_time >>> 0;
                if (object.end_time != null)
                    message.end_time = object.end_time >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a WeeklyMatchups message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @static
             * @param {CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups} message WeeklyMatchups
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WeeklyMatchups.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.matchup = [];
                if (options.defaults) {
                    object.start_time = 0;
                    object.end_time = 0;
                }
                if (message.matchup && message.matchup.length) {
                    object.matchup = [];
                    for (var j = 0; j < message.matchup.length; ++j)
                        object.matchup[j] = $root.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.toObject(message.matchup[j], options);
                }
                if (message.start_time != null && message.hasOwnProperty("start_time"))
                    object.start_time = message.start_time;
                if (message.end_time != null && message.hasOwnProperty("end_time"))
                    object.end_time = message.end_time;
                return object;
            };
    
            /**
             * Converts this WeeklyMatchups to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WeeklyMatchups.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return WeeklyMatchups;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueMatchupsResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_BAD_LEAGUE_ID=2 ERROR_BAD_LEAGUE_ID value
         * @property {number} ERROR_NO_PERMISSION=3 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyLeagueMatchupsResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_BAD_LEAGUE_ID"] = 2;
            values[valuesById[3] = "ERROR_NO_PERMISSION"] = 3;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueMatchupsResponse;
    })();
    
    $root.CMsgDOTAEditFantasyTeamRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAEditFantasyTeamRequest.
         * @exports ICMsgDOTAEditFantasyTeamRequest
         * @interface ICMsgDOTAEditFantasyTeamRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAEditFantasyTeamRequest fantasy_league_id
         * @property {number|null} [team_index] CMsgDOTAEditFantasyTeamRequest team_index
         * @property {string|null} [team_name] CMsgDOTAEditFantasyTeamRequest team_name
         * @property {number|Long|null} [team_logo] CMsgDOTAEditFantasyTeamRequest team_logo
         */
    
        /**
         * Constructs a new CMsgDOTAEditFantasyTeamRequest.
         * @exports CMsgDOTAEditFantasyTeamRequest
         * @classdesc Represents a CMsgDOTAEditFantasyTeamRequest.
         * @implements ICMsgDOTAEditFantasyTeamRequest
         * @constructor
         * @param {ICMsgDOTAEditFantasyTeamRequest=} [properties] Properties to set
         */
        function CMsgDOTAEditFantasyTeamRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAEditFantasyTeamRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @instance
         */
        CMsgDOTAEditFantasyTeamRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAEditFantasyTeamRequest team_index.
         * @member {number} team_index
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @instance
         */
        CMsgDOTAEditFantasyTeamRequest.prototype.team_index = 0;
    
        /**
         * CMsgDOTAEditFantasyTeamRequest team_name.
         * @member {string} team_name
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @instance
         */
        CMsgDOTAEditFantasyTeamRequest.prototype.team_name = "";
    
        /**
         * CMsgDOTAEditFantasyTeamRequest team_logo.
         * @member {number|Long} team_logo
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @instance
         */
        CMsgDOTAEditFantasyTeamRequest.prototype.team_logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CMsgDOTAEditFantasyTeamRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {ICMsgDOTAEditFantasyTeamRequest=} [properties] Properties to set
         * @returns {CMsgDOTAEditFantasyTeamRequest} CMsgDOTAEditFantasyTeamRequest instance
         */
        CMsgDOTAEditFantasyTeamRequest.create = function create(properties) {
            return new CMsgDOTAEditFantasyTeamRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAEditFantasyTeamRequest message. Does not implicitly {@link CMsgDOTAEditFantasyTeamRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {ICMsgDOTAEditFantasyTeamRequest} message CMsgDOTAEditFantasyTeamRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAEditFantasyTeamRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.team_index != null && Object.hasOwnProperty.call(message, "team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_index);
            if (message.team_name != null && Object.hasOwnProperty.call(message, "team_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.team_name);
            if (message.team_logo != null && Object.hasOwnProperty.call(message, "team_logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.team_logo);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAEditFantasyTeamRequest message, length delimited. Does not implicitly {@link CMsgDOTAEditFantasyTeamRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {ICMsgDOTAEditFantasyTeamRequest} message CMsgDOTAEditFantasyTeamRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAEditFantasyTeamRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAEditFantasyTeamRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAEditFantasyTeamRequest} CMsgDOTAEditFantasyTeamRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAEditFantasyTeamRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAEditFantasyTeamRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.team_index = reader.uint32();
                    break;
                case 3:
                    message.team_name = reader.string();
                    break;
                case 4:
                    message.team_logo = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAEditFantasyTeamRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAEditFantasyTeamRequest} CMsgDOTAEditFantasyTeamRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAEditFantasyTeamRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAEditFantasyTeamRequest message.
         * @function verify
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAEditFantasyTeamRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                if (!$util.isInteger(message.team_index))
                    return "team_index: integer expected";
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                if (!$util.isString(message.team_name))
                    return "team_name: string expected";
            if (message.team_logo != null && message.hasOwnProperty("team_logo"))
                if (!$util.isInteger(message.team_logo) && !(message.team_logo && $util.isInteger(message.team_logo.low) && $util.isInteger(message.team_logo.high)))
                    return "team_logo: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAEditFantasyTeamRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAEditFantasyTeamRequest} CMsgDOTAEditFantasyTeamRequest
         */
        CMsgDOTAEditFantasyTeamRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAEditFantasyTeamRequest)
                return object;
            var message = new $root.CMsgDOTAEditFantasyTeamRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.team_index != null)
                message.team_index = object.team_index >>> 0;
            if (object.team_name != null)
                message.team_name = String(object.team_name);
            if (object.team_logo != null)
                if ($util.Long)
                    (message.team_logo = $util.Long.fromValue(object.team_logo)).unsigned = true;
                else if (typeof object.team_logo === "string")
                    message.team_logo = parseInt(object.team_logo, 10);
                else if (typeof object.team_logo === "number")
                    message.team_logo = object.team_logo;
                else if (typeof object.team_logo === "object")
                    message.team_logo = new $util.LongBits(object.team_logo.low >>> 0, object.team_logo.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAEditFantasyTeamRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @static
         * @param {CMsgDOTAEditFantasyTeamRequest} message CMsgDOTAEditFantasyTeamRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAEditFantasyTeamRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.team_index = 0;
                object.team_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.team_logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.team_logo = options.longs === String ? "0" : 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                object.team_index = message.team_index;
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                object.team_name = message.team_name;
            if (message.team_logo != null && message.hasOwnProperty("team_logo"))
                if (typeof message.team_logo === "number")
                    object.team_logo = options.longs === String ? String(message.team_logo) : message.team_logo;
                else
                    object.team_logo = options.longs === String ? $util.Long.prototype.toString.call(message.team_logo) : options.longs === Number ? new $util.LongBits(message.team_logo.low >>> 0, message.team_logo.high >>> 0).toNumber(true) : message.team_logo;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAEditFantasyTeamRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAEditFantasyTeamRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAEditFantasyTeamRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAEditFantasyTeamRequest;
    })();
    
    $root.CMsgDOTAEditFantasyTeamResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAEditFantasyTeamResponse.
         * @exports ICMsgDOTAEditFantasyTeamResponse
         * @interface ICMsgDOTAEditFantasyTeamResponse
         * @property {CMsgDOTAEditFantasyTeamResponse.EResult|null} [result] CMsgDOTAEditFantasyTeamResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAEditFantasyTeamResponse.
         * @exports CMsgDOTAEditFantasyTeamResponse
         * @classdesc Represents a CMsgDOTAEditFantasyTeamResponse.
         * @implements ICMsgDOTAEditFantasyTeamResponse
         * @constructor
         * @param {ICMsgDOTAEditFantasyTeamResponse=} [properties] Properties to set
         */
        function CMsgDOTAEditFantasyTeamResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAEditFantasyTeamResponse result.
         * @member {CMsgDOTAEditFantasyTeamResponse.EResult} result
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @instance
         */
        CMsgDOTAEditFantasyTeamResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAEditFantasyTeamResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {ICMsgDOTAEditFantasyTeamResponse=} [properties] Properties to set
         * @returns {CMsgDOTAEditFantasyTeamResponse} CMsgDOTAEditFantasyTeamResponse instance
         */
        CMsgDOTAEditFantasyTeamResponse.create = function create(properties) {
            return new CMsgDOTAEditFantasyTeamResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAEditFantasyTeamResponse message. Does not implicitly {@link CMsgDOTAEditFantasyTeamResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {ICMsgDOTAEditFantasyTeamResponse} message CMsgDOTAEditFantasyTeamResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAEditFantasyTeamResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAEditFantasyTeamResponse message, length delimited. Does not implicitly {@link CMsgDOTAEditFantasyTeamResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {ICMsgDOTAEditFantasyTeamResponse} message CMsgDOTAEditFantasyTeamResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAEditFantasyTeamResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAEditFantasyTeamResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAEditFantasyTeamResponse} CMsgDOTAEditFantasyTeamResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAEditFantasyTeamResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAEditFantasyTeamResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAEditFantasyTeamResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAEditFantasyTeamResponse} CMsgDOTAEditFantasyTeamResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAEditFantasyTeamResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAEditFantasyTeamResponse message.
         * @function verify
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAEditFantasyTeamResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAEditFantasyTeamResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAEditFantasyTeamResponse} CMsgDOTAEditFantasyTeamResponse
         */
        CMsgDOTAEditFantasyTeamResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAEditFantasyTeamResponse)
                return object;
            var message = new $root.CMsgDOTAEditFantasyTeamResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_INVALID_TEAM_INFO":
            case 2:
                message.result = 2;
                break;
            case "ERROR_NAME_ALREADY_TAKEN":
            case 3:
                message.result = 3;
                break;
            case "ERROR_NO_PERMISSION":
            case 4:
                message.result = 4;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAEditFantasyTeamResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @static
         * @param {CMsgDOTAEditFantasyTeamResponse} message CMsgDOTAEditFantasyTeamResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAEditFantasyTeamResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAEditFantasyTeamResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAEditFantasyTeamResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAEditFantasyTeamResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAEditFantasyTeamResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAEditFantasyTeamResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_INVALID_TEAM_INFO=2 ERROR_INVALID_TEAM_INFO value
         * @property {number} ERROR_NAME_ALREADY_TAKEN=3 ERROR_NAME_ALREADY_TAKEN value
         * @property {number} ERROR_NO_PERMISSION=4 ERROR_NO_PERMISSION value
         */
        CMsgDOTAEditFantasyTeamResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_INVALID_TEAM_INFO"] = 2;
            values[valuesById[3] = "ERROR_NAME_ALREADY_TAKEN"] = 3;
            values[valuesById[4] = "ERROR_NO_PERMISSION"] = 4;
            return values;
        })();
    
        return CMsgDOTAEditFantasyTeamResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.
         * @exports ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @interface ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.
         * @exports CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @classdesc Represents a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.
         * @implements ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @constructor
         * @param {ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @instance
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID instance
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.create = function create(properties) {
            return new CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message. Does not implicitly {@link CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} message CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} message CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @static
         * @param {CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID} message CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID;
    })();
    
    $root.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.
         * @exports ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @interface ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @property {number|null} [owner_account_id] CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID owner_account_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.
         * @exports CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @classdesc Represents a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.
         * @implements ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @constructor
         * @param {ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID owner_account_id.
         * @member {number} owner_account_id
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @instance
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.prototype.owner_account_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID instance
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.create = function create(properties) {
            return new CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message. Does not implicitly {@link CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} message CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.owner_account_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} message CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_account_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                if (!$util.isInteger(message.owner_account_id))
                    return "owner_account_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID();
            if (object.owner_account_id != null)
                message.owner_account_id = object.owner_account_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @static
         * @param {CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID} message CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.owner_account_id = 0;
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                object.owner_account_id = message.owner_account_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID;
    })();
    
    $root.CMsgDOTAFantasyTeamInfoResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamInfoResponse.
         * @exports ICMsgDOTAFantasyTeamInfoResponse
         * @interface ICMsgDOTAFantasyTeamInfoResponse
         * @property {Array.<ICMsgDOTAFantasyTeamInfo>|null} [results] CMsgDOTAFantasyTeamInfoResponse results
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamInfoResponse.
         * @exports CMsgDOTAFantasyTeamInfoResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamInfoResponse.
         * @implements ICMsgDOTAFantasyTeamInfoResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamInfoResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamInfoResponse(properties) {
            this.results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamInfoResponse results.
         * @member {Array.<ICMsgDOTAFantasyTeamInfo>} results
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @instance
         */
        CMsgDOTAFantasyTeamInfoResponse.prototype.results = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamInfoResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamInfoResponse} CMsgDOTAFantasyTeamInfoResponse instance
         */
        CMsgDOTAFantasyTeamInfoResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamInfoResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfoResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoResponse} message CMsgDOTAFantasyTeamInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    $root.CMsgDOTAFantasyTeamInfo.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfoResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamInfoResponse} message CMsgDOTAFantasyTeamInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamInfoResponse} CMsgDOTAFantasyTeamInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.CMsgDOTAFantasyTeamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamInfoResponse} CMsgDOTAFantasyTeamInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamInfoResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i) {
                    var error = $root.CMsgDOTAFantasyTeamInfo.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamInfoResponse} CMsgDOTAFantasyTeamInfoResponse
         */
        CMsgDOTAFantasyTeamInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamInfoResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamInfoResponse();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".CMsgDOTAFantasyTeamInfoResponse.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyTeamInfoResponse.results: object expected");
                    message.results[i] = $root.CMsgDOTAFantasyTeamInfo.fromObject(object.results[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @static
         * @param {CMsgDOTAFantasyTeamInfoResponse} message CMsgDOTAFantasyTeamInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.CMsgDOTAFantasyTeamInfo.toObject(message.results[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamInfoResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamInfoResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamInfo = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamInfo.
         * @exports ICMsgDOTAFantasyTeamInfo
         * @interface ICMsgDOTAFantasyTeamInfo
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamInfo fantasy_league_id
         * @property {number|null} [owner_account_id] CMsgDOTAFantasyTeamInfo owner_account_id
         * @property {number|null} [fantasy_team_index] CMsgDOTAFantasyTeamInfo fantasy_team_index
         * @property {string|null} [team_name] CMsgDOTAFantasyTeamInfo team_name
         * @property {number|Long|null} [team_logo] CMsgDOTAFantasyTeamInfo team_logo
         * @property {number|null} [wins] CMsgDOTAFantasyTeamInfo wins
         * @property {number|null} [losses] CMsgDOTAFantasyTeamInfo losses
         * @property {Array.<number>|null} [current_roster] CMsgDOTAFantasyTeamInfo current_roster
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamInfo.
         * @exports CMsgDOTAFantasyTeamInfo
         * @classdesc Represents a CMsgDOTAFantasyTeamInfo.
         * @implements ICMsgDOTAFantasyTeamInfo
         * @constructor
         * @param {ICMsgDOTAFantasyTeamInfo=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamInfo(properties) {
            this.current_roster = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamInfo fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamInfo owner_account_id.
         * @member {number} owner_account_id
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.owner_account_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamInfo fantasy_team_index.
         * @member {number} fantasy_team_index
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.fantasy_team_index = 0;
    
        /**
         * CMsgDOTAFantasyTeamInfo team_name.
         * @member {string} team_name
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.team_name = "";
    
        /**
         * CMsgDOTAFantasyTeamInfo team_logo.
         * @member {number|Long} team_logo
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.team_logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyTeamInfo wins.
         * @member {number} wins
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.wins = 0;
    
        /**
         * CMsgDOTAFantasyTeamInfo losses.
         * @member {number} losses
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.losses = 0;
    
        /**
         * CMsgDOTAFantasyTeamInfo current_roster.
         * @member {Array.<number>} current_roster
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         */
        CMsgDOTAFantasyTeamInfo.prototype.current_roster = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamInfo instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {ICMsgDOTAFantasyTeamInfo=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamInfo} CMsgDOTAFantasyTeamInfo instance
         */
        CMsgDOTAFantasyTeamInfo.create = function create(properties) {
            return new CMsgDOTAFantasyTeamInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfo message. Does not implicitly {@link CMsgDOTAFantasyTeamInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {ICMsgDOTAFantasyTeamInfo} message CMsgDOTAFantasyTeamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.owner_account_id);
            if (message.fantasy_team_index != null && Object.hasOwnProperty.call(message, "fantasy_team_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.fantasy_team_index);
            if (message.team_name != null && Object.hasOwnProperty.call(message, "team_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.team_name);
            if (message.team_logo != null && Object.hasOwnProperty.call(message, "team_logo"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.team_logo);
            if (message.wins != null && Object.hasOwnProperty.call(message, "wins"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.wins);
            if (message.losses != null && Object.hasOwnProperty.call(message, "losses"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.losses);
            if (message.current_roster != null && message.current_roster.length)
                for (var i = 0; i < message.current_roster.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.current_roster[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamInfo message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {ICMsgDOTAFantasyTeamInfo} message CMsgDOTAFantasyTeamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamInfo} CMsgDOTAFantasyTeamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.owner_account_id = reader.uint32();
                    break;
                case 3:
                    message.fantasy_team_index = reader.uint32();
                    break;
                case 4:
                    message.team_name = reader.string();
                    break;
                case 5:
                    message.team_logo = reader.uint64();
                    break;
                case 6:
                    message.wins = reader.uint32();
                    break;
                case 7:
                    message.losses = reader.uint32();
                    break;
                case 8:
                    if (!(message.current_roster && message.current_roster.length))
                        message.current_roster = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.current_roster.push(reader.uint32());
                    } else
                        message.current_roster.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamInfo} CMsgDOTAFantasyTeamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamInfo message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                if (!$util.isInteger(message.owner_account_id))
                    return "owner_account_id: integer expected";
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                if (!$util.isInteger(message.fantasy_team_index))
                    return "fantasy_team_index: integer expected";
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                if (!$util.isString(message.team_name))
                    return "team_name: string expected";
            if (message.team_logo != null && message.hasOwnProperty("team_logo"))
                if (!$util.isInteger(message.team_logo) && !(message.team_logo && $util.isInteger(message.team_logo.low) && $util.isInteger(message.team_logo.high)))
                    return "team_logo: integer|Long expected";
            if (message.wins != null && message.hasOwnProperty("wins"))
                if (!$util.isInteger(message.wins))
                    return "wins: integer expected";
            if (message.losses != null && message.hasOwnProperty("losses"))
                if (!$util.isInteger(message.losses))
                    return "losses: integer expected";
            if (message.current_roster != null && message.hasOwnProperty("current_roster")) {
                if (!Array.isArray(message.current_roster))
                    return "current_roster: array expected";
                for (var i = 0; i < message.current_roster.length; ++i)
                    if (!$util.isInteger(message.current_roster[i]))
                        return "current_roster: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamInfo} CMsgDOTAFantasyTeamInfo
         */
        CMsgDOTAFantasyTeamInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamInfo)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamInfo();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.owner_account_id != null)
                message.owner_account_id = object.owner_account_id >>> 0;
            if (object.fantasy_team_index != null)
                message.fantasy_team_index = object.fantasy_team_index >>> 0;
            if (object.team_name != null)
                message.team_name = String(object.team_name);
            if (object.team_logo != null)
                if ($util.Long)
                    (message.team_logo = $util.Long.fromValue(object.team_logo)).unsigned = true;
                else if (typeof object.team_logo === "string")
                    message.team_logo = parseInt(object.team_logo, 10);
                else if (typeof object.team_logo === "number")
                    message.team_logo = object.team_logo;
                else if (typeof object.team_logo === "object")
                    message.team_logo = new $util.LongBits(object.team_logo.low >>> 0, object.team_logo.high >>> 0).toNumber(true);
            if (object.wins != null)
                message.wins = object.wins >>> 0;
            if (object.losses != null)
                message.losses = object.losses >>> 0;
            if (object.current_roster) {
                if (!Array.isArray(object.current_roster))
                    throw TypeError(".CMsgDOTAFantasyTeamInfo.current_roster: array expected");
                message.current_roster = [];
                for (var i = 0; i < object.current_roster.length; ++i)
                    message.current_roster[i] = object.current_roster[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamInfo
         * @static
         * @param {CMsgDOTAFantasyTeamInfo} message CMsgDOTAFantasyTeamInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.current_roster = [];
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.owner_account_id = 0;
                object.fantasy_team_index = 0;
                object.team_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.team_logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.team_logo = options.longs === String ? "0" : 0;
                object.wins = 0;
                object.losses = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                object.owner_account_id = message.owner_account_id;
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                object.fantasy_team_index = message.fantasy_team_index;
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                object.team_name = message.team_name;
            if (message.team_logo != null && message.hasOwnProperty("team_logo"))
                if (typeof message.team_logo === "number")
                    object.team_logo = options.longs === String ? String(message.team_logo) : message.team_logo;
                else
                    object.team_logo = options.longs === String ? $util.Long.prototype.toString.call(message.team_logo) : options.longs === Number ? new $util.LongBits(message.team_logo.low >>> 0, message.team_logo.high >>> 0).toNumber(true) : message.team_logo;
            if (message.wins != null && message.hasOwnProperty("wins"))
                object.wins = message.wins;
            if (message.losses != null && message.hasOwnProperty("losses"))
                object.losses = message.losses;
            if (message.current_roster && message.current_roster.length) {
                object.current_roster = [];
                for (var j = 0; j < message.current_roster.length; ++j)
                    object.current_roster[j] = message.current_roster[j];
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamInfo to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamInfo;
    })();
    
    $root.CMsgDOTAFantasyTeamScoreRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamScoreRequest.
         * @exports ICMsgDOTAFantasyTeamScoreRequest
         * @interface ICMsgDOTAFantasyTeamScoreRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamScoreRequest fantasy_league_id
         * @property {number|null} [owner_account_id] CMsgDOTAFantasyTeamScoreRequest owner_account_id
         * @property {number|null} [fantasy_team_index] CMsgDOTAFantasyTeamScoreRequest fantasy_team_index
         * @property {number|Long|null} [filter_match_id] CMsgDOTAFantasyTeamScoreRequest filter_match_id
         * @property {number|null} [filter_start_time] CMsgDOTAFantasyTeamScoreRequest filter_start_time
         * @property {number|null} [filter_end_time] CMsgDOTAFantasyTeamScoreRequest filter_end_time
         * @property {boolean|null} [include_bench] CMsgDOTAFantasyTeamScoreRequest include_bench
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamScoreRequest.
         * @exports CMsgDOTAFantasyTeamScoreRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamScoreRequest.
         * @implements ICMsgDOTAFantasyTeamScoreRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamScoreRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamScoreRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest owner_account_id.
         * @member {number} owner_account_id
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.owner_account_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest fantasy_team_index.
         * @member {number} fantasy_team_index
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.fantasy_team_index = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest filter_match_id.
         * @member {number|Long} filter_match_id
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.filter_match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest filter_start_time.
         * @member {number} filter_start_time
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.filter_start_time = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest filter_end_time.
         * @member {number} filter_end_time
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.filter_end_time = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreRequest include_bench.
         * @member {boolean} include_bench
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.include_bench = false;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamScoreRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamScoreRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamScoreRequest} CMsgDOTAFantasyTeamScoreRequest instance
         */
        CMsgDOTAFantasyTeamScoreRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamScoreRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamScoreRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamScoreRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamScoreRequest} message CMsgDOTAFantasyTeamScoreRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamScoreRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.owner_account_id);
            if (message.fantasy_team_index != null && Object.hasOwnProperty.call(message, "fantasy_team_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.fantasy_team_index);
            if (message.filter_match_id != null && Object.hasOwnProperty.call(message, "filter_match_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.filter_match_id);
            if (message.filter_start_time != null && Object.hasOwnProperty.call(message, "filter_start_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.filter_start_time);
            if (message.filter_end_time != null && Object.hasOwnProperty.call(message, "filter_end_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.filter_end_time);
            if (message.include_bench != null && Object.hasOwnProperty.call(message, "include_bench"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.include_bench);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamScoreRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamScoreRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamScoreRequest} message CMsgDOTAFantasyTeamScoreRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamScoreRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamScoreRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamScoreRequest} CMsgDOTAFantasyTeamScoreRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamScoreRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamScoreRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.owner_account_id = reader.uint32();
                    break;
                case 3:
                    message.fantasy_team_index = reader.uint32();
                    break;
                case 4:
                    message.filter_match_id = reader.uint64();
                    break;
                case 5:
                    message.filter_start_time = reader.uint32();
                    break;
                case 6:
                    message.filter_end_time = reader.uint32();
                    break;
                case 7:
                    message.include_bench = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamScoreRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamScoreRequest} CMsgDOTAFantasyTeamScoreRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamScoreRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamScoreRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamScoreRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                if (!$util.isInteger(message.owner_account_id))
                    return "owner_account_id: integer expected";
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                if (!$util.isInteger(message.fantasy_team_index))
                    return "fantasy_team_index: integer expected";
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (!$util.isInteger(message.filter_match_id) && !(message.filter_match_id && $util.isInteger(message.filter_match_id.low) && $util.isInteger(message.filter_match_id.high)))
                    return "filter_match_id: integer|Long expected";
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                if (!$util.isInteger(message.filter_start_time))
                    return "filter_start_time: integer expected";
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                if (!$util.isInteger(message.filter_end_time))
                    return "filter_end_time: integer expected";
            if (message.include_bench != null && message.hasOwnProperty("include_bench"))
                if (typeof message.include_bench !== "boolean")
                    return "include_bench: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamScoreRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamScoreRequest} CMsgDOTAFantasyTeamScoreRequest
         */
        CMsgDOTAFantasyTeamScoreRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamScoreRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamScoreRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.owner_account_id != null)
                message.owner_account_id = object.owner_account_id >>> 0;
            if (object.fantasy_team_index != null)
                message.fantasy_team_index = object.fantasy_team_index >>> 0;
            if (object.filter_match_id != null)
                if ($util.Long)
                    (message.filter_match_id = $util.Long.fromValue(object.filter_match_id)).unsigned = true;
                else if (typeof object.filter_match_id === "string")
                    message.filter_match_id = parseInt(object.filter_match_id, 10);
                else if (typeof object.filter_match_id === "number")
                    message.filter_match_id = object.filter_match_id;
                else if (typeof object.filter_match_id === "object")
                    message.filter_match_id = new $util.LongBits(object.filter_match_id.low >>> 0, object.filter_match_id.high >>> 0).toNumber(true);
            if (object.filter_start_time != null)
                message.filter_start_time = object.filter_start_time >>> 0;
            if (object.filter_end_time != null)
                message.filter_end_time = object.filter_end_time >>> 0;
            if (object.include_bench != null)
                message.include_bench = Boolean(object.include_bench);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamScoreRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @static
         * @param {CMsgDOTAFantasyTeamScoreRequest} message CMsgDOTAFantasyTeamScoreRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamScoreRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.owner_account_id = 0;
                object.fantasy_team_index = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.filter_match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.filter_match_id = options.longs === String ? "0" : 0;
                object.filter_start_time = 0;
                object.filter_end_time = 0;
                object.include_bench = false;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                object.owner_account_id = message.owner_account_id;
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                object.fantasy_team_index = message.fantasy_team_index;
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (typeof message.filter_match_id === "number")
                    object.filter_match_id = options.longs === String ? String(message.filter_match_id) : message.filter_match_id;
                else
                    object.filter_match_id = options.longs === String ? $util.Long.prototype.toString.call(message.filter_match_id) : options.longs === Number ? new $util.LongBits(message.filter_match_id.low >>> 0, message.filter_match_id.high >>> 0).toNumber(true) : message.filter_match_id;
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                object.filter_start_time = message.filter_start_time;
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                object.filter_end_time = message.filter_end_time;
            if (message.include_bench != null && message.hasOwnProperty("include_bench"))
                object.include_bench = message.include_bench;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamScoreRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamScoreRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamScoreRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamScoreRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamScoreResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamScoreResponse.
         * @exports ICMsgDOTAFantasyTeamScoreResponse
         * @interface ICMsgDOTAFantasyTeamScoreResponse
         * @property {CMsgDOTAFantasyTeamScoreResponse.EResult|null} [result] CMsgDOTAFantasyTeamScoreResponse result
         * @property {number|null} [fantasy_team_score] CMsgDOTAFantasyTeamScoreResponse fantasy_team_score
         * @property {Array.<CMsgDOTAFantasyTeamScoreResponse.ICMsgPlayerScore>|null} [fantasy_player_score] CMsgDOTAFantasyTeamScoreResponse fantasy_player_score
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamScoreResponse.
         * @exports CMsgDOTAFantasyTeamScoreResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamScoreResponse.
         * @implements ICMsgDOTAFantasyTeamScoreResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamScoreResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamScoreResponse(properties) {
            this.fantasy_player_score = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamScoreResponse result.
         * @member {CMsgDOTAFantasyTeamScoreResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @instance
         */
        CMsgDOTAFantasyTeamScoreResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreResponse fantasy_team_score.
         * @member {number} fantasy_team_score
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @instance
         */
        CMsgDOTAFantasyTeamScoreResponse.prototype.fantasy_team_score = 0;
    
        /**
         * CMsgDOTAFantasyTeamScoreResponse fantasy_player_score.
         * @member {Array.<CMsgDOTAFantasyTeamScoreResponse.ICMsgPlayerScore>} fantasy_player_score
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @instance
         */
        CMsgDOTAFantasyTeamScoreResponse.prototype.fantasy_player_score = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamScoreResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamScoreResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamScoreResponse} CMsgDOTAFantasyTeamScoreResponse instance
         */
        CMsgDOTAFantasyTeamScoreResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamScoreResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamScoreResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamScoreResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamScoreResponse} message CMsgDOTAFantasyTeamScoreResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamScoreResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_team_score != null && Object.hasOwnProperty.call(message, "fantasy_team_score"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.fantasy_team_score);
            if (message.fantasy_player_score != null && message.fantasy_player_score.length)
                for (var i = 0; i < message.fantasy_player_score.length; ++i)
                    $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.encode(message.fantasy_player_score[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamScoreResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamScoreResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamScoreResponse} message CMsgDOTAFantasyTeamScoreResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamScoreResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamScoreResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamScoreResponse} CMsgDOTAFantasyTeamScoreResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamScoreResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamScoreResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_team_score = reader.float();
                    break;
                case 3:
                    if (!(message.fantasy_player_score && message.fantasy_player_score.length))
                        message.fantasy_player_score = [];
                    message.fantasy_player_score.push($root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamScoreResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamScoreResponse} CMsgDOTAFantasyTeamScoreResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamScoreResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamScoreResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamScoreResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.fantasy_team_score != null && message.hasOwnProperty("fantasy_team_score"))
                if (typeof message.fantasy_team_score !== "number")
                    return "fantasy_team_score: number expected";
            if (message.fantasy_player_score != null && message.hasOwnProperty("fantasy_player_score")) {
                if (!Array.isArray(message.fantasy_player_score))
                    return "fantasy_player_score: array expected";
                for (var i = 0; i < message.fantasy_player_score.length; ++i) {
                    var error = $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.verify(message.fantasy_player_score[i]);
                    if (error)
                        return "fantasy_player_score." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamScoreResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamScoreResponse} CMsgDOTAFantasyTeamScoreResponse
         */
        CMsgDOTAFantasyTeamScoreResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamScoreResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamScoreResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            case "ERROR_OWNER_NOT_IN_LEAGUE":
            case 3:
                message.result = 3;
                break;
            }
            if (object.fantasy_team_score != null)
                message.fantasy_team_score = Number(object.fantasy_team_score);
            if (object.fantasy_player_score) {
                if (!Array.isArray(object.fantasy_player_score))
                    throw TypeError(".CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score: array expected");
                message.fantasy_player_score = [];
                for (var i = 0; i < object.fantasy_player_score.length; ++i) {
                    if (typeof object.fantasy_player_score[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score: object expected");
                    message.fantasy_player_score[i] = $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.fromObject(object.fantasy_player_score[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamScoreResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @static
         * @param {CMsgDOTAFantasyTeamScoreResponse} message CMsgDOTAFantasyTeamScoreResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamScoreResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fantasy_player_score = [];
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_team_score = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamScoreResponse.EResult[message.result] : message.result;
            if (message.fantasy_team_score != null && message.hasOwnProperty("fantasy_team_score"))
                object.fantasy_team_score = options.json && !isFinite(message.fantasy_team_score) ? String(message.fantasy_team_score) : message.fantasy_team_score;
            if (message.fantasy_player_score && message.fantasy_player_score.length) {
                object.fantasy_player_score = [];
                for (var j = 0; j < message.fantasy_player_score.length; ++j)
                    object.fantasy_player_score[j] = $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.toObject(message.fantasy_player_score[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamScoreResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamScoreResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamScoreResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore = (function() {
    
            /**
             * Properties of a CMsgPlayerScore.
             * @memberof CMsgDOTAFantasyTeamScoreResponse
             * @interface ICMsgPlayerScore
             * @property {number|null} [account_id] CMsgPlayerScore account_id
             * @property {number|null} [score] CMsgPlayerScore score
             */
    
            /**
             * Constructs a new CMsgPlayerScore.
             * @memberof CMsgDOTAFantasyTeamScoreResponse
             * @classdesc Represents a CMsgPlayerScore.
             * @implements ICMsgPlayerScore
             * @constructor
             * @param {CMsgDOTAFantasyTeamScoreResponse.ICMsgPlayerScore=} [properties] Properties to set
             */
            function CMsgPlayerScore(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CMsgPlayerScore account_id.
             * @member {number} account_id
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @instance
             */
            CMsgPlayerScore.prototype.account_id = 0;
    
            /**
             * CMsgPlayerScore score.
             * @member {number} score
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @instance
             */
            CMsgPlayerScore.prototype.score = 0;
    
            /**
             * Creates a new CMsgPlayerScore instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyTeamScoreResponse.ICMsgPlayerScore=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore} CMsgPlayerScore instance
             */
            CMsgPlayerScore.create = function create(properties) {
                return new CMsgPlayerScore(properties);
            };
    
            /**
             * Encodes the specified CMsgPlayerScore message. Does not implicitly {@link CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyTeamScoreResponse.ICMsgPlayerScore} message CMsgPlayerScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CMsgPlayerScore.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.account_id);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.score);
                return writer;
            };
    
            /**
             * Encodes the specified CMsgPlayerScore message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyTeamScoreResponse.ICMsgPlayerScore} message CMsgPlayerScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CMsgPlayerScore.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CMsgPlayerScore message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore} CMsgPlayerScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CMsgPlayerScore.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.account_id = reader.uint32();
                        break;
                    case 2:
                        message.score = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CMsgPlayerScore message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore} CMsgPlayerScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CMsgPlayerScore.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CMsgPlayerScore message.
             * @function verify
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CMsgPlayerScore.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account_id != null && message.hasOwnProperty("account_id"))
                    if (!$util.isInteger(message.account_id))
                        return "account_id: integer expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                return null;
            };
    
            /**
             * Creates a CMsgPlayerScore message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore} CMsgPlayerScore
             */
            CMsgPlayerScore.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore)
                    return object;
                var message = new $root.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore();
                if (object.account_id != null)
                    message.account_id = object.account_id >>> 0;
                if (object.score != null)
                    message.score = Number(object.score);
                return message;
            };
    
            /**
             * Creates a plain object from a CMsgPlayerScore message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore} message CMsgPlayerScore
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CMsgPlayerScore.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.account_id = 0;
                    object.score = 0;
                }
                if (message.account_id != null && message.hasOwnProperty("account_id"))
                    object.account_id = message.account_id;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                return object;
            };
    
            /**
             * Converts this CMsgPlayerScore to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CMsgPlayerScore.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CMsgPlayerScore;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamScoreResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         * @property {number} ERROR_OWNER_NOT_IN_LEAGUE=3 ERROR_OWNER_NOT_IN_LEAGUE value
         */
        CMsgDOTAFantasyTeamScoreResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            values[valuesById[3] = "ERROR_OWNER_NOT_IN_LEAGUE"] = 3;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamScoreResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamStandingsRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamStandingsRequest.
         * @exports ICMsgDOTAFantasyTeamStandingsRequest
         * @interface ICMsgDOTAFantasyTeamStandingsRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamStandingsRequest fantasy_league_id
         * @property {number|null} [count] CMsgDOTAFantasyTeamStandingsRequest count
         * @property {number|null} [filter_start_time] CMsgDOTAFantasyTeamStandingsRequest filter_start_time
         * @property {number|null} [filter_end_time] CMsgDOTAFantasyTeamStandingsRequest filter_end_time
         * @property {number|Long|null} [filter_match_id] CMsgDOTAFantasyTeamStandingsRequest filter_match_id
         * @property {boolean|null} [filter_last_match] CMsgDOTAFantasyTeamStandingsRequest filter_last_match
         * @property {boolean|null} [filter_in_hall] CMsgDOTAFantasyTeamStandingsRequest filter_in_hall
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamStandingsRequest.
         * @exports CMsgDOTAFantasyTeamStandingsRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamStandingsRequest.
         * @implements ICMsgDOTAFantasyTeamStandingsRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamStandingsRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamStandingsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest count.
         * @member {number} count
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.count = 0;
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest filter_start_time.
         * @member {number} filter_start_time
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.filter_start_time = 0;
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest filter_end_time.
         * @member {number} filter_end_time
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.filter_end_time = 0;
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest filter_match_id.
         * @member {number|Long} filter_match_id
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.filter_match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest filter_last_match.
         * @member {boolean} filter_last_match
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.filter_last_match = false;
    
        /**
         * CMsgDOTAFantasyTeamStandingsRequest filter_in_hall.
         * @member {boolean} filter_in_hall
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.filter_in_hall = false;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamStandingsRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamStandingsRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamStandingsRequest} CMsgDOTAFantasyTeamStandingsRequest instance
         */
        CMsgDOTAFantasyTeamStandingsRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamStandingsRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamStandingsRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamStandingsRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamStandingsRequest} message CMsgDOTAFantasyTeamStandingsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamStandingsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
            if (message.filter_start_time != null && Object.hasOwnProperty.call(message, "filter_start_time"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.filter_start_time);
            if (message.filter_end_time != null && Object.hasOwnProperty.call(message, "filter_end_time"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.filter_end_time);
            if (message.filter_match_id != null && Object.hasOwnProperty.call(message, "filter_match_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.filter_match_id);
            if (message.filter_last_match != null && Object.hasOwnProperty.call(message, "filter_last_match"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.filter_last_match);
            if (message.filter_in_hall != null && Object.hasOwnProperty.call(message, "filter_in_hall"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.filter_in_hall);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamStandingsRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamStandingsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamStandingsRequest} message CMsgDOTAFantasyTeamStandingsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamStandingsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamStandingsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamStandingsRequest} CMsgDOTAFantasyTeamStandingsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamStandingsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamStandingsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.count = reader.uint32();
                    break;
                case 3:
                    message.filter_start_time = reader.uint32();
                    break;
                case 4:
                    message.filter_end_time = reader.uint32();
                    break;
                case 5:
                    message.filter_match_id = reader.uint64();
                    break;
                case 6:
                    message.filter_last_match = reader.bool();
                    break;
                case 7:
                    message.filter_in_hall = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamStandingsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamStandingsRequest} CMsgDOTAFantasyTeamStandingsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamStandingsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamStandingsRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamStandingsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                if (!$util.isInteger(message.filter_start_time))
                    return "filter_start_time: integer expected";
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                if (!$util.isInteger(message.filter_end_time))
                    return "filter_end_time: integer expected";
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (!$util.isInteger(message.filter_match_id) && !(message.filter_match_id && $util.isInteger(message.filter_match_id.low) && $util.isInteger(message.filter_match_id.high)))
                    return "filter_match_id: integer|Long expected";
            if (message.filter_last_match != null && message.hasOwnProperty("filter_last_match"))
                if (typeof message.filter_last_match !== "boolean")
                    return "filter_last_match: boolean expected";
            if (message.filter_in_hall != null && message.hasOwnProperty("filter_in_hall"))
                if (typeof message.filter_in_hall !== "boolean")
                    return "filter_in_hall: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamStandingsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamStandingsRequest} CMsgDOTAFantasyTeamStandingsRequest
         */
        CMsgDOTAFantasyTeamStandingsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamStandingsRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamStandingsRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.count != null)
                message.count = object.count >>> 0;
            if (object.filter_start_time != null)
                message.filter_start_time = object.filter_start_time >>> 0;
            if (object.filter_end_time != null)
                message.filter_end_time = object.filter_end_time >>> 0;
            if (object.filter_match_id != null)
                if ($util.Long)
                    (message.filter_match_id = $util.Long.fromValue(object.filter_match_id)).unsigned = true;
                else if (typeof object.filter_match_id === "string")
                    message.filter_match_id = parseInt(object.filter_match_id, 10);
                else if (typeof object.filter_match_id === "number")
                    message.filter_match_id = object.filter_match_id;
                else if (typeof object.filter_match_id === "object")
                    message.filter_match_id = new $util.LongBits(object.filter_match_id.low >>> 0, object.filter_match_id.high >>> 0).toNumber(true);
            if (object.filter_last_match != null)
                message.filter_last_match = Boolean(object.filter_last_match);
            if (object.filter_in_hall != null)
                message.filter_in_hall = Boolean(object.filter_in_hall);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamStandingsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @static
         * @param {CMsgDOTAFantasyTeamStandingsRequest} message CMsgDOTAFantasyTeamStandingsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamStandingsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.count = 0;
                object.filter_start_time = 0;
                object.filter_end_time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.filter_match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.filter_match_id = options.longs === String ? "0" : 0;
                object.filter_last_match = false;
                object.filter_in_hall = false;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                object.filter_start_time = message.filter_start_time;
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                object.filter_end_time = message.filter_end_time;
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (typeof message.filter_match_id === "number")
                    object.filter_match_id = options.longs === String ? String(message.filter_match_id) : message.filter_match_id;
                else
                    object.filter_match_id = options.longs === String ? $util.Long.prototype.toString.call(message.filter_match_id) : options.longs === Number ? new $util.LongBits(message.filter_match_id.low >>> 0, message.filter_match_id.high >>> 0).toNumber(true) : message.filter_match_id;
            if (message.filter_last_match != null && message.hasOwnProperty("filter_last_match"))
                object.filter_last_match = message.filter_last_match;
            if (message.filter_in_hall != null && message.hasOwnProperty("filter_in_hall"))
                object.filter_in_hall = message.filter_in_hall;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamStandingsRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamStandingsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamStandingsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamStandingsRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamStandingsResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamStandingsResponse.
         * @exports ICMsgDOTAFantasyTeamStandingsResponse
         * @interface ICMsgDOTAFantasyTeamStandingsResponse
         * @property {CMsgDOTAFantasyTeamStandingsResponse.EResult|null} [result] CMsgDOTAFantasyTeamStandingsResponse result
         * @property {Array.<CMsgDOTAFantasyTeamStandingsResponse.ICMsgTeamScore>|null} [team_scores] CMsgDOTAFantasyTeamStandingsResponse team_scores
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamStandingsResponse.
         * @exports CMsgDOTAFantasyTeamStandingsResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamStandingsResponse.
         * @implements ICMsgDOTAFantasyTeamStandingsResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamStandingsResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamStandingsResponse(properties) {
            this.team_scores = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamStandingsResponse result.
         * @member {CMsgDOTAFantasyTeamStandingsResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyTeamStandingsResponse team_scores.
         * @member {Array.<CMsgDOTAFantasyTeamStandingsResponse.ICMsgTeamScore>} team_scores
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @instance
         */
        CMsgDOTAFantasyTeamStandingsResponse.prototype.team_scores = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamStandingsResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamStandingsResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamStandingsResponse} CMsgDOTAFantasyTeamStandingsResponse instance
         */
        CMsgDOTAFantasyTeamStandingsResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamStandingsResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamStandingsResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamStandingsResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamStandingsResponse} message CMsgDOTAFantasyTeamStandingsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamStandingsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.team_scores != null && message.team_scores.length)
                for (var i = 0; i < message.team_scores.length; ++i)
                    $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.encode(message.team_scores[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamStandingsResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamStandingsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamStandingsResponse} message CMsgDOTAFantasyTeamStandingsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamStandingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamStandingsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamStandingsResponse} CMsgDOTAFantasyTeamStandingsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamStandingsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamStandingsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 3:
                    if (!(message.team_scores && message.team_scores.length))
                        message.team_scores = [];
                    message.team_scores.push($root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamStandingsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamStandingsResponse} CMsgDOTAFantasyTeamStandingsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamStandingsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamStandingsResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamStandingsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.team_scores != null && message.hasOwnProperty("team_scores")) {
                if (!Array.isArray(message.team_scores))
                    return "team_scores: array expected";
                for (var i = 0; i < message.team_scores.length; ++i) {
                    var error = $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.verify(message.team_scores[i]);
                    if (error)
                        return "team_scores." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamStandingsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamStandingsResponse} CMsgDOTAFantasyTeamStandingsResponse
         */
        CMsgDOTAFantasyTeamStandingsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamStandingsResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamStandingsResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            if (object.team_scores) {
                if (!Array.isArray(object.team_scores))
                    throw TypeError(".CMsgDOTAFantasyTeamStandingsResponse.team_scores: array expected");
                message.team_scores = [];
                for (var i = 0; i < object.team_scores.length; ++i) {
                    if (typeof object.team_scores[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyTeamStandingsResponse.team_scores: object expected");
                    message.team_scores[i] = $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fromObject(object.team_scores[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamStandingsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @static
         * @param {CMsgDOTAFantasyTeamStandingsResponse} message CMsgDOTAFantasyTeamStandingsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamStandingsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.team_scores = [];
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamStandingsResponse.EResult[message.result] : message.result;
            if (message.team_scores && message.team_scores.length) {
                object.team_scores = [];
                for (var j = 0; j < message.team_scores.length; ++j)
                    object.team_scores[j] = $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.toObject(message.team_scores[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamStandingsResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamStandingsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamStandingsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore = (function() {
    
            /**
             * Properties of a CMsgTeamScore.
             * @memberof CMsgDOTAFantasyTeamStandingsResponse
             * @interface ICMsgTeamScore
             * @property {number|null} [fantasy_league_id] CMsgTeamScore fantasy_league_id
             * @property {number|null} [owner_account_id] CMsgTeamScore owner_account_id
             * @property {number|null} [fantasy_team_index] CMsgTeamScore fantasy_team_index
             * @property {number|Long|null} [fantasy_team_logo] CMsgTeamScore fantasy_team_logo
             * @property {string|null} [owner_name] CMsgTeamScore owner_name
             * @property {string|null} [fantasy_team_name] CMsgTeamScore fantasy_team_name
             * @property {number|null} [score] CMsgTeamScore score
             * @property {number|null} [score_against] CMsgTeamScore score_against
             * @property {number|null} [wins] CMsgTeamScore wins
             * @property {number|null} [losses] CMsgTeamScore losses
             * @property {number|null} [streak] CMsgTeamScore streak
             */
    
            /**
             * Constructs a new CMsgTeamScore.
             * @memberof CMsgDOTAFantasyTeamStandingsResponse
             * @classdesc Represents a CMsgTeamScore.
             * @implements ICMsgTeamScore
             * @constructor
             * @param {CMsgDOTAFantasyTeamStandingsResponse.ICMsgTeamScore=} [properties] Properties to set
             */
            function CMsgTeamScore(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CMsgTeamScore fantasy_league_id.
             * @member {number} fantasy_league_id
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.fantasy_league_id = 0;
    
            /**
             * CMsgTeamScore owner_account_id.
             * @member {number} owner_account_id
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.owner_account_id = 0;
    
            /**
             * CMsgTeamScore fantasy_team_index.
             * @member {number} fantasy_team_index
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.fantasy_team_index = 0;
    
            /**
             * CMsgTeamScore fantasy_team_logo.
             * @member {number|Long} fantasy_team_logo
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.fantasy_team_logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * CMsgTeamScore owner_name.
             * @member {string} owner_name
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.owner_name = "";
    
            /**
             * CMsgTeamScore fantasy_team_name.
             * @member {string} fantasy_team_name
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.fantasy_team_name = "";
    
            /**
             * CMsgTeamScore score.
             * @member {number} score
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.score = 0;
    
            /**
             * CMsgTeamScore score_against.
             * @member {number} score_against
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.score_against = 0;
    
            /**
             * CMsgTeamScore wins.
             * @member {number} wins
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.wins = 0;
    
            /**
             * CMsgTeamScore losses.
             * @member {number} losses
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.losses = 0;
    
            /**
             * CMsgTeamScore streak.
             * @member {number} streak
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             */
            CMsgTeamScore.prototype.streak = 0;
    
            /**
             * Creates a new CMsgTeamScore instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {CMsgDOTAFantasyTeamStandingsResponse.ICMsgTeamScore=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore} CMsgTeamScore instance
             */
            CMsgTeamScore.create = function create(properties) {
                return new CMsgTeamScore(properties);
            };
    
            /**
             * Encodes the specified CMsgTeamScore message. Does not implicitly {@link CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {CMsgDOTAFantasyTeamStandingsResponse.ICMsgTeamScore} message CMsgTeamScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CMsgTeamScore.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
                if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.owner_account_id);
                if (message.fantasy_team_index != null && Object.hasOwnProperty.call(message, "fantasy_team_index"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.fantasy_team_index);
                if (message.fantasy_team_logo != null && Object.hasOwnProperty.call(message, "fantasy_team_logo"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fantasy_team_logo);
                if (message.owner_name != null && Object.hasOwnProperty.call(message, "owner_name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.owner_name);
                if (message.fantasy_team_name != null && Object.hasOwnProperty.call(message, "fantasy_team_name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.fantasy_team_name);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.score);
                if (message.score_against != null && Object.hasOwnProperty.call(message, "score_against"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.score_against);
                if (message.wins != null && Object.hasOwnProperty.call(message, "wins"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.wins);
                if (message.losses != null && Object.hasOwnProperty.call(message, "losses"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.losses);
                if (message.streak != null && Object.hasOwnProperty.call(message, "streak"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.streak);
                return writer;
            };
    
            /**
             * Encodes the specified CMsgTeamScore message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {CMsgDOTAFantasyTeamStandingsResponse.ICMsgTeamScore} message CMsgTeamScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CMsgTeamScore.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CMsgTeamScore message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore} CMsgTeamScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CMsgTeamScore.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fantasy_league_id = reader.uint32();
                        break;
                    case 2:
                        message.owner_account_id = reader.uint32();
                        break;
                    case 3:
                        message.fantasy_team_index = reader.uint32();
                        break;
                    case 4:
                        message.fantasy_team_logo = reader.uint64();
                        break;
                    case 5:
                        message.owner_name = reader.string();
                        break;
                    case 6:
                        message.fantasy_team_name = reader.string();
                        break;
                    case 7:
                        message.score = reader.float();
                        break;
                    case 8:
                        message.score_against = reader.float();
                        break;
                    case 9:
                        message.wins = reader.uint32();
                        break;
                    case 10:
                        message.losses = reader.uint32();
                        break;
                    case 11:
                        message.streak = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CMsgTeamScore message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore} CMsgTeamScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CMsgTeamScore.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CMsgTeamScore message.
             * @function verify
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CMsgTeamScore.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                    if (!$util.isInteger(message.fantasy_league_id))
                        return "fantasy_league_id: integer expected";
                if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                    if (!$util.isInteger(message.owner_account_id))
                        return "owner_account_id: integer expected";
                if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                    if (!$util.isInteger(message.fantasy_team_index))
                        return "fantasy_team_index: integer expected";
                if (message.fantasy_team_logo != null && message.hasOwnProperty("fantasy_team_logo"))
                    if (!$util.isInteger(message.fantasy_team_logo) && !(message.fantasy_team_logo && $util.isInteger(message.fantasy_team_logo.low) && $util.isInteger(message.fantasy_team_logo.high)))
                        return "fantasy_team_logo: integer|Long expected";
                if (message.owner_name != null && message.hasOwnProperty("owner_name"))
                    if (!$util.isString(message.owner_name))
                        return "owner_name: string expected";
                if (message.fantasy_team_name != null && message.hasOwnProperty("fantasy_team_name"))
                    if (!$util.isString(message.fantasy_team_name))
                        return "fantasy_team_name: string expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                if (message.score_against != null && message.hasOwnProperty("score_against"))
                    if (typeof message.score_against !== "number")
                        return "score_against: number expected";
                if (message.wins != null && message.hasOwnProperty("wins"))
                    if (!$util.isInteger(message.wins))
                        return "wins: integer expected";
                if (message.losses != null && message.hasOwnProperty("losses"))
                    if (!$util.isInteger(message.losses))
                        return "losses: integer expected";
                if (message.streak != null && message.hasOwnProperty("streak"))
                    if (!$util.isInteger(message.streak))
                        return "streak: integer expected";
                return null;
            };
    
            /**
             * Creates a CMsgTeamScore message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore} CMsgTeamScore
             */
            CMsgTeamScore.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore)
                    return object;
                var message = new $root.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore();
                if (object.fantasy_league_id != null)
                    message.fantasy_league_id = object.fantasy_league_id >>> 0;
                if (object.owner_account_id != null)
                    message.owner_account_id = object.owner_account_id >>> 0;
                if (object.fantasy_team_index != null)
                    message.fantasy_team_index = object.fantasy_team_index >>> 0;
                if (object.fantasy_team_logo != null)
                    if ($util.Long)
                        (message.fantasy_team_logo = $util.Long.fromValue(object.fantasy_team_logo)).unsigned = true;
                    else if (typeof object.fantasy_team_logo === "string")
                        message.fantasy_team_logo = parseInt(object.fantasy_team_logo, 10);
                    else if (typeof object.fantasy_team_logo === "number")
                        message.fantasy_team_logo = object.fantasy_team_logo;
                    else if (typeof object.fantasy_team_logo === "object")
                        message.fantasy_team_logo = new $util.LongBits(object.fantasy_team_logo.low >>> 0, object.fantasy_team_logo.high >>> 0).toNumber(true);
                if (object.owner_name != null)
                    message.owner_name = String(object.owner_name);
                if (object.fantasy_team_name != null)
                    message.fantasy_team_name = String(object.fantasy_team_name);
                if (object.score != null)
                    message.score = Number(object.score);
                if (object.score_against != null)
                    message.score_against = Number(object.score_against);
                if (object.wins != null)
                    message.wins = object.wins >>> 0;
                if (object.losses != null)
                    message.losses = object.losses >>> 0;
                if (object.streak != null)
                    message.streak = object.streak | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a CMsgTeamScore message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @static
             * @param {CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore} message CMsgTeamScore
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CMsgTeamScore.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fantasy_league_id = 0;
                    object.owner_account_id = 0;
                    object.fantasy_team_index = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.fantasy_team_logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fantasy_team_logo = options.longs === String ? "0" : 0;
                    object.owner_name = "";
                    object.fantasy_team_name = "";
                    object.score = 0;
                    object.score_against = 0;
                    object.wins = 0;
                    object.losses = 0;
                    object.streak = 0;
                }
                if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                    object.fantasy_league_id = message.fantasy_league_id;
                if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                    object.owner_account_id = message.owner_account_id;
                if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                    object.fantasy_team_index = message.fantasy_team_index;
                if (message.fantasy_team_logo != null && message.hasOwnProperty("fantasy_team_logo"))
                    if (typeof message.fantasy_team_logo === "number")
                        object.fantasy_team_logo = options.longs === String ? String(message.fantasy_team_logo) : message.fantasy_team_logo;
                    else
                        object.fantasy_team_logo = options.longs === String ? $util.Long.prototype.toString.call(message.fantasy_team_logo) : options.longs === Number ? new $util.LongBits(message.fantasy_team_logo.low >>> 0, message.fantasy_team_logo.high >>> 0).toNumber(true) : message.fantasy_team_logo;
                if (message.owner_name != null && message.hasOwnProperty("owner_name"))
                    object.owner_name = message.owner_name;
                if (message.fantasy_team_name != null && message.hasOwnProperty("fantasy_team_name"))
                    object.fantasy_team_name = message.fantasy_team_name;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                if (message.score_against != null && message.hasOwnProperty("score_against"))
                    object.score_against = options.json && !isFinite(message.score_against) ? String(message.score_against) : message.score_against;
                if (message.wins != null && message.hasOwnProperty("wins"))
                    object.wins = message.wins;
                if (message.losses != null && message.hasOwnProperty("losses"))
                    object.losses = message.losses;
                if (message.streak != null && message.hasOwnProperty("streak"))
                    object.streak = message.streak;
                return object;
            };
    
            /**
             * Converts this CMsgTeamScore to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CMsgTeamScore.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CMsgTeamScore;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamStandingsResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyTeamStandingsResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamStandingsResponse;
    })();
    
    $root.CMsgDOTAFantasyPlayerScoreRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerScoreRequest.
         * @exports ICMsgDOTAFantasyPlayerScoreRequest
         * @interface ICMsgDOTAFantasyPlayerScoreRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyPlayerScoreRequest fantasy_league_id
         * @property {number|null} [player_account_id] CMsgDOTAFantasyPlayerScoreRequest player_account_id
         * @property {number|null} [filter_start_time] CMsgDOTAFantasyPlayerScoreRequest filter_start_time
         * @property {number|null} [filter_end_time] CMsgDOTAFantasyPlayerScoreRequest filter_end_time
         * @property {number|Long|null} [filter_match_id] CMsgDOTAFantasyPlayerScoreRequest filter_match_id
         * @property {boolean|null} [filter_last_match] CMsgDOTAFantasyPlayerScoreRequest filter_last_match
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerScoreRequest.
         * @exports CMsgDOTAFantasyPlayerScoreRequest
         * @classdesc Represents a CMsgDOTAFantasyPlayerScoreRequest.
         * @implements ICMsgDOTAFantasyPlayerScoreRequest
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerScoreRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerScoreRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerScoreRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreRequest player_account_id.
         * @member {number} player_account_id
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.player_account_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreRequest filter_start_time.
         * @member {number} filter_start_time
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.filter_start_time = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreRequest filter_end_time.
         * @member {number} filter_end_time
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.filter_end_time = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreRequest filter_match_id.
         * @member {number|Long} filter_match_id
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.filter_match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreRequest filter_last_match.
         * @member {boolean} filter_last_match
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.filter_last_match = false;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerScoreRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerScoreRequest} CMsgDOTAFantasyPlayerScoreRequest instance
         */
        CMsgDOTAFantasyPlayerScoreRequest.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerScoreRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreRequest message. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreRequest} message CMsgDOTAFantasyPlayerScoreRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.player_account_id != null && Object.hasOwnProperty.call(message, "player_account_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_account_id);
            if (message.filter_start_time != null && Object.hasOwnProperty.call(message, "filter_start_time"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.filter_start_time);
            if (message.filter_end_time != null && Object.hasOwnProperty.call(message, "filter_end_time"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.filter_end_time);
            if (message.filter_match_id != null && Object.hasOwnProperty.call(message, "filter_match_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.filter_match_id);
            if (message.filter_last_match != null && Object.hasOwnProperty.call(message, "filter_last_match"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.filter_last_match);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreRequest} message CMsgDOTAFantasyPlayerScoreRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerScoreRequest} CMsgDOTAFantasyPlayerScoreRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerScoreRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.player_account_id = reader.uint32();
                    break;
                case 3:
                    message.filter_start_time = reader.uint32();
                    break;
                case 4:
                    message.filter_end_time = reader.uint32();
                    break;
                case 5:
                    message.filter_match_id = reader.uint64();
                    break;
                case 6:
                    message.filter_last_match = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerScoreRequest} CMsgDOTAFantasyPlayerScoreRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerScoreRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerScoreRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                if (!$util.isInteger(message.player_account_id))
                    return "player_account_id: integer expected";
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                if (!$util.isInteger(message.filter_start_time))
                    return "filter_start_time: integer expected";
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                if (!$util.isInteger(message.filter_end_time))
                    return "filter_end_time: integer expected";
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (!$util.isInteger(message.filter_match_id) && !(message.filter_match_id && $util.isInteger(message.filter_match_id.low) && $util.isInteger(message.filter_match_id.high)))
                    return "filter_match_id: integer|Long expected";
            if (message.filter_last_match != null && message.hasOwnProperty("filter_last_match"))
                if (typeof message.filter_last_match !== "boolean")
                    return "filter_last_match: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerScoreRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerScoreRequest} CMsgDOTAFantasyPlayerScoreRequest
         */
        CMsgDOTAFantasyPlayerScoreRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerScoreRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerScoreRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.player_account_id != null)
                message.player_account_id = object.player_account_id >>> 0;
            if (object.filter_start_time != null)
                message.filter_start_time = object.filter_start_time >>> 0;
            if (object.filter_end_time != null)
                message.filter_end_time = object.filter_end_time >>> 0;
            if (object.filter_match_id != null)
                if ($util.Long)
                    (message.filter_match_id = $util.Long.fromValue(object.filter_match_id)).unsigned = true;
                else if (typeof object.filter_match_id === "string")
                    message.filter_match_id = parseInt(object.filter_match_id, 10);
                else if (typeof object.filter_match_id === "number")
                    message.filter_match_id = object.filter_match_id;
                else if (typeof object.filter_match_id === "object")
                    message.filter_match_id = new $util.LongBits(object.filter_match_id.low >>> 0, object.filter_match_id.high >>> 0).toNumber(true);
            if (object.filter_last_match != null)
                message.filter_last_match = Boolean(object.filter_last_match);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerScoreRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @static
         * @param {CMsgDOTAFantasyPlayerScoreRequest} message CMsgDOTAFantasyPlayerScoreRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerScoreRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.player_account_id = 0;
                object.filter_start_time = 0;
                object.filter_end_time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.filter_match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.filter_match_id = options.longs === String ? "0" : 0;
                object.filter_last_match = false;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                object.player_account_id = message.player_account_id;
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                object.filter_start_time = message.filter_start_time;
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                object.filter_end_time = message.filter_end_time;
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (typeof message.filter_match_id === "number")
                    object.filter_match_id = options.longs === String ? String(message.filter_match_id) : message.filter_match_id;
                else
                    object.filter_match_id = options.longs === String ? $util.Long.prototype.toString.call(message.filter_match_id) : options.longs === Number ? new $util.LongBits(message.filter_match_id.low >>> 0, message.filter_match_id.high >>> 0).toNumber(true) : message.filter_match_id;
            if (message.filter_last_match != null && message.hasOwnProperty("filter_last_match"))
                object.filter_last_match = message.filter_last_match;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerScoreRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerScoreRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerScoreRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyPlayerScoreRequest;
    })();
    
    $root.CMsgDOTAFantasyPlayerScoreResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerScoreResponse.
         * @exports ICMsgDOTAFantasyPlayerScoreResponse
         * @interface ICMsgDOTAFantasyPlayerScoreResponse
         * @property {CMsgDOTAFantasyPlayerScoreResponse.EResult|null} [result] CMsgDOTAFantasyPlayerScoreResponse result
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyPlayerScoreResponse fantasy_league_id
         * @property {number|null} [player_account_id] CMsgDOTAFantasyPlayerScoreResponse player_account_id
         * @property {string|null} [player_name] CMsgDOTAFantasyPlayerScoreResponse player_name
         * @property {number|null} [score] CMsgDOTAFantasyPlayerScoreResponse score
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerScoreResponse.
         * @exports CMsgDOTAFantasyPlayerScoreResponse
         * @classdesc Represents a CMsgDOTAFantasyPlayerScoreResponse.
         * @implements ICMsgDOTAFantasyPlayerScoreResponse
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerScoreResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerScoreResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerScoreResponse result.
         * @member {CMsgDOTAFantasyPlayerScoreResponse.EResult} result
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreResponse fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreResponse.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreResponse player_account_id.
         * @member {number} player_account_id
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreResponse.prototype.player_account_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreResponse player_name.
         * @member {string} player_name
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreResponse.prototype.player_name = "";
    
        /**
         * CMsgDOTAFantasyPlayerScoreResponse score.
         * @member {number} score
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreResponse.prototype.score = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerScoreResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerScoreResponse} CMsgDOTAFantasyPlayerScoreResponse instance
         */
        CMsgDOTAFantasyPlayerScoreResponse.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerScoreResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreResponse message. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreResponse} message CMsgDOTAFantasyPlayerScoreResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fantasy_league_id);
            if (message.player_account_id != null && Object.hasOwnProperty.call(message, "player_account_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.player_account_id);
            if (message.player_name != null && Object.hasOwnProperty.call(message, "player_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.player_name);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.score);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreResponse} message CMsgDOTAFantasyPlayerScoreResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerScoreResponse} CMsgDOTAFantasyPlayerScoreResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerScoreResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 3:
                    message.player_account_id = reader.uint32();
                    break;
                case 4:
                    message.player_name = reader.string();
                    break;
                case 5:
                    message.score = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerScoreResponse} CMsgDOTAFantasyPlayerScoreResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerScoreResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerScoreResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                if (!$util.isInteger(message.player_account_id))
                    return "player_account_id: integer expected";
            if (message.player_name != null && message.hasOwnProperty("player_name"))
                if (!$util.isString(message.player_name))
                    return "player_name: string expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerScoreResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerScoreResponse} CMsgDOTAFantasyPlayerScoreResponse
         */
        CMsgDOTAFantasyPlayerScoreResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerScoreResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerScoreResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.player_account_id != null)
                message.player_account_id = object.player_account_id >>> 0;
            if (object.player_name != null)
                message.player_name = String(object.player_name);
            if (object.score != null)
                message.score = Number(object.score);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerScoreResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @static
         * @param {CMsgDOTAFantasyPlayerScoreResponse} message CMsgDOTAFantasyPlayerScoreResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerScoreResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_league_id = 0;
                object.player_account_id = 0;
                object.player_name = "";
                object.score = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyPlayerScoreResponse.EResult[message.result] : message.result;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                object.player_account_id = message.player_account_id;
            if (message.player_name != null && message.hasOwnProperty("player_name"))
                object.player_name = message.player_name;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerScoreResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerScoreResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerScoreResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyPlayerScoreResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyPlayerScoreResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyPlayerScoreResponse;
    })();
    
    $root.CMsgDOTAFantasyPlayerStandingsRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerStandingsRequest.
         * @exports ICMsgDOTAFantasyPlayerStandingsRequest
         * @interface ICMsgDOTAFantasyPlayerStandingsRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyPlayerStandingsRequest fantasy_league_id
         * @property {number|null} [count] CMsgDOTAFantasyPlayerStandingsRequest count
         * @property {number|null} [role] CMsgDOTAFantasyPlayerStandingsRequest role
         * @property {number|null} [filter_start_time] CMsgDOTAFantasyPlayerStandingsRequest filter_start_time
         * @property {number|null} [filter_end_time] CMsgDOTAFantasyPlayerStandingsRequest filter_end_time
         * @property {number|Long|null} [filter_match_id] CMsgDOTAFantasyPlayerStandingsRequest filter_match_id
         * @property {boolean|null} [filter_last_match] CMsgDOTAFantasyPlayerStandingsRequest filter_last_match
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerStandingsRequest.
         * @exports CMsgDOTAFantasyPlayerStandingsRequest
         * @classdesc Represents a CMsgDOTAFantasyPlayerStandingsRequest.
         * @implements ICMsgDOTAFantasyPlayerStandingsRequest
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerStandingsRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerStandingsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest count.
         * @member {number} count
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.count = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest role.
         * @member {number} role
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.role = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest filter_start_time.
         * @member {number} filter_start_time
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.filter_start_time = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest filter_end_time.
         * @member {number} filter_end_time
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.filter_end_time = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest filter_match_id.
         * @member {number|Long} filter_match_id
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.filter_match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsRequest filter_last_match.
         * @member {boolean} filter_last_match
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.filter_last_match = false;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerStandingsRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerStandingsRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerStandingsRequest} CMsgDOTAFantasyPlayerStandingsRequest instance
         */
        CMsgDOTAFantasyPlayerStandingsRequest.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerStandingsRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerStandingsRequest message. Does not implicitly {@link CMsgDOTAFantasyPlayerStandingsRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerStandingsRequest} message CMsgDOTAFantasyPlayerStandingsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerStandingsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.filter_start_time != null && Object.hasOwnProperty.call(message, "filter_start_time"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.filter_start_time);
            if (message.filter_end_time != null && Object.hasOwnProperty.call(message, "filter_end_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.filter_end_time);
            if (message.filter_match_id != null && Object.hasOwnProperty.call(message, "filter_match_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.filter_match_id);
            if (message.filter_last_match != null && Object.hasOwnProperty.call(message, "filter_last_match"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.filter_last_match);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerStandingsRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerStandingsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerStandingsRequest} message CMsgDOTAFantasyPlayerStandingsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerStandingsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerStandingsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerStandingsRequest} CMsgDOTAFantasyPlayerStandingsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerStandingsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerStandingsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.count = reader.uint32();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.filter_start_time = reader.uint32();
                    break;
                case 5:
                    message.filter_end_time = reader.uint32();
                    break;
                case 6:
                    message.filter_match_id = reader.uint64();
                    break;
                case 7:
                    message.filter_last_match = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerStandingsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerStandingsRequest} CMsgDOTAFantasyPlayerStandingsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerStandingsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerStandingsRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerStandingsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isInteger(message.role))
                    return "role: integer expected";
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                if (!$util.isInteger(message.filter_start_time))
                    return "filter_start_time: integer expected";
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                if (!$util.isInteger(message.filter_end_time))
                    return "filter_end_time: integer expected";
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (!$util.isInteger(message.filter_match_id) && !(message.filter_match_id && $util.isInteger(message.filter_match_id.low) && $util.isInteger(message.filter_match_id.high)))
                    return "filter_match_id: integer|Long expected";
            if (message.filter_last_match != null && message.hasOwnProperty("filter_last_match"))
                if (typeof message.filter_last_match !== "boolean")
                    return "filter_last_match: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerStandingsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerStandingsRequest} CMsgDOTAFantasyPlayerStandingsRequest
         */
        CMsgDOTAFantasyPlayerStandingsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerStandingsRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerStandingsRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.count != null)
                message.count = object.count >>> 0;
            if (object.role != null)
                message.role = object.role >>> 0;
            if (object.filter_start_time != null)
                message.filter_start_time = object.filter_start_time >>> 0;
            if (object.filter_end_time != null)
                message.filter_end_time = object.filter_end_time >>> 0;
            if (object.filter_match_id != null)
                if ($util.Long)
                    (message.filter_match_id = $util.Long.fromValue(object.filter_match_id)).unsigned = true;
                else if (typeof object.filter_match_id === "string")
                    message.filter_match_id = parseInt(object.filter_match_id, 10);
                else if (typeof object.filter_match_id === "number")
                    message.filter_match_id = object.filter_match_id;
                else if (typeof object.filter_match_id === "object")
                    message.filter_match_id = new $util.LongBits(object.filter_match_id.low >>> 0, object.filter_match_id.high >>> 0).toNumber(true);
            if (object.filter_last_match != null)
                message.filter_last_match = Boolean(object.filter_last_match);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerStandingsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @static
         * @param {CMsgDOTAFantasyPlayerStandingsRequest} message CMsgDOTAFantasyPlayerStandingsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerStandingsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.count = 0;
                object.role = 0;
                object.filter_start_time = 0;
                object.filter_end_time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.filter_match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.filter_match_id = options.longs === String ? "0" : 0;
                object.filter_last_match = false;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.filter_start_time != null && message.hasOwnProperty("filter_start_time"))
                object.filter_start_time = message.filter_start_time;
            if (message.filter_end_time != null && message.hasOwnProperty("filter_end_time"))
                object.filter_end_time = message.filter_end_time;
            if (message.filter_match_id != null && message.hasOwnProperty("filter_match_id"))
                if (typeof message.filter_match_id === "number")
                    object.filter_match_id = options.longs === String ? String(message.filter_match_id) : message.filter_match_id;
                else
                    object.filter_match_id = options.longs === String ? $util.Long.prototype.toString.call(message.filter_match_id) : options.longs === Number ? new $util.LongBits(message.filter_match_id.low >>> 0, message.filter_match_id.high >>> 0).toNumber(true) : message.filter_match_id;
            if (message.filter_last_match != null && message.hasOwnProperty("filter_last_match"))
                object.filter_last_match = message.filter_last_match;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerStandingsRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerStandingsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerStandingsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyPlayerStandingsRequest;
    })();
    
    $root.CMsgDOTAFantasyPlayerStandingsResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerStandingsResponse.
         * @exports ICMsgDOTAFantasyPlayerStandingsResponse
         * @interface ICMsgDOTAFantasyPlayerStandingsResponse
         * @property {CMsgDOTAFantasyPlayerStandingsResponse.EResult|null} [result] CMsgDOTAFantasyPlayerStandingsResponse result
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyPlayerStandingsResponse fantasy_league_id
         * @property {number|null} [role] CMsgDOTAFantasyPlayerStandingsResponse role
         * @property {Array.<CMsgDOTAFantasyPlayerStandingsResponse.ICMsgPlayerScore>|null} [player_scores] CMsgDOTAFantasyPlayerStandingsResponse player_scores
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerStandingsResponse.
         * @exports CMsgDOTAFantasyPlayerStandingsResponse
         * @classdesc Represents a CMsgDOTAFantasyPlayerStandingsResponse.
         * @implements ICMsgDOTAFantasyPlayerStandingsResponse
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerStandingsResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerStandingsResponse(properties) {
            this.player_scores = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerStandingsResponse result.
         * @member {CMsgDOTAFantasyPlayerStandingsResponse.EResult} result
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsResponse fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsResponse.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsResponse role.
         * @member {number} role
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsResponse.prototype.role = 0;
    
        /**
         * CMsgDOTAFantasyPlayerStandingsResponse player_scores.
         * @member {Array.<CMsgDOTAFantasyPlayerStandingsResponse.ICMsgPlayerScore>} player_scores
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerStandingsResponse.prototype.player_scores = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerStandingsResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerStandingsResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerStandingsResponse} CMsgDOTAFantasyPlayerStandingsResponse instance
         */
        CMsgDOTAFantasyPlayerStandingsResponse.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerStandingsResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerStandingsResponse message. Does not implicitly {@link CMsgDOTAFantasyPlayerStandingsResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerStandingsResponse} message CMsgDOTAFantasyPlayerStandingsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerStandingsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fantasy_league_id);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.player_scores != null && message.player_scores.length)
                for (var i = 0; i < message.player_scores.length; ++i)
                    $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.encode(message.player_scores[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerStandingsResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerStandingsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerStandingsResponse} message CMsgDOTAFantasyPlayerStandingsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerStandingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerStandingsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerStandingsResponse} CMsgDOTAFantasyPlayerStandingsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerStandingsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerStandingsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    if (!(message.player_scores && message.player_scores.length))
                        message.player_scores = [];
                    message.player_scores.push($root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerStandingsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerStandingsResponse} CMsgDOTAFantasyPlayerStandingsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerStandingsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerStandingsResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerStandingsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isInteger(message.role))
                    return "role: integer expected";
            if (message.player_scores != null && message.hasOwnProperty("player_scores")) {
                if (!Array.isArray(message.player_scores))
                    return "player_scores: array expected";
                for (var i = 0; i < message.player_scores.length; ++i) {
                    var error = $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.verify(message.player_scores[i]);
                    if (error)
                        return "player_scores." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerStandingsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerStandingsResponse} CMsgDOTAFantasyPlayerStandingsResponse
         */
        CMsgDOTAFantasyPlayerStandingsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerStandingsResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerStandingsResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.role != null)
                message.role = object.role >>> 0;
            if (object.player_scores) {
                if (!Array.isArray(object.player_scores))
                    throw TypeError(".CMsgDOTAFantasyPlayerStandingsResponse.player_scores: array expected");
                message.player_scores = [];
                for (var i = 0; i < object.player_scores.length; ++i) {
                    if (typeof object.player_scores[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyPlayerStandingsResponse.player_scores: object expected");
                    message.player_scores[i] = $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.fromObject(object.player_scores[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerStandingsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @static
         * @param {CMsgDOTAFantasyPlayerStandingsResponse} message CMsgDOTAFantasyPlayerStandingsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerStandingsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.player_scores = [];
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_league_id = 0;
                object.role = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyPlayerStandingsResponse.EResult[message.result] : message.result;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.player_scores && message.player_scores.length) {
                object.player_scores = [];
                for (var j = 0; j < message.player_scores.length; ++j)
                    object.player_scores[j] = $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.toObject(message.player_scores[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerStandingsResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerStandingsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerStandingsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore = (function() {
    
            /**
             * Properties of a CMsgPlayerScore.
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse
             * @interface ICMsgPlayerScore
             * @property {number|null} [player_account_id] CMsgPlayerScore player_account_id
             * @property {string|null} [player_name] CMsgPlayerScore player_name
             * @property {number|null} [score] CMsgPlayerScore score
             */
    
            /**
             * Constructs a new CMsgPlayerScore.
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse
             * @classdesc Represents a CMsgPlayerScore.
             * @implements ICMsgPlayerScore
             * @constructor
             * @param {CMsgDOTAFantasyPlayerStandingsResponse.ICMsgPlayerScore=} [properties] Properties to set
             */
            function CMsgPlayerScore(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CMsgPlayerScore player_account_id.
             * @member {number} player_account_id
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @instance
             */
            CMsgPlayerScore.prototype.player_account_id = 0;
    
            /**
             * CMsgPlayerScore player_name.
             * @member {string} player_name
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @instance
             */
            CMsgPlayerScore.prototype.player_name = "";
    
            /**
             * CMsgPlayerScore score.
             * @member {number} score
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @instance
             */
            CMsgPlayerScore.prototype.score = 0;
    
            /**
             * Creates a new CMsgPlayerScore instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyPlayerStandingsResponse.ICMsgPlayerScore=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore} CMsgPlayerScore instance
             */
            CMsgPlayerScore.create = function create(properties) {
                return new CMsgPlayerScore(properties);
            };
    
            /**
             * Encodes the specified CMsgPlayerScore message. Does not implicitly {@link CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyPlayerStandingsResponse.ICMsgPlayerScore} message CMsgPlayerScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CMsgPlayerScore.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.player_account_id != null && Object.hasOwnProperty.call(message, "player_account_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.player_account_id);
                if (message.player_name != null && Object.hasOwnProperty.call(message, "player_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.player_name);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.score);
                return writer;
            };
    
            /**
             * Encodes the specified CMsgPlayerScore message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyPlayerStandingsResponse.ICMsgPlayerScore} message CMsgPlayerScore message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CMsgPlayerScore.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CMsgPlayerScore message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore} CMsgPlayerScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CMsgPlayerScore.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.player_account_id = reader.uint32();
                        break;
                    case 2:
                        message.player_name = reader.string();
                        break;
                    case 3:
                        message.score = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CMsgPlayerScore message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore} CMsgPlayerScore
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CMsgPlayerScore.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CMsgPlayerScore message.
             * @function verify
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CMsgPlayerScore.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                    if (!$util.isInteger(message.player_account_id))
                        return "player_account_id: integer expected";
                if (message.player_name != null && message.hasOwnProperty("player_name"))
                    if (!$util.isString(message.player_name))
                        return "player_name: string expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                return null;
            };
    
            /**
             * Creates a CMsgPlayerScore message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore} CMsgPlayerScore
             */
            CMsgPlayerScore.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore)
                    return object;
                var message = new $root.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore();
                if (object.player_account_id != null)
                    message.player_account_id = object.player_account_id >>> 0;
                if (object.player_name != null)
                    message.player_name = String(object.player_name);
                if (object.score != null)
                    message.score = Number(object.score);
                return message;
            };
    
            /**
             * Creates a plain object from a CMsgPlayerScore message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @static
             * @param {CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore} message CMsgPlayerScore
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CMsgPlayerScore.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.player_account_id = 0;
                    object.player_name = "";
                    object.score = 0;
                }
                if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                    object.player_account_id = message.player_account_id;
                if (message.player_name != null && message.hasOwnProperty("player_name"))
                    object.player_name = message.player_name;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                return object;
            };
    
            /**
             * Converts this CMsgPlayerScore to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CMsgPlayerScore.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CMsgPlayerScore;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyPlayerStandingsResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyPlayerStandingsResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyPlayerStandingsResponse;
    })();
    
    $root.CMsgDOTAFantasyLeagueCreateRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueCreateRequest.
         * @exports ICMsgDOTAFantasyLeagueCreateRequest
         * @interface ICMsgDOTAFantasyLeagueCreateRequest
         * @property {number|null} [season_id] CMsgDOTAFantasyLeagueCreateRequest season_id
         * @property {string|null} [fantasy_league_name] CMsgDOTAFantasyLeagueCreateRequest fantasy_league_name
         * @property {string|null} [password] CMsgDOTAFantasyLeagueCreateRequest password
         * @property {string|null} [team_name] CMsgDOTAFantasyLeagueCreateRequest team_name
         * @property {number|Long|null} [logo] CMsgDOTAFantasyLeagueCreateRequest logo
         * @property {number|Long|null} [ticket_item_id] CMsgDOTAFantasyLeagueCreateRequest ticket_item_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueCreateRequest.
         * @exports CMsgDOTAFantasyLeagueCreateRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueCreateRequest.
         * @implements ICMsgDOTAFantasyLeagueCreateRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueCreateRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueCreateRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueCreateRequest season_id.
         * @member {number} season_id
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.season_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueCreateRequest fantasy_league_name.
         * @member {string} fantasy_league_name
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.fantasy_league_name = "";
    
        /**
         * CMsgDOTAFantasyLeagueCreateRequest password.
         * @member {string} password
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.password = "";
    
        /**
         * CMsgDOTAFantasyLeagueCreateRequest team_name.
         * @member {string} team_name
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.team_name = "";
    
        /**
         * CMsgDOTAFantasyLeagueCreateRequest logo.
         * @member {number|Long} logo
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyLeagueCreateRequest ticket_item_id.
         * @member {number|Long} ticket_item_id
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.ticket_item_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueCreateRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueCreateRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueCreateRequest} CMsgDOTAFantasyLeagueCreateRequest instance
         */
        CMsgDOTAFantasyLeagueCreateRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueCreateRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueCreateRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueCreateRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueCreateRequest} message CMsgDOTAFantasyLeagueCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueCreateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.season_id != null && Object.hasOwnProperty.call(message, "season_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.season_id);
            if (message.fantasy_league_name != null && Object.hasOwnProperty.call(message, "fantasy_league_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fantasy_league_name);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
            if (message.team_name != null && Object.hasOwnProperty.call(message, "team_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.team_name);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.logo);
            if (message.ticket_item_id != null && Object.hasOwnProperty.call(message, "ticket_item_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.ticket_item_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueCreateRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueCreateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueCreateRequest} message CMsgDOTAFantasyLeagueCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueCreateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueCreateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueCreateRequest} CMsgDOTAFantasyLeagueCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueCreateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueCreateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.season_id = reader.uint32();
                    break;
                case 2:
                    message.fantasy_league_name = reader.string();
                    break;
                case 3:
                    message.password = reader.string();
                    break;
                case 4:
                    message.team_name = reader.string();
                    break;
                case 5:
                    message.logo = reader.uint64();
                    break;
                case 6:
                    message.ticket_item_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueCreateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueCreateRequest} CMsgDOTAFantasyLeagueCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueCreateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueCreateRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueCreateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.season_id != null && message.hasOwnProperty("season_id"))
                if (!$util.isInteger(message.season_id))
                    return "season_id: integer expected";
            if (message.fantasy_league_name != null && message.hasOwnProperty("fantasy_league_name"))
                if (!$util.isString(message.fantasy_league_name))
                    return "fantasy_league_name: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                if (!$util.isString(message.team_name))
                    return "team_name: string expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo) && !(message.logo && $util.isInteger(message.logo.low) && $util.isInteger(message.logo.high)))
                    return "logo: integer|Long expected";
            if (message.ticket_item_id != null && message.hasOwnProperty("ticket_item_id"))
                if (!$util.isInteger(message.ticket_item_id) && !(message.ticket_item_id && $util.isInteger(message.ticket_item_id.low) && $util.isInteger(message.ticket_item_id.high)))
                    return "ticket_item_id: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueCreateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueCreateRequest} CMsgDOTAFantasyLeagueCreateRequest
         */
        CMsgDOTAFantasyLeagueCreateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueCreateRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueCreateRequest();
            if (object.season_id != null)
                message.season_id = object.season_id >>> 0;
            if (object.fantasy_league_name != null)
                message.fantasy_league_name = String(object.fantasy_league_name);
            if (object.password != null)
                message.password = String(object.password);
            if (object.team_name != null)
                message.team_name = String(object.team_name);
            if (object.logo != null)
                if ($util.Long)
                    (message.logo = $util.Long.fromValue(object.logo)).unsigned = true;
                else if (typeof object.logo === "string")
                    message.logo = parseInt(object.logo, 10);
                else if (typeof object.logo === "number")
                    message.logo = object.logo;
                else if (typeof object.logo === "object")
                    message.logo = new $util.LongBits(object.logo.low >>> 0, object.logo.high >>> 0).toNumber(true);
            if (object.ticket_item_id != null)
                if ($util.Long)
                    (message.ticket_item_id = $util.Long.fromValue(object.ticket_item_id)).unsigned = true;
                else if (typeof object.ticket_item_id === "string")
                    message.ticket_item_id = parseInt(object.ticket_item_id, 10);
                else if (typeof object.ticket_item_id === "number")
                    message.ticket_item_id = object.ticket_item_id;
                else if (typeof object.ticket_item_id === "object")
                    message.ticket_item_id = new $util.LongBits(object.ticket_item_id.low >>> 0, object.ticket_item_id.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueCreateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueCreateRequest} message CMsgDOTAFantasyLeagueCreateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueCreateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.season_id = 0;
                object.fantasy_league_name = "";
                object.password = "";
                object.team_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.logo = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.ticket_item_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ticket_item_id = options.longs === String ? "0" : 0;
            }
            if (message.season_id != null && message.hasOwnProperty("season_id"))
                object.season_id = message.season_id;
            if (message.fantasy_league_name != null && message.hasOwnProperty("fantasy_league_name"))
                object.fantasy_league_name = message.fantasy_league_name;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                object.team_name = message.team_name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (typeof message.logo === "number")
                    object.logo = options.longs === String ? String(message.logo) : message.logo;
                else
                    object.logo = options.longs === String ? $util.Long.prototype.toString.call(message.logo) : options.longs === Number ? new $util.LongBits(message.logo.low >>> 0, message.logo.high >>> 0).toNumber(true) : message.logo;
            if (message.ticket_item_id != null && message.hasOwnProperty("ticket_item_id"))
                if (typeof message.ticket_item_id === "number")
                    object.ticket_item_id = options.longs === String ? String(message.ticket_item_id) : message.ticket_item_id;
                else
                    object.ticket_item_id = options.longs === String ? $util.Long.prototype.toString.call(message.ticket_item_id) : options.longs === Number ? new $util.LongBits(message.ticket_item_id.low >>> 0, message.ticket_item_id.high >>> 0).toNumber(true) : message.ticket_item_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueCreateRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueCreateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueCreateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueCreateRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueCreateResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueCreateResponse.
         * @exports ICMsgDOTAFantasyLeagueCreateResponse
         * @interface ICMsgDOTAFantasyLeagueCreateResponse
         * @property {CMsgDOTAFantasyLeagueCreateResponse.EResult|null} [result] CMsgDOTAFantasyLeagueCreateResponse result
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueCreateResponse fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueCreateResponse.
         * @exports CMsgDOTAFantasyLeagueCreateResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueCreateResponse.
         * @implements ICMsgDOTAFantasyLeagueCreateResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueCreateResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueCreateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueCreateResponse result.
         * @member {CMsgDOTAFantasyLeagueCreateResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyLeagueCreateResponse fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueCreateResponse.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueCreateResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueCreateResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueCreateResponse} CMsgDOTAFantasyLeagueCreateResponse instance
         */
        CMsgDOTAFantasyLeagueCreateResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueCreateResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueCreateResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueCreateResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueCreateResponse} message CMsgDOTAFantasyLeagueCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueCreateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueCreateResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueCreateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueCreateResponse} message CMsgDOTAFantasyLeagueCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueCreateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueCreateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueCreateResponse} CMsgDOTAFantasyLeagueCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueCreateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueCreateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueCreateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueCreateResponse} CMsgDOTAFantasyLeagueCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueCreateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueCreateResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueCreateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueCreateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueCreateResponse} CMsgDOTAFantasyLeagueCreateResponse
         */
        CMsgDOTAFantasyLeagueCreateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueCreateResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueCreateResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_NO_PERMISSION":
            case 1:
                message.result = 1;
                break;
            case "ERROR_BAD_SEASON_ID":
            case 2:
                message.result = 2;
                break;
            case "ERROR_BAD_LEAGUE_NAME":
            case 3:
                message.result = 3;
                break;
            case "ERROR_BAD_TEAM_NAME":
            case 4:
                message.result = 4;
                break;
            case "ERROR_UNSPECIFIED":
            case 5:
                message.result = 5;
                break;
            case "ERROR_FAILED_LOGO_UPLOAD":
            case 6:
                message.result = 6;
                break;
            case "ERROR_NO_TICKET":
            case 7:
                message.result = 7;
                break;
            }
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueCreateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueCreateResponse} message CMsgDOTAFantasyLeagueCreateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueCreateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_league_id = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueCreateResponse.EResult[message.result] : message.result;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueCreateResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueCreateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueCreateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueCreateResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_NO_PERMISSION=1 ERROR_NO_PERMISSION value
         * @property {number} ERROR_BAD_SEASON_ID=2 ERROR_BAD_SEASON_ID value
         * @property {number} ERROR_BAD_LEAGUE_NAME=3 ERROR_BAD_LEAGUE_NAME value
         * @property {number} ERROR_BAD_TEAM_NAME=4 ERROR_BAD_TEAM_NAME value
         * @property {number} ERROR_UNSPECIFIED=5 ERROR_UNSPECIFIED value
         * @property {number} ERROR_FAILED_LOGO_UPLOAD=6 ERROR_FAILED_LOGO_UPLOAD value
         * @property {number} ERROR_NO_TICKET=7 ERROR_NO_TICKET value
         */
        CMsgDOTAFantasyLeagueCreateResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_NO_PERMISSION"] = 1;
            values[valuesById[2] = "ERROR_BAD_SEASON_ID"] = 2;
            values[valuesById[3] = "ERROR_BAD_LEAGUE_NAME"] = 3;
            values[valuesById[4] = "ERROR_BAD_TEAM_NAME"] = 4;
            values[valuesById[5] = "ERROR_UNSPECIFIED"] = 5;
            values[valuesById[6] = "ERROR_FAILED_LOGO_UPLOAD"] = 6;
            values[valuesById[7] = "ERROR_NO_TICKET"] = 7;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueCreateResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamCreateRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamCreateRequest.
         * @exports ICMsgDOTAFantasyTeamCreateRequest
         * @interface ICMsgDOTAFantasyTeamCreateRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamCreateRequest fantasy_league_id
         * @property {string|null} [password] CMsgDOTAFantasyTeamCreateRequest password
         * @property {string|null} [team_name] CMsgDOTAFantasyTeamCreateRequest team_name
         * @property {number|Long|null} [logo] CMsgDOTAFantasyTeamCreateRequest logo
         * @property {number|Long|null} [ticket_item_id] CMsgDOTAFantasyTeamCreateRequest ticket_item_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamCreateRequest.
         * @exports CMsgDOTAFantasyTeamCreateRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamCreateRequest.
         * @implements ICMsgDOTAFantasyTeamCreateRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamCreateRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamCreateRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamCreateRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @instance
         */
        CMsgDOTAFantasyTeamCreateRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamCreateRequest password.
         * @member {string} password
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @instance
         */
        CMsgDOTAFantasyTeamCreateRequest.prototype.password = "";
    
        /**
         * CMsgDOTAFantasyTeamCreateRequest team_name.
         * @member {string} team_name
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @instance
         */
        CMsgDOTAFantasyTeamCreateRequest.prototype.team_name = "";
    
        /**
         * CMsgDOTAFantasyTeamCreateRequest logo.
         * @member {number|Long} logo
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @instance
         */
        CMsgDOTAFantasyTeamCreateRequest.prototype.logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAFantasyTeamCreateRequest ticket_item_id.
         * @member {number|Long} ticket_item_id
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @instance
         */
        CMsgDOTAFantasyTeamCreateRequest.prototype.ticket_item_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamCreateRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamCreateRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamCreateRequest} CMsgDOTAFantasyTeamCreateRequest instance
         */
        CMsgDOTAFantasyTeamCreateRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamCreateRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamCreateRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamCreateRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamCreateRequest} message CMsgDOTAFantasyTeamCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamCreateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            if (message.team_name != null && Object.hasOwnProperty.call(message, "team_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.team_name);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.logo);
            if (message.ticket_item_id != null && Object.hasOwnProperty.call(message, "ticket_item_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.ticket_item_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamCreateRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamCreateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamCreateRequest} message CMsgDOTAFantasyTeamCreateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamCreateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamCreateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamCreateRequest} CMsgDOTAFantasyTeamCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamCreateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamCreateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                case 3:
                    message.team_name = reader.string();
                    break;
                case 4:
                    message.logo = reader.uint64();
                    break;
                case 5:
                    message.ticket_item_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamCreateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamCreateRequest} CMsgDOTAFantasyTeamCreateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamCreateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamCreateRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamCreateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                if (!$util.isString(message.team_name))
                    return "team_name: string expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo) && !(message.logo && $util.isInteger(message.logo.low) && $util.isInteger(message.logo.high)))
                    return "logo: integer|Long expected";
            if (message.ticket_item_id != null && message.hasOwnProperty("ticket_item_id"))
                if (!$util.isInteger(message.ticket_item_id) && !(message.ticket_item_id && $util.isInteger(message.ticket_item_id.low) && $util.isInteger(message.ticket_item_id.high)))
                    return "ticket_item_id: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamCreateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamCreateRequest} CMsgDOTAFantasyTeamCreateRequest
         */
        CMsgDOTAFantasyTeamCreateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamCreateRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamCreateRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            if (object.team_name != null)
                message.team_name = String(object.team_name);
            if (object.logo != null)
                if ($util.Long)
                    (message.logo = $util.Long.fromValue(object.logo)).unsigned = true;
                else if (typeof object.logo === "string")
                    message.logo = parseInt(object.logo, 10);
                else if (typeof object.logo === "number")
                    message.logo = object.logo;
                else if (typeof object.logo === "object")
                    message.logo = new $util.LongBits(object.logo.low >>> 0, object.logo.high >>> 0).toNumber(true);
            if (object.ticket_item_id != null)
                if ($util.Long)
                    (message.ticket_item_id = $util.Long.fromValue(object.ticket_item_id)).unsigned = true;
                else if (typeof object.ticket_item_id === "string")
                    message.ticket_item_id = parseInt(object.ticket_item_id, 10);
                else if (typeof object.ticket_item_id === "number")
                    message.ticket_item_id = object.ticket_item_id;
                else if (typeof object.ticket_item_id === "object")
                    message.ticket_item_id = new $util.LongBits(object.ticket_item_id.low >>> 0, object.ticket_item_id.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamCreateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @static
         * @param {CMsgDOTAFantasyTeamCreateRequest} message CMsgDOTAFantasyTeamCreateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamCreateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.password = "";
                object.team_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.logo = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.ticket_item_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ticket_item_id = options.longs === String ? "0" : 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.team_name != null && message.hasOwnProperty("team_name"))
                object.team_name = message.team_name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (typeof message.logo === "number")
                    object.logo = options.longs === String ? String(message.logo) : message.logo;
                else
                    object.logo = options.longs === String ? $util.Long.prototype.toString.call(message.logo) : options.longs === Number ? new $util.LongBits(message.logo.low >>> 0, message.logo.high >>> 0).toNumber(true) : message.logo;
            if (message.ticket_item_id != null && message.hasOwnProperty("ticket_item_id"))
                if (typeof message.ticket_item_id === "number")
                    object.ticket_item_id = options.longs === String ? String(message.ticket_item_id) : message.ticket_item_id;
                else
                    object.ticket_item_id = options.longs === String ? $util.Long.prototype.toString.call(message.ticket_item_id) : options.longs === Number ? new $util.LongBits(message.ticket_item_id.low >>> 0, message.ticket_item_id.high >>> 0).toNumber(true) : message.ticket_item_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamCreateRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamCreateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamCreateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamCreateRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamCreateResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamCreateResponse.
         * @exports ICMsgDOTAFantasyTeamCreateResponse
         * @interface ICMsgDOTAFantasyTeamCreateResponse
         * @property {CMsgDOTAFantasyTeamCreateResponse.EResult|null} [result] CMsgDOTAFantasyTeamCreateResponse result
         * @property {number|null} [fantasy_team_index] CMsgDOTAFantasyTeamCreateResponse fantasy_team_index
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamCreateResponse.
         * @exports CMsgDOTAFantasyTeamCreateResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamCreateResponse.
         * @implements ICMsgDOTAFantasyTeamCreateResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamCreateResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamCreateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamCreateResponse result.
         * @member {CMsgDOTAFantasyTeamCreateResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @instance
         */
        CMsgDOTAFantasyTeamCreateResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyTeamCreateResponse fantasy_team_index.
         * @member {number} fantasy_team_index
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @instance
         */
        CMsgDOTAFantasyTeamCreateResponse.prototype.fantasy_team_index = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamCreateResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamCreateResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamCreateResponse} CMsgDOTAFantasyTeamCreateResponse instance
         */
        CMsgDOTAFantasyTeamCreateResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamCreateResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamCreateResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamCreateResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamCreateResponse} message CMsgDOTAFantasyTeamCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamCreateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fantasy_team_index != null && Object.hasOwnProperty.call(message, "fantasy_team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fantasy_team_index);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamCreateResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamCreateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamCreateResponse} message CMsgDOTAFantasyTeamCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamCreateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamCreateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamCreateResponse} CMsgDOTAFantasyTeamCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamCreateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamCreateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fantasy_team_index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamCreateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamCreateResponse} CMsgDOTAFantasyTeamCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamCreateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamCreateResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamCreateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                if (!$util.isInteger(message.fantasy_team_index))
                    return "fantasy_team_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamCreateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamCreateResponse} CMsgDOTAFantasyTeamCreateResponse
         */
        CMsgDOTAFantasyTeamCreateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamCreateResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamCreateResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_NO_PERMISSION":
            case 1:
                message.result = 1;
                break;
            case "ERROR_FAILED_LOGO_UPLOAD":
            case 2:
                message.result = 2;
                break;
            case "ERROR_BAD_FANTASY_LEAGUE_ID":
            case 3:
                message.result = 3;
                break;
            case "ERROR_BAD_NAME":
            case 4:
                message.result = 4;
                break;
            case "ERROR_FULL":
            case 5:
                message.result = 5;
                break;
            case "ERROR_ALREADY_MEMBER":
            case 6:
                message.result = 6;
                break;
            case "ERROR_BAD_PASSWORD":
            case 7:
                message.result = 7;
                break;
            case "ERROR_UNSPECIFIED":
            case 8:
                message.result = 8;
                break;
            case "ERROR_NO_TICKET":
            case 9:
                message.result = 9;
                break;
            case "ERROR_LEAGUE_LOCKED":
            case 10:
                message.result = 10;
                break;
            }
            if (object.fantasy_team_index != null)
                message.fantasy_team_index = object.fantasy_team_index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamCreateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @static
         * @param {CMsgDOTAFantasyTeamCreateResponse} message CMsgDOTAFantasyTeamCreateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamCreateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.fantasy_team_index = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamCreateResponse.EResult[message.result] : message.result;
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                object.fantasy_team_index = message.fantasy_team_index;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamCreateResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamCreateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamCreateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamCreateResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_NO_PERMISSION=1 ERROR_NO_PERMISSION value
         * @property {number} ERROR_FAILED_LOGO_UPLOAD=2 ERROR_FAILED_LOGO_UPLOAD value
         * @property {number} ERROR_BAD_FANTASY_LEAGUE_ID=3 ERROR_BAD_FANTASY_LEAGUE_ID value
         * @property {number} ERROR_BAD_NAME=4 ERROR_BAD_NAME value
         * @property {number} ERROR_FULL=5 ERROR_FULL value
         * @property {number} ERROR_ALREADY_MEMBER=6 ERROR_ALREADY_MEMBER value
         * @property {number} ERROR_BAD_PASSWORD=7 ERROR_BAD_PASSWORD value
         * @property {number} ERROR_UNSPECIFIED=8 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_TICKET=9 ERROR_NO_TICKET value
         * @property {number} ERROR_LEAGUE_LOCKED=10 ERROR_LEAGUE_LOCKED value
         */
        CMsgDOTAFantasyTeamCreateResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_NO_PERMISSION"] = 1;
            values[valuesById[2] = "ERROR_FAILED_LOGO_UPLOAD"] = 2;
            values[valuesById[3] = "ERROR_BAD_FANTASY_LEAGUE_ID"] = 3;
            values[valuesById[4] = "ERROR_BAD_NAME"] = 4;
            values[valuesById[5] = "ERROR_FULL"] = 5;
            values[valuesById[6] = "ERROR_ALREADY_MEMBER"] = 6;
            values[valuesById[7] = "ERROR_BAD_PASSWORD"] = 7;
            values[valuesById[8] = "ERROR_UNSPECIFIED"] = 8;
            values[valuesById[9] = "ERROR_NO_TICKET"] = 9;
            values[valuesById[10] = "ERROR_LEAGUE_LOCKED"] = 10;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamCreateResponse;
    })();
    
    $root.CMsgDOTAFantasyLeagueEditInvitesRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueEditInvitesRequest.
         * @exports ICMsgDOTAFantasyLeagueEditInvitesRequest
         * @interface ICMsgDOTAFantasyLeagueEditInvitesRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueEditInvitesRequest fantasy_league_id
         * @property {string|null} [password] CMsgDOTAFantasyLeagueEditInvitesRequest password
         * @property {Array.<CMsgDOTAFantasyLeagueEditInvitesRequest.IInviteChange>|null} [invite_change] CMsgDOTAFantasyLeagueEditInvitesRequest invite_change
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueEditInvitesRequest.
         * @exports CMsgDOTAFantasyLeagueEditInvitesRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueEditInvitesRequest.
         * @implements ICMsgDOTAFantasyLeagueEditInvitesRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueEditInvitesRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueEditInvitesRequest(properties) {
            this.invite_change = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueEditInvitesRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueEditInvitesRequest password.
         * @member {string} password
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.prototype.password = "";
    
        /**
         * CMsgDOTAFantasyLeagueEditInvitesRequest invite_change.
         * @member {Array.<CMsgDOTAFantasyLeagueEditInvitesRequest.IInviteChange>} invite_change
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.prototype.invite_change = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueEditInvitesRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInvitesRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest} CMsgDOTAFantasyLeagueEditInvitesRequest instance
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueEditInvitesRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInvitesRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInvitesRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInvitesRequest} message CMsgDOTAFantasyLeagueEditInvitesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            if (message.invite_change != null && message.invite_change.length)
                for (var i = 0; i < message.invite_change.length; ++i)
                    $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.encode(message.invite_change[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInvitesRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInvitesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInvitesRequest} message CMsgDOTAFantasyLeagueEditInvitesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInvitesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest} CMsgDOTAFantasyLeagueEditInvitesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueEditInvitesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                case 3:
                    if (!(message.invite_change && message.invite_change.length))
                        message.invite_change = [];
                    message.invite_change.push($root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInvitesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest} CMsgDOTAFantasyLeagueEditInvitesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueEditInvitesRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.invite_change != null && message.hasOwnProperty("invite_change")) {
                if (!Array.isArray(message.invite_change))
                    return "invite_change: array expected";
                for (var i = 0; i < message.invite_change.length; ++i) {
                    var error = $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.verify(message.invite_change[i]);
                    if (error)
                        return "invite_change." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueEditInvitesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest} CMsgDOTAFantasyLeagueEditInvitesRequest
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueEditInvitesRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueEditInvitesRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            if (object.invite_change) {
                if (!Array.isArray(object.invite_change))
                    throw TypeError(".CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change: array expected");
                message.invite_change = [];
                for (var i = 0; i < object.invite_change.length; ++i) {
                    if (typeof object.invite_change[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change: object expected");
                    message.invite_change[i] = $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.fromObject(object.invite_change[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueEditInvitesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueEditInvitesRequest} message CMsgDOTAFantasyLeagueEditInvitesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.invite_change = [];
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.password = "";
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.invite_change && message.invite_change.length) {
                object.invite_change = [];
                for (var j = 0; j < message.invite_change.length; ++j)
                    object.invite_change[j] = $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.toObject(message.invite_change[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueEditInvitesRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueEditInvitesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange = (function() {
    
            /**
             * Properties of an InviteChange.
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
             * @interface IInviteChange
             * @property {number|null} [account_id] InviteChange account_id
             * @property {boolean|null} [invited] InviteChange invited
             */
    
            /**
             * Constructs a new InviteChange.
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest
             * @classdesc Represents an InviteChange.
             * @implements IInviteChange
             * @constructor
             * @param {CMsgDOTAFantasyLeagueEditInvitesRequest.IInviteChange=} [properties] Properties to set
             */
            function InviteChange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * InviteChange account_id.
             * @member {number} account_id
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @instance
             */
            InviteChange.prototype.account_id = 0;
    
            /**
             * InviteChange invited.
             * @member {boolean} invited
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @instance
             */
            InviteChange.prototype.invited = false;
    
            /**
             * Creates a new InviteChange instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {CMsgDOTAFantasyLeagueEditInvitesRequest.IInviteChange=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange} InviteChange instance
             */
            InviteChange.create = function create(properties) {
                return new InviteChange(properties);
            };
    
            /**
             * Encodes the specified InviteChange message. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {CMsgDOTAFantasyLeagueEditInvitesRequest.IInviteChange} message InviteChange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InviteChange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.account_id);
                if (message.invited != null && Object.hasOwnProperty.call(message, "invited"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.invited);
                return writer;
            };
    
            /**
             * Encodes the specified InviteChange message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {CMsgDOTAFantasyLeagueEditInvitesRequest.IInviteChange} message InviteChange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InviteChange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an InviteChange message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange} InviteChange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InviteChange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.account_id = reader.uint32();
                        break;
                    case 2:
                        message.invited = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an InviteChange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange} InviteChange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InviteChange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an InviteChange message.
             * @function verify
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InviteChange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account_id != null && message.hasOwnProperty("account_id"))
                    if (!$util.isInteger(message.account_id))
                        return "account_id: integer expected";
                if (message.invited != null && message.hasOwnProperty("invited"))
                    if (typeof message.invited !== "boolean")
                        return "invited: boolean expected";
                return null;
            };
    
            /**
             * Creates an InviteChange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange} InviteChange
             */
            InviteChange.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange)
                    return object;
                var message = new $root.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange();
                if (object.account_id != null)
                    message.account_id = object.account_id >>> 0;
                if (object.invited != null)
                    message.invited = Boolean(object.invited);
                return message;
            };
    
            /**
             * Creates a plain object from an InviteChange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @static
             * @param {CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange} message InviteChange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InviteChange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.account_id = 0;
                    object.invited = false;
                }
                if (message.account_id != null && message.hasOwnProperty("account_id"))
                    object.account_id = message.account_id;
                if (message.invited != null && message.hasOwnProperty("invited"))
                    object.invited = message.invited;
                return object;
            };
    
            /**
             * Converts this InviteChange to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InviteChange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return InviteChange;
        })();
    
        return CMsgDOTAFantasyLeagueEditInvitesRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueEditInvitesResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueEditInvitesResponse.
         * @exports ICMsgDOTAFantasyLeagueEditInvitesResponse
         * @interface ICMsgDOTAFantasyLeagueEditInvitesResponse
         * @property {CMsgDOTAFantasyLeagueEditInvitesResponse.EResult|null} [result] CMsgDOTAFantasyLeagueEditInvitesResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueEditInvitesResponse.
         * @exports CMsgDOTAFantasyLeagueEditInvitesResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueEditInvitesResponse.
         * @implements ICMsgDOTAFantasyLeagueEditInvitesResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueEditInvitesResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueEditInvitesResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueEditInvitesResponse result.
         * @member {CMsgDOTAFantasyLeagueEditInvitesResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueEditInvitesResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInvitesResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueEditInvitesResponse} CMsgDOTAFantasyLeagueEditInvitesResponse instance
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueEditInvitesResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInvitesResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInvitesResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInvitesResponse} message CMsgDOTAFantasyLeagueEditInvitesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueEditInvitesResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueEditInvitesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueEditInvitesResponse} message CMsgDOTAFantasyLeagueEditInvitesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInvitesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueEditInvitesResponse} CMsgDOTAFantasyLeagueEditInvitesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueEditInvitesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueEditInvitesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueEditInvitesResponse} CMsgDOTAFantasyLeagueEditInvitesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueEditInvitesResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueEditInvitesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueEditInvitesResponse} CMsgDOTAFantasyLeagueEditInvitesResponse
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueEditInvitesResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueEditInvitesResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueEditInvitesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueEditInvitesResponse} message CMsgDOTAFantasyLeagueEditInvitesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueEditInvitesResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueEditInvitesResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueEditInvitesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueEditInvitesResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         */
        CMsgDOTAFantasyLeagueEditInvitesResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueEditInvitesResponse;
    })();
    
    $root.CMsgDOTAFantasyLeagueDraftStatusRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueDraftStatusRequest.
         * @exports ICMsgDOTAFantasyLeagueDraftStatusRequest
         * @interface ICMsgDOTAFantasyLeagueDraftStatusRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueDraftStatusRequest fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueDraftStatusRequest.
         * @exports CMsgDOTAFantasyLeagueDraftStatusRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueDraftStatusRequest.
         * @implements ICMsgDOTAFantasyLeagueDraftStatusRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueDraftStatusRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueDraftStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatusRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueDraftStatusRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftStatusRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueDraftStatusRequest} CMsgDOTAFantasyLeagueDraftStatusRequest instance
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueDraftStatusRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftStatusRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftStatusRequest} message CMsgDOTAFantasyLeagueDraftStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftStatusRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftStatusRequest} message CMsgDOTAFantasyLeagueDraftStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueDraftStatusRequest} CMsgDOTAFantasyLeagueDraftStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueDraftStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueDraftStatusRequest} CMsgDOTAFantasyLeagueDraftStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueDraftStatusRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueDraftStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueDraftStatusRequest} CMsgDOTAFantasyLeagueDraftStatusRequest
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueDraftStatusRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueDraftStatusRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueDraftStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueDraftStatusRequest} message CMsgDOTAFantasyLeagueDraftStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueDraftStatusRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueDraftStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueDraftStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueDraftStatusRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueDraftStatus = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueDraftStatus.
         * @exports ICMsgDOTAFantasyLeagueDraftStatus
         * @interface ICMsgDOTAFantasyLeagueDraftStatus
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueDraftStatus fantasy_league_id
         * @property {Array.<number>|null} [draft_order] CMsgDOTAFantasyLeagueDraftStatus draft_order
         * @property {number|null} [current_pick] CMsgDOTAFantasyLeagueDraftStatus current_pick
         * @property {number|null} [time_remaining] CMsgDOTAFantasyLeagueDraftStatus time_remaining
         * @property {boolean|null} [pending_resume] CMsgDOTAFantasyLeagueDraftStatus pending_resume
         * @property {boolean|null} [completed] CMsgDOTAFantasyLeagueDraftStatus completed
         * @property {Array.<number>|null} [available_players] CMsgDOTAFantasyLeagueDraftStatus available_players
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueDraftStatus.
         * @exports CMsgDOTAFantasyLeagueDraftStatus
         * @classdesc Represents a CMsgDOTAFantasyLeagueDraftStatus.
         * @implements ICMsgDOTAFantasyLeagueDraftStatus
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueDraftStatus=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueDraftStatus(properties) {
            this.draft_order = [];
            this.available_players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus draft_order.
         * @member {Array.<number>} draft_order
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.draft_order = $util.emptyArray;
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus current_pick.
         * @member {number} current_pick
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.current_pick = 0;
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus time_remaining.
         * @member {number} time_remaining
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.time_remaining = 0;
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus pending_resume.
         * @member {boolean} pending_resume
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.pending_resume = false;
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus completed.
         * @member {boolean} completed
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.completed = false;
    
        /**
         * CMsgDOTAFantasyLeagueDraftStatus available_players.
         * @member {Array.<number>} available_players
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.available_players = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueDraftStatus instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftStatus=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueDraftStatus} CMsgDOTAFantasyLeagueDraftStatus instance
         */
        CMsgDOTAFantasyLeagueDraftStatus.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueDraftStatus(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftStatus message. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftStatus.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftStatus} message CMsgDOTAFantasyLeagueDraftStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.draft_order != null && message.draft_order.length)
                for (var i = 0; i < message.draft_order.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.draft_order[i]);
            if (message.current_pick != null && Object.hasOwnProperty.call(message, "current_pick"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.current_pick);
            if (message.time_remaining != null && Object.hasOwnProperty.call(message, "time_remaining"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.time_remaining);
            if (message.pending_resume != null && Object.hasOwnProperty.call(message, "pending_resume"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.pending_resume);
            if (message.completed != null && Object.hasOwnProperty.call(message, "completed"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.completed);
            if (message.available_players != null && message.available_players.length)
                for (var i = 0; i < message.available_players.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.available_players[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftStatus message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftStatus} message CMsgDOTAFantasyLeagueDraftStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueDraftStatus} CMsgDOTAFantasyLeagueDraftStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueDraftStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    if (!(message.draft_order && message.draft_order.length))
                        message.draft_order = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.draft_order.push(reader.uint32());
                    } else
                        message.draft_order.push(reader.uint32());
                    break;
                case 3:
                    message.current_pick = reader.uint32();
                    break;
                case 4:
                    message.time_remaining = reader.uint32();
                    break;
                case 5:
                    message.pending_resume = reader.bool();
                    break;
                case 6:
                    message.completed = reader.bool();
                    break;
                case 7:
                    if (!(message.available_players && message.available_players.length))
                        message.available_players = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.available_players.push(reader.uint32());
                    } else
                        message.available_players.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueDraftStatus} CMsgDOTAFantasyLeagueDraftStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueDraftStatus message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueDraftStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.draft_order != null && message.hasOwnProperty("draft_order")) {
                if (!Array.isArray(message.draft_order))
                    return "draft_order: array expected";
                for (var i = 0; i < message.draft_order.length; ++i)
                    if (!$util.isInteger(message.draft_order[i]))
                        return "draft_order: integer[] expected";
            }
            if (message.current_pick != null && message.hasOwnProperty("current_pick"))
                if (!$util.isInteger(message.current_pick))
                    return "current_pick: integer expected";
            if (message.time_remaining != null && message.hasOwnProperty("time_remaining"))
                if (!$util.isInteger(message.time_remaining))
                    return "time_remaining: integer expected";
            if (message.pending_resume != null && message.hasOwnProperty("pending_resume"))
                if (typeof message.pending_resume !== "boolean")
                    return "pending_resume: boolean expected";
            if (message.completed != null && message.hasOwnProperty("completed"))
                if (typeof message.completed !== "boolean")
                    return "completed: boolean expected";
            if (message.available_players != null && message.hasOwnProperty("available_players")) {
                if (!Array.isArray(message.available_players))
                    return "available_players: array expected";
                for (var i = 0; i < message.available_players.length; ++i)
                    if (!$util.isInteger(message.available_players[i]))
                        return "available_players: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueDraftStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueDraftStatus} CMsgDOTAFantasyLeagueDraftStatus
         */
        CMsgDOTAFantasyLeagueDraftStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueDraftStatus)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueDraftStatus();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.draft_order) {
                if (!Array.isArray(object.draft_order))
                    throw TypeError(".CMsgDOTAFantasyLeagueDraftStatus.draft_order: array expected");
                message.draft_order = [];
                for (var i = 0; i < object.draft_order.length; ++i)
                    message.draft_order[i] = object.draft_order[i] >>> 0;
            }
            if (object.current_pick != null)
                message.current_pick = object.current_pick >>> 0;
            if (object.time_remaining != null)
                message.time_remaining = object.time_remaining >>> 0;
            if (object.pending_resume != null)
                message.pending_resume = Boolean(object.pending_resume);
            if (object.completed != null)
                message.completed = Boolean(object.completed);
            if (object.available_players) {
                if (!Array.isArray(object.available_players))
                    throw TypeError(".CMsgDOTAFantasyLeagueDraftStatus.available_players: array expected");
                message.available_players = [];
                for (var i = 0; i < object.available_players.length; ++i)
                    message.available_players[i] = object.available_players[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueDraftStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @static
         * @param {CMsgDOTAFantasyLeagueDraftStatus} message CMsgDOTAFantasyLeagueDraftStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueDraftStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.draft_order = [];
                object.available_players = [];
            }
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.current_pick = 0;
                object.time_remaining = 0;
                object.pending_resume = false;
                object.completed = false;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.draft_order && message.draft_order.length) {
                object.draft_order = [];
                for (var j = 0; j < message.draft_order.length; ++j)
                    object.draft_order[j] = message.draft_order[j];
            }
            if (message.current_pick != null && message.hasOwnProperty("current_pick"))
                object.current_pick = message.current_pick;
            if (message.time_remaining != null && message.hasOwnProperty("time_remaining"))
                object.time_remaining = message.time_remaining;
            if (message.pending_resume != null && message.hasOwnProperty("pending_resume"))
                object.pending_resume = message.pending_resume;
            if (message.completed != null && message.hasOwnProperty("completed"))
                object.completed = message.completed;
            if (message.available_players && message.available_players.length) {
                object.available_players = [];
                for (var j = 0; j < message.available_players.length; ++j)
                    object.available_players[j] = message.available_players[j];
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueDraftStatus to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueDraftStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueDraftStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueDraftStatus;
    })();
    
    $root.CMsgDOTAFantasyLeagueDraftPlayerRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueDraftPlayerRequest.
         * @exports ICMsgDOTAFantasyLeagueDraftPlayerRequest
         * @interface ICMsgDOTAFantasyLeagueDraftPlayerRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeagueDraftPlayerRequest fantasy_league_id
         * @property {number|null} [team_index] CMsgDOTAFantasyLeagueDraftPlayerRequest team_index
         * @property {number|null} [player_account_id] CMsgDOTAFantasyLeagueDraftPlayerRequest player_account_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueDraftPlayerRequest.
         * @exports CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @classdesc Represents a CMsgDOTAFantasyLeagueDraftPlayerRequest.
         * @implements ICMsgDOTAFantasyLeagueDraftPlayerRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueDraftPlayerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueDraftPlayerRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeagueDraftPlayerRequest team_index.
         * @member {number} team_index
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.prototype.team_index = 0;
    
        /**
         * CMsgDOTAFantasyLeagueDraftPlayerRequest player_account_id.
         * @member {number} player_account_id
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.prototype.player_account_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueDraftPlayerRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerRequest} CMsgDOTAFantasyLeagueDraftPlayerRequest instance
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueDraftPlayerRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftPlayerRequest message. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftPlayerRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerRequest} message CMsgDOTAFantasyLeagueDraftPlayerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.team_index != null && Object.hasOwnProperty.call(message, "team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_index);
            if (message.player_account_id != null && Object.hasOwnProperty.call(message, "player_account_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.player_account_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftPlayerRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftPlayerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerRequest} message CMsgDOTAFantasyLeagueDraftPlayerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftPlayerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerRequest} CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueDraftPlayerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.team_index = reader.uint32();
                    break;
                case 3:
                    message.player_account_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftPlayerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerRequest} CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueDraftPlayerRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                if (!$util.isInteger(message.team_index))
                    return "team_index: integer expected";
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                if (!$util.isInteger(message.player_account_id))
                    return "player_account_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueDraftPlayerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerRequest} CMsgDOTAFantasyLeagueDraftPlayerRequest
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueDraftPlayerRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueDraftPlayerRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.team_index != null)
                message.team_index = object.team_index >>> 0;
            if (object.player_account_id != null)
                message.player_account_id = object.player_account_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueDraftPlayerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @static
         * @param {CMsgDOTAFantasyLeagueDraftPlayerRequest} message CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.team_index = 0;
                object.player_account_id = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                object.team_index = message.team_index;
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                object.player_account_id = message.player_account_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueDraftPlayerRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueDraftPlayerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeagueDraftPlayerRequest;
    })();
    
    $root.CMsgDOTAFantasyLeagueDraftPlayerResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeagueDraftPlayerResponse.
         * @exports ICMsgDOTAFantasyLeagueDraftPlayerResponse
         * @interface ICMsgDOTAFantasyLeagueDraftPlayerResponse
         * @property {CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult|null} [result] CMsgDOTAFantasyLeagueDraftPlayerResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeagueDraftPlayerResponse.
         * @exports CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @classdesc Represents a CMsgDOTAFantasyLeagueDraftPlayerResponse.
         * @implements ICMsgDOTAFantasyLeagueDraftPlayerResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeagueDraftPlayerResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeagueDraftPlayerResponse result.
         * @member {CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @instance
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeagueDraftPlayerResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerResponse} CMsgDOTAFantasyLeagueDraftPlayerResponse instance
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeagueDraftPlayerResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftPlayerResponse message. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftPlayerResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerResponse} message CMsgDOTAFantasyLeagueDraftPlayerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeagueDraftPlayerResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeagueDraftPlayerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {ICMsgDOTAFantasyLeagueDraftPlayerResponse} message CMsgDOTAFantasyLeagueDraftPlayerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftPlayerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerResponse} CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeagueDraftPlayerResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeagueDraftPlayerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerResponse} CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeagueDraftPlayerResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeagueDraftPlayerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeagueDraftPlayerResponse} CMsgDOTAFantasyLeagueDraftPlayerResponse
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeagueDraftPlayerResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeagueDraftPlayerResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_INVALID_FANTASY_LEAGUE":
            case 2:
                message.result = 2;
                break;
            case "ERROR_FANTASY_LEAGUE_NOT_DRAFTING":
            case 3:
                message.result = 3;
                break;
            case "ERROR_OWNER_NOT_IN_LEAGUE":
            case 4:
                message.result = 4;
                break;
            case "ERROR_NOT_OWNERS_TURN":
            case 5:
                message.result = 5;
                break;
            case "ERROR_PLAYER_INVALID":
            case 6:
                message.result = 6;
                break;
            case "ERROR_PLAYER_UNAVAILABLE":
            case 7:
                message.result = 7;
                break;
            case "ERROR_PLAYER_NO_VALID_SLOTS":
            case 8:
                message.result = 8;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeagueDraftPlayerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @static
         * @param {CMsgDOTAFantasyLeagueDraftPlayerResponse} message CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeagueDraftPlayerResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeagueDraftPlayerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_INVALID_FANTASY_LEAGUE=2 ERROR_INVALID_FANTASY_LEAGUE value
         * @property {number} ERROR_FANTASY_LEAGUE_NOT_DRAFTING=3 ERROR_FANTASY_LEAGUE_NOT_DRAFTING value
         * @property {number} ERROR_OWNER_NOT_IN_LEAGUE=4 ERROR_OWNER_NOT_IN_LEAGUE value
         * @property {number} ERROR_NOT_OWNERS_TURN=5 ERROR_NOT_OWNERS_TURN value
         * @property {number} ERROR_PLAYER_INVALID=6 ERROR_PLAYER_INVALID value
         * @property {number} ERROR_PLAYER_UNAVAILABLE=7 ERROR_PLAYER_UNAVAILABLE value
         * @property {number} ERROR_PLAYER_NO_VALID_SLOTS=8 ERROR_PLAYER_NO_VALID_SLOTS value
         */
        CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_INVALID_FANTASY_LEAGUE"] = 2;
            values[valuesById[3] = "ERROR_FANTASY_LEAGUE_NOT_DRAFTING"] = 3;
            values[valuesById[4] = "ERROR_OWNER_NOT_IN_LEAGUE"] = 4;
            values[valuesById[5] = "ERROR_NOT_OWNERS_TURN"] = 5;
            values[valuesById[6] = "ERROR_PLAYER_INVALID"] = 6;
            values[valuesById[7] = "ERROR_PLAYER_UNAVAILABLE"] = 7;
            values[valuesById[8] = "ERROR_PLAYER_NO_VALID_SLOTS"] = 8;
            return values;
        })();
    
        return CMsgDOTAFantasyLeagueDraftPlayerResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamRosterSwapRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamRosterSwapRequest.
         * @exports ICMsgDOTAFantasyTeamRosterSwapRequest
         * @interface ICMsgDOTAFantasyTeamRosterSwapRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamRosterSwapRequest fantasy_league_id
         * @property {number|null} [team_index] CMsgDOTAFantasyTeamRosterSwapRequest team_index
         * @property {number|null} [timestamp] CMsgDOTAFantasyTeamRosterSwapRequest timestamp
         * @property {number|null} [slot_1] CMsgDOTAFantasyTeamRosterSwapRequest slot_1
         * @property {number|null} [slot_2] CMsgDOTAFantasyTeamRosterSwapRequest slot_2
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamRosterSwapRequest.
         * @exports CMsgDOTAFantasyTeamRosterSwapRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamRosterSwapRequest.
         * @implements ICMsgDOTAFantasyTeamRosterSwapRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamRosterSwapRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamRosterSwapRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamRosterSwapRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterSwapRequest team_index.
         * @member {number} team_index
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.prototype.team_index = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterSwapRequest timestamp.
         * @member {number} timestamp
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.prototype.timestamp = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterSwapRequest slot_1.
         * @member {number} slot_1
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.prototype.slot_1 = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterSwapRequest slot_2.
         * @member {number} slot_2
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.prototype.slot_2 = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamRosterSwapRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterSwapRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamRosterSwapRequest} CMsgDOTAFantasyTeamRosterSwapRequest instance
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamRosterSwapRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterSwapRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamRosterSwapRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterSwapRequest} message CMsgDOTAFantasyTeamRosterSwapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.team_index != null && Object.hasOwnProperty.call(message, "team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_index);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp);
            if (message.slot_1 != null && Object.hasOwnProperty.call(message, "slot_1"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.slot_1);
            if (message.slot_2 != null && Object.hasOwnProperty.call(message, "slot_2"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.slot_2);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterSwapRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamRosterSwapRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterSwapRequest} message CMsgDOTAFantasyTeamRosterSwapRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterSwapRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamRosterSwapRequest} CMsgDOTAFantasyTeamRosterSwapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamRosterSwapRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.team_index = reader.uint32();
                    break;
                case 3:
                    message.timestamp = reader.uint32();
                    break;
                case 4:
                    message.slot_1 = reader.uint32();
                    break;
                case 5:
                    message.slot_2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterSwapRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamRosterSwapRequest} CMsgDOTAFantasyTeamRosterSwapRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamRosterSwapRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                if (!$util.isInteger(message.team_index))
                    return "team_index: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.slot_1 != null && message.hasOwnProperty("slot_1"))
                if (!$util.isInteger(message.slot_1))
                    return "slot_1: integer expected";
            if (message.slot_2 != null && message.hasOwnProperty("slot_2"))
                if (!$util.isInteger(message.slot_2))
                    return "slot_2: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamRosterSwapRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamRosterSwapRequest} CMsgDOTAFantasyTeamRosterSwapRequest
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamRosterSwapRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamRosterSwapRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.team_index != null)
                message.team_index = object.team_index >>> 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.slot_1 != null)
                message.slot_1 = object.slot_1 >>> 0;
            if (object.slot_2 != null)
                message.slot_2 = object.slot_2 >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamRosterSwapRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @static
         * @param {CMsgDOTAFantasyTeamRosterSwapRequest} message CMsgDOTAFantasyTeamRosterSwapRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.team_index = 0;
                object.timestamp = 0;
                object.slot_1 = 0;
                object.slot_2 = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                object.team_index = message.team_index;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.slot_1 != null && message.hasOwnProperty("slot_1"))
                object.slot_1 = message.slot_1;
            if (message.slot_2 != null && message.hasOwnProperty("slot_2"))
                object.slot_2 = message.slot_2;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamRosterSwapRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamRosterSwapRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamRosterSwapRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamRosterSwapRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamRosterSwapResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamRosterSwapResponse.
         * @exports ICMsgDOTAFantasyTeamRosterSwapResponse
         * @interface ICMsgDOTAFantasyTeamRosterSwapResponse
         * @property {CMsgDOTAFantasyTeamRosterSwapResponse.EResult|null} [result] CMsgDOTAFantasyTeamRosterSwapResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamRosterSwapResponse.
         * @exports CMsgDOTAFantasyTeamRosterSwapResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamRosterSwapResponse.
         * @implements ICMsgDOTAFantasyTeamRosterSwapResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamRosterSwapResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamRosterSwapResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamRosterSwapResponse result.
         * @member {CMsgDOTAFantasyTeamRosterSwapResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @instance
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamRosterSwapResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterSwapResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamRosterSwapResponse} CMsgDOTAFantasyTeamRosterSwapResponse instance
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamRosterSwapResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterSwapResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamRosterSwapResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterSwapResponse} message CMsgDOTAFantasyTeamRosterSwapResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterSwapResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamRosterSwapResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterSwapResponse} message CMsgDOTAFantasyTeamRosterSwapResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterSwapResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamRosterSwapResponse} CMsgDOTAFantasyTeamRosterSwapResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamRosterSwapResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterSwapResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamRosterSwapResponse} CMsgDOTAFantasyTeamRosterSwapResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamRosterSwapResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamRosterSwapResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamRosterSwapResponse} CMsgDOTAFantasyTeamRosterSwapResponse
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamRosterSwapResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamRosterSwapResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_OWNER_NOT_IN_LEAGUE":
            case 2:
                message.result = 2;
                break;
            case "ERROR_SLOTS_INVALID":
            case 3:
                message.result = 3;
                break;
            case "ERROR_SLOT_LOCKED":
            case 4:
                message.result = 4;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamRosterSwapResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @static
         * @param {CMsgDOTAFantasyTeamRosterSwapResponse} message CMsgDOTAFantasyTeamRosterSwapResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamRosterSwapResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamRosterSwapResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamRosterSwapResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamRosterSwapResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_OWNER_NOT_IN_LEAGUE=2 ERROR_OWNER_NOT_IN_LEAGUE value
         * @property {number} ERROR_SLOTS_INVALID=3 ERROR_SLOTS_INVALID value
         * @property {number} ERROR_SLOT_LOCKED=4 ERROR_SLOT_LOCKED value
         */
        CMsgDOTAFantasyTeamRosterSwapResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_OWNER_NOT_IN_LEAGUE"] = 2;
            values[valuesById[3] = "ERROR_SLOTS_INVALID"] = 3;
            values[valuesById[4] = "ERROR_SLOT_LOCKED"] = 4;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamRosterSwapResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamRosterAddDropRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamRosterAddDropRequest.
         * @exports ICMsgDOTAFantasyTeamRosterAddDropRequest
         * @interface ICMsgDOTAFantasyTeamRosterAddDropRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamRosterAddDropRequest fantasy_league_id
         * @property {number|null} [team_index] CMsgDOTAFantasyTeamRosterAddDropRequest team_index
         * @property {number|null} [add_account_id] CMsgDOTAFantasyTeamRosterAddDropRequest add_account_id
         * @property {number|null} [drop_account_id] CMsgDOTAFantasyTeamRosterAddDropRequest drop_account_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamRosterAddDropRequest.
         * @exports CMsgDOTAFantasyTeamRosterAddDropRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamRosterAddDropRequest.
         * @implements ICMsgDOTAFantasyTeamRosterAddDropRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamRosterAddDropRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamRosterAddDropRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamRosterAddDropRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterAddDropRequest team_index.
         * @member {number} team_index
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.prototype.team_index = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterAddDropRequest add_account_id.
         * @member {number} add_account_id
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.prototype.add_account_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterAddDropRequest drop_account_id.
         * @member {number} drop_account_id
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.prototype.drop_account_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamRosterAddDropRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterAddDropRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamRosterAddDropRequest} CMsgDOTAFantasyTeamRosterAddDropRequest instance
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamRosterAddDropRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterAddDropRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamRosterAddDropRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterAddDropRequest} message CMsgDOTAFantasyTeamRosterAddDropRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.team_index != null && Object.hasOwnProperty.call(message, "team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_index);
            if (message.add_account_id != null && Object.hasOwnProperty.call(message, "add_account_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.add_account_id);
            if (message.drop_account_id != null && Object.hasOwnProperty.call(message, "drop_account_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.drop_account_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterAddDropRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamRosterAddDropRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterAddDropRequest} message CMsgDOTAFantasyTeamRosterAddDropRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterAddDropRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamRosterAddDropRequest} CMsgDOTAFantasyTeamRosterAddDropRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamRosterAddDropRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.team_index = reader.uint32();
                    break;
                case 5:
                    message.add_account_id = reader.uint32();
                    break;
                case 6:
                    message.drop_account_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterAddDropRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamRosterAddDropRequest} CMsgDOTAFantasyTeamRosterAddDropRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamRosterAddDropRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                if (!$util.isInteger(message.team_index))
                    return "team_index: integer expected";
            if (message.add_account_id != null && message.hasOwnProperty("add_account_id"))
                if (!$util.isInteger(message.add_account_id))
                    return "add_account_id: integer expected";
            if (message.drop_account_id != null && message.hasOwnProperty("drop_account_id"))
                if (!$util.isInteger(message.drop_account_id))
                    return "drop_account_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamRosterAddDropRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamRosterAddDropRequest} CMsgDOTAFantasyTeamRosterAddDropRequest
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamRosterAddDropRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamRosterAddDropRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.team_index != null)
                message.team_index = object.team_index >>> 0;
            if (object.add_account_id != null)
                message.add_account_id = object.add_account_id >>> 0;
            if (object.drop_account_id != null)
                message.drop_account_id = object.drop_account_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamRosterAddDropRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @static
         * @param {CMsgDOTAFantasyTeamRosterAddDropRequest} message CMsgDOTAFantasyTeamRosterAddDropRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.team_index = 0;
                object.add_account_id = 0;
                object.drop_account_id = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                object.team_index = message.team_index;
            if (message.add_account_id != null && message.hasOwnProperty("add_account_id"))
                object.add_account_id = message.add_account_id;
            if (message.drop_account_id != null && message.hasOwnProperty("drop_account_id"))
                object.drop_account_id = message.drop_account_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamRosterAddDropRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamRosterAddDropRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamRosterAddDropRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamRosterAddDropRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamRosterAddDropResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamRosterAddDropResponse.
         * @exports ICMsgDOTAFantasyTeamRosterAddDropResponse
         * @interface ICMsgDOTAFantasyTeamRosterAddDropResponse
         * @property {CMsgDOTAFantasyTeamRosterAddDropResponse.EResult|null} [result] CMsgDOTAFantasyTeamRosterAddDropResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamRosterAddDropResponse.
         * @exports CMsgDOTAFantasyTeamRosterAddDropResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamRosterAddDropResponse.
         * @implements ICMsgDOTAFantasyTeamRosterAddDropResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamRosterAddDropResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamRosterAddDropResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamRosterAddDropResponse result.
         * @member {CMsgDOTAFantasyTeamRosterAddDropResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @instance
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamRosterAddDropResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterAddDropResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamRosterAddDropResponse} CMsgDOTAFantasyTeamRosterAddDropResponse instance
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamRosterAddDropResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterAddDropResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamRosterAddDropResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterAddDropResponse} message CMsgDOTAFantasyTeamRosterAddDropResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterAddDropResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamRosterAddDropResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterAddDropResponse} message CMsgDOTAFantasyTeamRosterAddDropResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterAddDropResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamRosterAddDropResponse} CMsgDOTAFantasyTeamRosterAddDropResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamRosterAddDropResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterAddDropResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamRosterAddDropResponse} CMsgDOTAFantasyTeamRosterAddDropResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamRosterAddDropResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamRosterAddDropResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamRosterAddDropResponse} CMsgDOTAFantasyTeamRosterAddDropResponse
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamRosterAddDropResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamRosterAddDropResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_OWNER_NOT_IN_LEAGUE":
            case 2:
                message.result = 2;
                break;
            case "ERROR_PLAYER_NOT_AVAILABLE":
            case 3:
                message.result = 3;
                break;
            case "ERROR_PLAYER_NOT_ON_TEAM":
            case 4:
                message.result = 4;
                break;
            case "ERROR_TRADE_ALREADY_PENDING":
            case 5:
                message.result = 5;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamRosterAddDropResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @static
         * @param {CMsgDOTAFantasyTeamRosterAddDropResponse} message CMsgDOTAFantasyTeamRosterAddDropResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamRosterAddDropResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamRosterAddDropResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamRosterAddDropResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamRosterAddDropResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_OWNER_NOT_IN_LEAGUE=2 ERROR_OWNER_NOT_IN_LEAGUE value
         * @property {number} ERROR_PLAYER_NOT_AVAILABLE=3 ERROR_PLAYER_NOT_AVAILABLE value
         * @property {number} ERROR_PLAYER_NOT_ON_TEAM=4 ERROR_PLAYER_NOT_ON_TEAM value
         * @property {number} ERROR_TRADE_ALREADY_PENDING=5 ERROR_TRADE_ALREADY_PENDING value
         */
        CMsgDOTAFantasyTeamRosterAddDropResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_OWNER_NOT_IN_LEAGUE"] = 2;
            values[valuesById[3] = "ERROR_PLAYER_NOT_AVAILABLE"] = 3;
            values[valuesById[4] = "ERROR_PLAYER_NOT_ON_TEAM"] = 4;
            values[valuesById[5] = "ERROR_TRADE_ALREADY_PENDING"] = 5;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamRosterAddDropResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamTradesRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamTradesRequest.
         * @exports ICMsgDOTAFantasyTeamTradesRequest
         * @interface ICMsgDOTAFantasyTeamTradesRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamTradesRequest fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamTradesRequest.
         * @exports CMsgDOTAFantasyTeamTradesRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamTradesRequest.
         * @implements ICMsgDOTAFantasyTeamTradesRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamTradesRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamTradesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamTradesRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @instance
         */
        CMsgDOTAFantasyTeamTradesRequest.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamTradesRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamTradesRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamTradesRequest} CMsgDOTAFantasyTeamTradesRequest instance
         */
        CMsgDOTAFantasyTeamTradesRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamTradesRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradesRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamTradesRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamTradesRequest} message CMsgDOTAFantasyTeamTradesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradesRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamTradesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamTradesRequest} message CMsgDOTAFantasyTeamTradesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamTradesRequest} CMsgDOTAFantasyTeamTradesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamTradesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamTradesRequest} CMsgDOTAFantasyTeamTradesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamTradesRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamTradesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamTradesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamTradesRequest} CMsgDOTAFantasyTeamTradesRequest
         */
        CMsgDOTAFantasyTeamTradesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamTradesRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamTradesRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamTradesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @static
         * @param {CMsgDOTAFantasyTeamTradesRequest} message CMsgDOTAFantasyTeamTradesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamTradesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamTradesRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamTradesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamTradesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamTradesRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamTradesResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamTradesResponse.
         * @exports ICMsgDOTAFantasyTeamTradesResponse
         * @interface ICMsgDOTAFantasyTeamTradesResponse
         * @property {CMsgDOTAFantasyTeamTradesResponse.EResult|null} [result] CMsgDOTAFantasyTeamTradesResponse result
         * @property {Array.<CMsgDOTAFantasyTeamTradesResponse.ITrade>|null} [trades] CMsgDOTAFantasyTeamTradesResponse trades
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamTradesResponse.
         * @exports CMsgDOTAFantasyTeamTradesResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamTradesResponse.
         * @implements ICMsgDOTAFantasyTeamTradesResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamTradesResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamTradesResponse(properties) {
            this.trades = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamTradesResponse result.
         * @member {CMsgDOTAFantasyTeamTradesResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @instance
         */
        CMsgDOTAFantasyTeamTradesResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyTeamTradesResponse trades.
         * @member {Array.<CMsgDOTAFantasyTeamTradesResponse.ITrade>} trades
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @instance
         */
        CMsgDOTAFantasyTeamTradesResponse.prototype.trades = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamTradesResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamTradesResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamTradesResponse} CMsgDOTAFantasyTeamTradesResponse instance
         */
        CMsgDOTAFantasyTeamTradesResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamTradesResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradesResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamTradesResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamTradesResponse} message CMsgDOTAFantasyTeamTradesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.trades != null && message.trades.length)
                for (var i = 0; i < message.trades.length; ++i)
                    $root.CMsgDOTAFantasyTeamTradesResponse.Trade.encode(message.trades[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradesResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamTradesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamTradesResponse} message CMsgDOTAFantasyTeamTradesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamTradesResponse} CMsgDOTAFantasyTeamTradesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamTradesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.trades && message.trades.length))
                        message.trades = [];
                    message.trades.push($root.CMsgDOTAFantasyTeamTradesResponse.Trade.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamTradesResponse} CMsgDOTAFantasyTeamTradesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamTradesResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamTradesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.trades != null && message.hasOwnProperty("trades")) {
                if (!Array.isArray(message.trades))
                    return "trades: array expected";
                for (var i = 0; i < message.trades.length; ++i) {
                    var error = $root.CMsgDOTAFantasyTeamTradesResponse.Trade.verify(message.trades[i]);
                    if (error)
                        return "trades." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamTradesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamTradesResponse} CMsgDOTAFantasyTeamTradesResponse
         */
        CMsgDOTAFantasyTeamTradesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamTradesResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamTradesResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            if (object.trades) {
                if (!Array.isArray(object.trades))
                    throw TypeError(".CMsgDOTAFantasyTeamTradesResponse.trades: array expected");
                message.trades = [];
                for (var i = 0; i < object.trades.length; ++i) {
                    if (typeof object.trades[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyTeamTradesResponse.trades: object expected");
                    message.trades[i] = $root.CMsgDOTAFantasyTeamTradesResponse.Trade.fromObject(object.trades[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamTradesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @static
         * @param {CMsgDOTAFantasyTeamTradesResponse} message CMsgDOTAFantasyTeamTradesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamTradesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trades = [];
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamTradesResponse.EResult[message.result] : message.result;
            if (message.trades && message.trades.length) {
                object.trades = [];
                for (var j = 0; j < message.trades.length; ++j)
                    object.trades[j] = $root.CMsgDOTAFantasyTeamTradesResponse.Trade.toObject(message.trades[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamTradesResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamTradesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamTradesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyTeamTradesResponse.Trade = (function() {
    
            /**
             * Properties of a Trade.
             * @memberof CMsgDOTAFantasyTeamTradesResponse
             * @interface ITrade
             * @property {number|null} [timestamp] Trade timestamp
             * @property {number|null} [owner_account_id_1] Trade owner_account_id_1
             * @property {number|null} [owner_account_id_2] Trade owner_account_id_2
             * @property {number|null} [player_account_id_1] Trade player_account_id_1
             * @property {number|null} [player_account_id_2] Trade player_account_id_2
             * @property {number|null} [status] Trade status
             */
    
            /**
             * Constructs a new Trade.
             * @memberof CMsgDOTAFantasyTeamTradesResponse
             * @classdesc Represents a Trade.
             * @implements ITrade
             * @constructor
             * @param {CMsgDOTAFantasyTeamTradesResponse.ITrade=} [properties] Properties to set
             */
            function Trade(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Trade timestamp.
             * @member {number} timestamp
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             */
            Trade.prototype.timestamp = 0;
    
            /**
             * Trade owner_account_id_1.
             * @member {number} owner_account_id_1
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             */
            Trade.prototype.owner_account_id_1 = 0;
    
            /**
             * Trade owner_account_id_2.
             * @member {number} owner_account_id_2
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             */
            Trade.prototype.owner_account_id_2 = 0;
    
            /**
             * Trade player_account_id_1.
             * @member {number} player_account_id_1
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             */
            Trade.prototype.player_account_id_1 = 0;
    
            /**
             * Trade player_account_id_2.
             * @member {number} player_account_id_2
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             */
            Trade.prototype.player_account_id_2 = 0;
    
            /**
             * Trade status.
             * @member {number} status
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             */
            Trade.prototype.status = 0;
    
            /**
             * Creates a new Trade instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {CMsgDOTAFantasyTeamTradesResponse.ITrade=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyTeamTradesResponse.Trade} Trade instance
             */
            Trade.create = function create(properties) {
                return new Trade(properties);
            };
    
            /**
             * Encodes the specified Trade message. Does not implicitly {@link CMsgDOTAFantasyTeamTradesResponse.Trade.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {CMsgDOTAFantasyTeamTradesResponse.ITrade} message Trade message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trade.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp);
                if (message.owner_account_id_1 != null && Object.hasOwnProperty.call(message, "owner_account_id_1"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.owner_account_id_1);
                if (message.owner_account_id_2 != null && Object.hasOwnProperty.call(message, "owner_account_id_2"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.owner_account_id_2);
                if (message.player_account_id_1 != null && Object.hasOwnProperty.call(message, "player_account_id_1"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.player_account_id_1);
                if (message.player_account_id_2 != null && Object.hasOwnProperty.call(message, "player_account_id_2"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.player_account_id_2);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.status);
                return writer;
            };
    
            /**
             * Encodes the specified Trade message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamTradesResponse.Trade.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {CMsgDOTAFantasyTeamTradesResponse.ITrade} message Trade message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trade.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Trade message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyTeamTradesResponse.Trade} Trade
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trade.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamTradesResponse.Trade();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.uint32();
                        break;
                    case 2:
                        message.owner_account_id_1 = reader.uint32();
                        break;
                    case 3:
                        message.owner_account_id_2 = reader.uint32();
                        break;
                    case 4:
                        message.player_account_id_1 = reader.uint32();
                        break;
                    case 5:
                        message.player_account_id_2 = reader.uint32();
                        break;
                    case 6:
                        message.status = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Trade message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyTeamTradesResponse.Trade} Trade
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trade.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Trade message.
             * @function verify
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Trade.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp))
                        return "timestamp: integer expected";
                if (message.owner_account_id_1 != null && message.hasOwnProperty("owner_account_id_1"))
                    if (!$util.isInteger(message.owner_account_id_1))
                        return "owner_account_id_1: integer expected";
                if (message.owner_account_id_2 != null && message.hasOwnProperty("owner_account_id_2"))
                    if (!$util.isInteger(message.owner_account_id_2))
                        return "owner_account_id_2: integer expected";
                if (message.player_account_id_1 != null && message.hasOwnProperty("player_account_id_1"))
                    if (!$util.isInteger(message.player_account_id_1))
                        return "player_account_id_1: integer expected";
                if (message.player_account_id_2 != null && message.hasOwnProperty("player_account_id_2"))
                    if (!$util.isInteger(message.player_account_id_2))
                        return "player_account_id_2: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                return null;
            };
    
            /**
             * Creates a Trade message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyTeamTradesResponse.Trade} Trade
             */
            Trade.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyTeamTradesResponse.Trade)
                    return object;
                var message = new $root.CMsgDOTAFantasyTeamTradesResponse.Trade();
                if (object.timestamp != null)
                    message.timestamp = object.timestamp >>> 0;
                if (object.owner_account_id_1 != null)
                    message.owner_account_id_1 = object.owner_account_id_1 >>> 0;
                if (object.owner_account_id_2 != null)
                    message.owner_account_id_2 = object.owner_account_id_2 >>> 0;
                if (object.player_account_id_1 != null)
                    message.player_account_id_1 = object.player_account_id_1 >>> 0;
                if (object.player_account_id_2 != null)
                    message.player_account_id_2 = object.player_account_id_2 >>> 0;
                if (object.status != null)
                    message.status = object.status >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Trade message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @static
             * @param {CMsgDOTAFantasyTeamTradesResponse.Trade} message Trade
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Trade.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.timestamp = 0;
                    object.owner_account_id_1 = 0;
                    object.owner_account_id_2 = 0;
                    object.player_account_id_1 = 0;
                    object.player_account_id_2 = 0;
                    object.status = 0;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                if (message.owner_account_id_1 != null && message.hasOwnProperty("owner_account_id_1"))
                    object.owner_account_id_1 = message.owner_account_id_1;
                if (message.owner_account_id_2 != null && message.hasOwnProperty("owner_account_id_2"))
                    object.owner_account_id_2 = message.owner_account_id_2;
                if (message.player_account_id_1 != null && message.hasOwnProperty("player_account_id_1"))
                    object.player_account_id_1 = message.player_account_id_1;
                if (message.player_account_id_2 != null && message.hasOwnProperty("player_account_id_2"))
                    object.player_account_id_2 = message.player_account_id_2;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };
    
            /**
             * Converts this Trade to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyTeamTradesResponse.Trade
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Trade.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Trade;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamTradesResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyTeamTradesResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamTradesResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamTradeCancelRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamTradeCancelRequest.
         * @exports ICMsgDOTAFantasyTeamTradeCancelRequest
         * @interface ICMsgDOTAFantasyTeamTradeCancelRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamTradeCancelRequest fantasy_league_id
         * @property {number|null} [team_index_1] CMsgDOTAFantasyTeamTradeCancelRequest team_index_1
         * @property {number|null} [owner_account_id_2] CMsgDOTAFantasyTeamTradeCancelRequest owner_account_id_2
         * @property {number|null} [team_index_2] CMsgDOTAFantasyTeamTradeCancelRequest team_index_2
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamTradeCancelRequest.
         * @exports CMsgDOTAFantasyTeamTradeCancelRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamTradeCancelRequest.
         * @implements ICMsgDOTAFantasyTeamTradeCancelRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamTradeCancelRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamTradeCancelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamTradeCancelRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @instance
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamTradeCancelRequest team_index_1.
         * @member {number} team_index_1
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @instance
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.prototype.team_index_1 = 0;
    
        /**
         * CMsgDOTAFantasyTeamTradeCancelRequest owner_account_id_2.
         * @member {number} owner_account_id_2
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @instance
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.prototype.owner_account_id_2 = 0;
    
        /**
         * CMsgDOTAFantasyTeamTradeCancelRequest team_index_2.
         * @member {number} team_index_2
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @instance
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.prototype.team_index_2 = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamTradeCancelRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamTradeCancelRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamTradeCancelRequest} CMsgDOTAFantasyTeamTradeCancelRequest instance
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamTradeCancelRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradeCancelRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamTradeCancelRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamTradeCancelRequest} message CMsgDOTAFantasyTeamTradeCancelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.team_index_1 != null && Object.hasOwnProperty.call(message, "team_index_1"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team_index_1);
            if (message.owner_account_id_2 != null && Object.hasOwnProperty.call(message, "owner_account_id_2"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.owner_account_id_2);
            if (message.team_index_2 != null && Object.hasOwnProperty.call(message, "team_index_2"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.team_index_2);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradeCancelRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamTradeCancelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamTradeCancelRequest} message CMsgDOTAFantasyTeamTradeCancelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradeCancelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamTradeCancelRequest} CMsgDOTAFantasyTeamTradeCancelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamTradeCancelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 3:
                    message.team_index_1 = reader.uint32();
                    break;
                case 4:
                    message.owner_account_id_2 = reader.uint32();
                    break;
                case 5:
                    message.team_index_2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradeCancelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamTradeCancelRequest} CMsgDOTAFantasyTeamTradeCancelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamTradeCancelRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.team_index_1 != null && message.hasOwnProperty("team_index_1"))
                if (!$util.isInteger(message.team_index_1))
                    return "team_index_1: integer expected";
            if (message.owner_account_id_2 != null && message.hasOwnProperty("owner_account_id_2"))
                if (!$util.isInteger(message.owner_account_id_2))
                    return "owner_account_id_2: integer expected";
            if (message.team_index_2 != null && message.hasOwnProperty("team_index_2"))
                if (!$util.isInteger(message.team_index_2))
                    return "team_index_2: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamTradeCancelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamTradeCancelRequest} CMsgDOTAFantasyTeamTradeCancelRequest
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamTradeCancelRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamTradeCancelRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.team_index_1 != null)
                message.team_index_1 = object.team_index_1 >>> 0;
            if (object.owner_account_id_2 != null)
                message.owner_account_id_2 = object.owner_account_id_2 >>> 0;
            if (object.team_index_2 != null)
                message.team_index_2 = object.team_index_2 >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamTradeCancelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @static
         * @param {CMsgDOTAFantasyTeamTradeCancelRequest} message CMsgDOTAFantasyTeamTradeCancelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.team_index_1 = 0;
                object.owner_account_id_2 = 0;
                object.team_index_2 = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.team_index_1 != null && message.hasOwnProperty("team_index_1"))
                object.team_index_1 = message.team_index_1;
            if (message.owner_account_id_2 != null && message.hasOwnProperty("owner_account_id_2"))
                object.owner_account_id_2 = message.owner_account_id_2;
            if (message.team_index_2 != null && message.hasOwnProperty("team_index_2"))
                object.team_index_2 = message.team_index_2;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamTradeCancelRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamTradeCancelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamTradeCancelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamTradeCancelRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamTradeCancelResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamTradeCancelResponse.
         * @exports ICMsgDOTAFantasyTeamTradeCancelResponse
         * @interface ICMsgDOTAFantasyTeamTradeCancelResponse
         * @property {CMsgDOTAFantasyTeamTradeCancelResponse.EResult|null} [result] CMsgDOTAFantasyTeamTradeCancelResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamTradeCancelResponse.
         * @exports CMsgDOTAFantasyTeamTradeCancelResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamTradeCancelResponse.
         * @implements ICMsgDOTAFantasyTeamTradeCancelResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamTradeCancelResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamTradeCancelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamTradeCancelResponse result.
         * @member {CMsgDOTAFantasyTeamTradeCancelResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @instance
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamTradeCancelResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamTradeCancelResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamTradeCancelResponse} CMsgDOTAFantasyTeamTradeCancelResponse instance
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamTradeCancelResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradeCancelResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamTradeCancelResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamTradeCancelResponse} message CMsgDOTAFantasyTeamTradeCancelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamTradeCancelResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamTradeCancelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamTradeCancelResponse} message CMsgDOTAFantasyTeamTradeCancelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradeCancelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamTradeCancelResponse} CMsgDOTAFantasyTeamTradeCancelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamTradeCancelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamTradeCancelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamTradeCancelResponse} CMsgDOTAFantasyTeamTradeCancelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamTradeCancelResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamTradeCancelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamTradeCancelResponse} CMsgDOTAFantasyTeamTradeCancelResponse
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamTradeCancelResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamTradeCancelResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            case "ERROR_NO_TRADE":
            case 3:
                message.result = 3;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamTradeCancelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @static
         * @param {CMsgDOTAFantasyTeamTradeCancelResponse} message CMsgDOTAFantasyTeamTradeCancelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamTradeCancelResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamTradeCancelResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamTradeCancelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamTradeCancelResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         * @property {number} ERROR_NO_TRADE=3 ERROR_NO_TRADE value
         */
        CMsgDOTAFantasyTeamTradeCancelResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            values[valuesById[3] = "ERROR_NO_TRADE"] = 3;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamTradeCancelResponse;
    })();
    
    $root.CMsgDOTAFantasyTeamRosterRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamRosterRequest.
         * @exports ICMsgDOTAFantasyTeamRosterRequest
         * @interface ICMsgDOTAFantasyTeamRosterRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyTeamRosterRequest fantasy_league_id
         * @property {number|null} [team_index] CMsgDOTAFantasyTeamRosterRequest team_index
         * @property {number|null} [owner_account_id] CMsgDOTAFantasyTeamRosterRequest owner_account_id
         * @property {number|null} [timestamp] CMsgDOTAFantasyTeamRosterRequest timestamp
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamRosterRequest.
         * @exports CMsgDOTAFantasyTeamRosterRequest
         * @classdesc Represents a CMsgDOTAFantasyTeamRosterRequest.
         * @implements ICMsgDOTAFantasyTeamRosterRequest
         * @constructor
         * @param {ICMsgDOTAFantasyTeamRosterRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamRosterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamRosterRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterRequest team_index.
         * @member {number} team_index
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterRequest.prototype.team_index = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterRequest owner_account_id.
         * @member {number} owner_account_id
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterRequest.prototype.owner_account_id = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterRequest timestamp.
         * @member {number} timestamp
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @instance
         */
        CMsgDOTAFantasyTeamRosterRequest.prototype.timestamp = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamRosterRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamRosterRequest} CMsgDOTAFantasyTeamRosterRequest instance
         */
        CMsgDOTAFantasyTeamRosterRequest.create = function create(properties) {
            return new CMsgDOTAFantasyTeamRosterRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterRequest message. Does not implicitly {@link CMsgDOTAFantasyTeamRosterRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterRequest} message CMsgDOTAFantasyTeamRosterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.team_index != null && Object.hasOwnProperty.call(message, "team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_index);
            if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.owner_account_id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamRosterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterRequest} message CMsgDOTAFantasyTeamRosterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamRosterRequest} CMsgDOTAFantasyTeamRosterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamRosterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.team_index = reader.uint32();
                    break;
                case 3:
                    message.owner_account_id = reader.uint32();
                    break;
                case 4:
                    message.timestamp = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamRosterRequest} CMsgDOTAFantasyTeamRosterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamRosterRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamRosterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                if (!$util.isInteger(message.team_index))
                    return "team_index: integer expected";
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                if (!$util.isInteger(message.owner_account_id))
                    return "owner_account_id: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamRosterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamRosterRequest} CMsgDOTAFantasyTeamRosterRequest
         */
        CMsgDOTAFantasyTeamRosterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamRosterRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamRosterRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.team_index != null)
                message.team_index = object.team_index >>> 0;
            if (object.owner_account_id != null)
                message.owner_account_id = object.owner_account_id >>> 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamRosterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @static
         * @param {CMsgDOTAFantasyTeamRosterRequest} message CMsgDOTAFantasyTeamRosterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamRosterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.team_index = 0;
                object.owner_account_id = 0;
                object.timestamp = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                object.team_index = message.team_index;
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                object.owner_account_id = message.owner_account_id;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamRosterRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamRosterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamRosterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyTeamRosterRequest;
    })();
    
    $root.CMsgDOTAFantasyTeamRosterResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyTeamRosterResponse.
         * @exports ICMsgDOTAFantasyTeamRosterResponse
         * @interface ICMsgDOTAFantasyTeamRosterResponse
         * @property {CMsgDOTAFantasyTeamRosterResponse.EResult|null} [result] CMsgDOTAFantasyTeamRosterResponse result
         * @property {Array.<number>|null} [player_account_ids] CMsgDOTAFantasyTeamRosterResponse player_account_ids
         * @property {Array.<boolean>|null} [player_locked] CMsgDOTAFantasyTeamRosterResponse player_locked
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyTeamRosterResponse.
         * @exports CMsgDOTAFantasyTeamRosterResponse
         * @classdesc Represents a CMsgDOTAFantasyTeamRosterResponse.
         * @implements ICMsgDOTAFantasyTeamRosterResponse
         * @constructor
         * @param {ICMsgDOTAFantasyTeamRosterResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyTeamRosterResponse(properties) {
            this.player_account_ids = [];
            this.player_locked = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyTeamRosterResponse result.
         * @member {CMsgDOTAFantasyTeamRosterResponse.EResult} result
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @instance
         */
        CMsgDOTAFantasyTeamRosterResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyTeamRosterResponse player_account_ids.
         * @member {Array.<number>} player_account_ids
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @instance
         */
        CMsgDOTAFantasyTeamRosterResponse.prototype.player_account_ids = $util.emptyArray;
    
        /**
         * CMsgDOTAFantasyTeamRosterResponse player_locked.
         * @member {Array.<boolean>} player_locked
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @instance
         */
        CMsgDOTAFantasyTeamRosterResponse.prototype.player_locked = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyTeamRosterResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyTeamRosterResponse} CMsgDOTAFantasyTeamRosterResponse instance
         */
        CMsgDOTAFantasyTeamRosterResponse.create = function create(properties) {
            return new CMsgDOTAFantasyTeamRosterResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterResponse message. Does not implicitly {@link CMsgDOTAFantasyTeamRosterResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterResponse} message CMsgDOTAFantasyTeamRosterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.player_account_ids != null && message.player_account_ids.length)
                for (var i = 0; i < message.player_account_ids.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_account_ids[i]);
            if (message.player_locked != null && message.player_locked.length)
                for (var i = 0; i < message.player_locked.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.player_locked[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyTeamRosterResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyTeamRosterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {ICMsgDOTAFantasyTeamRosterResponse} message CMsgDOTAFantasyTeamRosterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyTeamRosterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyTeamRosterResponse} CMsgDOTAFantasyTeamRosterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyTeamRosterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.player_account_ids && message.player_account_ids.length))
                        message.player_account_ids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player_account_ids.push(reader.uint32());
                    } else
                        message.player_account_ids.push(reader.uint32());
                    break;
                case 3:
                    if (!(message.player_locked && message.player_locked.length))
                        message.player_locked = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player_locked.push(reader.bool());
                    } else
                        message.player_locked.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyTeamRosterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyTeamRosterResponse} CMsgDOTAFantasyTeamRosterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyTeamRosterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyTeamRosterResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyTeamRosterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.player_account_ids != null && message.hasOwnProperty("player_account_ids")) {
                if (!Array.isArray(message.player_account_ids))
                    return "player_account_ids: array expected";
                for (var i = 0; i < message.player_account_ids.length; ++i)
                    if (!$util.isInteger(message.player_account_ids[i]))
                        return "player_account_ids: integer[] expected";
            }
            if (message.player_locked != null && message.hasOwnProperty("player_locked")) {
                if (!Array.isArray(message.player_locked))
                    return "player_locked: array expected";
                for (var i = 0; i < message.player_locked.length; ++i)
                    if (typeof message.player_locked[i] !== "boolean")
                        return "player_locked: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyTeamRosterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyTeamRosterResponse} CMsgDOTAFantasyTeamRosterResponse
         */
        CMsgDOTAFantasyTeamRosterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyTeamRosterResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyTeamRosterResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            case "ERROR_OWNER_NOT_IN_LEAGUE":
            case 3:
                message.result = 3;
                break;
            }
            if (object.player_account_ids) {
                if (!Array.isArray(object.player_account_ids))
                    throw TypeError(".CMsgDOTAFantasyTeamRosterResponse.player_account_ids: array expected");
                message.player_account_ids = [];
                for (var i = 0; i < object.player_account_ids.length; ++i)
                    message.player_account_ids[i] = object.player_account_ids[i] >>> 0;
            }
            if (object.player_locked) {
                if (!Array.isArray(object.player_locked))
                    throw TypeError(".CMsgDOTAFantasyTeamRosterResponse.player_locked: array expected");
                message.player_locked = [];
                for (var i = 0; i < object.player_locked.length; ++i)
                    message.player_locked[i] = Boolean(object.player_locked[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyTeamRosterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @static
         * @param {CMsgDOTAFantasyTeamRosterResponse} message CMsgDOTAFantasyTeamRosterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyTeamRosterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.player_account_ids = [];
                object.player_locked = [];
            }
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyTeamRosterResponse.EResult[message.result] : message.result;
            if (message.player_account_ids && message.player_account_ids.length) {
                object.player_account_ids = [];
                for (var j = 0; j < message.player_account_ids.length; ++j)
                    object.player_account_ids[j] = message.player_account_ids[j];
            }
            if (message.player_locked && message.player_locked.length) {
                object.player_locked = [];
                for (var j = 0; j < message.player_locked.length; ++j)
                    object.player_locked[j] = message.player_locked[j];
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyTeamRosterResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyTeamRosterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyTeamRosterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyTeamRosterResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         * @property {number} ERROR_OWNER_NOT_IN_LEAGUE=3 ERROR_OWNER_NOT_IN_LEAGUE value
         */
        CMsgDOTAFantasyTeamRosterResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            values[valuesById[3] = "ERROR_OWNER_NOT_IN_LEAGUE"] = 3;
            return values;
        })();
    
        return CMsgDOTAFantasyTeamRosterResponse;
    })();
    
    $root.CMsgDOTAFantasyPlayerHisoricalStatsRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerHisoricalStatsRequest.
         * @exports ICMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @interface ICMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyPlayerHisoricalStatsRequest fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerHisoricalStatsRequest.
         * @exports CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @classdesc Represents a CMsgDOTAFantasyPlayerHisoricalStatsRequest.
         * @implements ICMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerHisoricalStatsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerHisoricalStatsRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerHisoricalStatsRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsRequest} CMsgDOTAFantasyPlayerHisoricalStatsRequest instance
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerHisoricalStatsRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerHisoricalStatsRequest message. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsRequest} message CMsgDOTAFantasyPlayerHisoricalStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerHisoricalStatsRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsRequest} message CMsgDOTAFantasyPlayerHisoricalStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerHisoricalStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsRequest} CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerHisoricalStatsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsRequest} CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerHisoricalStatsRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerHisoricalStatsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsRequest} CMsgDOTAFantasyPlayerHisoricalStatsRequest
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerHisoricalStatsRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerHisoricalStatsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @static
         * @param {CMsgDOTAFantasyPlayerHisoricalStatsRequest} message CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerHisoricalStatsRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerHisoricalStatsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyPlayerHisoricalStatsRequest;
    })();
    
    $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerHisoricalStatsResponse.
         * @exports ICMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @interface ICMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @property {CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult|null} [result] CMsgDOTAFantasyPlayerHisoricalStatsResponse result
         * @property {Array.<CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerStats>|null} [stats] CMsgDOTAFantasyPlayerHisoricalStatsResponse stats
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerHisoricalStatsResponse.
         * @exports CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @classdesc Represents a CMsgDOTAFantasyPlayerHisoricalStatsResponse.
         * @implements ICMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerHisoricalStatsResponse(properties) {
            this.stats = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerHisoricalStatsResponse result.
         * @member {CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult} result
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyPlayerHisoricalStatsResponse stats.
         * @member {Array.<CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerStats>} stats
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.prototype.stats = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerHisoricalStatsResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse} CMsgDOTAFantasyPlayerHisoricalStatsResponse instance
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerHisoricalStatsResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerHisoricalStatsResponse message. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsResponse} message CMsgDOTAFantasyPlayerHisoricalStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.stats != null && message.stats.length)
                for (var i = 0; i < message.stats.length; ++i)
                    $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.encode(message.stats[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerHisoricalStatsResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerHisoricalStatsResponse} message CMsgDOTAFantasyPlayerHisoricalStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerHisoricalStatsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse} CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerHisoricalStatsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse} CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerHisoricalStatsResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stats != null && message.hasOwnProperty("stats")) {
                if (!Array.isArray(message.stats))
                    return "stats: array expected";
                for (var i = 0; i < message.stats.length; ++i) {
                    var error = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.verify(message.stats[i]);
                    if (error)
                        return "stats." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerHisoricalStatsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse} CMsgDOTAFantasyPlayerHisoricalStatsResponse
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            if (object.stats) {
                if (!Array.isArray(object.stats))
                    throw TypeError(".CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats: array expected");
                message.stats = [];
                for (var i = 0; i < object.stats.length; ++i) {
                    if (typeof object.stats[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats: object expected");
                    message.stats[i] = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.fromObject(object.stats[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerHisoricalStatsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @static
         * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse} message CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.stats = [];
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult[message.result] : message.result;
            if (message.stats && message.stats.length) {
                object.stats = [];
                for (var j = 0; j < message.stats.length; ++j)
                    object.stats[j] = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.toObject(message.stats[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerHisoricalStatsResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator = (function() {
    
            /**
             * Properties of a PlayerScoreAccumulator.
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
             * @interface IPlayerScoreAccumulator
             * @property {number|null} [matches] PlayerScoreAccumulator matches
             * @property {number|null} [levels] PlayerScoreAccumulator levels
             * @property {number|null} [kills] PlayerScoreAccumulator kills
             * @property {number|null} [deaths] PlayerScoreAccumulator deaths
             * @property {number|null} [assists] PlayerScoreAccumulator assists
             * @property {number|null} [last_hits] PlayerScoreAccumulator last_hits
             * @property {number|null} [denies] PlayerScoreAccumulator denies
             * @property {number|null} [gpm] PlayerScoreAccumulator gpm
             * @property {number|null} [xppm] PlayerScoreAccumulator xppm
             * @property {number|null} [stuns] PlayerScoreAccumulator stuns
             * @property {number|null} [healing] PlayerScoreAccumulator healing
             * @property {number|null} [tower_kills] PlayerScoreAccumulator tower_kills
             * @property {number|null} [roshan_kills] PlayerScoreAccumulator roshan_kills
             * @property {number|null} [score] PlayerScoreAccumulator score
             */
    
            /**
             * Constructs a new PlayerScoreAccumulator.
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
             * @classdesc Represents a PlayerScoreAccumulator.
             * @implements IPlayerScoreAccumulator
             * @constructor
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator=} [properties] Properties to set
             */
            function PlayerScoreAccumulator(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerScoreAccumulator matches.
             * @member {number} matches
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.matches = 0;
    
            /**
             * PlayerScoreAccumulator levels.
             * @member {number} levels
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.levels = 0;
    
            /**
             * PlayerScoreAccumulator kills.
             * @member {number} kills
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.kills = 0;
    
            /**
             * PlayerScoreAccumulator deaths.
             * @member {number} deaths
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.deaths = 0;
    
            /**
             * PlayerScoreAccumulator assists.
             * @member {number} assists
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.assists = 0;
    
            /**
             * PlayerScoreAccumulator last_hits.
             * @member {number} last_hits
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.last_hits = 0;
    
            /**
             * PlayerScoreAccumulator denies.
             * @member {number} denies
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.denies = 0;
    
            /**
             * PlayerScoreAccumulator gpm.
             * @member {number} gpm
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.gpm = 0;
    
            /**
             * PlayerScoreAccumulator xppm.
             * @member {number} xppm
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.xppm = 0;
    
            /**
             * PlayerScoreAccumulator stuns.
             * @member {number} stuns
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.stuns = 0;
    
            /**
             * PlayerScoreAccumulator healing.
             * @member {number} healing
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.healing = 0;
    
            /**
             * PlayerScoreAccumulator tower_kills.
             * @member {number} tower_kills
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.tower_kills = 0;
    
            /**
             * PlayerScoreAccumulator roshan_kills.
             * @member {number} roshan_kills
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.roshan_kills = 0;
    
            /**
             * PlayerScoreAccumulator score.
             * @member {number} score
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             */
            PlayerScoreAccumulator.prototype.score = 0;
    
            /**
             * Creates a new PlayerScoreAccumulator instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator} PlayerScoreAccumulator instance
             */
            PlayerScoreAccumulator.create = function create(properties) {
                return new PlayerScoreAccumulator(properties);
            };
    
            /**
             * Encodes the specified PlayerScoreAccumulator message. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator} message PlayerScoreAccumulator message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerScoreAccumulator.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.matches != null && Object.hasOwnProperty.call(message, "matches"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.matches);
                if (message.levels != null && Object.hasOwnProperty.call(message, "levels"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.levels);
                if (message.kills != null && Object.hasOwnProperty.call(message, "kills"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.kills);
                if (message.deaths != null && Object.hasOwnProperty.call(message, "deaths"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.deaths);
                if (message.assists != null && Object.hasOwnProperty.call(message, "assists"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.assists);
                if (message.last_hits != null && Object.hasOwnProperty.call(message, "last_hits"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.last_hits);
                if (message.denies != null && Object.hasOwnProperty.call(message, "denies"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.denies);
                if (message.gpm != null && Object.hasOwnProperty.call(message, "gpm"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.gpm);
                if (message.xppm != null && Object.hasOwnProperty.call(message, "xppm"))
                    writer.uint32(/* id 9, wireType 5 =*/77).float(message.xppm);
                if (message.stuns != null && Object.hasOwnProperty.call(message, "stuns"))
                    writer.uint32(/* id 10, wireType 5 =*/85).float(message.stuns);
                if (message.healing != null && Object.hasOwnProperty.call(message, "healing"))
                    writer.uint32(/* id 11, wireType 5 =*/93).float(message.healing);
                if (message.tower_kills != null && Object.hasOwnProperty.call(message, "tower_kills"))
                    writer.uint32(/* id 12, wireType 5 =*/101).float(message.tower_kills);
                if (message.roshan_kills != null && Object.hasOwnProperty.call(message, "roshan_kills"))
                    writer.uint32(/* id 13, wireType 5 =*/109).float(message.roshan_kills);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 14, wireType 5 =*/117).float(message.score);
                return writer;
            };
    
            /**
             * Encodes the specified PlayerScoreAccumulator message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator} message PlayerScoreAccumulator message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerScoreAccumulator.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PlayerScoreAccumulator message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator} PlayerScoreAccumulator
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerScoreAccumulator.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.matches = reader.uint32();
                        break;
                    case 2:
                        message.levels = reader.float();
                        break;
                    case 3:
                        message.kills = reader.float();
                        break;
                    case 4:
                        message.deaths = reader.float();
                        break;
                    case 5:
                        message.assists = reader.float();
                        break;
                    case 6:
                        message.last_hits = reader.float();
                        break;
                    case 7:
                        message.denies = reader.float();
                        break;
                    case 8:
                        message.gpm = reader.float();
                        break;
                    case 9:
                        message.xppm = reader.float();
                        break;
                    case 10:
                        message.stuns = reader.float();
                        break;
                    case 11:
                        message.healing = reader.float();
                        break;
                    case 12:
                        message.tower_kills = reader.float();
                        break;
                    case 13:
                        message.roshan_kills = reader.float();
                        break;
                    case 14:
                        message.score = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PlayerScoreAccumulator message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator} PlayerScoreAccumulator
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerScoreAccumulator.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PlayerScoreAccumulator message.
             * @function verify
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerScoreAccumulator.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.matches != null && message.hasOwnProperty("matches"))
                    if (!$util.isInteger(message.matches))
                        return "matches: integer expected";
                if (message.levels != null && message.hasOwnProperty("levels"))
                    if (typeof message.levels !== "number")
                        return "levels: number expected";
                if (message.kills != null && message.hasOwnProperty("kills"))
                    if (typeof message.kills !== "number")
                        return "kills: number expected";
                if (message.deaths != null && message.hasOwnProperty("deaths"))
                    if (typeof message.deaths !== "number")
                        return "deaths: number expected";
                if (message.assists != null && message.hasOwnProperty("assists"))
                    if (typeof message.assists !== "number")
                        return "assists: number expected";
                if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                    if (typeof message.last_hits !== "number")
                        return "last_hits: number expected";
                if (message.denies != null && message.hasOwnProperty("denies"))
                    if (typeof message.denies !== "number")
                        return "denies: number expected";
                if (message.gpm != null && message.hasOwnProperty("gpm"))
                    if (typeof message.gpm !== "number")
                        return "gpm: number expected";
                if (message.xppm != null && message.hasOwnProperty("xppm"))
                    if (typeof message.xppm !== "number")
                        return "xppm: number expected";
                if (message.stuns != null && message.hasOwnProperty("stuns"))
                    if (typeof message.stuns !== "number")
                        return "stuns: number expected";
                if (message.healing != null && message.hasOwnProperty("healing"))
                    if (typeof message.healing !== "number")
                        return "healing: number expected";
                if (message.tower_kills != null && message.hasOwnProperty("tower_kills"))
                    if (typeof message.tower_kills !== "number")
                        return "tower_kills: number expected";
                if (message.roshan_kills != null && message.hasOwnProperty("roshan_kills"))
                    if (typeof message.roshan_kills !== "number")
                        return "roshan_kills: number expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                return null;
            };
    
            /**
             * Creates a PlayerScoreAccumulator message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator} PlayerScoreAccumulator
             */
            PlayerScoreAccumulator.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator)
                    return object;
                var message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator();
                if (object.matches != null)
                    message.matches = object.matches >>> 0;
                if (object.levels != null)
                    message.levels = Number(object.levels);
                if (object.kills != null)
                    message.kills = Number(object.kills);
                if (object.deaths != null)
                    message.deaths = Number(object.deaths);
                if (object.assists != null)
                    message.assists = Number(object.assists);
                if (object.last_hits != null)
                    message.last_hits = Number(object.last_hits);
                if (object.denies != null)
                    message.denies = Number(object.denies);
                if (object.gpm != null)
                    message.gpm = Number(object.gpm);
                if (object.xppm != null)
                    message.xppm = Number(object.xppm);
                if (object.stuns != null)
                    message.stuns = Number(object.stuns);
                if (object.healing != null)
                    message.healing = Number(object.healing);
                if (object.tower_kills != null)
                    message.tower_kills = Number(object.tower_kills);
                if (object.roshan_kills != null)
                    message.roshan_kills = Number(object.roshan_kills);
                if (object.score != null)
                    message.score = Number(object.score);
                return message;
            };
    
            /**
             * Creates a plain object from a PlayerScoreAccumulator message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator} message PlayerScoreAccumulator
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlayerScoreAccumulator.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.matches = 0;
                    object.levels = 0;
                    object.kills = 0;
                    object.deaths = 0;
                    object.assists = 0;
                    object.last_hits = 0;
                    object.denies = 0;
                    object.gpm = 0;
                    object.xppm = 0;
                    object.stuns = 0;
                    object.healing = 0;
                    object.tower_kills = 0;
                    object.roshan_kills = 0;
                    object.score = 0;
                }
                if (message.matches != null && message.hasOwnProperty("matches"))
                    object.matches = message.matches;
                if (message.levels != null && message.hasOwnProperty("levels"))
                    object.levels = options.json && !isFinite(message.levels) ? String(message.levels) : message.levels;
                if (message.kills != null && message.hasOwnProperty("kills"))
                    object.kills = options.json && !isFinite(message.kills) ? String(message.kills) : message.kills;
                if (message.deaths != null && message.hasOwnProperty("deaths"))
                    object.deaths = options.json && !isFinite(message.deaths) ? String(message.deaths) : message.deaths;
                if (message.assists != null && message.hasOwnProperty("assists"))
                    object.assists = options.json && !isFinite(message.assists) ? String(message.assists) : message.assists;
                if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                    object.last_hits = options.json && !isFinite(message.last_hits) ? String(message.last_hits) : message.last_hits;
                if (message.denies != null && message.hasOwnProperty("denies"))
                    object.denies = options.json && !isFinite(message.denies) ? String(message.denies) : message.denies;
                if (message.gpm != null && message.hasOwnProperty("gpm"))
                    object.gpm = options.json && !isFinite(message.gpm) ? String(message.gpm) : message.gpm;
                if (message.xppm != null && message.hasOwnProperty("xppm"))
                    object.xppm = options.json && !isFinite(message.xppm) ? String(message.xppm) : message.xppm;
                if (message.stuns != null && message.hasOwnProperty("stuns"))
                    object.stuns = options.json && !isFinite(message.stuns) ? String(message.stuns) : message.stuns;
                if (message.healing != null && message.hasOwnProperty("healing"))
                    object.healing = options.json && !isFinite(message.healing) ? String(message.healing) : message.healing;
                if (message.tower_kills != null && message.hasOwnProperty("tower_kills"))
                    object.tower_kills = options.json && !isFinite(message.tower_kills) ? String(message.tower_kills) : message.tower_kills;
                if (message.roshan_kills != null && message.hasOwnProperty("roshan_kills"))
                    object.roshan_kills = options.json && !isFinite(message.roshan_kills) ? String(message.roshan_kills) : message.roshan_kills;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                return object;
            };
    
            /**
             * Converts this PlayerScoreAccumulator to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlayerScoreAccumulator.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PlayerScoreAccumulator;
        })();
    
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats = (function() {
    
            /**
             * Properties of a PlayerStats.
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
             * @interface IPlayerStats
             * @property {number|null} [account_id] PlayerStats account_id
             * @property {number|null} [weeks] PlayerStats weeks
             * @property {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator|null} [stats_premium] PlayerStats stats_premium
             * @property {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator|null} [stats_professional] PlayerStats stats_professional
             */
    
            /**
             * Constructs a new PlayerStats.
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse
             * @classdesc Represents a PlayerStats.
             * @implements IPlayerStats
             * @constructor
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerStats=} [properties] Properties to set
             */
            function PlayerStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerStats account_id.
             * @member {number} account_id
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @instance
             */
            PlayerStats.prototype.account_id = 0;
    
            /**
             * PlayerStats weeks.
             * @member {number} weeks
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @instance
             */
            PlayerStats.prototype.weeks = 0;
    
            /**
             * PlayerStats stats_premium.
             * @member {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator|null|undefined} stats_premium
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @instance
             */
            PlayerStats.prototype.stats_premium = null;
    
            /**
             * PlayerStats stats_professional.
             * @member {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerScoreAccumulator|null|undefined} stats_professional
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @instance
             */
            PlayerStats.prototype.stats_professional = null;
    
            /**
             * Creates a new PlayerStats instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerStats=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats} PlayerStats instance
             */
            PlayerStats.create = function create(properties) {
                return new PlayerStats(properties);
            };
    
            /**
             * Encodes the specified PlayerStats message. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerStats} message PlayerStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account_id != null && Object.hasOwnProperty.call(message, "account_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.account_id);
                if (message.weeks != null && Object.hasOwnProperty.call(message, "weeks"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weeks);
                if (message.stats_premium != null && Object.hasOwnProperty.call(message, "stats_premium"))
                    $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.encode(message.stats_premium, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.stats_professional != null && Object.hasOwnProperty.call(message, "stats_professional"))
                    $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.encode(message.stats_professional, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PlayerStats message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.IPlayerStats} message PlayerStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PlayerStats message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats} PlayerStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.account_id = reader.uint32();
                        break;
                    case 2:
                        message.weeks = reader.uint32();
                        break;
                    case 4:
                        message.stats_premium = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.stats_professional = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PlayerStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats} PlayerStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PlayerStats message.
             * @function verify
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account_id != null && message.hasOwnProperty("account_id"))
                    if (!$util.isInteger(message.account_id))
                        return "account_id: integer expected";
                if (message.weeks != null && message.hasOwnProperty("weeks"))
                    if (!$util.isInteger(message.weeks))
                        return "weeks: integer expected";
                if (message.stats_premium != null && message.hasOwnProperty("stats_premium")) {
                    var error = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.verify(message.stats_premium);
                    if (error)
                        return "stats_premium." + error;
                }
                if (message.stats_professional != null && message.hasOwnProperty("stats_professional")) {
                    var error = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.verify(message.stats_professional);
                    if (error)
                        return "stats_professional." + error;
                }
                return null;
            };
    
            /**
             * Creates a PlayerStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats} PlayerStats
             */
            PlayerStats.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats)
                    return object;
                var message = new $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats();
                if (object.account_id != null)
                    message.account_id = object.account_id >>> 0;
                if (object.weeks != null)
                    message.weeks = object.weeks >>> 0;
                if (object.stats_premium != null) {
                    if (typeof object.stats_premium !== "object")
                        throw TypeError(".CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium: object expected");
                    message.stats_premium = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.fromObject(object.stats_premium);
                }
                if (object.stats_professional != null) {
                    if (typeof object.stats_professional !== "object")
                        throw TypeError(".CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional: object expected");
                    message.stats_professional = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.fromObject(object.stats_professional);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PlayerStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @static
             * @param {CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats} message PlayerStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlayerStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.account_id = 0;
                    object.weeks = 0;
                    object.stats_premium = null;
                    object.stats_professional = null;
                }
                if (message.account_id != null && message.hasOwnProperty("account_id"))
                    object.account_id = message.account_id;
                if (message.weeks != null && message.hasOwnProperty("weeks"))
                    object.weeks = message.weeks;
                if (message.stats_premium != null && message.hasOwnProperty("stats_premium"))
                    object.stats_premium = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.toObject(message.stats_premium, options);
                if (message.stats_professional != null && message.hasOwnProperty("stats_professional"))
                    object.stats_professional = $root.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.toObject(message.stats_professional, options);
                return object;
            };
    
            /**
             * Converts this PlayerStats to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlayerStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PlayerStats;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyPlayerHisoricalStatsResponse;
    })();
    
    $root.CMsgDOTAFantasyMessageAdd = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyMessageAdd.
         * @exports ICMsgDOTAFantasyMessageAdd
         * @interface ICMsgDOTAFantasyMessageAdd
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyMessageAdd fantasy_league_id
         * @property {string|null} [message] CMsgDOTAFantasyMessageAdd message
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyMessageAdd.
         * @exports CMsgDOTAFantasyMessageAdd
         * @classdesc Represents a CMsgDOTAFantasyMessageAdd.
         * @implements ICMsgDOTAFantasyMessageAdd
         * @constructor
         * @param {ICMsgDOTAFantasyMessageAdd=} [properties] Properties to set
         */
        function CMsgDOTAFantasyMessageAdd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyMessageAdd fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyMessageAdd
         * @instance
         */
        CMsgDOTAFantasyMessageAdd.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyMessageAdd message.
         * @member {string} message
         * @memberof CMsgDOTAFantasyMessageAdd
         * @instance
         */
        CMsgDOTAFantasyMessageAdd.prototype.message = "";
    
        /**
         * Creates a new CMsgDOTAFantasyMessageAdd instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {ICMsgDOTAFantasyMessageAdd=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyMessageAdd} CMsgDOTAFantasyMessageAdd instance
         */
        CMsgDOTAFantasyMessageAdd.create = function create(properties) {
            return new CMsgDOTAFantasyMessageAdd(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyMessageAdd message. Does not implicitly {@link CMsgDOTAFantasyMessageAdd.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {ICMsgDOTAFantasyMessageAdd} message CMsgDOTAFantasyMessageAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyMessageAdd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyMessageAdd message, length delimited. Does not implicitly {@link CMsgDOTAFantasyMessageAdd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {ICMsgDOTAFantasyMessageAdd} message CMsgDOTAFantasyMessageAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyMessageAdd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyMessageAdd message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyMessageAdd} CMsgDOTAFantasyMessageAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyMessageAdd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyMessageAdd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyMessageAdd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyMessageAdd} CMsgDOTAFantasyMessageAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyMessageAdd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyMessageAdd message.
         * @function verify
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyMessageAdd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyMessageAdd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyMessageAdd} CMsgDOTAFantasyMessageAdd
         */
        CMsgDOTAFantasyMessageAdd.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyMessageAdd)
                return object;
            var message = new $root.CMsgDOTAFantasyMessageAdd();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyMessageAdd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyMessageAdd
         * @static
         * @param {CMsgDOTAFantasyMessageAdd} message CMsgDOTAFantasyMessageAdd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyMessageAdd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.message = "";
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyMessageAdd to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyMessageAdd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyMessageAdd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyMessageAdd;
    })();
    
    $root.CMsgDOTAFantasyMessagesRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyMessagesRequest.
         * @exports ICMsgDOTAFantasyMessagesRequest
         * @interface ICMsgDOTAFantasyMessagesRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyMessagesRequest fantasy_league_id
         * @property {number|null} [start_message] CMsgDOTAFantasyMessagesRequest start_message
         * @property {number|null} [end_message] CMsgDOTAFantasyMessagesRequest end_message
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyMessagesRequest.
         * @exports CMsgDOTAFantasyMessagesRequest
         * @classdesc Represents a CMsgDOTAFantasyMessagesRequest.
         * @implements ICMsgDOTAFantasyMessagesRequest
         * @constructor
         * @param {ICMsgDOTAFantasyMessagesRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyMessagesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyMessagesRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @instance
         */
        CMsgDOTAFantasyMessagesRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyMessagesRequest start_message.
         * @member {number} start_message
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @instance
         */
        CMsgDOTAFantasyMessagesRequest.prototype.start_message = 0;
    
        /**
         * CMsgDOTAFantasyMessagesRequest end_message.
         * @member {number} end_message
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @instance
         */
        CMsgDOTAFantasyMessagesRequest.prototype.end_message = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyMessagesRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {ICMsgDOTAFantasyMessagesRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyMessagesRequest} CMsgDOTAFantasyMessagesRequest instance
         */
        CMsgDOTAFantasyMessagesRequest.create = function create(properties) {
            return new CMsgDOTAFantasyMessagesRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyMessagesRequest message. Does not implicitly {@link CMsgDOTAFantasyMessagesRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {ICMsgDOTAFantasyMessagesRequest} message CMsgDOTAFantasyMessagesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyMessagesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.start_message != null && Object.hasOwnProperty.call(message, "start_message"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.start_message);
            if (message.end_message != null && Object.hasOwnProperty.call(message, "end_message"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.end_message);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyMessagesRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyMessagesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {ICMsgDOTAFantasyMessagesRequest} message CMsgDOTAFantasyMessagesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyMessagesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyMessagesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyMessagesRequest} CMsgDOTAFantasyMessagesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyMessagesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyMessagesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.start_message = reader.uint32();
                    break;
                case 3:
                    message.end_message = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyMessagesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyMessagesRequest} CMsgDOTAFantasyMessagesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyMessagesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyMessagesRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyMessagesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.start_message != null && message.hasOwnProperty("start_message"))
                if (!$util.isInteger(message.start_message))
                    return "start_message: integer expected";
            if (message.end_message != null && message.hasOwnProperty("end_message"))
                if (!$util.isInteger(message.end_message))
                    return "end_message: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyMessagesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyMessagesRequest} CMsgDOTAFantasyMessagesRequest
         */
        CMsgDOTAFantasyMessagesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyMessagesRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyMessagesRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.start_message != null)
                message.start_message = object.start_message >>> 0;
            if (object.end_message != null)
                message.end_message = object.end_message >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyMessagesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @static
         * @param {CMsgDOTAFantasyMessagesRequest} message CMsgDOTAFantasyMessagesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyMessagesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.start_message = 0;
                object.end_message = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.start_message != null && message.hasOwnProperty("start_message"))
                object.start_message = message.start_message;
            if (message.end_message != null && message.hasOwnProperty("end_message"))
                object.end_message = message.end_message;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyMessagesRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyMessagesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyMessagesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyMessagesRequest;
    })();
    
    $root.CMsgDOTAFantasyMessagesResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyMessagesResponse.
         * @exports ICMsgDOTAFantasyMessagesResponse
         * @interface ICMsgDOTAFantasyMessagesResponse
         * @property {CMsgDOTAFantasyMessagesResponse.EResult|null} [result] CMsgDOTAFantasyMessagesResponse result
         * @property {Array.<CMsgDOTAFantasyMessagesResponse.IMessage>|null} [messages] CMsgDOTAFantasyMessagesResponse messages
         * @property {number|null} [num_total_messages] CMsgDOTAFantasyMessagesResponse num_total_messages
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyMessagesResponse.
         * @exports CMsgDOTAFantasyMessagesResponse
         * @classdesc Represents a CMsgDOTAFantasyMessagesResponse.
         * @implements ICMsgDOTAFantasyMessagesResponse
         * @constructor
         * @param {ICMsgDOTAFantasyMessagesResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyMessagesResponse(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyMessagesResponse result.
         * @member {CMsgDOTAFantasyMessagesResponse.EResult} result
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @instance
         */
        CMsgDOTAFantasyMessagesResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyMessagesResponse messages.
         * @member {Array.<CMsgDOTAFantasyMessagesResponse.IMessage>} messages
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @instance
         */
        CMsgDOTAFantasyMessagesResponse.prototype.messages = $util.emptyArray;
    
        /**
         * CMsgDOTAFantasyMessagesResponse num_total_messages.
         * @member {number} num_total_messages
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @instance
         */
        CMsgDOTAFantasyMessagesResponse.prototype.num_total_messages = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyMessagesResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {ICMsgDOTAFantasyMessagesResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyMessagesResponse} CMsgDOTAFantasyMessagesResponse instance
         */
        CMsgDOTAFantasyMessagesResponse.create = function create(properties) {
            return new CMsgDOTAFantasyMessagesResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyMessagesResponse message. Does not implicitly {@link CMsgDOTAFantasyMessagesResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {ICMsgDOTAFantasyMessagesResponse} message CMsgDOTAFantasyMessagesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyMessagesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.CMsgDOTAFantasyMessagesResponse.Message.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.num_total_messages != null && Object.hasOwnProperty.call(message, "num_total_messages"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_total_messages);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyMessagesResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyMessagesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {ICMsgDOTAFantasyMessagesResponse} message CMsgDOTAFantasyMessagesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyMessagesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyMessagesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyMessagesResponse} CMsgDOTAFantasyMessagesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyMessagesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyMessagesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.CMsgDOTAFantasyMessagesResponse.Message.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.num_total_messages = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyMessagesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyMessagesResponse} CMsgDOTAFantasyMessagesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyMessagesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyMessagesResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyMessagesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.CMsgDOTAFantasyMessagesResponse.Message.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            if (message.num_total_messages != null && message.hasOwnProperty("num_total_messages"))
                if (!$util.isInteger(message.num_total_messages))
                    return "num_total_messages: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyMessagesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyMessagesResponse} CMsgDOTAFantasyMessagesResponse
         */
        CMsgDOTAFantasyMessagesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyMessagesResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyMessagesResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            }
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".CMsgDOTAFantasyMessagesResponse.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyMessagesResponse.messages: object expected");
                    message.messages[i] = $root.CMsgDOTAFantasyMessagesResponse.Message.fromObject(object.messages[i]);
                }
            }
            if (object.num_total_messages != null)
                message.num_total_messages = object.num_total_messages >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyMessagesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @static
         * @param {CMsgDOTAFantasyMessagesResponse} message CMsgDOTAFantasyMessagesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyMessagesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.num_total_messages = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyMessagesResponse.EResult[message.result] : message.result;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.CMsgDOTAFantasyMessagesResponse.Message.toObject(message.messages[j], options);
            }
            if (message.num_total_messages != null && message.hasOwnProperty("num_total_messages"))
                object.num_total_messages = message.num_total_messages;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyMessagesResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyMessagesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyMessagesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyMessagesResponse.Message = (function() {
    
            /**
             * Properties of a Message.
             * @memberof CMsgDOTAFantasyMessagesResponse
             * @interface IMessage
             * @property {number|null} [message_id] Message message_id
             * @property {string|null} [message] Message message
             * @property {number|null} [author_account_id] Message author_account_id
             * @property {number|null} [time] Message time
             */
    
            /**
             * Constructs a new Message.
             * @memberof CMsgDOTAFantasyMessagesResponse
             * @classdesc Represents a Message.
             * @implements IMessage
             * @constructor
             * @param {CMsgDOTAFantasyMessagesResponse.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Message message_id.
             * @member {number} message_id
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @instance
             */
            Message.prototype.message_id = 0;
    
            /**
             * Message message.
             * @member {string} message
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @instance
             */
            Message.prototype.message = "";
    
            /**
             * Message author_account_id.
             * @member {number} author_account_id
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @instance
             */
            Message.prototype.author_account_id = 0;
    
            /**
             * Message time.
             * @member {number} time
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @instance
             */
            Message.prototype.time = 0;
    
            /**
             * Creates a new Message instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {CMsgDOTAFantasyMessagesResponse.IMessage=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyMessagesResponse.Message} Message instance
             */
            Message.create = function create(properties) {
                return new Message(properties);
            };
    
            /**
             * Encodes the specified Message message. Does not implicitly {@link CMsgDOTAFantasyMessagesResponse.Message.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {CMsgDOTAFantasyMessagesResponse.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.message_id);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.author_account_id != null && Object.hasOwnProperty.call(message, "author_account_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.author_account_id);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.time);
                return writer;
            };
    
            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link CMsgDOTAFantasyMessagesResponse.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {CMsgDOTAFantasyMessagesResponse.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyMessagesResponse.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyMessagesResponse.Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.message_id = reader.uint32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.author_account_id = reader.uint32();
                        break;
                    case 4:
                        message.time = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyMessagesResponse.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Message message.
             * @function verify
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isInteger(message.message_id))
                        return "message_id: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.author_account_id != null && message.hasOwnProperty("author_account_id"))
                    if (!$util.isInteger(message.author_account_id))
                        return "author_account_id: integer expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                return null;
            };
    
            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyMessagesResponse.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyMessagesResponse.Message)
                    return object;
                var message = new $root.CMsgDOTAFantasyMessagesResponse.Message();
                if (object.message_id != null)
                    message.message_id = object.message_id >>> 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.author_account_id != null)
                    message.author_account_id = object.author_account_id >>> 0;
                if (object.time != null)
                    message.time = object.time >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @static
             * @param {CMsgDOTAFantasyMessagesResponse.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.message_id = 0;
                    object.message = "";
                    object.author_account_id = 0;
                    object.time = 0;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.author_account_id != null && message.hasOwnProperty("author_account_id"))
                    object.author_account_id = message.author_account_id;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                return object;
            };
    
            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyMessagesResponse.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Message;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyMessagesResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         */
        CMsgDOTAFantasyMessagesResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyMessagesResponse;
    })();
    
    $root.CMsgDOTAFantasyRemoveOwner = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyRemoveOwner.
         * @exports ICMsgDOTAFantasyRemoveOwner
         * @interface ICMsgDOTAFantasyRemoveOwner
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyRemoveOwner fantasy_league_id
         * @property {number|null} [owner_account_id] CMsgDOTAFantasyRemoveOwner owner_account_id
         * @property {number|null} [team_index] CMsgDOTAFantasyRemoveOwner team_index
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyRemoveOwner.
         * @exports CMsgDOTAFantasyRemoveOwner
         * @classdesc Represents a CMsgDOTAFantasyRemoveOwner.
         * @implements ICMsgDOTAFantasyRemoveOwner
         * @constructor
         * @param {ICMsgDOTAFantasyRemoveOwner=} [properties] Properties to set
         */
        function CMsgDOTAFantasyRemoveOwner(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyRemoveOwner fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @instance
         */
        CMsgDOTAFantasyRemoveOwner.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyRemoveOwner owner_account_id.
         * @member {number} owner_account_id
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @instance
         */
        CMsgDOTAFantasyRemoveOwner.prototype.owner_account_id = 0;
    
        /**
         * CMsgDOTAFantasyRemoveOwner team_index.
         * @member {number} team_index
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @instance
         */
        CMsgDOTAFantasyRemoveOwner.prototype.team_index = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyRemoveOwner instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {ICMsgDOTAFantasyRemoveOwner=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyRemoveOwner} CMsgDOTAFantasyRemoveOwner instance
         */
        CMsgDOTAFantasyRemoveOwner.create = function create(properties) {
            return new CMsgDOTAFantasyRemoveOwner(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyRemoveOwner message. Does not implicitly {@link CMsgDOTAFantasyRemoveOwner.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {ICMsgDOTAFantasyRemoveOwner} message CMsgDOTAFantasyRemoveOwner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyRemoveOwner.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.owner_account_id != null && Object.hasOwnProperty.call(message, "owner_account_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.owner_account_id);
            if (message.team_index != null && Object.hasOwnProperty.call(message, "team_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team_index);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyRemoveOwner message, length delimited. Does not implicitly {@link CMsgDOTAFantasyRemoveOwner.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {ICMsgDOTAFantasyRemoveOwner} message CMsgDOTAFantasyRemoveOwner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyRemoveOwner.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyRemoveOwner message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyRemoveOwner} CMsgDOTAFantasyRemoveOwner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyRemoveOwner.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyRemoveOwner();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.owner_account_id = reader.uint32();
                    break;
                case 3:
                    message.team_index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyRemoveOwner message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyRemoveOwner} CMsgDOTAFantasyRemoveOwner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyRemoveOwner.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyRemoveOwner message.
         * @function verify
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyRemoveOwner.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                if (!$util.isInteger(message.owner_account_id))
                    return "owner_account_id: integer expected";
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                if (!$util.isInteger(message.team_index))
                    return "team_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyRemoveOwner message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyRemoveOwner} CMsgDOTAFantasyRemoveOwner
         */
        CMsgDOTAFantasyRemoveOwner.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyRemoveOwner)
                return object;
            var message = new $root.CMsgDOTAFantasyRemoveOwner();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.owner_account_id != null)
                message.owner_account_id = object.owner_account_id >>> 0;
            if (object.team_index != null)
                message.team_index = object.team_index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyRemoveOwner message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @static
         * @param {CMsgDOTAFantasyRemoveOwner} message CMsgDOTAFantasyRemoveOwner
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyRemoveOwner.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.owner_account_id = 0;
                object.team_index = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.owner_account_id != null && message.hasOwnProperty("owner_account_id"))
                object.owner_account_id = message.owner_account_id;
            if (message.team_index != null && message.hasOwnProperty("team_index"))
                object.team_index = message.team_index;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyRemoveOwner to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyRemoveOwner
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyRemoveOwner.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyRemoveOwner;
    })();
    
    $root.CMsgDOTAFantasyRemoveOwnerResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyRemoveOwnerResponse.
         * @exports ICMsgDOTAFantasyRemoveOwnerResponse
         * @interface ICMsgDOTAFantasyRemoveOwnerResponse
         * @property {CMsgDOTAFantasyRemoveOwnerResponse.EResult|null} [result] CMsgDOTAFantasyRemoveOwnerResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyRemoveOwnerResponse.
         * @exports CMsgDOTAFantasyRemoveOwnerResponse
         * @classdesc Represents a CMsgDOTAFantasyRemoveOwnerResponse.
         * @implements ICMsgDOTAFantasyRemoveOwnerResponse
         * @constructor
         * @param {ICMsgDOTAFantasyRemoveOwnerResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyRemoveOwnerResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyRemoveOwnerResponse result.
         * @member {CMsgDOTAFantasyRemoveOwnerResponse.EResult} result
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @instance
         */
        CMsgDOTAFantasyRemoveOwnerResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyRemoveOwnerResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {ICMsgDOTAFantasyRemoveOwnerResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyRemoveOwnerResponse} CMsgDOTAFantasyRemoveOwnerResponse instance
         */
        CMsgDOTAFantasyRemoveOwnerResponse.create = function create(properties) {
            return new CMsgDOTAFantasyRemoveOwnerResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyRemoveOwnerResponse message. Does not implicitly {@link CMsgDOTAFantasyRemoveOwnerResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {ICMsgDOTAFantasyRemoveOwnerResponse} message CMsgDOTAFantasyRemoveOwnerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyRemoveOwnerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyRemoveOwnerResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyRemoveOwnerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {ICMsgDOTAFantasyRemoveOwnerResponse} message CMsgDOTAFantasyRemoveOwnerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyRemoveOwnerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyRemoveOwnerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyRemoveOwnerResponse} CMsgDOTAFantasyRemoveOwnerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyRemoveOwnerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyRemoveOwnerResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyRemoveOwnerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyRemoveOwnerResponse} CMsgDOTAFantasyRemoveOwnerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyRemoveOwnerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyRemoveOwnerResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyRemoveOwnerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyRemoveOwnerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyRemoveOwnerResponse} CMsgDOTAFantasyRemoveOwnerResponse
         */
        CMsgDOTAFantasyRemoveOwnerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyRemoveOwnerResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyRemoveOwnerResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NO_PERMISSION":
            case 2:
                message.result = 2;
                break;
            case "ERROR_LEAGUE_LOCKED":
            case 3:
                message.result = 3;
                break;
            case "ERROR_NOT_A_MEMBER":
            case 4:
                message.result = 4;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyRemoveOwnerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @static
         * @param {CMsgDOTAFantasyRemoveOwnerResponse} message CMsgDOTAFantasyRemoveOwnerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyRemoveOwnerResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyRemoveOwnerResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyRemoveOwnerResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyRemoveOwnerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyRemoveOwnerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyRemoveOwnerResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NO_PERMISSION=2 ERROR_NO_PERMISSION value
         * @property {number} ERROR_LEAGUE_LOCKED=3 ERROR_LEAGUE_LOCKED value
         * @property {number} ERROR_NOT_A_MEMBER=4 ERROR_NOT_A_MEMBER value
         */
        CMsgDOTAFantasyRemoveOwnerResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NO_PERMISSION"] = 2;
            values[valuesById[3] = "ERROR_LEAGUE_LOCKED"] = 3;
            values[valuesById[4] = "ERROR_NOT_A_MEMBER"] = 4;
            return values;
        })();
    
        return CMsgDOTAFantasyRemoveOwnerResponse;
    })();
    
    $root.CMsgDOTAFantasyScheduledMatchesRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyScheduledMatchesRequest.
         * @exports ICMsgDOTAFantasyScheduledMatchesRequest
         * @interface ICMsgDOTAFantasyScheduledMatchesRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyScheduledMatchesRequest fantasy_league_id
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyScheduledMatchesRequest.
         * @exports CMsgDOTAFantasyScheduledMatchesRequest
         * @classdesc Represents a CMsgDOTAFantasyScheduledMatchesRequest.
         * @implements ICMsgDOTAFantasyScheduledMatchesRequest
         * @constructor
         * @param {ICMsgDOTAFantasyScheduledMatchesRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyScheduledMatchesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyScheduledMatchesRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @instance
         */
        CMsgDOTAFantasyScheduledMatchesRequest.prototype.fantasy_league_id = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyScheduledMatchesRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {ICMsgDOTAFantasyScheduledMatchesRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyScheduledMatchesRequest} CMsgDOTAFantasyScheduledMatchesRequest instance
         */
        CMsgDOTAFantasyScheduledMatchesRequest.create = function create(properties) {
            return new CMsgDOTAFantasyScheduledMatchesRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyScheduledMatchesRequest message. Does not implicitly {@link CMsgDOTAFantasyScheduledMatchesRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {ICMsgDOTAFantasyScheduledMatchesRequest} message CMsgDOTAFantasyScheduledMatchesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyScheduledMatchesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyScheduledMatchesRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyScheduledMatchesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {ICMsgDOTAFantasyScheduledMatchesRequest} message CMsgDOTAFantasyScheduledMatchesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyScheduledMatchesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyScheduledMatchesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyScheduledMatchesRequest} CMsgDOTAFantasyScheduledMatchesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyScheduledMatchesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyScheduledMatchesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyScheduledMatchesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyScheduledMatchesRequest} CMsgDOTAFantasyScheduledMatchesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyScheduledMatchesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyScheduledMatchesRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyScheduledMatchesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyScheduledMatchesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyScheduledMatchesRequest} CMsgDOTAFantasyScheduledMatchesRequest
         */
        CMsgDOTAFantasyScheduledMatchesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyScheduledMatchesRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyScheduledMatchesRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyScheduledMatchesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @static
         * @param {CMsgDOTAFantasyScheduledMatchesRequest} message CMsgDOTAFantasyScheduledMatchesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyScheduledMatchesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fantasy_league_id = 0;
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyScheduledMatchesRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyScheduledMatchesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyScheduledMatchesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyScheduledMatchesRequest;
    })();
    
    $root.CMsgDOTAFantasyScheduledMatchesResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyScheduledMatchesResponse.
         * @exports ICMsgDOTAFantasyScheduledMatchesResponse
         * @interface ICMsgDOTAFantasyScheduledMatchesResponse
         * @property {CMsgDOTAFantasyScheduledMatchesResponse.EResult|null} [result] CMsgDOTAFantasyScheduledMatchesResponse result
         * @property {Array.<CMsgDOTAFantasyScheduledMatchesResponse.IScheduledMatchDays>|null} [scheduled_match_days] CMsgDOTAFantasyScheduledMatchesResponse scheduled_match_days
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyScheduledMatchesResponse.
         * @exports CMsgDOTAFantasyScheduledMatchesResponse
         * @classdesc Represents a CMsgDOTAFantasyScheduledMatchesResponse.
         * @implements ICMsgDOTAFantasyScheduledMatchesResponse
         * @constructor
         * @param {ICMsgDOTAFantasyScheduledMatchesResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyScheduledMatchesResponse(properties) {
            this.scheduled_match_days = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyScheduledMatchesResponse result.
         * @member {CMsgDOTAFantasyScheduledMatchesResponse.EResult} result
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @instance
         */
        CMsgDOTAFantasyScheduledMatchesResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyScheduledMatchesResponse scheduled_match_days.
         * @member {Array.<CMsgDOTAFantasyScheduledMatchesResponse.IScheduledMatchDays>} scheduled_match_days
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @instance
         */
        CMsgDOTAFantasyScheduledMatchesResponse.prototype.scheduled_match_days = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyScheduledMatchesResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {ICMsgDOTAFantasyScheduledMatchesResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyScheduledMatchesResponse} CMsgDOTAFantasyScheduledMatchesResponse instance
         */
        CMsgDOTAFantasyScheduledMatchesResponse.create = function create(properties) {
            return new CMsgDOTAFantasyScheduledMatchesResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyScheduledMatchesResponse message. Does not implicitly {@link CMsgDOTAFantasyScheduledMatchesResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {ICMsgDOTAFantasyScheduledMatchesResponse} message CMsgDOTAFantasyScheduledMatchesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyScheduledMatchesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.scheduled_match_days != null && message.scheduled_match_days.length)
                for (var i = 0; i < message.scheduled_match_days.length; ++i)
                    $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.encode(message.scheduled_match_days[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyScheduledMatchesResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyScheduledMatchesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {ICMsgDOTAFantasyScheduledMatchesResponse} message CMsgDOTAFantasyScheduledMatchesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyScheduledMatchesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyScheduledMatchesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyScheduledMatchesResponse} CMsgDOTAFantasyScheduledMatchesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyScheduledMatchesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyScheduledMatchesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.scheduled_match_days && message.scheduled_match_days.length))
                        message.scheduled_match_days = [];
                    message.scheduled_match_days.push($root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyScheduledMatchesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyScheduledMatchesResponse} CMsgDOTAFantasyScheduledMatchesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyScheduledMatchesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyScheduledMatchesResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyScheduledMatchesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.scheduled_match_days != null && message.hasOwnProperty("scheduled_match_days")) {
                if (!Array.isArray(message.scheduled_match_days))
                    return "scheduled_match_days: array expected";
                for (var i = 0; i < message.scheduled_match_days.length; ++i) {
                    var error = $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.verify(message.scheduled_match_days[i]);
                    if (error)
                        return "scheduled_match_days." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyScheduledMatchesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyScheduledMatchesResponse} CMsgDOTAFantasyScheduledMatchesResponse
         */
        CMsgDOTAFantasyScheduledMatchesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyScheduledMatchesResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyScheduledMatchesResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            }
            if (object.scheduled_match_days) {
                if (!Array.isArray(object.scheduled_match_days))
                    throw TypeError(".CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days: array expected");
                message.scheduled_match_days = [];
                for (var i = 0; i < object.scheduled_match_days.length; ++i) {
                    if (typeof object.scheduled_match_days[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days: object expected");
                    message.scheduled_match_days[i] = $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.fromObject(object.scheduled_match_days[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyScheduledMatchesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @static
         * @param {CMsgDOTAFantasyScheduledMatchesResponse} message CMsgDOTAFantasyScheduledMatchesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyScheduledMatchesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.scheduled_match_days = [];
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyScheduledMatchesResponse.EResult[message.result] : message.result;
            if (message.scheduled_match_days && message.scheduled_match_days.length) {
                object.scheduled_match_days = [];
                for (var j = 0; j < message.scheduled_match_days.length; ++j)
                    object.scheduled_match_days[j] = $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.toObject(message.scheduled_match_days[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyScheduledMatchesResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyScheduledMatchesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyScheduledMatchesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays = (function() {
    
            /**
             * Properties of a ScheduledMatchDays.
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse
             * @interface IScheduledMatchDays
             * @property {number|null} [timestamp] ScheduledMatchDays timestamp
             * @property {Array.<number>|null} [team_ids] ScheduledMatchDays team_ids
             * @property {Array.<number>|null} [league_ids] ScheduledMatchDays league_ids
             */
    
            /**
             * Constructs a new ScheduledMatchDays.
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse
             * @classdesc Represents a ScheduledMatchDays.
             * @implements IScheduledMatchDays
             * @constructor
             * @param {CMsgDOTAFantasyScheduledMatchesResponse.IScheduledMatchDays=} [properties] Properties to set
             */
            function ScheduledMatchDays(properties) {
                this.team_ids = [];
                this.league_ids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ScheduledMatchDays timestamp.
             * @member {number} timestamp
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @instance
             */
            ScheduledMatchDays.prototype.timestamp = 0;
    
            /**
             * ScheduledMatchDays team_ids.
             * @member {Array.<number>} team_ids
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @instance
             */
            ScheduledMatchDays.prototype.team_ids = $util.emptyArray;
    
            /**
             * ScheduledMatchDays league_ids.
             * @member {Array.<number>} league_ids
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @instance
             */
            ScheduledMatchDays.prototype.league_ids = $util.emptyArray;
    
            /**
             * Creates a new ScheduledMatchDays instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {CMsgDOTAFantasyScheduledMatchesResponse.IScheduledMatchDays=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays} ScheduledMatchDays instance
             */
            ScheduledMatchDays.create = function create(properties) {
                return new ScheduledMatchDays(properties);
            };
    
            /**
             * Encodes the specified ScheduledMatchDays message. Does not implicitly {@link CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {CMsgDOTAFantasyScheduledMatchesResponse.IScheduledMatchDays} message ScheduledMatchDays message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduledMatchDays.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp);
                if (message.team_ids != null && message.team_ids.length)
                    for (var i = 0; i < message.team_ids.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.team_ids[i]);
                if (message.league_ids != null && message.league_ids.length)
                    for (var i = 0; i < message.league_ids.length; ++i)
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.league_ids[i]);
                return writer;
            };
    
            /**
             * Encodes the specified ScheduledMatchDays message, length delimited. Does not implicitly {@link CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {CMsgDOTAFantasyScheduledMatchesResponse.IScheduledMatchDays} message ScheduledMatchDays message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduledMatchDays.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ScheduledMatchDays message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays} ScheduledMatchDays
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduledMatchDays.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.uint32();
                        break;
                    case 2:
                        if (!(message.team_ids && message.team_ids.length))
                            message.team_ids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.team_ids.push(reader.uint32());
                        } else
                            message.team_ids.push(reader.uint32());
                        break;
                    case 3:
                        if (!(message.league_ids && message.league_ids.length))
                            message.league_ids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.league_ids.push(reader.uint32());
                        } else
                            message.league_ids.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ScheduledMatchDays message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays} ScheduledMatchDays
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduledMatchDays.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ScheduledMatchDays message.
             * @function verify
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScheduledMatchDays.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp))
                        return "timestamp: integer expected";
                if (message.team_ids != null && message.hasOwnProperty("team_ids")) {
                    if (!Array.isArray(message.team_ids))
                        return "team_ids: array expected";
                    for (var i = 0; i < message.team_ids.length; ++i)
                        if (!$util.isInteger(message.team_ids[i]))
                            return "team_ids: integer[] expected";
                }
                if (message.league_ids != null && message.hasOwnProperty("league_ids")) {
                    if (!Array.isArray(message.league_ids))
                        return "league_ids: array expected";
                    for (var i = 0; i < message.league_ids.length; ++i)
                        if (!$util.isInteger(message.league_ids[i]))
                            return "league_ids: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a ScheduledMatchDays message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays} ScheduledMatchDays
             */
            ScheduledMatchDays.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays)
                    return object;
                var message = new $root.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays();
                if (object.timestamp != null)
                    message.timestamp = object.timestamp >>> 0;
                if (object.team_ids) {
                    if (!Array.isArray(object.team_ids))
                        throw TypeError(".CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids: array expected");
                    message.team_ids = [];
                    for (var i = 0; i < object.team_ids.length; ++i)
                        message.team_ids[i] = object.team_ids[i] >>> 0;
                }
                if (object.league_ids) {
                    if (!Array.isArray(object.league_ids))
                        throw TypeError(".CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids: array expected");
                    message.league_ids = [];
                    for (var i = 0; i < object.league_ids.length; ++i)
                        message.league_ids[i] = object.league_ids[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ScheduledMatchDays message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @static
             * @param {CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays} message ScheduledMatchDays
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScheduledMatchDays.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.team_ids = [];
                    object.league_ids = [];
                }
                if (options.defaults)
                    object.timestamp = 0;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                if (message.team_ids && message.team_ids.length) {
                    object.team_ids = [];
                    for (var j = 0; j < message.team_ids.length; ++j)
                        object.team_ids[j] = message.team_ids[j];
                }
                if (message.league_ids && message.league_ids.length) {
                    object.league_ids = [];
                    for (var j = 0; j < message.league_ids.length; ++j)
                        object.league_ids[j] = message.league_ids[j];
                }
                return object;
            };
    
            /**
             * Converts this ScheduledMatchDays to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScheduledMatchDays.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ScheduledMatchDays;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyScheduledMatchesResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         */
        CMsgDOTAFantasyScheduledMatchesResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            return values;
        })();
    
        return CMsgDOTAFantasyScheduledMatchesResponse;
    })();
    
    $root.CMsgDOTAFantasyLeaveLeagueRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeaveLeagueRequest.
         * @exports ICMsgDOTAFantasyLeaveLeagueRequest
         * @interface ICMsgDOTAFantasyLeaveLeagueRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyLeaveLeagueRequest fantasy_league_id
         * @property {number|null} [fantasy_team_index] CMsgDOTAFantasyLeaveLeagueRequest fantasy_team_index
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeaveLeagueRequest.
         * @exports CMsgDOTAFantasyLeaveLeagueRequest
         * @classdesc Represents a CMsgDOTAFantasyLeaveLeagueRequest.
         * @implements ICMsgDOTAFantasyLeaveLeagueRequest
         * @constructor
         * @param {ICMsgDOTAFantasyLeaveLeagueRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeaveLeagueRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeaveLeagueRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @instance
         */
        CMsgDOTAFantasyLeaveLeagueRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyLeaveLeagueRequest fantasy_team_index.
         * @member {number} fantasy_team_index
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @instance
         */
        CMsgDOTAFantasyLeaveLeagueRequest.prototype.fantasy_team_index = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeaveLeagueRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {ICMsgDOTAFantasyLeaveLeagueRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeaveLeagueRequest} CMsgDOTAFantasyLeaveLeagueRequest instance
         */
        CMsgDOTAFantasyLeaveLeagueRequest.create = function create(properties) {
            return new CMsgDOTAFantasyLeaveLeagueRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeaveLeagueRequest message. Does not implicitly {@link CMsgDOTAFantasyLeaveLeagueRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {ICMsgDOTAFantasyLeaveLeagueRequest} message CMsgDOTAFantasyLeaveLeagueRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeaveLeagueRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.fantasy_team_index != null && Object.hasOwnProperty.call(message, "fantasy_team_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fantasy_team_index);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeaveLeagueRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeaveLeagueRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {ICMsgDOTAFantasyLeaveLeagueRequest} message CMsgDOTAFantasyLeaveLeagueRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeaveLeagueRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeaveLeagueRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeaveLeagueRequest} CMsgDOTAFantasyLeaveLeagueRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeaveLeagueRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeaveLeagueRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.fantasy_team_index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeaveLeagueRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeaveLeagueRequest} CMsgDOTAFantasyLeaveLeagueRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeaveLeagueRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeaveLeagueRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeaveLeagueRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                if (!$util.isInteger(message.fantasy_team_index))
                    return "fantasy_team_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeaveLeagueRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeaveLeagueRequest} CMsgDOTAFantasyLeaveLeagueRequest
         */
        CMsgDOTAFantasyLeaveLeagueRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeaveLeagueRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyLeaveLeagueRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.fantasy_team_index != null)
                message.fantasy_team_index = object.fantasy_team_index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeaveLeagueRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @static
         * @param {CMsgDOTAFantasyLeaveLeagueRequest} message CMsgDOTAFantasyLeaveLeagueRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeaveLeagueRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.fantasy_team_index = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.fantasy_team_index != null && message.hasOwnProperty("fantasy_team_index"))
                object.fantasy_team_index = message.fantasy_team_index;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeaveLeagueRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeaveLeagueRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeaveLeagueRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyLeaveLeagueRequest;
    })();
    
    $root.CMsgDOTAFantasyLeaveLeagueResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyLeaveLeagueResponse.
         * @exports ICMsgDOTAFantasyLeaveLeagueResponse
         * @interface ICMsgDOTAFantasyLeaveLeagueResponse
         * @property {CMsgDOTAFantasyLeaveLeagueResponse.EResult|null} [result] CMsgDOTAFantasyLeaveLeagueResponse result
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyLeaveLeagueResponse.
         * @exports CMsgDOTAFantasyLeaveLeagueResponse
         * @classdesc Represents a CMsgDOTAFantasyLeaveLeagueResponse.
         * @implements ICMsgDOTAFantasyLeaveLeagueResponse
         * @constructor
         * @param {ICMsgDOTAFantasyLeaveLeagueResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyLeaveLeagueResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyLeaveLeagueResponse result.
         * @member {CMsgDOTAFantasyLeaveLeagueResponse.EResult} result
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @instance
         */
        CMsgDOTAFantasyLeaveLeagueResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyLeaveLeagueResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {ICMsgDOTAFantasyLeaveLeagueResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyLeaveLeagueResponse} CMsgDOTAFantasyLeaveLeagueResponse instance
         */
        CMsgDOTAFantasyLeaveLeagueResponse.create = function create(properties) {
            return new CMsgDOTAFantasyLeaveLeagueResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeaveLeagueResponse message. Does not implicitly {@link CMsgDOTAFantasyLeaveLeagueResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {ICMsgDOTAFantasyLeaveLeagueResponse} message CMsgDOTAFantasyLeaveLeagueResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeaveLeagueResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyLeaveLeagueResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyLeaveLeagueResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {ICMsgDOTAFantasyLeaveLeagueResponse} message CMsgDOTAFantasyLeaveLeagueResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyLeaveLeagueResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeaveLeagueResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyLeaveLeagueResponse} CMsgDOTAFantasyLeaveLeagueResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeaveLeagueResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyLeaveLeagueResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyLeaveLeagueResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyLeaveLeagueResponse} CMsgDOTAFantasyLeaveLeagueResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyLeaveLeagueResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyLeaveLeagueResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyLeaveLeagueResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyLeaveLeagueResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyLeaveLeagueResponse} CMsgDOTAFantasyLeaveLeagueResponse
         */
        CMsgDOTAFantasyLeaveLeagueResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyLeaveLeagueResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyLeaveLeagueResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NOT_MEMBER":
            case 2:
                message.result = 2;
                break;
            case "ERROR_LEAGUE_NOT_FOUND":
            case 3:
                message.result = 3;
                break;
            case "ERROR_DRAFT_ACTIVE":
            case 4:
                message.result = 4;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyLeaveLeagueResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @static
         * @param {CMsgDOTAFantasyLeaveLeagueResponse} message CMsgDOTAFantasyLeaveLeagueResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyLeaveLeagueResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyLeaveLeagueResponse.EResult[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyLeaveLeagueResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyLeaveLeagueResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyLeaveLeagueResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyLeaveLeagueResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NOT_MEMBER=2 ERROR_NOT_MEMBER value
         * @property {number} ERROR_LEAGUE_NOT_FOUND=3 ERROR_LEAGUE_NOT_FOUND value
         * @property {number} ERROR_DRAFT_ACTIVE=4 ERROR_DRAFT_ACTIVE value
         */
        CMsgDOTAFantasyLeaveLeagueResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NOT_MEMBER"] = 2;
            values[valuesById[3] = "ERROR_LEAGUE_NOT_FOUND"] = 3;
            values[valuesById[4] = "ERROR_DRAFT_ACTIVE"] = 4;
            return values;
        })();
    
        return CMsgDOTAFantasyLeaveLeagueResponse;
    })();
    
    $root.CMsgDOTAFantasyPlayerScoreDetailsRequest = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerScoreDetailsRequest.
         * @exports ICMsgDOTAFantasyPlayerScoreDetailsRequest
         * @interface ICMsgDOTAFantasyPlayerScoreDetailsRequest
         * @property {number|null} [fantasy_league_id] CMsgDOTAFantasyPlayerScoreDetailsRequest fantasy_league_id
         * @property {number|null} [player_account_id] CMsgDOTAFantasyPlayerScoreDetailsRequest player_account_id
         * @property {number|null} [start_time] CMsgDOTAFantasyPlayerScoreDetailsRequest start_time
         * @property {number|null} [end_time] CMsgDOTAFantasyPlayerScoreDetailsRequest end_time
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerScoreDetailsRequest.
         * @exports CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @classdesc Represents a CMsgDOTAFantasyPlayerScoreDetailsRequest.
         * @implements ICMsgDOTAFantasyPlayerScoreDetailsRequest
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsRequest=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerScoreDetailsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerScoreDetailsRequest fantasy_league_id.
         * @member {number} fantasy_league_id
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.prototype.fantasy_league_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreDetailsRequest player_account_id.
         * @member {number} player_account_id
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.prototype.player_account_id = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreDetailsRequest start_time.
         * @member {number} start_time
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.prototype.start_time = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreDetailsRequest end_time.
         * @member {number} end_time
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.prototype.end_time = 0;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerScoreDetailsRequest instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsRequest=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsRequest} CMsgDOTAFantasyPlayerScoreDetailsRequest instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerScoreDetailsRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreDetailsRequest message. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreDetailsRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsRequest} message CMsgDOTAFantasyPlayerScoreDetailsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fantasy_league_id != null && Object.hasOwnProperty.call(message, "fantasy_league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fantasy_league_id);
            if (message.player_account_id != null && Object.hasOwnProperty.call(message, "player_account_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player_account_id);
            if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.start_time);
            if (message.end_time != null && Object.hasOwnProperty.call(message, "end_time"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.end_time);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreDetailsRequest message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreDetailsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsRequest} message CMsgDOTAFantasyPlayerScoreDetailsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreDetailsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsRequest} CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerScoreDetailsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fantasy_league_id = reader.uint32();
                    break;
                case 2:
                    message.player_account_id = reader.uint32();
                    break;
                case 3:
                    message.start_time = reader.uint32();
                    break;
                case 4:
                    message.end_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreDetailsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsRequest} CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerScoreDetailsRequest message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                if (!$util.isInteger(message.fantasy_league_id))
                    return "fantasy_league_id: integer expected";
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                if (!$util.isInteger(message.player_account_id))
                    return "player_account_id: integer expected";
            if (message.start_time != null && message.hasOwnProperty("start_time"))
                if (!$util.isInteger(message.start_time))
                    return "start_time: integer expected";
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                if (!$util.isInteger(message.end_time))
                    return "end_time: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerScoreDetailsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsRequest} CMsgDOTAFantasyPlayerScoreDetailsRequest
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerScoreDetailsRequest)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerScoreDetailsRequest();
            if (object.fantasy_league_id != null)
                message.fantasy_league_id = object.fantasy_league_id >>> 0;
            if (object.player_account_id != null)
                message.player_account_id = object.player_account_id >>> 0;
            if (object.start_time != null)
                message.start_time = object.start_time >>> 0;
            if (object.end_time != null)
                message.end_time = object.end_time >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerScoreDetailsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @static
         * @param {CMsgDOTAFantasyPlayerScoreDetailsRequest} message CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fantasy_league_id = 0;
                object.player_account_id = 0;
                object.start_time = 0;
                object.end_time = 0;
            }
            if (message.fantasy_league_id != null && message.hasOwnProperty("fantasy_league_id"))
                object.fantasy_league_id = message.fantasy_league_id;
            if (message.player_account_id != null && message.hasOwnProperty("player_account_id"))
                object.player_account_id = message.player_account_id;
            if (message.start_time != null && message.hasOwnProperty("start_time"))
                object.start_time = message.start_time;
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                object.end_time = message.end_time;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerScoreDetailsRequest to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerScoreDetailsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAFantasyPlayerScoreDetailsRequest;
    })();
    
    $root.CMsgDOTAFantasyPlayerScoreDetailsResponse = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyPlayerScoreDetailsResponse.
         * @exports ICMsgDOTAFantasyPlayerScoreDetailsResponse
         * @interface ICMsgDOTAFantasyPlayerScoreDetailsResponse
         * @property {CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult|null} [result] CMsgDOTAFantasyPlayerScoreDetailsResponse result
         * @property {Array.<CMsgDOTAFantasyPlayerScoreDetailsResponse.IPlayerMatchData>|null} [data] CMsgDOTAFantasyPlayerScoreDetailsResponse data
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyPlayerScoreDetailsResponse.
         * @exports CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @classdesc Represents a CMsgDOTAFantasyPlayerScoreDetailsResponse.
         * @implements ICMsgDOTAFantasyPlayerScoreDetailsResponse
         * @constructor
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsResponse=} [properties] Properties to set
         */
        function CMsgDOTAFantasyPlayerScoreDetailsResponse(properties) {
            this.data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyPlayerScoreDetailsResponse result.
         * @member {CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult} result
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.prototype.result = 0;
    
        /**
         * CMsgDOTAFantasyPlayerScoreDetailsResponse data.
         * @member {Array.<CMsgDOTAFantasyPlayerScoreDetailsResponse.IPlayerMatchData>} data
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.prototype.data = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyPlayerScoreDetailsResponse instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsResponse=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse} CMsgDOTAFantasyPlayerScoreDetailsResponse instance
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.create = function create(properties) {
            return new CMsgDOTAFantasyPlayerScoreDetailsResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreDetailsResponse message. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreDetailsResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsResponse} message CMsgDOTAFantasyPlayerScoreDetailsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.data != null && message.data.length)
                for (var i = 0; i < message.data.length; ++i)
                    $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.encode(message.data[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyPlayerScoreDetailsResponse message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreDetailsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {ICMsgDOTAFantasyPlayerScoreDetailsResponse} message CMsgDOTAFantasyPlayerScoreDetailsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreDetailsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse} CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerScoreDetailsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.data && message.data.length))
                        message.data = [];
                    message.data.push($root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyPlayerScoreDetailsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse} CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyPlayerScoreDetailsResponse message.
         * @function verify
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.data != null && message.hasOwnProperty("data")) {
                if (!Array.isArray(message.data))
                    return "data: array expected";
                for (var i = 0; i < message.data.length; ++i) {
                    var error = $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.verify(message.data[i]);
                    if (error)
                        return "data." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyPlayerScoreDetailsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse} CMsgDOTAFantasyPlayerScoreDetailsResponse
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyPlayerScoreDetailsResponse)
                return object;
            var message = new $root.CMsgDOTAFantasyPlayerScoreDetailsResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_NOT_MEMBER":
            case 2:
                message.result = 2;
                break;
            }
            if (object.data) {
                if (!Array.isArray(object.data))
                    throw TypeError(".CMsgDOTAFantasyPlayerScoreDetailsResponse.data: array expected");
                message.data = [];
                for (var i = 0; i < object.data.length; ++i) {
                    if (typeof object.data[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyPlayerScoreDetailsResponse.data: object expected");
                    message.data[i] = $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.fromObject(object.data[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyPlayerScoreDetailsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @static
         * @param {CMsgDOTAFantasyPlayerScoreDetailsResponse} message CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.data = [];
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult[message.result] : message.result;
            if (message.data && message.data.length) {
                object.data = [];
                for (var j = 0; j < message.data.length; ++j)
                    object.data[j] = $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.toObject(message.data[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyPlayerScoreDetailsResponse to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData = (function() {
    
            /**
             * Properties of a PlayerMatchData.
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
             * @interface IPlayerMatchData
             * @property {number|Long|null} [match_id] PlayerMatchData match_id
             * @property {number|null} [series_id] PlayerMatchData series_id
             * @property {number|null} [series_num] PlayerMatchData series_num
             * @property {number|null} [series_type] PlayerMatchData series_type
             * @property {number|null} [league_tier] PlayerMatchData league_tier
             * @property {number|null} [league_id] PlayerMatchData league_id
             * @property {number|null} [opposing_team_id] PlayerMatchData opposing_team_id
             * @property {number|Long|null} [opposing_team_logo] PlayerMatchData opposing_team_logo
             * @property {string|null} [opposing_team_name] PlayerMatchData opposing_team_name
             * @property {number|null} [owned_by] PlayerMatchData owned_by
             * @property {boolean|null} [benched] PlayerMatchData benched
             */
    
            /**
             * Constructs a new PlayerMatchData.
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse
             * @classdesc Represents a PlayerMatchData.
             * @implements IPlayerMatchData
             * @constructor
             * @param {CMsgDOTAFantasyPlayerScoreDetailsResponse.IPlayerMatchData=} [properties] Properties to set
             */
            function PlayerMatchData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerMatchData match_id.
             * @member {number|Long} match_id
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PlayerMatchData series_id.
             * @member {number} series_id
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.series_id = 0;
    
            /**
             * PlayerMatchData series_num.
             * @member {number} series_num
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.series_num = 0;
    
            /**
             * PlayerMatchData series_type.
             * @member {number} series_type
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.series_type = 0;
    
            /**
             * PlayerMatchData league_tier.
             * @member {number} league_tier
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.league_tier = 0;
    
            /**
             * PlayerMatchData league_id.
             * @member {number} league_id
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.league_id = 0;
    
            /**
             * PlayerMatchData opposing_team_id.
             * @member {number} opposing_team_id
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.opposing_team_id = 0;
    
            /**
             * PlayerMatchData opposing_team_logo.
             * @member {number|Long} opposing_team_logo
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.opposing_team_logo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PlayerMatchData opposing_team_name.
             * @member {string} opposing_team_name
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.opposing_team_name = "";
    
            /**
             * PlayerMatchData owned_by.
             * @member {number} owned_by
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.owned_by = 0;
    
            /**
             * PlayerMatchData benched.
             * @member {boolean} benched
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             */
            PlayerMatchData.prototype.benched = false;
    
            /**
             * Creates a new PlayerMatchData instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {CMsgDOTAFantasyPlayerScoreDetailsResponse.IPlayerMatchData=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData} PlayerMatchData instance
             */
            PlayerMatchData.create = function create(properties) {
                return new PlayerMatchData(properties);
            };
    
            /**
             * Encodes the specified PlayerMatchData message. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {CMsgDOTAFantasyPlayerScoreDetailsResponse.IPlayerMatchData} message PlayerMatchData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerMatchData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.match_id);
                if (message.series_id != null && Object.hasOwnProperty.call(message, "series_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.series_id);
                if (message.series_num != null && Object.hasOwnProperty.call(message, "series_num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.series_num);
                if (message.series_type != null && Object.hasOwnProperty.call(message, "series_type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.series_type);
                if (message.league_tier != null && Object.hasOwnProperty.call(message, "league_tier"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.league_tier);
                if (message.league_id != null && Object.hasOwnProperty.call(message, "league_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.league_id);
                if (message.opposing_team_id != null && Object.hasOwnProperty.call(message, "opposing_team_id"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.opposing_team_id);
                if (message.opposing_team_logo != null && Object.hasOwnProperty.call(message, "opposing_team_logo"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.opposing_team_logo);
                if (message.opposing_team_name != null && Object.hasOwnProperty.call(message, "opposing_team_name"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.opposing_team_name);
                if (message.owned_by != null && Object.hasOwnProperty.call(message, "owned_by"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.owned_by);
                if (message.benched != null && Object.hasOwnProperty.call(message, "benched"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.benched);
                return writer;
            };
    
            /**
             * Encodes the specified PlayerMatchData message, length delimited. Does not implicitly {@link CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {CMsgDOTAFantasyPlayerScoreDetailsResponse.IPlayerMatchData} message PlayerMatchData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerMatchData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PlayerMatchData message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData} PlayerMatchData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerMatchData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.match_id = reader.uint64();
                        break;
                    case 2:
                        message.series_id = reader.uint32();
                        break;
                    case 3:
                        message.series_num = reader.uint32();
                        break;
                    case 4:
                        message.series_type = reader.uint32();
                        break;
                    case 5:
                        message.league_tier = reader.uint32();
                        break;
                    case 6:
                        message.league_id = reader.uint32();
                        break;
                    case 7:
                        message.opposing_team_id = reader.uint32();
                        break;
                    case 8:
                        message.opposing_team_logo = reader.uint64();
                        break;
                    case 9:
                        message.opposing_team_name = reader.string();
                        break;
                    case 11:
                        message.owned_by = reader.uint32();
                        break;
                    case 12:
                        message.benched = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PlayerMatchData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData} PlayerMatchData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerMatchData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PlayerMatchData message.
             * @function verify
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerMatchData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.match_id != null && message.hasOwnProperty("match_id"))
                    if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                        return "match_id: integer|Long expected";
                if (message.series_id != null && message.hasOwnProperty("series_id"))
                    if (!$util.isInteger(message.series_id))
                        return "series_id: integer expected";
                if (message.series_num != null && message.hasOwnProperty("series_num"))
                    if (!$util.isInteger(message.series_num))
                        return "series_num: integer expected";
                if (message.series_type != null && message.hasOwnProperty("series_type"))
                    if (!$util.isInteger(message.series_type))
                        return "series_type: integer expected";
                if (message.league_tier != null && message.hasOwnProperty("league_tier"))
                    if (!$util.isInteger(message.league_tier))
                        return "league_tier: integer expected";
                if (message.league_id != null && message.hasOwnProperty("league_id"))
                    if (!$util.isInteger(message.league_id))
                        return "league_id: integer expected";
                if (message.opposing_team_id != null && message.hasOwnProperty("opposing_team_id"))
                    if (!$util.isInteger(message.opposing_team_id))
                        return "opposing_team_id: integer expected";
                if (message.opposing_team_logo != null && message.hasOwnProperty("opposing_team_logo"))
                    if (!$util.isInteger(message.opposing_team_logo) && !(message.opposing_team_logo && $util.isInteger(message.opposing_team_logo.low) && $util.isInteger(message.opposing_team_logo.high)))
                        return "opposing_team_logo: integer|Long expected";
                if (message.opposing_team_name != null && message.hasOwnProperty("opposing_team_name"))
                    if (!$util.isString(message.opposing_team_name))
                        return "opposing_team_name: string expected";
                if (message.owned_by != null && message.hasOwnProperty("owned_by"))
                    if (!$util.isInteger(message.owned_by))
                        return "owned_by: integer expected";
                if (message.benched != null && message.hasOwnProperty("benched"))
                    if (typeof message.benched !== "boolean")
                        return "benched: boolean expected";
                return null;
            };
    
            /**
             * Creates a PlayerMatchData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData} PlayerMatchData
             */
            PlayerMatchData.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData)
                    return object;
                var message = new $root.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData();
                if (object.match_id != null)
                    if ($util.Long)
                        (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                    else if (typeof object.match_id === "string")
                        message.match_id = parseInt(object.match_id, 10);
                    else if (typeof object.match_id === "number")
                        message.match_id = object.match_id;
                    else if (typeof object.match_id === "object")
                        message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
                if (object.series_id != null)
                    message.series_id = object.series_id >>> 0;
                if (object.series_num != null)
                    message.series_num = object.series_num >>> 0;
                if (object.series_type != null)
                    message.series_type = object.series_type >>> 0;
                if (object.league_tier != null)
                    message.league_tier = object.league_tier >>> 0;
                if (object.league_id != null)
                    message.league_id = object.league_id >>> 0;
                if (object.opposing_team_id != null)
                    message.opposing_team_id = object.opposing_team_id >>> 0;
                if (object.opposing_team_logo != null)
                    if ($util.Long)
                        (message.opposing_team_logo = $util.Long.fromValue(object.opposing_team_logo)).unsigned = true;
                    else if (typeof object.opposing_team_logo === "string")
                        message.opposing_team_logo = parseInt(object.opposing_team_logo, 10);
                    else if (typeof object.opposing_team_logo === "number")
                        message.opposing_team_logo = object.opposing_team_logo;
                    else if (typeof object.opposing_team_logo === "object")
                        message.opposing_team_logo = new $util.LongBits(object.opposing_team_logo.low >>> 0, object.opposing_team_logo.high >>> 0).toNumber(true);
                if (object.opposing_team_name != null)
                    message.opposing_team_name = String(object.opposing_team_name);
                if (object.owned_by != null)
                    message.owned_by = object.owned_by >>> 0;
                if (object.benched != null)
                    message.benched = Boolean(object.benched);
                return message;
            };
    
            /**
             * Creates a plain object from a PlayerMatchData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @static
             * @param {CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData} message PlayerMatchData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlayerMatchData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.match_id = options.longs === String ? "0" : 0;
                    object.series_id = 0;
                    object.series_num = 0;
                    object.series_type = 0;
                    object.league_tier = 0;
                    object.league_id = 0;
                    object.opposing_team_id = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.opposing_team_logo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.opposing_team_logo = options.longs === String ? "0" : 0;
                    object.opposing_team_name = "";
                    object.owned_by = 0;
                    object.benched = false;
                }
                if (message.match_id != null && message.hasOwnProperty("match_id"))
                    if (typeof message.match_id === "number")
                        object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                    else
                        object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
                if (message.series_id != null && message.hasOwnProperty("series_id"))
                    object.series_id = message.series_id;
                if (message.series_num != null && message.hasOwnProperty("series_num"))
                    object.series_num = message.series_num;
                if (message.series_type != null && message.hasOwnProperty("series_type"))
                    object.series_type = message.series_type;
                if (message.league_tier != null && message.hasOwnProperty("league_tier"))
                    object.league_tier = message.league_tier;
                if (message.league_id != null && message.hasOwnProperty("league_id"))
                    object.league_id = message.league_id;
                if (message.opposing_team_id != null && message.hasOwnProperty("opposing_team_id"))
                    object.opposing_team_id = message.opposing_team_id;
                if (message.opposing_team_logo != null && message.hasOwnProperty("opposing_team_logo"))
                    if (typeof message.opposing_team_logo === "number")
                        object.opposing_team_logo = options.longs === String ? String(message.opposing_team_logo) : message.opposing_team_logo;
                    else
                        object.opposing_team_logo = options.longs === String ? $util.Long.prototype.toString.call(message.opposing_team_logo) : options.longs === Number ? new $util.LongBits(message.opposing_team_logo.low >>> 0, message.opposing_team_logo.high >>> 0).toNumber(true) : message.opposing_team_logo;
                if (message.opposing_team_name != null && message.hasOwnProperty("opposing_team_name"))
                    object.opposing_team_name = message.opposing_team_name;
                if (message.owned_by != null && message.hasOwnProperty("owned_by"))
                    object.owned_by = message.owned_by;
                if (message.benched != null && message.hasOwnProperty("benched"))
                    object.benched = message.benched;
                return object;
            };
    
            /**
             * Converts this PlayerMatchData to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlayerMatchData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PlayerMatchData;
        })();
    
        /**
         * EResult enum.
         * @name CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_NOT_MEMBER=2 ERROR_NOT_MEMBER value
         */
        CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_NOT_MEMBER"] = 2;
            return values;
        })();
    
        return CMsgDOTAFantasyPlayerScoreDetailsResponse;
    })();
    
    $root.CMsgDOTAPassportVoteTeamGuess = (function() {
    
        /**
         * Properties of a CMsgDOTAPassportVoteTeamGuess.
         * @exports ICMsgDOTAPassportVoteTeamGuess
         * @interface ICMsgDOTAPassportVoteTeamGuess
         * @property {number|null} [league_id] CMsgDOTAPassportVoteTeamGuess league_id
         * @property {number|null} [winner_id] CMsgDOTAPassportVoteTeamGuess winner_id
         * @property {number|null} [runnerup_id] CMsgDOTAPassportVoteTeamGuess runnerup_id
         */
    
        /**
         * Constructs a new CMsgDOTAPassportVoteTeamGuess.
         * @exports CMsgDOTAPassportVoteTeamGuess
         * @classdesc Represents a CMsgDOTAPassportVoteTeamGuess.
         * @implements ICMsgDOTAPassportVoteTeamGuess
         * @constructor
         * @param {ICMsgDOTAPassportVoteTeamGuess=} [properties] Properties to set
         */
        function CMsgDOTAPassportVoteTeamGuess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPassportVoteTeamGuess league_id.
         * @member {number} league_id
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @instance
         */
        CMsgDOTAPassportVoteTeamGuess.prototype.league_id = 0;
    
        /**
         * CMsgDOTAPassportVoteTeamGuess winner_id.
         * @member {number} winner_id
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @instance
         */
        CMsgDOTAPassportVoteTeamGuess.prototype.winner_id = 0;
    
        /**
         * CMsgDOTAPassportVoteTeamGuess runnerup_id.
         * @member {number} runnerup_id
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @instance
         */
        CMsgDOTAPassportVoteTeamGuess.prototype.runnerup_id = 0;
    
        /**
         * Creates a new CMsgDOTAPassportVoteTeamGuess instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {ICMsgDOTAPassportVoteTeamGuess=} [properties] Properties to set
         * @returns {CMsgDOTAPassportVoteTeamGuess} CMsgDOTAPassportVoteTeamGuess instance
         */
        CMsgDOTAPassportVoteTeamGuess.create = function create(properties) {
            return new CMsgDOTAPassportVoteTeamGuess(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportVoteTeamGuess message. Does not implicitly {@link CMsgDOTAPassportVoteTeamGuess.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {ICMsgDOTAPassportVoteTeamGuess} message CMsgDOTAPassportVoteTeamGuess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportVoteTeamGuess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.league_id != null && Object.hasOwnProperty.call(message, "league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.league_id);
            if (message.winner_id != null && Object.hasOwnProperty.call(message, "winner_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.winner_id);
            if (message.runnerup_id != null && Object.hasOwnProperty.call(message, "runnerup_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.runnerup_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportVoteTeamGuess message, length delimited. Does not implicitly {@link CMsgDOTAPassportVoteTeamGuess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {ICMsgDOTAPassportVoteTeamGuess} message CMsgDOTAPassportVoteTeamGuess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportVoteTeamGuess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPassportVoteTeamGuess message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPassportVoteTeamGuess} CMsgDOTAPassportVoteTeamGuess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportVoteTeamGuess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPassportVoteTeamGuess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.league_id = reader.uint32();
                    break;
                case 2:
                    message.winner_id = reader.uint32();
                    break;
                case 3:
                    message.runnerup_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPassportVoteTeamGuess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPassportVoteTeamGuess} CMsgDOTAPassportVoteTeamGuess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportVoteTeamGuess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPassportVoteTeamGuess message.
         * @function verify
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPassportVoteTeamGuess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.league_id != null && message.hasOwnProperty("league_id"))
                if (!$util.isInteger(message.league_id))
                    return "league_id: integer expected";
            if (message.winner_id != null && message.hasOwnProperty("winner_id"))
                if (!$util.isInteger(message.winner_id))
                    return "winner_id: integer expected";
            if (message.runnerup_id != null && message.hasOwnProperty("runnerup_id"))
                if (!$util.isInteger(message.runnerup_id))
                    return "runnerup_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPassportVoteTeamGuess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPassportVoteTeamGuess} CMsgDOTAPassportVoteTeamGuess
         */
        CMsgDOTAPassportVoteTeamGuess.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPassportVoteTeamGuess)
                return object;
            var message = new $root.CMsgDOTAPassportVoteTeamGuess();
            if (object.league_id != null)
                message.league_id = object.league_id >>> 0;
            if (object.winner_id != null)
                message.winner_id = object.winner_id >>> 0;
            if (object.runnerup_id != null)
                message.runnerup_id = object.runnerup_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPassportVoteTeamGuess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @static
         * @param {CMsgDOTAPassportVoteTeamGuess} message CMsgDOTAPassportVoteTeamGuess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPassportVoteTeamGuess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.league_id = 0;
                object.winner_id = 0;
                object.runnerup_id = 0;
            }
            if (message.league_id != null && message.hasOwnProperty("league_id"))
                object.league_id = message.league_id;
            if (message.winner_id != null && message.hasOwnProperty("winner_id"))
                object.winner_id = message.winner_id;
            if (message.runnerup_id != null && message.hasOwnProperty("runnerup_id"))
                object.runnerup_id = message.runnerup_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPassportVoteTeamGuess to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPassportVoteTeamGuess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPassportVoteTeamGuess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAPassportVoteTeamGuess;
    })();
    
    $root.CMsgDOTAPassportVoteGenericSelection = (function() {
    
        /**
         * Properties of a CMsgDOTAPassportVoteGenericSelection.
         * @exports ICMsgDOTAPassportVoteGenericSelection
         * @interface ICMsgDOTAPassportVoteGenericSelection
         * @property {DOTA_2013PassportSelectionIndices|null} [selection_index] CMsgDOTAPassportVoteGenericSelection selection_index
         * @property {number|null} [selection] CMsgDOTAPassportVoteGenericSelection selection
         */
    
        /**
         * Constructs a new CMsgDOTAPassportVoteGenericSelection.
         * @exports CMsgDOTAPassportVoteGenericSelection
         * @classdesc Represents a CMsgDOTAPassportVoteGenericSelection.
         * @implements ICMsgDOTAPassportVoteGenericSelection
         * @constructor
         * @param {ICMsgDOTAPassportVoteGenericSelection=} [properties] Properties to set
         */
        function CMsgDOTAPassportVoteGenericSelection(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPassportVoteGenericSelection selection_index.
         * @member {DOTA_2013PassportSelectionIndices} selection_index
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @instance
         */
        CMsgDOTAPassportVoteGenericSelection.prototype.selection_index = 0;
    
        /**
         * CMsgDOTAPassportVoteGenericSelection selection.
         * @member {number} selection
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @instance
         */
        CMsgDOTAPassportVoteGenericSelection.prototype.selection = 0;
    
        /**
         * Creates a new CMsgDOTAPassportVoteGenericSelection instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {ICMsgDOTAPassportVoteGenericSelection=} [properties] Properties to set
         * @returns {CMsgDOTAPassportVoteGenericSelection} CMsgDOTAPassportVoteGenericSelection instance
         */
        CMsgDOTAPassportVoteGenericSelection.create = function create(properties) {
            return new CMsgDOTAPassportVoteGenericSelection(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportVoteGenericSelection message. Does not implicitly {@link CMsgDOTAPassportVoteGenericSelection.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {ICMsgDOTAPassportVoteGenericSelection} message CMsgDOTAPassportVoteGenericSelection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportVoteGenericSelection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selection_index != null && Object.hasOwnProperty.call(message, "selection_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.selection_index);
            if (message.selection != null && Object.hasOwnProperty.call(message, "selection"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.selection);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportVoteGenericSelection message, length delimited. Does not implicitly {@link CMsgDOTAPassportVoteGenericSelection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {ICMsgDOTAPassportVoteGenericSelection} message CMsgDOTAPassportVoteGenericSelection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportVoteGenericSelection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPassportVoteGenericSelection message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPassportVoteGenericSelection} CMsgDOTAPassportVoteGenericSelection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportVoteGenericSelection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPassportVoteGenericSelection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.selection_index = reader.int32();
                    break;
                case 2:
                    message.selection = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPassportVoteGenericSelection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPassportVoteGenericSelection} CMsgDOTAPassportVoteGenericSelection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportVoteGenericSelection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPassportVoteGenericSelection message.
         * @function verify
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPassportVoteGenericSelection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selection_index != null && message.hasOwnProperty("selection_index"))
                switch (message.selection_index) {
                default:
                    return "selection_index: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                    break;
                }
            if (message.selection != null && message.hasOwnProperty("selection"))
                if (!$util.isInteger(message.selection))
                    return "selection: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPassportVoteGenericSelection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPassportVoteGenericSelection} CMsgDOTAPassportVoteGenericSelection
         */
        CMsgDOTAPassportVoteGenericSelection.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPassportVoteGenericSelection)
                return object;
            var message = new $root.CMsgDOTAPassportVoteGenericSelection();
            switch (object.selection_index) {
            case "PP13_SEL_ALLSTAR_PLAYER_0":
            case 0:
                message.selection_index = 0;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_1":
            case 1:
                message.selection_index = 1;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_2":
            case 2:
                message.selection_index = 2;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_3":
            case 3:
                message.selection_index = 3;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_4":
            case 4:
                message.selection_index = 4;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_5":
            case 5:
                message.selection_index = 5;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_6":
            case 6:
                message.selection_index = 6;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_7":
            case 7:
                message.selection_index = 7;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_8":
            case 8:
                message.selection_index = 8;
                break;
            case "PP13_SEL_ALLSTAR_PLAYER_9":
            case 9:
                message.selection_index = 9;
                break;
            case "PP13_SEL_QUALPRED_WEST_0":
            case 10:
                message.selection_index = 10;
                break;
            case "PP13_SEL_QUALPRED_WEST_1":
            case 11:
                message.selection_index = 11;
                break;
            case "PP13_SEL_QUALPRED_WEST_2":
            case 12:
                message.selection_index = 12;
                break;
            case "PP13_SEL_QUALPRED_WEST_3":
            case 13:
                message.selection_index = 13;
                break;
            case "PP13_SEL_QUALPRED_WEST_4":
            case 14:
                message.selection_index = 14;
                break;
            case "PP13_SEL_QUALPRED_WEST_5":
            case 15:
                message.selection_index = 15;
                break;
            case "PP13_SEL_QUALPRED_WEST_6":
            case 16:
                message.selection_index = 16;
                break;
            case "PP13_SEL_QUALPRED_WEST_7":
            case 17:
                message.selection_index = 17;
                break;
            case "PP13_SEL_QUALPRED_WEST_8":
            case 18:
                message.selection_index = 18;
                break;
            case "PP13_SEL_QUALPRED_WEST_9":
            case 19:
                message.selection_index = 19;
                break;
            case "PP13_SEL_QUALPRED_WEST_10":
            case 20:
                message.selection_index = 20;
                break;
            case "PP13_SEL_QUALPRED_WEST_11":
            case 21:
                message.selection_index = 21;
                break;
            case "PP13_SEL_QUALPRED_WEST_12":
            case 22:
                message.selection_index = 22;
                break;
            case "PP13_SEL_QUALPRED_WEST_13":
            case 23:
                message.selection_index = 23;
                break;
            case "PP13_SEL_QUALPRED_WEST_14":
            case 24:
                message.selection_index = 24;
                break;
            case "PP13_SEL_QUALPRED_EAST_0":
            case 25:
                message.selection_index = 25;
                break;
            case "PP13_SEL_QUALPRED_EAST_1":
            case 26:
                message.selection_index = 26;
                break;
            case "PP13_SEL_QUALPRED_EAST_2":
            case 27:
                message.selection_index = 27;
                break;
            case "PP13_SEL_QUALPRED_EAST_3":
            case 28:
                message.selection_index = 28;
                break;
            case "PP13_SEL_QUALPRED_EAST_4":
            case 29:
                message.selection_index = 29;
                break;
            case "PP13_SEL_QUALPRED_EAST_5":
            case 30:
                message.selection_index = 30;
                break;
            case "PP13_SEL_QUALPRED_EAST_6":
            case 31:
                message.selection_index = 31;
                break;
            case "PP13_SEL_QUALPRED_EAST_7":
            case 32:
                message.selection_index = 32;
                break;
            case "PP13_SEL_QUALPRED_EAST_8":
            case 33:
                message.selection_index = 33;
                break;
            case "PP13_SEL_QUALPRED_EAST_9":
            case 34:
                message.selection_index = 34;
                break;
            case "PP13_SEL_QUALPRED_EAST_10":
            case 35:
                message.selection_index = 35;
                break;
            case "PP13_SEL_QUALPRED_EAST_11":
            case 36:
                message.selection_index = 36;
                break;
            case "PP13_SEL_QUALPRED_EAST_12":
            case 37:
                message.selection_index = 37;
                break;
            case "PP13_SEL_QUALPRED_EAST_13":
            case 38:
                message.selection_index = 38;
                break;
            case "PP13_SEL_QUALPRED_EAST_14":
            case 39:
                message.selection_index = 39;
                break;
            case "PP13_SEL_TEAMCUP_TEAM":
            case 40:
                message.selection_index = 40;
                break;
            case "PP13_SEL_TEAMCUP_PLAYER":
            case 41:
                message.selection_index = 41;
                break;
            case "PP13_SEL_TEAMCUP_TEAM_LOCK":
            case 42:
                message.selection_index = 42;
                break;
            case "PP13_SEL_TEAMCUP_PLAYER_LOCK":
            case 43:
                message.selection_index = 43;
                break;
            case "PP13_SEL_EVENTPRED_0":
            case 44:
                message.selection_index = 44;
                break;
            case "PP13_SEL_EVENTPRED_1":
            case 45:
                message.selection_index = 45;
                break;
            case "PP13_SEL_EVENTPRED_2":
            case 46:
                message.selection_index = 46;
                break;
            case "PP13_SEL_EVENTPRED_3":
            case 47:
                message.selection_index = 47;
                break;
            case "PP13_SEL_EVENTPRED_4":
            case 48:
                message.selection_index = 48;
                break;
            case "PP13_SEL_EVENTPRED_5":
            case 49:
                message.selection_index = 49;
                break;
            case "PP13_SEL_EVENTPRED_6":
            case 50:
                message.selection_index = 50;
                break;
            case "PP13_SEL_EVENTPRED_7":
            case 51:
                message.selection_index = 51;
                break;
            case "PP13_SEL_EVENTPRED_8":
            case 52:
                message.selection_index = 52;
                break;
            case "PP13_SEL_EVENTPRED_9":
            case 53:
                message.selection_index = 53;
                break;
            case "PP13_SEL_EVENTPRED_10":
            case 54:
                message.selection_index = 54;
                break;
            case "PP13_SEL_EVENTPRED_11":
            case 55:
                message.selection_index = 55;
                break;
            case "PP13_SEL_EVENTPRED_12":
            case 56:
                message.selection_index = 56;
                break;
            case "PP13_SEL_EVENTPRED_13":
            case 57:
                message.selection_index = 57;
                break;
            case "PP13_SEL_EVENTPRED_14":
            case 58:
                message.selection_index = 58;
                break;
            case "PP13_SEL_EVENTPRED_15":
            case 59:
                message.selection_index = 59;
                break;
            case "PP13_SEL_EVENTPRED_16":
            case 60:
                message.selection_index = 60;
                break;
            case "PP13_SEL_EVENTPRED_17":
            case 61:
                message.selection_index = 61;
                break;
            case "PP13_SEL_EVENTPRED_18":
            case 62:
                message.selection_index = 62;
                break;
            case "PP13_SEL_EVENTPRED_19":
            case 63:
                message.selection_index = 63;
                break;
            case "PP13_SEL_EVENTPRED_20":
            case 64:
                message.selection_index = 64;
                break;
            case "PP13_SEL_EVENTPRED_21":
            case 65:
                message.selection_index = 65;
                break;
            case "PP13_SEL_EVENTPRED_22":
            case 66:
                message.selection_index = 66;
                break;
            case "PP13_SEL_EVENTPRED_23":
            case 67:
                message.selection_index = 67;
                break;
            case "PP13_SEL_EVENTPRED_24":
            case 68:
                message.selection_index = 68;
                break;
            case "PP13_SEL_EVENTPRED_25":
            case 69:
                message.selection_index = 69;
                break;
            case "PP13_SEL_EVENTPRED_26":
            case 70:
                message.selection_index = 70;
                break;
            case "PP13_SEL_EVENTPRED_27":
            case 71:
                message.selection_index = 71;
                break;
            case "PP13_SEL_EVENTPRED_28":
            case 72:
                message.selection_index = 72;
                break;
            case "PP13_SEL_EVENTPRED_29":
            case 73:
                message.selection_index = 73;
                break;
            case "PP13_SEL_EVENTPRED_30":
            case 74:
                message.selection_index = 74;
                break;
            case "PP13_SEL_EVENTPRED_31":
            case 75:
                message.selection_index = 75;
                break;
            case "PP13_SEL_EVENTPRED_32":
            case 76:
                message.selection_index = 76;
                break;
            case "PP13_SEL_EVENTPRED_33":
            case 77:
                message.selection_index = 77;
                break;
            case "PP13_SEL_EVENTPRED_34":
            case 78:
                message.selection_index = 78;
                break;
            case "PP13_SEL_EVENTPRED_35":
            case 79:
                message.selection_index = 79;
                break;
            case "PP13_SEL_EVENTPRED_36":
            case 80:
                message.selection_index = 80;
                break;
            case "PP13_SEL_EVENTPRED_37":
            case 81:
                message.selection_index = 81;
                break;
            case "PP13_SEL_EVENTPRED_38":
            case 82:
                message.selection_index = 82;
                break;
            case "PP13_SEL_EVENTPRED_39":
            case 83:
                message.selection_index = 83;
                break;
            case "PP13_SEL_EVENTPRED_40":
            case 84:
                message.selection_index = 84;
                break;
            case "PP13_SEL_EVENTPRED_41":
            case 85:
                message.selection_index = 85;
                break;
            case "PP13_SEL_EVENTPRED_42":
            case 86:
                message.selection_index = 86;
                break;
            case "PP13_SEL_EVENTPRED_43":
            case 87:
                message.selection_index = 87;
                break;
            case "PP13_SEL_SOLO_0":
            case 88:
                message.selection_index = 88;
                break;
            case "PP13_SEL_SOLO_1":
            case 89:
                message.selection_index = 89;
                break;
            case "PP13_SEL_SOLO_2":
            case 90:
                message.selection_index = 90;
                break;
            case "PP13_SEL_SOLO_3":
            case 91:
                message.selection_index = 91;
                break;
            case "PP13_SEL_SOLO_4":
            case 92:
                message.selection_index = 92;
                break;
            case "PP13_SEL_SOLO_5":
            case 93:
                message.selection_index = 93;
                break;
            case "PP13_SEL_SOLO_6":
            case 94:
                message.selection_index = 94;
                break;
            case "PP13_SEL_SOLO_7":
            case 95:
                message.selection_index = 95;
                break;
            }
            if (object.selection != null)
                message.selection = object.selection >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPassportVoteGenericSelection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @static
         * @param {CMsgDOTAPassportVoteGenericSelection} message CMsgDOTAPassportVoteGenericSelection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPassportVoteGenericSelection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.selection_index = options.enums === String ? "PP13_SEL_ALLSTAR_PLAYER_0" : 0;
                object.selection = 0;
            }
            if (message.selection_index != null && message.hasOwnProperty("selection_index"))
                object.selection_index = options.enums === String ? $root.DOTA_2013PassportSelectionIndices[message.selection_index] : message.selection_index;
            if (message.selection != null && message.hasOwnProperty("selection"))
                object.selection = message.selection;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPassportVoteGenericSelection to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPassportVoteGenericSelection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPassportVoteGenericSelection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAPassportVoteGenericSelection;
    })();
    
    $root.CMsgDOTAPassportStampedPlayer = (function() {
    
        /**
         * Properties of a CMsgDOTAPassportStampedPlayer.
         * @exports ICMsgDOTAPassportStampedPlayer
         * @interface ICMsgDOTAPassportStampedPlayer
         * @property {number|Long|null} [steam_id] CMsgDOTAPassportStampedPlayer steam_id
         * @property {number|null} [stamp_level] CMsgDOTAPassportStampedPlayer stamp_level
         */
    
        /**
         * Constructs a new CMsgDOTAPassportStampedPlayer.
         * @exports CMsgDOTAPassportStampedPlayer
         * @classdesc Represents a CMsgDOTAPassportStampedPlayer.
         * @implements ICMsgDOTAPassportStampedPlayer
         * @constructor
         * @param {ICMsgDOTAPassportStampedPlayer=} [properties] Properties to set
         */
        function CMsgDOTAPassportStampedPlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPassportStampedPlayer steam_id.
         * @member {number|Long} steam_id
         * @memberof CMsgDOTAPassportStampedPlayer
         * @instance
         */
        CMsgDOTAPassportStampedPlayer.prototype.steam_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgDOTAPassportStampedPlayer stamp_level.
         * @member {number} stamp_level
         * @memberof CMsgDOTAPassportStampedPlayer
         * @instance
         */
        CMsgDOTAPassportStampedPlayer.prototype.stamp_level = 0;
    
        /**
         * Creates a new CMsgDOTAPassportStampedPlayer instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {ICMsgDOTAPassportStampedPlayer=} [properties] Properties to set
         * @returns {CMsgDOTAPassportStampedPlayer} CMsgDOTAPassportStampedPlayer instance
         */
        CMsgDOTAPassportStampedPlayer.create = function create(properties) {
            return new CMsgDOTAPassportStampedPlayer(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportStampedPlayer message. Does not implicitly {@link CMsgDOTAPassportStampedPlayer.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {ICMsgDOTAPassportStampedPlayer} message CMsgDOTAPassportStampedPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportStampedPlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.steam_id != null && Object.hasOwnProperty.call(message, "steam_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.steam_id);
            if (message.stamp_level != null && Object.hasOwnProperty.call(message, "stamp_level"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stamp_level);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportStampedPlayer message, length delimited. Does not implicitly {@link CMsgDOTAPassportStampedPlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {ICMsgDOTAPassportStampedPlayer} message CMsgDOTAPassportStampedPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportStampedPlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPassportStampedPlayer message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPassportStampedPlayer} CMsgDOTAPassportStampedPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportStampedPlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPassportStampedPlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.steam_id = reader.uint64();
                    break;
                case 2:
                    message.stamp_level = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPassportStampedPlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPassportStampedPlayer} CMsgDOTAPassportStampedPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportStampedPlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPassportStampedPlayer message.
         * @function verify
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPassportStampedPlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.steam_id != null && message.hasOwnProperty("steam_id"))
                if (!$util.isInteger(message.steam_id) && !(message.steam_id && $util.isInteger(message.steam_id.low) && $util.isInteger(message.steam_id.high)))
                    return "steam_id: integer|Long expected";
            if (message.stamp_level != null && message.hasOwnProperty("stamp_level"))
                if (!$util.isInteger(message.stamp_level))
                    return "stamp_level: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPassportStampedPlayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPassportStampedPlayer} CMsgDOTAPassportStampedPlayer
         */
        CMsgDOTAPassportStampedPlayer.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPassportStampedPlayer)
                return object;
            var message = new $root.CMsgDOTAPassportStampedPlayer();
            if (object.steam_id != null)
                if ($util.Long)
                    (message.steam_id = $util.Long.fromValue(object.steam_id)).unsigned = true;
                else if (typeof object.steam_id === "string")
                    message.steam_id = parseInt(object.steam_id, 10);
                else if (typeof object.steam_id === "number")
                    message.steam_id = object.steam_id;
                else if (typeof object.steam_id === "object")
                    message.steam_id = new $util.LongBits(object.steam_id.low >>> 0, object.steam_id.high >>> 0).toNumber(true);
            if (object.stamp_level != null)
                message.stamp_level = object.stamp_level >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPassportStampedPlayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPassportStampedPlayer
         * @static
         * @param {CMsgDOTAPassportStampedPlayer} message CMsgDOTAPassportStampedPlayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPassportStampedPlayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.steam_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steam_id = options.longs === String ? "0" : 0;
                object.stamp_level = 0;
            }
            if (message.steam_id != null && message.hasOwnProperty("steam_id"))
                if (typeof message.steam_id === "number")
                    object.steam_id = options.longs === String ? String(message.steam_id) : message.steam_id;
                else
                    object.steam_id = options.longs === String ? $util.Long.prototype.toString.call(message.steam_id) : options.longs === Number ? new $util.LongBits(message.steam_id.low >>> 0, message.steam_id.high >>> 0).toNumber(true) : message.steam_id;
            if (message.stamp_level != null && message.hasOwnProperty("stamp_level"))
                object.stamp_level = message.stamp_level;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPassportStampedPlayer to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPassportStampedPlayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPassportStampedPlayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAPassportStampedPlayer;
    })();
    
    $root.CMsgDOTAPassportPlayerCardChallenge = (function() {
    
        /**
         * Properties of a CMsgDOTAPassportPlayerCardChallenge.
         * @exports ICMsgDOTAPassportPlayerCardChallenge
         * @interface ICMsgDOTAPassportPlayerCardChallenge
         * @property {number|null} [challenge_id] CMsgDOTAPassportPlayerCardChallenge challenge_id
         */
    
        /**
         * Constructs a new CMsgDOTAPassportPlayerCardChallenge.
         * @exports CMsgDOTAPassportPlayerCardChallenge
         * @classdesc Represents a CMsgDOTAPassportPlayerCardChallenge.
         * @implements ICMsgDOTAPassportPlayerCardChallenge
         * @constructor
         * @param {ICMsgDOTAPassportPlayerCardChallenge=} [properties] Properties to set
         */
        function CMsgDOTAPassportPlayerCardChallenge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPassportPlayerCardChallenge challenge_id.
         * @member {number} challenge_id
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @instance
         */
        CMsgDOTAPassportPlayerCardChallenge.prototype.challenge_id = 0;
    
        /**
         * Creates a new CMsgDOTAPassportPlayerCardChallenge instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {ICMsgDOTAPassportPlayerCardChallenge=} [properties] Properties to set
         * @returns {CMsgDOTAPassportPlayerCardChallenge} CMsgDOTAPassportPlayerCardChallenge instance
         */
        CMsgDOTAPassportPlayerCardChallenge.create = function create(properties) {
            return new CMsgDOTAPassportPlayerCardChallenge(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportPlayerCardChallenge message. Does not implicitly {@link CMsgDOTAPassportPlayerCardChallenge.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {ICMsgDOTAPassportPlayerCardChallenge} message CMsgDOTAPassportPlayerCardChallenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportPlayerCardChallenge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.challenge_id != null && Object.hasOwnProperty.call(message, "challenge_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.challenge_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportPlayerCardChallenge message, length delimited. Does not implicitly {@link CMsgDOTAPassportPlayerCardChallenge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {ICMsgDOTAPassportPlayerCardChallenge} message CMsgDOTAPassportPlayerCardChallenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportPlayerCardChallenge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPassportPlayerCardChallenge message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPassportPlayerCardChallenge} CMsgDOTAPassportPlayerCardChallenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportPlayerCardChallenge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPassportPlayerCardChallenge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.challenge_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPassportPlayerCardChallenge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPassportPlayerCardChallenge} CMsgDOTAPassportPlayerCardChallenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportPlayerCardChallenge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPassportPlayerCardChallenge message.
         * @function verify
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPassportPlayerCardChallenge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.challenge_id != null && message.hasOwnProperty("challenge_id"))
                if (!$util.isInteger(message.challenge_id))
                    return "challenge_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPassportPlayerCardChallenge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPassportPlayerCardChallenge} CMsgDOTAPassportPlayerCardChallenge
         */
        CMsgDOTAPassportPlayerCardChallenge.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPassportPlayerCardChallenge)
                return object;
            var message = new $root.CMsgDOTAPassportPlayerCardChallenge();
            if (object.challenge_id != null)
                message.challenge_id = object.challenge_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPassportPlayerCardChallenge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @static
         * @param {CMsgDOTAPassportPlayerCardChallenge} message CMsgDOTAPassportPlayerCardChallenge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPassportPlayerCardChallenge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.challenge_id = 0;
            if (message.challenge_id != null && message.hasOwnProperty("challenge_id"))
                object.challenge_id = message.challenge_id;
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPassportPlayerCardChallenge to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPassportPlayerCardChallenge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPassportPlayerCardChallenge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAPassportPlayerCardChallenge;
    })();
    
    $root.CMsgDOTAPassportVote = (function() {
    
        /**
         * Properties of a CMsgDOTAPassportVote.
         * @exports ICMsgDOTAPassportVote
         * @interface ICMsgDOTAPassportVote
         * @property {Array.<ICMsgDOTAPassportVoteTeamGuess>|null} [team_votes] CMsgDOTAPassportVote team_votes
         * @property {Array.<ICMsgDOTAPassportVoteGenericSelection>|null} [generic_selections] CMsgDOTAPassportVote generic_selections
         * @property {Array.<ICMsgDOTAPassportStampedPlayer>|null} [stamped_players] CMsgDOTAPassportVote stamped_players
         * @property {Array.<ICMsgDOTAPassportPlayerCardChallenge>|null} [player_card_challenges] CMsgDOTAPassportVote player_card_challenges
         */
    
        /**
         * Constructs a new CMsgDOTAPassportVote.
         * @exports CMsgDOTAPassportVote
         * @classdesc Represents a CMsgDOTAPassportVote.
         * @implements ICMsgDOTAPassportVote
         * @constructor
         * @param {ICMsgDOTAPassportVote=} [properties] Properties to set
         */
        function CMsgDOTAPassportVote(properties) {
            this.team_votes = [];
            this.generic_selections = [];
            this.stamped_players = [];
            this.player_card_challenges = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAPassportVote team_votes.
         * @member {Array.<ICMsgDOTAPassportVoteTeamGuess>} team_votes
         * @memberof CMsgDOTAPassportVote
         * @instance
         */
        CMsgDOTAPassportVote.prototype.team_votes = $util.emptyArray;
    
        /**
         * CMsgDOTAPassportVote generic_selections.
         * @member {Array.<ICMsgDOTAPassportVoteGenericSelection>} generic_selections
         * @memberof CMsgDOTAPassportVote
         * @instance
         */
        CMsgDOTAPassportVote.prototype.generic_selections = $util.emptyArray;
    
        /**
         * CMsgDOTAPassportVote stamped_players.
         * @member {Array.<ICMsgDOTAPassportStampedPlayer>} stamped_players
         * @memberof CMsgDOTAPassportVote
         * @instance
         */
        CMsgDOTAPassportVote.prototype.stamped_players = $util.emptyArray;
    
        /**
         * CMsgDOTAPassportVote player_card_challenges.
         * @member {Array.<ICMsgDOTAPassportPlayerCardChallenge>} player_card_challenges
         * @memberof CMsgDOTAPassportVote
         * @instance
         */
        CMsgDOTAPassportVote.prototype.player_card_challenges = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAPassportVote instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {ICMsgDOTAPassportVote=} [properties] Properties to set
         * @returns {CMsgDOTAPassportVote} CMsgDOTAPassportVote instance
         */
        CMsgDOTAPassportVote.create = function create(properties) {
            return new CMsgDOTAPassportVote(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportVote message. Does not implicitly {@link CMsgDOTAPassportVote.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {ICMsgDOTAPassportVote} message CMsgDOTAPassportVote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportVote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.team_votes != null && message.team_votes.length)
                for (var i = 0; i < message.team_votes.length; ++i)
                    $root.CMsgDOTAPassportVoteTeamGuess.encode(message.team_votes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.generic_selections != null && message.generic_selections.length)
                for (var i = 0; i < message.generic_selections.length; ++i)
                    $root.CMsgDOTAPassportVoteGenericSelection.encode(message.generic_selections[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.stamped_players != null && message.stamped_players.length)
                for (var i = 0; i < message.stamped_players.length; ++i)
                    $root.CMsgDOTAPassportStampedPlayer.encode(message.stamped_players[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.player_card_challenges != null && message.player_card_challenges.length)
                for (var i = 0; i < message.player_card_challenges.length; ++i)
                    $root.CMsgDOTAPassportPlayerCardChallenge.encode(message.player_card_challenges[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAPassportVote message, length delimited. Does not implicitly {@link CMsgDOTAPassportVote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {ICMsgDOTAPassportVote} message CMsgDOTAPassportVote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAPassportVote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAPassportVote message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAPassportVote} CMsgDOTAPassportVote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportVote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAPassportVote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.team_votes && message.team_votes.length))
                        message.team_votes = [];
                    message.team_votes.push($root.CMsgDOTAPassportVoteTeamGuess.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.generic_selections && message.generic_selections.length))
                        message.generic_selections = [];
                    message.generic_selections.push($root.CMsgDOTAPassportVoteGenericSelection.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.stamped_players && message.stamped_players.length))
                        message.stamped_players = [];
                    message.stamped_players.push($root.CMsgDOTAPassportStampedPlayer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.player_card_challenges && message.player_card_challenges.length))
                        message.player_card_challenges = [];
                    message.player_card_challenges.push($root.CMsgDOTAPassportPlayerCardChallenge.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAPassportVote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAPassportVote} CMsgDOTAPassportVote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAPassportVote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAPassportVote message.
         * @function verify
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAPassportVote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.team_votes != null && message.hasOwnProperty("team_votes")) {
                if (!Array.isArray(message.team_votes))
                    return "team_votes: array expected";
                for (var i = 0; i < message.team_votes.length; ++i) {
                    var error = $root.CMsgDOTAPassportVoteTeamGuess.verify(message.team_votes[i]);
                    if (error)
                        return "team_votes." + error;
                }
            }
            if (message.generic_selections != null && message.hasOwnProperty("generic_selections")) {
                if (!Array.isArray(message.generic_selections))
                    return "generic_selections: array expected";
                for (var i = 0; i < message.generic_selections.length; ++i) {
                    var error = $root.CMsgDOTAPassportVoteGenericSelection.verify(message.generic_selections[i]);
                    if (error)
                        return "generic_selections." + error;
                }
            }
            if (message.stamped_players != null && message.hasOwnProperty("stamped_players")) {
                if (!Array.isArray(message.stamped_players))
                    return "stamped_players: array expected";
                for (var i = 0; i < message.stamped_players.length; ++i) {
                    var error = $root.CMsgDOTAPassportStampedPlayer.verify(message.stamped_players[i]);
                    if (error)
                        return "stamped_players." + error;
                }
            }
            if (message.player_card_challenges != null && message.hasOwnProperty("player_card_challenges")) {
                if (!Array.isArray(message.player_card_challenges))
                    return "player_card_challenges: array expected";
                for (var i = 0; i < message.player_card_challenges.length; ++i) {
                    var error = $root.CMsgDOTAPassportPlayerCardChallenge.verify(message.player_card_challenges[i]);
                    if (error)
                        return "player_card_challenges." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAPassportVote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAPassportVote} CMsgDOTAPassportVote
         */
        CMsgDOTAPassportVote.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAPassportVote)
                return object;
            var message = new $root.CMsgDOTAPassportVote();
            if (object.team_votes) {
                if (!Array.isArray(object.team_votes))
                    throw TypeError(".CMsgDOTAPassportVote.team_votes: array expected");
                message.team_votes = [];
                for (var i = 0; i < object.team_votes.length; ++i) {
                    if (typeof object.team_votes[i] !== "object")
                        throw TypeError(".CMsgDOTAPassportVote.team_votes: object expected");
                    message.team_votes[i] = $root.CMsgDOTAPassportVoteTeamGuess.fromObject(object.team_votes[i]);
                }
            }
            if (object.generic_selections) {
                if (!Array.isArray(object.generic_selections))
                    throw TypeError(".CMsgDOTAPassportVote.generic_selections: array expected");
                message.generic_selections = [];
                for (var i = 0; i < object.generic_selections.length; ++i) {
                    if (typeof object.generic_selections[i] !== "object")
                        throw TypeError(".CMsgDOTAPassportVote.generic_selections: object expected");
                    message.generic_selections[i] = $root.CMsgDOTAPassportVoteGenericSelection.fromObject(object.generic_selections[i]);
                }
            }
            if (object.stamped_players) {
                if (!Array.isArray(object.stamped_players))
                    throw TypeError(".CMsgDOTAPassportVote.stamped_players: array expected");
                message.stamped_players = [];
                for (var i = 0; i < object.stamped_players.length; ++i) {
                    if (typeof object.stamped_players[i] !== "object")
                        throw TypeError(".CMsgDOTAPassportVote.stamped_players: object expected");
                    message.stamped_players[i] = $root.CMsgDOTAPassportStampedPlayer.fromObject(object.stamped_players[i]);
                }
            }
            if (object.player_card_challenges) {
                if (!Array.isArray(object.player_card_challenges))
                    throw TypeError(".CMsgDOTAPassportVote.player_card_challenges: array expected");
                message.player_card_challenges = [];
                for (var i = 0; i < object.player_card_challenges.length; ++i) {
                    if (typeof object.player_card_challenges[i] !== "object")
                        throw TypeError(".CMsgDOTAPassportVote.player_card_challenges: object expected");
                    message.player_card_challenges[i] = $root.CMsgDOTAPassportPlayerCardChallenge.fromObject(object.player_card_challenges[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAPassportVote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAPassportVote
         * @static
         * @param {CMsgDOTAPassportVote} message CMsgDOTAPassportVote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAPassportVote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.team_votes = [];
                object.generic_selections = [];
                object.stamped_players = [];
                object.player_card_challenges = [];
            }
            if (message.team_votes && message.team_votes.length) {
                object.team_votes = [];
                for (var j = 0; j < message.team_votes.length; ++j)
                    object.team_votes[j] = $root.CMsgDOTAPassportVoteTeamGuess.toObject(message.team_votes[j], options);
            }
            if (message.generic_selections && message.generic_selections.length) {
                object.generic_selections = [];
                for (var j = 0; j < message.generic_selections.length; ++j)
                    object.generic_selections[j] = $root.CMsgDOTAPassportVoteGenericSelection.toObject(message.generic_selections[j], options);
            }
            if (message.stamped_players && message.stamped_players.length) {
                object.stamped_players = [];
                for (var j = 0; j < message.stamped_players.length; ++j)
                    object.stamped_players[j] = $root.CMsgDOTAPassportStampedPlayer.toObject(message.stamped_players[j], options);
            }
            if (message.player_card_challenges && message.player_card_challenges.length) {
                object.player_card_challenges = [];
                for (var j = 0; j < message.player_card_challenges.length; ++j)
                    object.player_card_challenges[j] = $root.CMsgDOTAPassportPlayerCardChallenge.toObject(message.player_card_challenges[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAPassportVote to JSON.
         * @function toJSON
         * @memberof CMsgDOTAPassportVote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAPassportVote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTAPassportVote;
    })();
    
    $root.CMsgClientToGCGetPlayerCardRosterRequest = (function() {
    
        /**
         * Properties of a CMsgClientToGCGetPlayerCardRosterRequest.
         * @exports ICMsgClientToGCGetPlayerCardRosterRequest
         * @interface ICMsgClientToGCGetPlayerCardRosterRequest
         * @property {number|null} [league_id] CMsgClientToGCGetPlayerCardRosterRequest league_id
         * @property {number|null} [timestamp] CMsgClientToGCGetPlayerCardRosterRequest timestamp
         */
    
        /**
         * Constructs a new CMsgClientToGCGetPlayerCardRosterRequest.
         * @exports CMsgClientToGCGetPlayerCardRosterRequest
         * @classdesc Represents a CMsgClientToGCGetPlayerCardRosterRequest.
         * @implements ICMsgClientToGCGetPlayerCardRosterRequest
         * @constructor
         * @param {ICMsgClientToGCGetPlayerCardRosterRequest=} [properties] Properties to set
         */
        function CMsgClientToGCGetPlayerCardRosterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgClientToGCGetPlayerCardRosterRequest league_id.
         * @member {number} league_id
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterRequest.prototype.league_id = 0;
    
        /**
         * CMsgClientToGCGetPlayerCardRosterRequest timestamp.
         * @member {number} timestamp
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterRequest.prototype.timestamp = 0;
    
        /**
         * Creates a new CMsgClientToGCGetPlayerCardRosterRequest instance using the specified properties.
         * @function create
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {ICMsgClientToGCGetPlayerCardRosterRequest=} [properties] Properties to set
         * @returns {CMsgClientToGCGetPlayerCardRosterRequest} CMsgClientToGCGetPlayerCardRosterRequest instance
         */
        CMsgClientToGCGetPlayerCardRosterRequest.create = function create(properties) {
            return new CMsgClientToGCGetPlayerCardRosterRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgClientToGCGetPlayerCardRosterRequest message. Does not implicitly {@link CMsgClientToGCGetPlayerCardRosterRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {ICMsgClientToGCGetPlayerCardRosterRequest} message CMsgClientToGCGetPlayerCardRosterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCGetPlayerCardRosterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.league_id != null && Object.hasOwnProperty.call(message, "league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.league_id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgClientToGCGetPlayerCardRosterRequest message, length delimited. Does not implicitly {@link CMsgClientToGCGetPlayerCardRosterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {ICMsgClientToGCGetPlayerCardRosterRequest} message CMsgClientToGCGetPlayerCardRosterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCGetPlayerCardRosterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgClientToGCGetPlayerCardRosterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgClientToGCGetPlayerCardRosterRequest} CMsgClientToGCGetPlayerCardRosterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCGetPlayerCardRosterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgClientToGCGetPlayerCardRosterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.league_id = reader.uint32();
                    break;
                case 2:
                    message.timestamp = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgClientToGCGetPlayerCardRosterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgClientToGCGetPlayerCardRosterRequest} CMsgClientToGCGetPlayerCardRosterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCGetPlayerCardRosterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgClientToGCGetPlayerCardRosterRequest message.
         * @function verify
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgClientToGCGetPlayerCardRosterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.league_id != null && message.hasOwnProperty("league_id"))
                if (!$util.isInteger(message.league_id))
                    return "league_id: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgClientToGCGetPlayerCardRosterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgClientToGCGetPlayerCardRosterRequest} CMsgClientToGCGetPlayerCardRosterRequest
         */
        CMsgClientToGCGetPlayerCardRosterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgClientToGCGetPlayerCardRosterRequest)
                return object;
            var message = new $root.CMsgClientToGCGetPlayerCardRosterRequest();
            if (object.league_id != null)
                message.league_id = object.league_id >>> 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgClientToGCGetPlayerCardRosterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @static
         * @param {CMsgClientToGCGetPlayerCardRosterRequest} message CMsgClientToGCGetPlayerCardRosterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgClientToGCGetPlayerCardRosterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.league_id = 0;
                object.timestamp = 0;
            }
            if (message.league_id != null && message.hasOwnProperty("league_id"))
                object.league_id = message.league_id;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };
    
        /**
         * Converts this CMsgClientToGCGetPlayerCardRosterRequest to JSON.
         * @function toJSON
         * @memberof CMsgClientToGCGetPlayerCardRosterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgClientToGCGetPlayerCardRosterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgClientToGCGetPlayerCardRosterRequest;
    })();
    
    $root.CMsgClientToGCGetPlayerCardRosterResponse = (function() {
    
        /**
         * Properties of a CMsgClientToGCGetPlayerCardRosterResponse.
         * @exports ICMsgClientToGCGetPlayerCardRosterResponse
         * @interface ICMsgClientToGCGetPlayerCardRosterResponse
         * @property {CMsgClientToGCGetPlayerCardRosterResponse.Result|null} [result] CMsgClientToGCGetPlayerCardRosterResponse result
         * @property {Array.<number|Long>|null} [player_card_item_id] CMsgClientToGCGetPlayerCardRosterResponse player_card_item_id
         * @property {number|null} [score] CMsgClientToGCGetPlayerCardRosterResponse score
         * @property {boolean|null} [finalized] CMsgClientToGCGetPlayerCardRosterResponse finalized
         * @property {number|null} [percentile] CMsgClientToGCGetPlayerCardRosterResponse percentile
         */
    
        /**
         * Constructs a new CMsgClientToGCGetPlayerCardRosterResponse.
         * @exports CMsgClientToGCGetPlayerCardRosterResponse
         * @classdesc Represents a CMsgClientToGCGetPlayerCardRosterResponse.
         * @implements ICMsgClientToGCGetPlayerCardRosterResponse
         * @constructor
         * @param {ICMsgClientToGCGetPlayerCardRosterResponse=} [properties] Properties to set
         */
        function CMsgClientToGCGetPlayerCardRosterResponse(properties) {
            this.player_card_item_id = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgClientToGCGetPlayerCardRosterResponse result.
         * @member {CMsgClientToGCGetPlayerCardRosterResponse.Result} result
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterResponse.prototype.result = 0;
    
        /**
         * CMsgClientToGCGetPlayerCardRosterResponse player_card_item_id.
         * @member {Array.<number|Long>} player_card_item_id
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterResponse.prototype.player_card_item_id = $util.emptyArray;
    
        /**
         * CMsgClientToGCGetPlayerCardRosterResponse score.
         * @member {number} score
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterResponse.prototype.score = 0;
    
        /**
         * CMsgClientToGCGetPlayerCardRosterResponse finalized.
         * @member {boolean} finalized
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterResponse.prototype.finalized = false;
    
        /**
         * CMsgClientToGCGetPlayerCardRosterResponse percentile.
         * @member {number} percentile
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @instance
         */
        CMsgClientToGCGetPlayerCardRosterResponse.prototype.percentile = 0;
    
        /**
         * Creates a new CMsgClientToGCGetPlayerCardRosterResponse instance using the specified properties.
         * @function create
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {ICMsgClientToGCGetPlayerCardRosterResponse=} [properties] Properties to set
         * @returns {CMsgClientToGCGetPlayerCardRosterResponse} CMsgClientToGCGetPlayerCardRosterResponse instance
         */
        CMsgClientToGCGetPlayerCardRosterResponse.create = function create(properties) {
            return new CMsgClientToGCGetPlayerCardRosterResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgClientToGCGetPlayerCardRosterResponse message. Does not implicitly {@link CMsgClientToGCGetPlayerCardRosterResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {ICMsgClientToGCGetPlayerCardRosterResponse} message CMsgClientToGCGetPlayerCardRosterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCGetPlayerCardRosterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.player_card_item_id != null && message.player_card_item_id.length)
                for (var i = 0; i < message.player_card_item_id.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.player_card_item_id[i]);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.score);
            if (message.finalized != null && Object.hasOwnProperty.call(message, "finalized"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.finalized);
            if (message.percentile != null && Object.hasOwnProperty.call(message, "percentile"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.percentile);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgClientToGCGetPlayerCardRosterResponse message, length delimited. Does not implicitly {@link CMsgClientToGCGetPlayerCardRosterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {ICMsgClientToGCGetPlayerCardRosterResponse} message CMsgClientToGCGetPlayerCardRosterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCGetPlayerCardRosterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgClientToGCGetPlayerCardRosterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgClientToGCGetPlayerCardRosterResponse} CMsgClientToGCGetPlayerCardRosterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCGetPlayerCardRosterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgClientToGCGetPlayerCardRosterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.player_card_item_id && message.player_card_item_id.length))
                        message.player_card_item_id = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player_card_item_id.push(reader.uint64());
                    } else
                        message.player_card_item_id.push(reader.uint64());
                    break;
                case 3:
                    message.score = reader.float();
                    break;
                case 4:
                    message.finalized = reader.bool();
                    break;
                case 5:
                    message.percentile = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgClientToGCGetPlayerCardRosterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgClientToGCGetPlayerCardRosterResponse} CMsgClientToGCGetPlayerCardRosterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCGetPlayerCardRosterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgClientToGCGetPlayerCardRosterResponse message.
         * @function verify
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgClientToGCGetPlayerCardRosterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.player_card_item_id != null && message.hasOwnProperty("player_card_item_id")) {
                if (!Array.isArray(message.player_card_item_id))
                    return "player_card_item_id: array expected";
                for (var i = 0; i < message.player_card_item_id.length; ++i)
                    if (!$util.isInteger(message.player_card_item_id[i]) && !(message.player_card_item_id[i] && $util.isInteger(message.player_card_item_id[i].low) && $util.isInteger(message.player_card_item_id[i].high)))
                        return "player_card_item_id: integer|Long[] expected";
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            if (message.finalized != null && message.hasOwnProperty("finalized"))
                if (typeof message.finalized !== "boolean")
                    return "finalized: boolean expected";
            if (message.percentile != null && message.hasOwnProperty("percentile"))
                if (typeof message.percentile !== "number")
                    return "percentile: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgClientToGCGetPlayerCardRosterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgClientToGCGetPlayerCardRosterResponse} CMsgClientToGCGetPlayerCardRosterResponse
         */
        CMsgClientToGCGetPlayerCardRosterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgClientToGCGetPlayerCardRosterResponse)
                return object;
            var message = new $root.CMsgClientToGCGetPlayerCardRosterResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_INVALID_LEAGUE_ID":
            case 2:
                message.result = 2;
                break;
            case "ERROR_INVALID_TIMESTAMP":
            case 3:
                message.result = 3;
                break;
            }
            if (object.player_card_item_id) {
                if (!Array.isArray(object.player_card_item_id))
                    throw TypeError(".CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id: array expected");
                message.player_card_item_id = [];
                for (var i = 0; i < object.player_card_item_id.length; ++i)
                    if ($util.Long)
                        (message.player_card_item_id[i] = $util.Long.fromValue(object.player_card_item_id[i])).unsigned = true;
                    else if (typeof object.player_card_item_id[i] === "string")
                        message.player_card_item_id[i] = parseInt(object.player_card_item_id[i], 10);
                    else if (typeof object.player_card_item_id[i] === "number")
                        message.player_card_item_id[i] = object.player_card_item_id[i];
                    else if (typeof object.player_card_item_id[i] === "object")
                        message.player_card_item_id[i] = new $util.LongBits(object.player_card_item_id[i].low >>> 0, object.player_card_item_id[i].high >>> 0).toNumber(true);
            }
            if (object.score != null)
                message.score = Number(object.score);
            if (object.finalized != null)
                message.finalized = Boolean(object.finalized);
            if (object.percentile != null)
                message.percentile = Number(object.percentile);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgClientToGCGetPlayerCardRosterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @static
         * @param {CMsgClientToGCGetPlayerCardRosterResponse} message CMsgClientToGCGetPlayerCardRosterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgClientToGCGetPlayerCardRosterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.player_card_item_id = [];
            if (options.defaults) {
                object.result = options.enums === String ? "SUCCESS" : 0;
                object.score = 0;
                object.finalized = false;
                object.percentile = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgClientToGCGetPlayerCardRosterResponse.Result[message.result] : message.result;
            if (message.player_card_item_id && message.player_card_item_id.length) {
                object.player_card_item_id = [];
                for (var j = 0; j < message.player_card_item_id.length; ++j)
                    if (typeof message.player_card_item_id[j] === "number")
                        object.player_card_item_id[j] = options.longs === String ? String(message.player_card_item_id[j]) : message.player_card_item_id[j];
                    else
                        object.player_card_item_id[j] = options.longs === String ? $util.Long.prototype.toString.call(message.player_card_item_id[j]) : options.longs === Number ? new $util.LongBits(message.player_card_item_id[j].low >>> 0, message.player_card_item_id[j].high >>> 0).toNumber(true) : message.player_card_item_id[j];
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.finalized != null && message.hasOwnProperty("finalized"))
                object.finalized = message.finalized;
            if (message.percentile != null && message.hasOwnProperty("percentile"))
                object.percentile = options.json && !isFinite(message.percentile) ? String(message.percentile) : message.percentile;
            return object;
        };
    
        /**
         * Converts this CMsgClientToGCGetPlayerCardRosterResponse to JSON.
         * @function toJSON
         * @memberof CMsgClientToGCGetPlayerCardRosterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgClientToGCGetPlayerCardRosterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Result enum.
         * @name CMsgClientToGCGetPlayerCardRosterResponse.Result
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_INVALID_LEAGUE_ID=2 ERROR_INVALID_LEAGUE_ID value
         * @property {number} ERROR_INVALID_TIMESTAMP=3 ERROR_INVALID_TIMESTAMP value
         */
        CMsgClientToGCGetPlayerCardRosterResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_INVALID_LEAGUE_ID"] = 2;
            values[valuesById[3] = "ERROR_INVALID_TIMESTAMP"] = 3;
            return values;
        })();
    
        return CMsgClientToGCGetPlayerCardRosterResponse;
    })();
    
    $root.CMsgClientToGCSetPlayerCardRosterRequest = (function() {
    
        /**
         * Properties of a CMsgClientToGCSetPlayerCardRosterRequest.
         * @exports ICMsgClientToGCSetPlayerCardRosterRequest
         * @interface ICMsgClientToGCSetPlayerCardRosterRequest
         * @property {number|null} [league_id] CMsgClientToGCSetPlayerCardRosterRequest league_id
         * @property {number|null} [timestamp] CMsgClientToGCSetPlayerCardRosterRequest timestamp
         * @property {number|null} [slot] CMsgClientToGCSetPlayerCardRosterRequest slot
         * @property {number|Long|null} [player_card_item_id] CMsgClientToGCSetPlayerCardRosterRequest player_card_item_id
         * @property {number|null} [event_id] CMsgClientToGCSetPlayerCardRosterRequest event_id
         */
    
        /**
         * Constructs a new CMsgClientToGCSetPlayerCardRosterRequest.
         * @exports CMsgClientToGCSetPlayerCardRosterRequest
         * @classdesc Represents a CMsgClientToGCSetPlayerCardRosterRequest.
         * @implements ICMsgClientToGCSetPlayerCardRosterRequest
         * @constructor
         * @param {ICMsgClientToGCSetPlayerCardRosterRequest=} [properties] Properties to set
         */
        function CMsgClientToGCSetPlayerCardRosterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgClientToGCSetPlayerCardRosterRequest league_id.
         * @member {number} league_id
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCSetPlayerCardRosterRequest.prototype.league_id = 0;
    
        /**
         * CMsgClientToGCSetPlayerCardRosterRequest timestamp.
         * @member {number} timestamp
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCSetPlayerCardRosterRequest.prototype.timestamp = 0;
    
        /**
         * CMsgClientToGCSetPlayerCardRosterRequest slot.
         * @member {number} slot
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCSetPlayerCardRosterRequest.prototype.slot = 0;
    
        /**
         * CMsgClientToGCSetPlayerCardRosterRequest player_card_item_id.
         * @member {number|Long} player_card_item_id
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCSetPlayerCardRosterRequest.prototype.player_card_item_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgClientToGCSetPlayerCardRosterRequest event_id.
         * @member {number} event_id
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @instance
         */
        CMsgClientToGCSetPlayerCardRosterRequest.prototype.event_id = 0;
    
        /**
         * Creates a new CMsgClientToGCSetPlayerCardRosterRequest instance using the specified properties.
         * @function create
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {ICMsgClientToGCSetPlayerCardRosterRequest=} [properties] Properties to set
         * @returns {CMsgClientToGCSetPlayerCardRosterRequest} CMsgClientToGCSetPlayerCardRosterRequest instance
         */
        CMsgClientToGCSetPlayerCardRosterRequest.create = function create(properties) {
            return new CMsgClientToGCSetPlayerCardRosterRequest(properties);
        };
    
        /**
         * Encodes the specified CMsgClientToGCSetPlayerCardRosterRequest message. Does not implicitly {@link CMsgClientToGCSetPlayerCardRosterRequest.verify|verify} messages.
         * @function encode
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {ICMsgClientToGCSetPlayerCardRosterRequest} message CMsgClientToGCSetPlayerCardRosterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCSetPlayerCardRosterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.league_id != null && Object.hasOwnProperty.call(message, "league_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.league_id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.slot);
            if (message.player_card_item_id != null && Object.hasOwnProperty.call(message, "player_card_item_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.player_card_item_id);
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.event_id);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgClientToGCSetPlayerCardRosterRequest message, length delimited. Does not implicitly {@link CMsgClientToGCSetPlayerCardRosterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {ICMsgClientToGCSetPlayerCardRosterRequest} message CMsgClientToGCSetPlayerCardRosterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCSetPlayerCardRosterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgClientToGCSetPlayerCardRosterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgClientToGCSetPlayerCardRosterRequest} CMsgClientToGCSetPlayerCardRosterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCSetPlayerCardRosterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgClientToGCSetPlayerCardRosterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.league_id = reader.uint32();
                    break;
                case 2:
                    message.timestamp = reader.uint32();
                    break;
                case 3:
                    message.slot = reader.uint32();
                    break;
                case 4:
                    message.player_card_item_id = reader.uint64();
                    break;
                case 5:
                    message.event_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgClientToGCSetPlayerCardRosterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgClientToGCSetPlayerCardRosterRequest} CMsgClientToGCSetPlayerCardRosterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCSetPlayerCardRosterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgClientToGCSetPlayerCardRosterRequest message.
         * @function verify
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgClientToGCSetPlayerCardRosterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.league_id != null && message.hasOwnProperty("league_id"))
                if (!$util.isInteger(message.league_id))
                    return "league_id: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            if (message.player_card_item_id != null && message.hasOwnProperty("player_card_item_id"))
                if (!$util.isInteger(message.player_card_item_id) && !(message.player_card_item_id && $util.isInteger(message.player_card_item_id.low) && $util.isInteger(message.player_card_item_id.high)))
                    return "player_card_item_id: integer|Long expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                if (!$util.isInteger(message.event_id))
                    return "event_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgClientToGCSetPlayerCardRosterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgClientToGCSetPlayerCardRosterRequest} CMsgClientToGCSetPlayerCardRosterRequest
         */
        CMsgClientToGCSetPlayerCardRosterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgClientToGCSetPlayerCardRosterRequest)
                return object;
            var message = new $root.CMsgClientToGCSetPlayerCardRosterRequest();
            if (object.league_id != null)
                message.league_id = object.league_id >>> 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.slot != null)
                message.slot = object.slot >>> 0;
            if (object.player_card_item_id != null)
                if ($util.Long)
                    (message.player_card_item_id = $util.Long.fromValue(object.player_card_item_id)).unsigned = true;
                else if (typeof object.player_card_item_id === "string")
                    message.player_card_item_id = parseInt(object.player_card_item_id, 10);
                else if (typeof object.player_card_item_id === "number")
                    message.player_card_item_id = object.player_card_item_id;
                else if (typeof object.player_card_item_id === "object")
                    message.player_card_item_id = new $util.LongBits(object.player_card_item_id.low >>> 0, object.player_card_item_id.high >>> 0).toNumber(true);
            if (object.event_id != null)
                message.event_id = object.event_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgClientToGCSetPlayerCardRosterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @static
         * @param {CMsgClientToGCSetPlayerCardRosterRequest} message CMsgClientToGCSetPlayerCardRosterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgClientToGCSetPlayerCardRosterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.league_id = 0;
                object.timestamp = 0;
                object.slot = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.player_card_item_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.player_card_item_id = options.longs === String ? "0" : 0;
                object.event_id = 0;
            }
            if (message.league_id != null && message.hasOwnProperty("league_id"))
                object.league_id = message.league_id;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.player_card_item_id != null && message.hasOwnProperty("player_card_item_id"))
                if (typeof message.player_card_item_id === "number")
                    object.player_card_item_id = options.longs === String ? String(message.player_card_item_id) : message.player_card_item_id;
                else
                    object.player_card_item_id = options.longs === String ? $util.Long.prototype.toString.call(message.player_card_item_id) : options.longs === Number ? new $util.LongBits(message.player_card_item_id.low >>> 0, message.player_card_item_id.high >>> 0).toNumber(true) : message.player_card_item_id;
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = message.event_id;
            return object;
        };
    
        /**
         * Converts this CMsgClientToGCSetPlayerCardRosterRequest to JSON.
         * @function toJSON
         * @memberof CMsgClientToGCSetPlayerCardRosterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgClientToGCSetPlayerCardRosterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgClientToGCSetPlayerCardRosterRequest;
    })();
    
    $root.CMsgClientToGCSetPlayerCardRosterResponse = (function() {
    
        /**
         * Properties of a CMsgClientToGCSetPlayerCardRosterResponse.
         * @exports ICMsgClientToGCSetPlayerCardRosterResponse
         * @interface ICMsgClientToGCSetPlayerCardRosterResponse
         * @property {CMsgClientToGCSetPlayerCardRosterResponse.Result|null} [result] CMsgClientToGCSetPlayerCardRosterResponse result
         */
    
        /**
         * Constructs a new CMsgClientToGCSetPlayerCardRosterResponse.
         * @exports CMsgClientToGCSetPlayerCardRosterResponse
         * @classdesc Represents a CMsgClientToGCSetPlayerCardRosterResponse.
         * @implements ICMsgClientToGCSetPlayerCardRosterResponse
         * @constructor
         * @param {ICMsgClientToGCSetPlayerCardRosterResponse=} [properties] Properties to set
         */
        function CMsgClientToGCSetPlayerCardRosterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgClientToGCSetPlayerCardRosterResponse result.
         * @member {CMsgClientToGCSetPlayerCardRosterResponse.Result} result
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @instance
         */
        CMsgClientToGCSetPlayerCardRosterResponse.prototype.result = 0;
    
        /**
         * Creates a new CMsgClientToGCSetPlayerCardRosterResponse instance using the specified properties.
         * @function create
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {ICMsgClientToGCSetPlayerCardRosterResponse=} [properties] Properties to set
         * @returns {CMsgClientToGCSetPlayerCardRosterResponse} CMsgClientToGCSetPlayerCardRosterResponse instance
         */
        CMsgClientToGCSetPlayerCardRosterResponse.create = function create(properties) {
            return new CMsgClientToGCSetPlayerCardRosterResponse(properties);
        };
    
        /**
         * Encodes the specified CMsgClientToGCSetPlayerCardRosterResponse message. Does not implicitly {@link CMsgClientToGCSetPlayerCardRosterResponse.verify|verify} messages.
         * @function encode
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {ICMsgClientToGCSetPlayerCardRosterResponse} message CMsgClientToGCSetPlayerCardRosterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCSetPlayerCardRosterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgClientToGCSetPlayerCardRosterResponse message, length delimited. Does not implicitly {@link CMsgClientToGCSetPlayerCardRosterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {ICMsgClientToGCSetPlayerCardRosterResponse} message CMsgClientToGCSetPlayerCardRosterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgClientToGCSetPlayerCardRosterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgClientToGCSetPlayerCardRosterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgClientToGCSetPlayerCardRosterResponse} CMsgClientToGCSetPlayerCardRosterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCSetPlayerCardRosterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgClientToGCSetPlayerCardRosterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgClientToGCSetPlayerCardRosterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgClientToGCSetPlayerCardRosterResponse} CMsgClientToGCSetPlayerCardRosterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgClientToGCSetPlayerCardRosterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgClientToGCSetPlayerCardRosterResponse message.
         * @function verify
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgClientToGCSetPlayerCardRosterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CMsgClientToGCSetPlayerCardRosterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgClientToGCSetPlayerCardRosterResponse} CMsgClientToGCSetPlayerCardRosterResponse
         */
        CMsgClientToGCSetPlayerCardRosterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgClientToGCSetPlayerCardRosterResponse)
                return object;
            var message = new $root.CMsgClientToGCSetPlayerCardRosterResponse();
            switch (object.result) {
            case "SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "ERROR_UNSPECIFIED":
            case 1:
                message.result = 1;
                break;
            case "ERROR_INVALID_LEAGUE_ID":
            case 2:
                message.result = 2;
                break;
            case "ERROR_INVALID_TIMESTAMP":
            case 3:
                message.result = 3;
                break;
            case "ERROR_PLAYER_CARD_NOT_OWNED":
            case 4:
                message.result = 4;
                break;
            case "ERROR_INVALID_SLOT":
            case 5:
                message.result = 5;
                break;
            case "ERROR_FAILED_CARD_INFO":
            case 6:
                message.result = 6;
                break;
            case "ERROR_ACCOUNT_DUPLICATE":
            case 7:
                message.result = 7;
                break;
            case "ERROR_LOCKED_TIMESTAMP":
            case 8:
                message.result = 8;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgClientToGCSetPlayerCardRosterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @static
         * @param {CMsgClientToGCSetPlayerCardRosterResponse} message CMsgClientToGCSetPlayerCardRosterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgClientToGCSetPlayerCardRosterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.CMsgClientToGCSetPlayerCardRosterResponse.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CMsgClientToGCSetPlayerCardRosterResponse to JSON.
         * @function toJSON
         * @memberof CMsgClientToGCSetPlayerCardRosterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgClientToGCSetPlayerCardRosterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Result enum.
         * @name CMsgClientToGCSetPlayerCardRosterResponse.Result
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR_UNSPECIFIED=1 ERROR_UNSPECIFIED value
         * @property {number} ERROR_INVALID_LEAGUE_ID=2 ERROR_INVALID_LEAGUE_ID value
         * @property {number} ERROR_INVALID_TIMESTAMP=3 ERROR_INVALID_TIMESTAMP value
         * @property {number} ERROR_PLAYER_CARD_NOT_OWNED=4 ERROR_PLAYER_CARD_NOT_OWNED value
         * @property {number} ERROR_INVALID_SLOT=5 ERROR_INVALID_SLOT value
         * @property {number} ERROR_FAILED_CARD_INFO=6 ERROR_FAILED_CARD_INFO value
         * @property {number} ERROR_ACCOUNT_DUPLICATE=7 ERROR_ACCOUNT_DUPLICATE value
         * @property {number} ERROR_LOCKED_TIMESTAMP=8 ERROR_LOCKED_TIMESTAMP value
         */
        CMsgClientToGCSetPlayerCardRosterResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR_UNSPECIFIED"] = 1;
            values[valuesById[2] = "ERROR_INVALID_LEAGUE_ID"] = 2;
            values[valuesById[3] = "ERROR_INVALID_TIMESTAMP"] = 3;
            values[valuesById[4] = "ERROR_PLAYER_CARD_NOT_OWNED"] = 4;
            values[valuesById[5] = "ERROR_INVALID_SLOT"] = 5;
            values[valuesById[6] = "ERROR_FAILED_CARD_INFO"] = 6;
            values[valuesById[7] = "ERROR_ACCOUNT_DUPLICATE"] = 7;
            values[valuesById[8] = "ERROR_LOCKED_TIMESTAMP"] = 8;
            return values;
        })();
    
        return CMsgClientToGCSetPlayerCardRosterResponse;
    })();
    
    $root.CMsgDOTAFantasyDPCLeagueStatus = (function() {
    
        /**
         * Properties of a CMsgDOTAFantasyDPCLeagueStatus.
         * @exports ICMsgDOTAFantasyDPCLeagueStatus
         * @interface ICMsgDOTAFantasyDPCLeagueStatus
         * @property {Array.<CMsgDOTAFantasyDPCLeagueStatus.ILeagueInfo>|null} [league_infos] CMsgDOTAFantasyDPCLeagueStatus league_infos
         */
    
        /**
         * Constructs a new CMsgDOTAFantasyDPCLeagueStatus.
         * @exports CMsgDOTAFantasyDPCLeagueStatus
         * @classdesc Represents a CMsgDOTAFantasyDPCLeagueStatus.
         * @implements ICMsgDOTAFantasyDPCLeagueStatus
         * @constructor
         * @param {ICMsgDOTAFantasyDPCLeagueStatus=} [properties] Properties to set
         */
        function CMsgDOTAFantasyDPCLeagueStatus(properties) {
            this.league_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTAFantasyDPCLeagueStatus league_infos.
         * @member {Array.<CMsgDOTAFantasyDPCLeagueStatus.ILeagueInfo>} league_infos
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @instance
         */
        CMsgDOTAFantasyDPCLeagueStatus.prototype.league_infos = $util.emptyArray;
    
        /**
         * Creates a new CMsgDOTAFantasyDPCLeagueStatus instance using the specified properties.
         * @function create
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {ICMsgDOTAFantasyDPCLeagueStatus=} [properties] Properties to set
         * @returns {CMsgDOTAFantasyDPCLeagueStatus} CMsgDOTAFantasyDPCLeagueStatus instance
         */
        CMsgDOTAFantasyDPCLeagueStatus.create = function create(properties) {
            return new CMsgDOTAFantasyDPCLeagueStatus(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyDPCLeagueStatus message. Does not implicitly {@link CMsgDOTAFantasyDPCLeagueStatus.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {ICMsgDOTAFantasyDPCLeagueStatus} message CMsgDOTAFantasyDPCLeagueStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyDPCLeagueStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.league_infos != null && message.league_infos.length)
                for (var i = 0; i < message.league_infos.length; ++i)
                    $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.encode(message.league_infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTAFantasyDPCLeagueStatus message, length delimited. Does not implicitly {@link CMsgDOTAFantasyDPCLeagueStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {ICMsgDOTAFantasyDPCLeagueStatus} message CMsgDOTAFantasyDPCLeagueStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTAFantasyDPCLeagueStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTAFantasyDPCLeagueStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTAFantasyDPCLeagueStatus} CMsgDOTAFantasyDPCLeagueStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyDPCLeagueStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyDPCLeagueStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.league_infos && message.league_infos.length))
                        message.league_infos = [];
                    message.league_infos.push($root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTAFantasyDPCLeagueStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTAFantasyDPCLeagueStatus} CMsgDOTAFantasyDPCLeagueStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTAFantasyDPCLeagueStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTAFantasyDPCLeagueStatus message.
         * @function verify
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTAFantasyDPCLeagueStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.league_infos != null && message.hasOwnProperty("league_infos")) {
                if (!Array.isArray(message.league_infos))
                    return "league_infos: array expected";
                for (var i = 0; i < message.league_infos.length; ++i) {
                    var error = $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.verify(message.league_infos[i]);
                    if (error)
                        return "league_infos." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgDOTAFantasyDPCLeagueStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTAFantasyDPCLeagueStatus} CMsgDOTAFantasyDPCLeagueStatus
         */
        CMsgDOTAFantasyDPCLeagueStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTAFantasyDPCLeagueStatus)
                return object;
            var message = new $root.CMsgDOTAFantasyDPCLeagueStatus();
            if (object.league_infos) {
                if (!Array.isArray(object.league_infos))
                    throw TypeError(".CMsgDOTAFantasyDPCLeagueStatus.league_infos: array expected");
                message.league_infos = [];
                for (var i = 0; i < object.league_infos.length; ++i) {
                    if (typeof object.league_infos[i] !== "object")
                        throw TypeError(".CMsgDOTAFantasyDPCLeagueStatus.league_infos: object expected");
                    message.league_infos[i] = $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.fromObject(object.league_infos[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTAFantasyDPCLeagueStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @static
         * @param {CMsgDOTAFantasyDPCLeagueStatus} message CMsgDOTAFantasyDPCLeagueStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTAFantasyDPCLeagueStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.league_infos = [];
            if (message.league_infos && message.league_infos.length) {
                object.league_infos = [];
                for (var j = 0; j < message.league_infos.length; ++j)
                    object.league_infos[j] = $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.toObject(message.league_infos[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgDOTAFantasyDPCLeagueStatus to JSON.
         * @function toJSON
         * @memberof CMsgDOTAFantasyDPCLeagueStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTAFantasyDPCLeagueStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo = (function() {
    
            /**
             * Properties of a LeagueInfo.
             * @memberof CMsgDOTAFantasyDPCLeagueStatus
             * @interface ILeagueInfo
             * @property {number|null} [league_id] LeagueInfo league_id
             * @property {string|null} [league_name] LeagueInfo league_name
             * @property {number|null} [start_timestamp] LeagueInfo start_timestamp
             * @property {number|null} [end_timestamp] LeagueInfo end_timestamp
             * @property {Array.<number>|null} [day_timestamps] LeagueInfo day_timestamps
             * @property {CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus|null} [status] LeagueInfo status
             */
    
            /**
             * Constructs a new LeagueInfo.
             * @memberof CMsgDOTAFantasyDPCLeagueStatus
             * @classdesc Represents a LeagueInfo.
             * @implements ILeagueInfo
             * @constructor
             * @param {CMsgDOTAFantasyDPCLeagueStatus.ILeagueInfo=} [properties] Properties to set
             */
            function LeagueInfo(properties) {
                this.day_timestamps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LeagueInfo league_id.
             * @member {number} league_id
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             */
            LeagueInfo.prototype.league_id = 0;
    
            /**
             * LeagueInfo league_name.
             * @member {string} league_name
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             */
            LeagueInfo.prototype.league_name = "";
    
            /**
             * LeagueInfo start_timestamp.
             * @member {number} start_timestamp
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             */
            LeagueInfo.prototype.start_timestamp = 0;
    
            /**
             * LeagueInfo end_timestamp.
             * @member {number} end_timestamp
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             */
            LeagueInfo.prototype.end_timestamp = 0;
    
            /**
             * LeagueInfo day_timestamps.
             * @member {Array.<number>} day_timestamps
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             */
            LeagueInfo.prototype.day_timestamps = $util.emptyArray;
    
            /**
             * LeagueInfo status.
             * @member {CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus} status
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             */
            LeagueInfo.prototype.status = 0;
    
            /**
             * Creates a new LeagueInfo instance using the specified properties.
             * @function create
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {CMsgDOTAFantasyDPCLeagueStatus.ILeagueInfo=} [properties] Properties to set
             * @returns {CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo} LeagueInfo instance
             */
            LeagueInfo.create = function create(properties) {
                return new LeagueInfo(properties);
            };
    
            /**
             * Encodes the specified LeagueInfo message. Does not implicitly {@link CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.verify|verify} messages.
             * @function encode
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {CMsgDOTAFantasyDPCLeagueStatus.ILeagueInfo} message LeagueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeagueInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.league_id != null && Object.hasOwnProperty.call(message, "league_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.league_id);
                if (message.league_name != null && Object.hasOwnProperty.call(message, "league_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.league_name);
                if (message.start_timestamp != null && Object.hasOwnProperty.call(message, "start_timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.start_timestamp);
                if (message.end_timestamp != null && Object.hasOwnProperty.call(message, "end_timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.end_timestamp);
                if (message.day_timestamps != null && message.day_timestamps.length)
                    for (var i = 0; i < message.day_timestamps.length; ++i)
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.day_timestamps[i]);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.status);
                return writer;
            };
    
            /**
             * Encodes the specified LeagueInfo message, length delimited. Does not implicitly {@link CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {CMsgDOTAFantasyDPCLeagueStatus.ILeagueInfo} message LeagueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeagueInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LeagueInfo message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo} LeagueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeagueInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.league_id = reader.uint32();
                        break;
                    case 2:
                        message.league_name = reader.string();
                        break;
                    case 3:
                        message.start_timestamp = reader.uint32();
                        break;
                    case 4:
                        message.end_timestamp = reader.uint32();
                        break;
                    case 5:
                        if (!(message.day_timestamps && message.day_timestamps.length))
                            message.day_timestamps = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.day_timestamps.push(reader.uint32());
                        } else
                            message.day_timestamps.push(reader.uint32());
                        break;
                    case 8:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LeagueInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo} LeagueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeagueInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LeagueInfo message.
             * @function verify
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeagueInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.league_id != null && message.hasOwnProperty("league_id"))
                    if (!$util.isInteger(message.league_id))
                        return "league_id: integer expected";
                if (message.league_name != null && message.hasOwnProperty("league_name"))
                    if (!$util.isString(message.league_name))
                        return "league_name: string expected";
                if (message.start_timestamp != null && message.hasOwnProperty("start_timestamp"))
                    if (!$util.isInteger(message.start_timestamp))
                        return "start_timestamp: integer expected";
                if (message.end_timestamp != null && message.hasOwnProperty("end_timestamp"))
                    if (!$util.isInteger(message.end_timestamp))
                        return "end_timestamp: integer expected";
                if (message.day_timestamps != null && message.hasOwnProperty("day_timestamps")) {
                    if (!Array.isArray(message.day_timestamps))
                        return "day_timestamps: array expected";
                    for (var i = 0; i < message.day_timestamps.length; ++i)
                        if (!$util.isInteger(message.day_timestamps[i]))
                            return "day_timestamps: integer[] expected";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a LeagueInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo} LeagueInfo
             */
            LeagueInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo)
                    return object;
                var message = new $root.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo();
                if (object.league_id != null)
                    message.league_id = object.league_id >>> 0;
                if (object.league_name != null)
                    message.league_name = String(object.league_name);
                if (object.start_timestamp != null)
                    message.start_timestamp = object.start_timestamp >>> 0;
                if (object.end_timestamp != null)
                    message.end_timestamp = object.end_timestamp >>> 0;
                if (object.day_timestamps) {
                    if (!Array.isArray(object.day_timestamps))
                        throw TypeError(".CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.day_timestamps: array expected");
                    message.day_timestamps = [];
                    for (var i = 0; i < object.day_timestamps.length; ++i)
                        message.day_timestamps[i] = object.day_timestamps[i] >>> 0;
                }
                switch (object.status) {
                case "UNSET":
                case 0:
                    message.status = 0;
                    break;
                case "PARTIAL":
                case 1:
                    message.status = 1;
                    break;
                case "FULL":
                case 2:
                    message.status = 2;
                    break;
                case "CONCLUDED":
                case 3:
                    message.status = 3;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a LeagueInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @static
             * @param {CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo} message LeagueInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeagueInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.day_timestamps = [];
                if (options.defaults) {
                    object.league_id = 0;
                    object.league_name = "";
                    object.start_timestamp = 0;
                    object.end_timestamp = 0;
                    object.status = options.enums === String ? "UNSET" : 0;
                }
                if (message.league_id != null && message.hasOwnProperty("league_id"))
                    object.league_id = message.league_id;
                if (message.league_name != null && message.hasOwnProperty("league_name"))
                    object.league_name = message.league_name;
                if (message.start_timestamp != null && message.hasOwnProperty("start_timestamp"))
                    object.start_timestamp = message.start_timestamp;
                if (message.end_timestamp != null && message.hasOwnProperty("end_timestamp"))
                    object.end_timestamp = message.end_timestamp;
                if (message.day_timestamps && message.day_timestamps.length) {
                    object.day_timestamps = [];
                    for (var j = 0; j < message.day_timestamps.length; ++j)
                        object.day_timestamps[j] = message.day_timestamps[j];
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus[message.status] : message.status;
                return object;
            };
    
            /**
             * Converts this LeagueInfo to JSON.
             * @function toJSON
             * @memberof CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeagueInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LeagueInfo;
        })();
    
        /**
         * ERosterStatus enum.
         * @name CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus
         * @enum {number}
         * @property {number} UNSET=0 UNSET value
         * @property {number} PARTIAL=1 PARTIAL value
         * @property {number} FULL=2 FULL value
         * @property {number} CONCLUDED=3 CONCLUDED value
         */
        CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[1] = "PARTIAL"] = 1;
            values[valuesById[2] = "FULL"] = 2;
            values[valuesById[3] = "CONCLUDED"] = 3;
            return values;
        })();
    
        return CMsgDOTAFantasyDPCLeagueStatus;
    })();
    
    /**
     * DOTA_GameMode enum.
     * @exports DOTA_GameMode
     * @enum {number}
     * @property {number} DOTA_GAMEMODE_NONE=0 DOTA_GAMEMODE_NONE value
     * @property {number} DOTA_GAMEMODE_AP=1 DOTA_GAMEMODE_AP value
     * @property {number} DOTA_GAMEMODE_CM=2 DOTA_GAMEMODE_CM value
     * @property {number} DOTA_GAMEMODE_RD=3 DOTA_GAMEMODE_RD value
     * @property {number} DOTA_GAMEMODE_SD=4 DOTA_GAMEMODE_SD value
     * @property {number} DOTA_GAMEMODE_AR=5 DOTA_GAMEMODE_AR value
     * @property {number} DOTA_GAMEMODE_INTRO=6 DOTA_GAMEMODE_INTRO value
     * @property {number} DOTA_GAMEMODE_HW=7 DOTA_GAMEMODE_HW value
     * @property {number} DOTA_GAMEMODE_REVERSE_CM=8 DOTA_GAMEMODE_REVERSE_CM value
     * @property {number} DOTA_GAMEMODE_XMAS=9 DOTA_GAMEMODE_XMAS value
     * @property {number} DOTA_GAMEMODE_TUTORIAL=10 DOTA_GAMEMODE_TUTORIAL value
     * @property {number} DOTA_GAMEMODE_MO=11 DOTA_GAMEMODE_MO value
     * @property {number} DOTA_GAMEMODE_LP=12 DOTA_GAMEMODE_LP value
     * @property {number} DOTA_GAMEMODE_POOL1=13 DOTA_GAMEMODE_POOL1 value
     * @property {number} DOTA_GAMEMODE_FH=14 DOTA_GAMEMODE_FH value
     * @property {number} DOTA_GAMEMODE_CUSTOM=15 DOTA_GAMEMODE_CUSTOM value
     * @property {number} DOTA_GAMEMODE_CD=16 DOTA_GAMEMODE_CD value
     * @property {number} DOTA_GAMEMODE_BD=17 DOTA_GAMEMODE_BD value
     * @property {number} DOTA_GAMEMODE_ABILITY_DRAFT=18 DOTA_GAMEMODE_ABILITY_DRAFT value
     * @property {number} DOTA_GAMEMODE_EVENT=19 DOTA_GAMEMODE_EVENT value
     * @property {number} DOTA_GAMEMODE_ARDM=20 DOTA_GAMEMODE_ARDM value
     * @property {number} DOTA_GAMEMODE_1V1MID=21 DOTA_GAMEMODE_1V1MID value
     * @property {number} DOTA_GAMEMODE_ALL_DRAFT=22 DOTA_GAMEMODE_ALL_DRAFT value
     * @property {number} DOTA_GAMEMODE_TURBO=23 DOTA_GAMEMODE_TURBO value
     * @property {number} DOTA_GAMEMODE_MUTATION=24 DOTA_GAMEMODE_MUTATION value
     * @property {number} DOTA_GAMEMODE_COACHES_CHALLENGE=25 DOTA_GAMEMODE_COACHES_CHALLENGE value
     */
    $root.DOTA_GameMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GAMEMODE_NONE"] = 0;
        values[valuesById[1] = "DOTA_GAMEMODE_AP"] = 1;
        values[valuesById[2] = "DOTA_GAMEMODE_CM"] = 2;
        values[valuesById[3] = "DOTA_GAMEMODE_RD"] = 3;
        values[valuesById[4] = "DOTA_GAMEMODE_SD"] = 4;
        values[valuesById[5] = "DOTA_GAMEMODE_AR"] = 5;
        values[valuesById[6] = "DOTA_GAMEMODE_INTRO"] = 6;
        values[valuesById[7] = "DOTA_GAMEMODE_HW"] = 7;
        values[valuesById[8] = "DOTA_GAMEMODE_REVERSE_CM"] = 8;
        values[valuesById[9] = "DOTA_GAMEMODE_XMAS"] = 9;
        values[valuesById[10] = "DOTA_GAMEMODE_TUTORIAL"] = 10;
        values[valuesById[11] = "DOTA_GAMEMODE_MO"] = 11;
        values[valuesById[12] = "DOTA_GAMEMODE_LP"] = 12;
        values[valuesById[13] = "DOTA_GAMEMODE_POOL1"] = 13;
        values[valuesById[14] = "DOTA_GAMEMODE_FH"] = 14;
        values[valuesById[15] = "DOTA_GAMEMODE_CUSTOM"] = 15;
        values[valuesById[16] = "DOTA_GAMEMODE_CD"] = 16;
        values[valuesById[17] = "DOTA_GAMEMODE_BD"] = 17;
        values[valuesById[18] = "DOTA_GAMEMODE_ABILITY_DRAFT"] = 18;
        values[valuesById[19] = "DOTA_GAMEMODE_EVENT"] = 19;
        values[valuesById[20] = "DOTA_GAMEMODE_ARDM"] = 20;
        values[valuesById[21] = "DOTA_GAMEMODE_1V1MID"] = 21;
        values[valuesById[22] = "DOTA_GAMEMODE_ALL_DRAFT"] = 22;
        values[valuesById[23] = "DOTA_GAMEMODE_TURBO"] = 23;
        values[valuesById[24] = "DOTA_GAMEMODE_MUTATION"] = 24;
        values[valuesById[25] = "DOTA_GAMEMODE_COACHES_CHALLENGE"] = 25;
        return values;
    })();
    
    /**
     * DOTA_GameState enum.
     * @exports DOTA_GameState
     * @enum {number}
     * @property {number} DOTA_GAMERULES_STATE_INIT=0 DOTA_GAMERULES_STATE_INIT value
     * @property {number} DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD=1 DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD value
     * @property {number} DOTA_GAMERULES_STATE_HERO_SELECTION=2 DOTA_GAMERULES_STATE_HERO_SELECTION value
     * @property {number} DOTA_GAMERULES_STATE_STRATEGY_TIME=3 DOTA_GAMERULES_STATE_STRATEGY_TIME value
     * @property {number} DOTA_GAMERULES_STATE_PRE_GAME=4 DOTA_GAMERULES_STATE_PRE_GAME value
     * @property {number} DOTA_GAMERULES_STATE_GAME_IN_PROGRESS=5 DOTA_GAMERULES_STATE_GAME_IN_PROGRESS value
     * @property {number} DOTA_GAMERULES_STATE_POST_GAME=6 DOTA_GAMERULES_STATE_POST_GAME value
     * @property {number} DOTA_GAMERULES_STATE_DISCONNECT=7 DOTA_GAMERULES_STATE_DISCONNECT value
     * @property {number} DOTA_GAMERULES_STATE_TEAM_SHOWCASE=8 DOTA_GAMERULES_STATE_TEAM_SHOWCASE value
     * @property {number} DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP=9 DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP value
     * @property {number} DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD=10 DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD value
     * @property {number} DOTA_GAMERULES_STATE_LAST=11 DOTA_GAMERULES_STATE_LAST value
     */
    $root.DOTA_GameState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GAMERULES_STATE_INIT"] = 0;
        values[valuesById[1] = "DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD"] = 1;
        values[valuesById[2] = "DOTA_GAMERULES_STATE_HERO_SELECTION"] = 2;
        values[valuesById[3] = "DOTA_GAMERULES_STATE_STRATEGY_TIME"] = 3;
        values[valuesById[4] = "DOTA_GAMERULES_STATE_PRE_GAME"] = 4;
        values[valuesById[5] = "DOTA_GAMERULES_STATE_GAME_IN_PROGRESS"] = 5;
        values[valuesById[6] = "DOTA_GAMERULES_STATE_POST_GAME"] = 6;
        values[valuesById[7] = "DOTA_GAMERULES_STATE_DISCONNECT"] = 7;
        values[valuesById[8] = "DOTA_GAMERULES_STATE_TEAM_SHOWCASE"] = 8;
        values[valuesById[9] = "DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP"] = 9;
        values[valuesById[10] = "DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD"] = 10;
        values[valuesById[11] = "DOTA_GAMERULES_STATE_LAST"] = 11;
        return values;
    })();
    
    /**
     * DOTA_GC_TEAM enum.
     * @exports DOTA_GC_TEAM
     * @enum {number}
     * @property {number} DOTA_GC_TEAM_GOOD_GUYS=0 DOTA_GC_TEAM_GOOD_GUYS value
     * @property {number} DOTA_GC_TEAM_BAD_GUYS=1 DOTA_GC_TEAM_BAD_GUYS value
     * @property {number} DOTA_GC_TEAM_BROADCASTER=2 DOTA_GC_TEAM_BROADCASTER value
     * @property {number} DOTA_GC_TEAM_SPECTATOR=3 DOTA_GC_TEAM_SPECTATOR value
     * @property {number} DOTA_GC_TEAM_PLAYER_POOL=4 DOTA_GC_TEAM_PLAYER_POOL value
     * @property {number} DOTA_GC_TEAM_NOTEAM=5 DOTA_GC_TEAM_NOTEAM value
     */
    $root.DOTA_GC_TEAM = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_GC_TEAM_GOOD_GUYS"] = 0;
        values[valuesById[1] = "DOTA_GC_TEAM_BAD_GUYS"] = 1;
        values[valuesById[2] = "DOTA_GC_TEAM_BROADCASTER"] = 2;
        values[valuesById[3] = "DOTA_GC_TEAM_SPECTATOR"] = 3;
        values[valuesById[4] = "DOTA_GC_TEAM_PLAYER_POOL"] = 4;
        values[valuesById[5] = "DOTA_GC_TEAM_NOTEAM"] = 5;
        return values;
    })();
    
    /**
     * EEvent enum.
     * @exports EEvent
     * @enum {number}
     * @property {number} EVENT_ID_NONE=0 EVENT_ID_NONE value
     * @property {number} EVENT_ID_DIRETIDE=1 EVENT_ID_DIRETIDE value
     * @property {number} EVENT_ID_SPRING_FESTIVAL=2 EVENT_ID_SPRING_FESTIVAL value
     * @property {number} EVENT_ID_FROSTIVUS_2013=3 EVENT_ID_FROSTIVUS_2013 value
     * @property {number} EVENT_ID_COMPENDIUM_2014=4 EVENT_ID_COMPENDIUM_2014 value
     * @property {number} EVENT_ID_NEXON_PC_BANG=5 EVENT_ID_NEXON_PC_BANG value
     * @property {number} EVENT_ID_PWRD_DAC_2015=6 EVENT_ID_PWRD_DAC_2015 value
     * @property {number} EVENT_ID_NEW_BLOOM_2015=7 EVENT_ID_NEW_BLOOM_2015 value
     * @property {number} EVENT_ID_INTERNATIONAL_2015=8 EVENT_ID_INTERNATIONAL_2015 value
     * @property {number} EVENT_ID_FALL_MAJOR_2015=9 EVENT_ID_FALL_MAJOR_2015 value
     * @property {number} EVENT_ID_ORACLE_PA=10 EVENT_ID_ORACLE_PA value
     * @property {number} EVENT_ID_NEW_BLOOM_2015_PREBEAST=11 EVENT_ID_NEW_BLOOM_2015_PREBEAST value
     * @property {number} EVENT_ID_FROSTIVUS=12 EVENT_ID_FROSTIVUS value
     * @property {number} EVENT_ID_WINTER_MAJOR_2016=13 EVENT_ID_WINTER_MAJOR_2016 value
     * @property {number} EVENT_ID_INTERNATIONAL_2016=14 EVENT_ID_INTERNATIONAL_2016 value
     * @property {number} EVENT_ID_FALL_MAJOR_2016=15 EVENT_ID_FALL_MAJOR_2016 value
     * @property {number} EVENT_ID_WINTER_MAJOR_2017=16 EVENT_ID_WINTER_MAJOR_2017 value
     * @property {number} EVENT_ID_NEW_BLOOM_2017=17 EVENT_ID_NEW_BLOOM_2017 value
     * @property {number} EVENT_ID_INTERNATIONAL_2017=18 EVENT_ID_INTERNATIONAL_2017 value
     * @property {number} EVENT_ID_PLUS_SUBSCRIPTION=19 EVENT_ID_PLUS_SUBSCRIPTION value
     * @property {number} EVENT_ID_SINGLES_DAY_2017=20 EVENT_ID_SINGLES_DAY_2017 value
     * @property {number} EVENT_ID_FROSTIVUS_2017=21 EVENT_ID_FROSTIVUS_2017 value
     * @property {number} EVENT_ID_INTERNATIONAL_2018=22 EVENT_ID_INTERNATIONAL_2018 value
     * @property {number} EVENT_ID_FROSTIVUS_2018=23 EVENT_ID_FROSTIVUS_2018 value
     * @property {number} EVENT_ID_NEW_BLOOM_2019=24 EVENT_ID_NEW_BLOOM_2019 value
     * @property {number} EVENT_ID_INTERNATIONAL_2019=25 EVENT_ID_INTERNATIONAL_2019 value
     * @property {number} EVENT_ID_NEW_PLAYER_EXPERIENCE=26 EVENT_ID_NEW_PLAYER_EXPERIENCE value
     * @property {number} EVENT_ID_FROSTIVUS_2019=27 EVENT_ID_FROSTIVUS_2019 value
     * @property {number} EVENT_ID_NEW_BLOOM_2020=28 EVENT_ID_NEW_BLOOM_2020 value
     * @property {number} EVENT_ID_INTERNATIONAL_2020=29 EVENT_ID_INTERNATIONAL_2020 value
     * @property {number} EVENT_ID_TEAM_FANDOM=30 EVENT_ID_TEAM_FANDOM value
     * @property {number} EVENT_ID_DIRETIDE_2020=31 EVENT_ID_DIRETIDE_2020 value
     * @property {number} EVENT_ID_COUNT=32 EVENT_ID_COUNT value
     */
    $root.EEvent = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EVENT_ID_NONE"] = 0;
        values[valuesById[1] = "EVENT_ID_DIRETIDE"] = 1;
        values[valuesById[2] = "EVENT_ID_SPRING_FESTIVAL"] = 2;
        values[valuesById[3] = "EVENT_ID_FROSTIVUS_2013"] = 3;
        values[valuesById[4] = "EVENT_ID_COMPENDIUM_2014"] = 4;
        values[valuesById[5] = "EVENT_ID_NEXON_PC_BANG"] = 5;
        values[valuesById[6] = "EVENT_ID_PWRD_DAC_2015"] = 6;
        values[valuesById[7] = "EVENT_ID_NEW_BLOOM_2015"] = 7;
        values[valuesById[8] = "EVENT_ID_INTERNATIONAL_2015"] = 8;
        values[valuesById[9] = "EVENT_ID_FALL_MAJOR_2015"] = 9;
        values[valuesById[10] = "EVENT_ID_ORACLE_PA"] = 10;
        values[valuesById[11] = "EVENT_ID_NEW_BLOOM_2015_PREBEAST"] = 11;
        values[valuesById[12] = "EVENT_ID_FROSTIVUS"] = 12;
        values[valuesById[13] = "EVENT_ID_WINTER_MAJOR_2016"] = 13;
        values[valuesById[14] = "EVENT_ID_INTERNATIONAL_2016"] = 14;
        values[valuesById[15] = "EVENT_ID_FALL_MAJOR_2016"] = 15;
        values[valuesById[16] = "EVENT_ID_WINTER_MAJOR_2017"] = 16;
        values[valuesById[17] = "EVENT_ID_NEW_BLOOM_2017"] = 17;
        values[valuesById[18] = "EVENT_ID_INTERNATIONAL_2017"] = 18;
        values[valuesById[19] = "EVENT_ID_PLUS_SUBSCRIPTION"] = 19;
        values[valuesById[20] = "EVENT_ID_SINGLES_DAY_2017"] = 20;
        values[valuesById[21] = "EVENT_ID_FROSTIVUS_2017"] = 21;
        values[valuesById[22] = "EVENT_ID_INTERNATIONAL_2018"] = 22;
        values[valuesById[23] = "EVENT_ID_FROSTIVUS_2018"] = 23;
        values[valuesById[24] = "EVENT_ID_NEW_BLOOM_2019"] = 24;
        values[valuesById[25] = "EVENT_ID_INTERNATIONAL_2019"] = 25;
        values[valuesById[26] = "EVENT_ID_NEW_PLAYER_EXPERIENCE"] = 26;
        values[valuesById[27] = "EVENT_ID_FROSTIVUS_2019"] = 27;
        values[valuesById[28] = "EVENT_ID_NEW_BLOOM_2020"] = 28;
        values[valuesById[29] = "EVENT_ID_INTERNATIONAL_2020"] = 29;
        values[valuesById[30] = "EVENT_ID_TEAM_FANDOM"] = 30;
        values[valuesById[31] = "EVENT_ID_DIRETIDE_2020"] = 31;
        values[valuesById[32] = "EVENT_ID_COUNT"] = 32;
        return values;
    })();
    
    /**
     * DOTALeaverStatus_t enum.
     * @exports DOTALeaverStatus_t
     * @enum {number}
     * @property {number} DOTA_LEAVER_NONE=0 DOTA_LEAVER_NONE value
     * @property {number} DOTA_LEAVER_DISCONNECTED=1 DOTA_LEAVER_DISCONNECTED value
     * @property {number} DOTA_LEAVER_DISCONNECTED_TOO_LONG=2 DOTA_LEAVER_DISCONNECTED_TOO_LONG value
     * @property {number} DOTA_LEAVER_ABANDONED=3 DOTA_LEAVER_ABANDONED value
     * @property {number} DOTA_LEAVER_AFK=4 DOTA_LEAVER_AFK value
     * @property {number} DOTA_LEAVER_NEVER_CONNECTED=5 DOTA_LEAVER_NEVER_CONNECTED value
     * @property {number} DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG=6 DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG value
     * @property {number} DOTA_LEAVER_FAILED_TO_READY_UP=7 DOTA_LEAVER_FAILED_TO_READY_UP value
     * @property {number} DOTA_LEAVER_DECLINED=8 DOTA_LEAVER_DECLINED value
     */
    $root.DOTALeaverStatus_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_LEAVER_NONE"] = 0;
        values[valuesById[1] = "DOTA_LEAVER_DISCONNECTED"] = 1;
        values[valuesById[2] = "DOTA_LEAVER_DISCONNECTED_TOO_LONG"] = 2;
        values[valuesById[3] = "DOTA_LEAVER_ABANDONED"] = 3;
        values[valuesById[4] = "DOTA_LEAVER_AFK"] = 4;
        values[valuesById[5] = "DOTA_LEAVER_NEVER_CONNECTED"] = 5;
        values[valuesById[6] = "DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG"] = 6;
        values[valuesById[7] = "DOTA_LEAVER_FAILED_TO_READY_UP"] = 7;
        values[valuesById[8] = "DOTA_LEAVER_DECLINED"] = 8;
        return values;
    })();
    
    /**
     * DOTAConnectionState_t enum.
     * @exports DOTAConnectionState_t
     * @enum {number}
     * @property {number} DOTA_CONNECTION_STATE_UNKNOWN=0 DOTA_CONNECTION_STATE_UNKNOWN value
     * @property {number} DOTA_CONNECTION_STATE_NOT_YET_CONNECTED=1 DOTA_CONNECTION_STATE_NOT_YET_CONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_CONNECTED=2 DOTA_CONNECTION_STATE_CONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_DISCONNECTED=3 DOTA_CONNECTION_STATE_DISCONNECTED value
     * @property {number} DOTA_CONNECTION_STATE_ABANDONED=4 DOTA_CONNECTION_STATE_ABANDONED value
     * @property {number} DOTA_CONNECTION_STATE_LOADING=5 DOTA_CONNECTION_STATE_LOADING value
     * @property {number} DOTA_CONNECTION_STATE_FAILED=6 DOTA_CONNECTION_STATE_FAILED value
     */
    $root.DOTAConnectionState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_CONNECTION_STATE_UNKNOWN"] = 0;
        values[valuesById[1] = "DOTA_CONNECTION_STATE_NOT_YET_CONNECTED"] = 1;
        values[valuesById[2] = "DOTA_CONNECTION_STATE_CONNECTED"] = 2;
        values[valuesById[3] = "DOTA_CONNECTION_STATE_DISCONNECTED"] = 3;
        values[valuesById[4] = "DOTA_CONNECTION_STATE_ABANDONED"] = 4;
        values[valuesById[5] = "DOTA_CONNECTION_STATE_LOADING"] = 5;
        values[valuesById[6] = "DOTA_CONNECTION_STATE_FAILED"] = 6;
        return values;
    })();
    
    /**
     * Fantasy_Roles enum.
     * @exports Fantasy_Roles
     * @enum {number}
     * @property {number} FANTASY_ROLE_UNDEFINED=0 FANTASY_ROLE_UNDEFINED value
     * @property {number} FANTASY_ROLE_CORE=1 FANTASY_ROLE_CORE value
     * @property {number} FANTASY_ROLE_SUPPORT=2 FANTASY_ROLE_SUPPORT value
     * @property {number} FANTASY_ROLE_OFFLANE=3 FANTASY_ROLE_OFFLANE value
     * @property {number} FANTASY_ROLE_MID=4 FANTASY_ROLE_MID value
     */
    $root.Fantasy_Roles = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_ROLE_UNDEFINED"] = 0;
        values[valuesById[1] = "FANTASY_ROLE_CORE"] = 1;
        values[valuesById[2] = "FANTASY_ROLE_SUPPORT"] = 2;
        values[valuesById[3] = "FANTASY_ROLE_OFFLANE"] = 3;
        values[valuesById[4] = "FANTASY_ROLE_MID"] = 4;
        return values;
    })();
    
    /**
     * Fantasy_Team_Slots enum.
     * @exports Fantasy_Team_Slots
     * @enum {number}
     * @property {number} FANTASY_SLOT_NONE=0 FANTASY_SLOT_NONE value
     * @property {number} FANTASY_SLOT_CORE=1 FANTASY_SLOT_CORE value
     * @property {number} FANTASY_SLOT_SUPPORT=2 FANTASY_SLOT_SUPPORT value
     * @property {number} FANTASY_SLOT_ANY=3 FANTASY_SLOT_ANY value
     * @property {number} FANTASY_SLOT_BENCH=4 FANTASY_SLOT_BENCH value
     */
    $root.Fantasy_Team_Slots = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_SLOT_NONE"] = 0;
        values[valuesById[1] = "FANTASY_SLOT_CORE"] = 1;
        values[valuesById[2] = "FANTASY_SLOT_SUPPORT"] = 2;
        values[valuesById[3] = "FANTASY_SLOT_ANY"] = 3;
        values[valuesById[4] = "FANTASY_SLOT_BENCH"] = 4;
        return values;
    })();
    
    /**
     * Fantasy_Selection_Mode enum.
     * @exports Fantasy_Selection_Mode
     * @enum {number}
     * @property {number} FANTASY_SELECTION_INVALID=0 FANTASY_SELECTION_INVALID value
     * @property {number} FANTASY_SELECTION_LOCKED=1 FANTASY_SELECTION_LOCKED value
     * @property {number} FANTASY_SELECTION_SHUFFLE=2 FANTASY_SELECTION_SHUFFLE value
     * @property {number} FANTASY_SELECTION_FREE_PICK=3 FANTASY_SELECTION_FREE_PICK value
     * @property {number} FANTASY_SELECTION_ENDED=4 FANTASY_SELECTION_ENDED value
     * @property {number} FANTASY_SELECTION_PRE_SEASON=5 FANTASY_SELECTION_PRE_SEASON value
     * @property {number} FANTASY_SELECTION_PRE_DRAFT=6 FANTASY_SELECTION_PRE_DRAFT value
     * @property {number} FANTASY_SELECTION_DRAFTING=7 FANTASY_SELECTION_DRAFTING value
     * @property {number} FANTASY_SELECTION_REGULAR_SEASON=8 FANTASY_SELECTION_REGULAR_SEASON value
     * @property {number} FANTASY_SELECTION_CARD_BASED=9 FANTASY_SELECTION_CARD_BASED value
     */
    $root.Fantasy_Selection_Mode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FANTASY_SELECTION_INVALID"] = 0;
        values[valuesById[1] = "FANTASY_SELECTION_LOCKED"] = 1;
        values[valuesById[2] = "FANTASY_SELECTION_SHUFFLE"] = 2;
        values[valuesById[3] = "FANTASY_SELECTION_FREE_PICK"] = 3;
        values[valuesById[4] = "FANTASY_SELECTION_ENDED"] = 4;
        values[valuesById[5] = "FANTASY_SELECTION_PRE_SEASON"] = 5;
        values[valuesById[6] = "FANTASY_SELECTION_PRE_DRAFT"] = 6;
        values[valuesById[7] = "FANTASY_SELECTION_DRAFTING"] = 7;
        values[valuesById[8] = "FANTASY_SELECTION_REGULAR_SEASON"] = 8;
        values[valuesById[9] = "FANTASY_SELECTION_CARD_BASED"] = 9;
        return values;
    })();
    
    /**
     * DOTAChatChannelType_t enum.
     * @exports DOTAChatChannelType_t
     * @enum {number}
     * @property {number} DOTAChannelType_Regional=0 DOTAChannelType_Regional value
     * @property {number} DOTAChannelType_Custom=1 DOTAChannelType_Custom value
     * @property {number} DOTAChannelType_Party=2 DOTAChannelType_Party value
     * @property {number} DOTAChannelType_Lobby=3 DOTAChannelType_Lobby value
     * @property {number} DOTAChannelType_Team=4 DOTAChannelType_Team value
     * @property {number} DOTAChannelType_Guild=5 DOTAChannelType_Guild value
     * @property {number} DOTAChannelType_Fantasy=6 DOTAChannelType_Fantasy value
     * @property {number} DOTAChannelType_Whisper=7 DOTAChannelType_Whisper value
     * @property {number} DOTAChannelType_Console=8 DOTAChannelType_Console value
     * @property {number} DOTAChannelType_Tab=9 DOTAChannelType_Tab value
     * @property {number} DOTAChannelType_Invalid=10 DOTAChannelType_Invalid value
     * @property {number} DOTAChannelType_GameAll=11 DOTAChannelType_GameAll value
     * @property {number} DOTAChannelType_GameAllies=12 DOTAChannelType_GameAllies value
     * @property {number} DOTAChannelType_GameSpectator=13 DOTAChannelType_GameSpectator value
     * @property {number} DOTAChannelType_Cafe=15 DOTAChannelType_Cafe value
     * @property {number} DOTAChannelType_CustomGame=16 DOTAChannelType_CustomGame value
     * @property {number} DOTAChannelType_Private=17 DOTAChannelType_Private value
     * @property {number} DOTAChannelType_PostGame=18 DOTAChannelType_PostGame value
     * @property {number} DOTAChannelType_BattleCup=19 DOTAChannelType_BattleCup value
     * @property {number} DOTAChannelType_HLTVSpectator=20 DOTAChannelType_HLTVSpectator value
     * @property {number} DOTAChannelType_GameEvents=21 DOTAChannelType_GameEvents value
     * @property {number} DOTAChannelType_Trivia=22 DOTAChannelType_Trivia value
     */
    $root.DOTAChatChannelType_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTAChannelType_Regional"] = 0;
        values[valuesById[1] = "DOTAChannelType_Custom"] = 1;
        values[valuesById[2] = "DOTAChannelType_Party"] = 2;
        values[valuesById[3] = "DOTAChannelType_Lobby"] = 3;
        values[valuesById[4] = "DOTAChannelType_Team"] = 4;
        values[valuesById[5] = "DOTAChannelType_Guild"] = 5;
        values[valuesById[6] = "DOTAChannelType_Fantasy"] = 6;
        values[valuesById[7] = "DOTAChannelType_Whisper"] = 7;
        values[valuesById[8] = "DOTAChannelType_Console"] = 8;
        values[valuesById[9] = "DOTAChannelType_Tab"] = 9;
        values[valuesById[10] = "DOTAChannelType_Invalid"] = 10;
        values[valuesById[11] = "DOTAChannelType_GameAll"] = 11;
        values[valuesById[12] = "DOTAChannelType_GameAllies"] = 12;
        values[valuesById[13] = "DOTAChannelType_GameSpectator"] = 13;
        values[valuesById[15] = "DOTAChannelType_Cafe"] = 15;
        values[valuesById[16] = "DOTAChannelType_CustomGame"] = 16;
        values[valuesById[17] = "DOTAChannelType_Private"] = 17;
        values[valuesById[18] = "DOTAChannelType_PostGame"] = 18;
        values[valuesById[19] = "DOTAChannelType_BattleCup"] = 19;
        values[valuesById[20] = "DOTAChannelType_HLTVSpectator"] = 20;
        values[valuesById[21] = "DOTAChannelType_GameEvents"] = 21;
        values[valuesById[22] = "DOTAChannelType_Trivia"] = 22;
        return values;
    })();
    
    /**
     * EProfileCardSlotType enum.
     * @exports EProfileCardSlotType
     * @enum {number}
     * @property {number} k_EProfileCardSlotType_Empty=0 k_EProfileCardSlotType_Empty value
     * @property {number} k_EProfileCardSlotType_Stat=1 k_EProfileCardSlotType_Stat value
     * @property {number} k_EProfileCardSlotType_Trophy=2 k_EProfileCardSlotType_Trophy value
     * @property {number} k_EProfileCardSlotType_Item=3 k_EProfileCardSlotType_Item value
     * @property {number} k_EProfileCardSlotType_Hero=4 k_EProfileCardSlotType_Hero value
     * @property {number} k_EProfileCardSlotType_Emoticon=5 k_EProfileCardSlotType_Emoticon value
     * @property {number} k_EProfileCardSlotType_Team=6 k_EProfileCardSlotType_Team value
     */
    $root.EProfileCardSlotType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EProfileCardSlotType_Empty"] = 0;
        values[valuesById[1] = "k_EProfileCardSlotType_Stat"] = 1;
        values[valuesById[2] = "k_EProfileCardSlotType_Trophy"] = 2;
        values[valuesById[3] = "k_EProfileCardSlotType_Item"] = 3;
        values[valuesById[4] = "k_EProfileCardSlotType_Hero"] = 4;
        values[valuesById[5] = "k_EProfileCardSlotType_Emoticon"] = 5;
        values[valuesById[6] = "k_EProfileCardSlotType_Team"] = 6;
        return values;
    })();
    
    /**
     * EMatchGroupServerStatus enum.
     * @exports EMatchGroupServerStatus
     * @enum {number}
     * @property {number} k_EMatchGroupServerStatus_OK=0 k_EMatchGroupServerStatus_OK value
     * @property {number} k_EMatchGroupServerStatus_LimitedAvailability=1 k_EMatchGroupServerStatus_LimitedAvailability value
     * @property {number} k_EMatchGroupServerStatus_Offline=2 k_EMatchGroupServerStatus_Offline value
     */
    $root.EMatchGroupServerStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EMatchGroupServerStatus_OK"] = 0;
        values[valuesById[1] = "k_EMatchGroupServerStatus_LimitedAvailability"] = 1;
        values[valuesById[2] = "k_EMatchGroupServerStatus_Offline"] = 2;
        return values;
    })();
    
    /**
     * DOTA_CM_PICK enum.
     * @exports DOTA_CM_PICK
     * @enum {number}
     * @property {number} DOTA_CM_RANDOM=0 DOTA_CM_RANDOM value
     * @property {number} DOTA_CM_GOOD_GUYS=1 DOTA_CM_GOOD_GUYS value
     * @property {number} DOTA_CM_BAD_GUYS=2 DOTA_CM_BAD_GUYS value
     */
    $root.DOTA_CM_PICK = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_CM_RANDOM"] = 0;
        values[valuesById[1] = "DOTA_CM_GOOD_GUYS"] = 1;
        values[valuesById[2] = "DOTA_CM_BAD_GUYS"] = 2;
        return values;
    })();
    
    /**
     * DOTALowPriorityBanType enum.
     * @exports DOTALowPriorityBanType
     * @enum {number}
     * @property {number} DOTA_LOW_PRIORITY_BAN_ABANDON=0 DOTA_LOW_PRIORITY_BAN_ABANDON value
     * @property {number} DOTA_LOW_PRIORITY_BAN_REPORTS=1 DOTA_LOW_PRIORITY_BAN_REPORTS value
     * @property {number} DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON=2 DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON value
     * @property {number} DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE=3 DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE value
     */
    $root.DOTALowPriorityBanType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_LOW_PRIORITY_BAN_ABANDON"] = 0;
        values[valuesById[1] = "DOTA_LOW_PRIORITY_BAN_REPORTS"] = 1;
        values[valuesById[2] = "DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON"] = 2;
        values[valuesById[3] = "DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE"] = 3;
        return values;
    })();
    
    /**
     * DOTALobbyReadyState enum.
     * @exports DOTALobbyReadyState
     * @enum {number}
     * @property {number} DOTALobbyReadyState_UNDECLARED=0 DOTALobbyReadyState_UNDECLARED value
     * @property {number} DOTALobbyReadyState_ACCEPTED=1 DOTALobbyReadyState_ACCEPTED value
     * @property {number} DOTALobbyReadyState_DECLINED=2 DOTALobbyReadyState_DECLINED value
     */
    $root.DOTALobbyReadyState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTALobbyReadyState_UNDECLARED"] = 0;
        values[valuesById[1] = "DOTALobbyReadyState_ACCEPTED"] = 1;
        values[valuesById[2] = "DOTALobbyReadyState_DECLINED"] = 2;
        return values;
    })();
    
    /**
     * DOTAGameVersion enum.
     * @exports DOTAGameVersion
     * @enum {number}
     * @property {number} GAME_VERSION_CURRENT=0 GAME_VERSION_CURRENT value
     * @property {number} GAME_VERSION_STABLE=1 GAME_VERSION_STABLE value
     */
    $root.DOTAGameVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GAME_VERSION_CURRENT"] = 0;
        values[valuesById[1] = "GAME_VERSION_STABLE"] = 1;
        return values;
    })();
    
    /**
     * DOTAJoinLobbyResult enum.
     * @exports DOTAJoinLobbyResult
     * @enum {number}
     * @property {number} DOTA_JOIN_RESULT_SUCCESS=0 DOTA_JOIN_RESULT_SUCCESS value
     * @property {number} DOTA_JOIN_RESULT_ALREADY_IN_GAME=1 DOTA_JOIN_RESULT_ALREADY_IN_GAME value
     * @property {number} DOTA_JOIN_RESULT_INVALID_LOBBY=2 DOTA_JOIN_RESULT_INVALID_LOBBY value
     * @property {number} DOTA_JOIN_RESULT_INCORRECT_PASSWORD=3 DOTA_JOIN_RESULT_INCORRECT_PASSWORD value
     * @property {number} DOTA_JOIN_RESULT_ACCESS_DENIED=4 DOTA_JOIN_RESULT_ACCESS_DENIED value
     * @property {number} DOTA_JOIN_RESULT_GENERIC_ERROR=5 DOTA_JOIN_RESULT_GENERIC_ERROR value
     * @property {number} DOTA_JOIN_RESULT_INCORRECT_VERSION=6 DOTA_JOIN_RESULT_INCORRECT_VERSION value
     * @property {number} DOTA_JOIN_RESULT_IN_TEAM_PARTY=7 DOTA_JOIN_RESULT_IN_TEAM_PARTY value
     * @property {number} DOTA_JOIN_RESULT_NO_LOBBY_FOUND=8 DOTA_JOIN_RESULT_NO_LOBBY_FOUND value
     * @property {number} DOTA_JOIN_RESULT_LOBBY_FULL=9 DOTA_JOIN_RESULT_LOBBY_FULL value
     * @property {number} DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION=10 DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION value
     * @property {number} DOTA_JOIN_RESULT_TIMEOUT=11 DOTA_JOIN_RESULT_TIMEOUT value
     * @property {number} DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN=12 DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN value
     * @property {number} DOTA_JOIN_RESULT_BUSY=13 DOTA_JOIN_RESULT_BUSY value
     * @property {number} DOTA_JOIN_RESULT_NO_PLAYTIME=14 DOTA_JOIN_RESULT_NO_PLAYTIME value
     */
    $root.DOTAJoinLobbyResult = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_JOIN_RESULT_SUCCESS"] = 0;
        values[valuesById[1] = "DOTA_JOIN_RESULT_ALREADY_IN_GAME"] = 1;
        values[valuesById[2] = "DOTA_JOIN_RESULT_INVALID_LOBBY"] = 2;
        values[valuesById[3] = "DOTA_JOIN_RESULT_INCORRECT_PASSWORD"] = 3;
        values[valuesById[4] = "DOTA_JOIN_RESULT_ACCESS_DENIED"] = 4;
        values[valuesById[5] = "DOTA_JOIN_RESULT_GENERIC_ERROR"] = 5;
        values[valuesById[6] = "DOTA_JOIN_RESULT_INCORRECT_VERSION"] = 6;
        values[valuesById[7] = "DOTA_JOIN_RESULT_IN_TEAM_PARTY"] = 7;
        values[valuesById[8] = "DOTA_JOIN_RESULT_NO_LOBBY_FOUND"] = 8;
        values[valuesById[9] = "DOTA_JOIN_RESULT_LOBBY_FULL"] = 9;
        values[valuesById[10] = "DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION"] = 10;
        values[valuesById[11] = "DOTA_JOIN_RESULT_TIMEOUT"] = 11;
        values[valuesById[12] = "DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN"] = 12;
        values[valuesById[13] = "DOTA_JOIN_RESULT_BUSY"] = 13;
        values[valuesById[14] = "DOTA_JOIN_RESULT_NO_PLAYTIME"] = 14;
        return values;
    })();
    
    /**
     * DOTASelectionPriorityRules enum.
     * @exports DOTASelectionPriorityRules
     * @enum {number}
     * @property {number} k_DOTASelectionPriorityRules_Manual=0 k_DOTASelectionPriorityRules_Manual value
     * @property {number} k_DOTASelectionPriorityRules_Automatic=1 k_DOTASelectionPriorityRules_Automatic value
     */
    $root.DOTASelectionPriorityRules = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_DOTASelectionPriorityRules_Manual"] = 0;
        values[valuesById[1] = "k_DOTASelectionPriorityRules_Automatic"] = 1;
        return values;
    })();
    
    /**
     * DOTASelectionPriorityChoice enum.
     * @exports DOTASelectionPriorityChoice
     * @enum {number}
     * @property {number} k_DOTASelectionPriorityChoice_Invalid=0 k_DOTASelectionPriorityChoice_Invalid value
     * @property {number} k_DOTASelectionPriorityChoice_FirstPick=1 k_DOTASelectionPriorityChoice_FirstPick value
     * @property {number} k_DOTASelectionPriorityChoice_SecondPick=2 k_DOTASelectionPriorityChoice_SecondPick value
     * @property {number} k_DOTASelectionPriorityChoice_Radiant=3 k_DOTASelectionPriorityChoice_Radiant value
     * @property {number} k_DOTASelectionPriorityChoice_Dire=4 k_DOTASelectionPriorityChoice_Dire value
     */
    $root.DOTASelectionPriorityChoice = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_DOTASelectionPriorityChoice_Invalid"] = 0;
        values[valuesById[1] = "k_DOTASelectionPriorityChoice_FirstPick"] = 1;
        values[valuesById[2] = "k_DOTASelectionPriorityChoice_SecondPick"] = 2;
        values[valuesById[3] = "k_DOTASelectionPriorityChoice_Radiant"] = 3;
        values[valuesById[4] = "k_DOTASelectionPriorityChoice_Dire"] = 4;
        return values;
    })();
    
    /**
     * DOTAMatchVote enum.
     * @exports DOTAMatchVote
     * @enum {number}
     * @property {number} DOTAMatchVote_INVALID=0 DOTAMatchVote_INVALID value
     * @property {number} DOTAMatchVote_POSITIVE=1 DOTAMatchVote_POSITIVE value
     * @property {number} DOTAMatchVote_NEGATIVE=2 DOTAMatchVote_NEGATIVE value
     */
    $root.DOTAMatchVote = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTAMatchVote_INVALID"] = 0;
        values[valuesById[1] = "DOTAMatchVote_POSITIVE"] = 1;
        values[valuesById[2] = "DOTAMatchVote_NEGATIVE"] = 2;
        return values;
    })();
    
    /**
     * DOTALobbyVisibility enum.
     * @exports DOTALobbyVisibility
     * @enum {number}
     * @property {number} DOTALobbyVisibility_Public=0 DOTALobbyVisibility_Public value
     * @property {number} DOTALobbyVisibility_Friends=1 DOTALobbyVisibility_Friends value
     * @property {number} DOTALobbyVisibility_Unlisted=2 DOTALobbyVisibility_Unlisted value
     */
    $root.DOTALobbyVisibility = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTALobbyVisibility_Public"] = 0;
        values[valuesById[1] = "DOTALobbyVisibility_Friends"] = 1;
        values[valuesById[2] = "DOTALobbyVisibility_Unlisted"] = 2;
        return values;
    })();
    
    /**
     * EDOTAPlayerMMRType enum.
     * @exports EDOTAPlayerMMRType
     * @enum {number}
     * @property {number} k_EDOTAPlayerMMRType_Invalid=0 k_EDOTAPlayerMMRType_Invalid value
     * @property {number} k_EDOTAPlayerMMRType_GeneralHidden=1 k_EDOTAPlayerMMRType_GeneralHidden value
     * @property {number} k_EDOTAPlayerMMRType_GeneralCompetitive=3 k_EDOTAPlayerMMRType_GeneralCompetitive value
     * @property {number} k_EDOTAPlayerMMRType_SoloCompetitive2019=4 k_EDOTAPlayerMMRType_SoloCompetitive2019 value
     * @property {number} k_EDOTAPlayerMMRType_1v1Competitive_UNUSED=5 k_EDOTAPlayerMMRType_1v1Competitive_UNUSED value
     * @property {number} k_EDOTAPlayerMMRType_GeneralSeasonalRanked=6 k_EDOTAPlayerMMRType_GeneralSeasonalRanked value
     * @property {number} k_EDOTAPlayerMMRType_SoloSeasonalRanked=7 k_EDOTAPlayerMMRType_SoloSeasonalRanked value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Core=8 k_EDOTAPlayerMMRType_Competitive_Core value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Support=9 k_EDOTAPlayerMMRType_Competitive_Support value
     * @property {number} k_EDOTAPlayerMMRType_Competitive_Classic=10 k_EDOTAPlayerMMRType_Competitive_Classic value
     */
    $root.EDOTAPlayerMMRType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTAPlayerMMRType_Invalid"] = 0;
        values[valuesById[1] = "k_EDOTAPlayerMMRType_GeneralHidden"] = 1;
        values[valuesById[3] = "k_EDOTAPlayerMMRType_GeneralCompetitive"] = 3;
        values[valuesById[4] = "k_EDOTAPlayerMMRType_SoloCompetitive2019"] = 4;
        values[valuesById[5] = "k_EDOTAPlayerMMRType_1v1Competitive_UNUSED"] = 5;
        values[valuesById[6] = "k_EDOTAPlayerMMRType_GeneralSeasonalRanked"] = 6;
        values[valuesById[7] = "k_EDOTAPlayerMMRType_SoloSeasonalRanked"] = 7;
        values[valuesById[8] = "k_EDOTAPlayerMMRType_Competitive_Core"] = 8;
        values[valuesById[9] = "k_EDOTAPlayerMMRType_Competitive_Support"] = 9;
        values[valuesById[10] = "k_EDOTAPlayerMMRType_Competitive_Classic"] = 10;
        return values;
    })();
    
    /**
     * EDOTAMMRBoostType enum.
     * @exports EDOTAMMRBoostType
     * @enum {number}
     * @property {number} k_EDOTAMMRBoostType_None=0 k_EDOTAMMRBoostType_None value
     * @property {number} k_EDOTAMMRBoostType_Leader=1 k_EDOTAMMRBoostType_Leader value
     * @property {number} k_EDOTAMMRBoostType_Follower=2 k_EDOTAMMRBoostType_Follower value
     */
    $root.EDOTAMMRBoostType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EDOTAMMRBoostType_None"] = 0;
        values[valuesById[1] = "k_EDOTAMMRBoostType_Leader"] = 1;
        values[valuesById[2] = "k_EDOTAMMRBoostType_Follower"] = 2;
        return values;
    })();
    
    /**
     * MatchType enum.
     * @exports MatchType
     * @enum {number}
     * @property {number} MATCH_TYPE_CASUAL=0 MATCH_TYPE_CASUAL value
     * @property {number} MATCH_TYPE_COOP_BOTS=1 MATCH_TYPE_COOP_BOTS value
     * @property {number} MATCH_TYPE_LEGACY_TEAM_RANKED=2 MATCH_TYPE_LEGACY_TEAM_RANKED value
     * @property {number} MATCH_TYPE_LEGACY_SOLO_QUEUE=3 MATCH_TYPE_LEGACY_SOLO_QUEUE value
     * @property {number} MATCH_TYPE_COMPETITIVE=4 MATCH_TYPE_COMPETITIVE value
     * @property {number} MATCH_TYPE_WEEKEND_TOURNEY=5 MATCH_TYPE_WEEKEND_TOURNEY value
     * @property {number} MATCH_TYPE_CASUAL_1V1=6 MATCH_TYPE_CASUAL_1V1 value
     * @property {number} MATCH_TYPE_EVENT=7 MATCH_TYPE_EVENT value
     * @property {number} MATCH_TYPE_SEASONAL_RANKED=8 MATCH_TYPE_SEASONAL_RANKED value
     * @property {number} MATCH_TYPE_LOWPRI_DEPRECATED=9 MATCH_TYPE_LOWPRI_DEPRECATED value
     * @property {number} MATCH_TYPE_STEAM_GROUP=10 MATCH_TYPE_STEAM_GROUP value
     * @property {number} MATCH_TYPE_MUTATION=11 MATCH_TYPE_MUTATION value
     * @property {number} MATCH_TYPE_COACHES_CHALLENGE=12 MATCH_TYPE_COACHES_CHALLENGE value
     * @property {number} MATCH_TYPE_GAUNTLET=13 MATCH_TYPE_GAUNTLET value
     */
    $root.MatchType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MATCH_TYPE_CASUAL"] = 0;
        values[valuesById[1] = "MATCH_TYPE_COOP_BOTS"] = 1;
        values[valuesById[2] = "MATCH_TYPE_LEGACY_TEAM_RANKED"] = 2;
        values[valuesById[3] = "MATCH_TYPE_LEGACY_SOLO_QUEUE"] = 3;
        values[valuesById[4] = "MATCH_TYPE_COMPETITIVE"] = 4;
        values[valuesById[5] = "MATCH_TYPE_WEEKEND_TOURNEY"] = 5;
        values[valuesById[6] = "MATCH_TYPE_CASUAL_1V1"] = 6;
        values[valuesById[7] = "MATCH_TYPE_EVENT"] = 7;
        values[valuesById[8] = "MATCH_TYPE_SEASONAL_RANKED"] = 8;
        values[valuesById[9] = "MATCH_TYPE_LOWPRI_DEPRECATED"] = 9;
        values[valuesById[10] = "MATCH_TYPE_STEAM_GROUP"] = 10;
        values[valuesById[11] = "MATCH_TYPE_MUTATION"] = 11;
        values[valuesById[12] = "MATCH_TYPE_COACHES_CHALLENGE"] = 12;
        values[valuesById[13] = "MATCH_TYPE_GAUNTLET"] = 13;
        return values;
    })();
    
    /**
     * DOTABotDifficulty enum.
     * @exports DOTABotDifficulty
     * @enum {number}
     * @property {number} BOT_DIFFICULTY_PASSIVE=0 BOT_DIFFICULTY_PASSIVE value
     * @property {number} BOT_DIFFICULTY_EASY=1 BOT_DIFFICULTY_EASY value
     * @property {number} BOT_DIFFICULTY_MEDIUM=2 BOT_DIFFICULTY_MEDIUM value
     * @property {number} BOT_DIFFICULTY_HARD=3 BOT_DIFFICULTY_HARD value
     * @property {number} BOT_DIFFICULTY_UNFAIR=4 BOT_DIFFICULTY_UNFAIR value
     * @property {number} BOT_DIFFICULTY_INVALID=5 BOT_DIFFICULTY_INVALID value
     * @property {number} BOT_DIFFICULTY_EXTRA1=6 BOT_DIFFICULTY_EXTRA1 value
     * @property {number} BOT_DIFFICULTY_EXTRA2=7 BOT_DIFFICULTY_EXTRA2 value
     * @property {number} BOT_DIFFICULTY_EXTRA3=8 BOT_DIFFICULTY_EXTRA3 value
     */
    $root.DOTABotDifficulty = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BOT_DIFFICULTY_PASSIVE"] = 0;
        values[valuesById[1] = "BOT_DIFFICULTY_EASY"] = 1;
        values[valuesById[2] = "BOT_DIFFICULTY_MEDIUM"] = 2;
        values[valuesById[3] = "BOT_DIFFICULTY_HARD"] = 3;
        values[valuesById[4] = "BOT_DIFFICULTY_UNFAIR"] = 4;
        values[valuesById[5] = "BOT_DIFFICULTY_INVALID"] = 5;
        values[valuesById[6] = "BOT_DIFFICULTY_EXTRA1"] = 6;
        values[valuesById[7] = "BOT_DIFFICULTY_EXTRA2"] = 7;
        values[valuesById[8] = "BOT_DIFFICULTY_EXTRA3"] = 8;
        return values;
    })();
    
    /**
     * DOTA_BOT_MODE enum.
     * @exports DOTA_BOT_MODE
     * @enum {number}
     * @property {number} DOTA_BOT_MODE_NONE=0 DOTA_BOT_MODE_NONE value
     * @property {number} DOTA_BOT_MODE_LANING=1 DOTA_BOT_MODE_LANING value
     * @property {number} DOTA_BOT_MODE_ATTACK=2 DOTA_BOT_MODE_ATTACK value
     * @property {number} DOTA_BOT_MODE_ROAM=3 DOTA_BOT_MODE_ROAM value
     * @property {number} DOTA_BOT_MODE_RETREAT=4 DOTA_BOT_MODE_RETREAT value
     * @property {number} DOTA_BOT_MODE_SECRET_SHOP=5 DOTA_BOT_MODE_SECRET_SHOP value
     * @property {number} DOTA_BOT_MODE_SIDE_SHOP=6 DOTA_BOT_MODE_SIDE_SHOP value
     * @property {number} DOTA_BOT_MODE_RUNE=7 DOTA_BOT_MODE_RUNE value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_TOP=8 DOTA_BOT_MODE_PUSH_TOWER_TOP value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_MID=9 DOTA_BOT_MODE_PUSH_TOWER_MID value
     * @property {number} DOTA_BOT_MODE_PUSH_TOWER_BOT=10 DOTA_BOT_MODE_PUSH_TOWER_BOT value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_TOP=11 DOTA_BOT_MODE_DEFEND_TOWER_TOP value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_MID=12 DOTA_BOT_MODE_DEFEND_TOWER_MID value
     * @property {number} DOTA_BOT_MODE_DEFEND_TOWER_BOT=13 DOTA_BOT_MODE_DEFEND_TOWER_BOT value
     * @property {number} DOTA_BOT_MODE_ASSEMBLE=14 DOTA_BOT_MODE_ASSEMBLE value
     * @property {number} DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS=15 DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS value
     * @property {number} DOTA_BOT_MODE_TEAM_ROAM=16 DOTA_BOT_MODE_TEAM_ROAM value
     * @property {number} DOTA_BOT_MODE_FARM=17 DOTA_BOT_MODE_FARM value
     * @property {number} DOTA_BOT_MODE_DEFEND_ALLY=18 DOTA_BOT_MODE_DEFEND_ALLY value
     * @property {number} DOTA_BOT_MODE_EVASIVE_MANEUVERS=19 DOTA_BOT_MODE_EVASIVE_MANEUVERS value
     * @property {number} DOTA_BOT_MODE_ROSHAN=20 DOTA_BOT_MODE_ROSHAN value
     * @property {number} DOTA_BOT_MODE_ITEM=21 DOTA_BOT_MODE_ITEM value
     * @property {number} DOTA_BOT_MODE_WARD=22 DOTA_BOT_MODE_WARD value
     * @property {number} DOTA_BOT_MODE_COMPANION=23 DOTA_BOT_MODE_COMPANION value
     * @property {number} DOTA_BOT_MODE_TUTORIAL_BOSS=24 DOTA_BOT_MODE_TUTORIAL_BOSS value
     * @property {number} DOTA_BOT_MODE_MINION=25 DOTA_BOT_MODE_MINION value
     */
    $root.DOTA_BOT_MODE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DOTA_BOT_MODE_NONE"] = 0;
        values[valuesById[1] = "DOTA_BOT_MODE_LANING"] = 1;
        values[valuesById[2] = "DOTA_BOT_MODE_ATTACK"] = 2;
        values[valuesById[3] = "DOTA_BOT_MODE_ROAM"] = 3;
        values[valuesById[4] = "DOTA_BOT_MODE_RETREAT"] = 4;
        values[valuesById[5] = "DOTA_BOT_MODE_SECRET_SHOP"] = 5;
        values[valuesById[6] = "DOTA_BOT_MODE_SIDE_SHOP"] = 6;
        values[valuesById[7] = "DOTA_BOT_MODE_RUNE"] = 7;
        values[valuesById[8] = "DOTA_BOT_MODE_PUSH_TOWER_TOP"] = 8;
        values[valuesById[9] = "DOTA_BOT_MODE_PUSH_TOWER_MID"] = 9;
        values[valuesById[10] = "DOTA_BOT_MODE_PUSH_TOWER_BOT"] = 10;
        values[valuesById[11] = "DOTA_BOT_MODE_DEFEND_TOWER_TOP"] = 11;
        values[valuesById[12] = "DOTA_BOT_MODE_DEFEND_TOWER_MID"] = 12;
        values[valuesById[13] = "DOTA_BOT_MODE_DEFEND_TOWER_BOT"] = 13;
        values[valuesById[14] = "DOTA_BOT_MODE_ASSEMBLE"] = 14;
        values[valuesById[15] = "DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS"] = 15;
        values[valuesById[16] = "DOTA_BOT_MODE_TEAM_ROAM"] = 16;
        values[valuesById[17] = "DOTA_BOT_MODE_FARM"] = 17;
        values[valuesById[18] = "DOTA_BOT_MODE_DEFEND_ALLY"] = 18;
        values[valuesById[19] = "DOTA_BOT_MODE_EVASIVE_MANEUVERS"] = 19;
        values[valuesById[20] = "DOTA_BOT_MODE_ROSHAN"] = 20;
        values[valuesById[21] = "DOTA_BOT_MODE_ITEM"] = 21;
        values[valuesById[22] = "DOTA_BOT_MODE_WARD"] = 22;
        values[valuesById[23] = "DOTA_BOT_MODE_COMPANION"] = 23;
        values[valuesById[24] = "DOTA_BOT_MODE_TUTORIAL_BOSS"] = 24;
        values[valuesById[25] = "DOTA_BOT_MODE_MINION"] = 25;
        return values;
    })();
    
    /**
     * MatchLanguages enum.
     * @exports MatchLanguages
     * @enum {number}
     * @property {number} MATCH_LANGUAGE_INVALID=0 MATCH_LANGUAGE_INVALID value
     * @property {number} MATCH_LANGUAGE_ENGLISH=1 MATCH_LANGUAGE_ENGLISH value
     * @property {number} MATCH_LANGUAGE_RUSSIAN=2 MATCH_LANGUAGE_RUSSIAN value
     * @property {number} MATCH_LANGUAGE_CHINESE=3 MATCH_LANGUAGE_CHINESE value
     * @property {number} MATCH_LANGUAGE_KOREAN=4 MATCH_LANGUAGE_KOREAN value
     * @property {number} MATCH_LANGUAGE_SPANISH=5 MATCH_LANGUAGE_SPANISH value
     * @property {number} MATCH_LANGUAGE_PORTUGUESE=6 MATCH_LANGUAGE_PORTUGUESE value
     * @property {number} MATCH_LANGUAGE_ENGLISH2=7 MATCH_LANGUAGE_ENGLISH2 value
     */
    $root.MatchLanguages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MATCH_LANGUAGE_INVALID"] = 0;
        values[valuesById[1] = "MATCH_LANGUAGE_ENGLISH"] = 1;
        values[valuesById[2] = "MATCH_LANGUAGE_RUSSIAN"] = 2;
        values[valuesById[3] = "MATCH_LANGUAGE_CHINESE"] = 3;
        values[valuesById[4] = "MATCH_LANGUAGE_KOREAN"] = 4;
        values[valuesById[5] = "MATCH_LANGUAGE_SPANISH"] = 5;
        values[valuesById[6] = "MATCH_LANGUAGE_PORTUGUESE"] = 6;
        values[valuesById[7] = "MATCH_LANGUAGE_ENGLISH2"] = 7;
        return values;
    })();
    
    /**
     * ETourneyQueueDeadlineState enum.
     * @exports ETourneyQueueDeadlineState
     * @enum {number}
     * @property {number} k_ETourneyQueueDeadlineState_Normal=0 k_ETourneyQueueDeadlineState_Normal value
     * @property {number} k_ETourneyQueueDeadlineState_Missed=1 k_ETourneyQueueDeadlineState_Missed value
     * @property {number} k_ETourneyQueueDeadlineState_ExpiredOK=2 k_ETourneyQueueDeadlineState_ExpiredOK value
     * @property {number} k_ETourneyQueueDeadlineState_SeekingBye=3 k_ETourneyQueueDeadlineState_SeekingBye value
     * @property {number} k_ETourneyQueueDeadlineState_EligibleForRefund=4 k_ETourneyQueueDeadlineState_EligibleForRefund value
     * @property {number} k_ETourneyQueueDeadlineState_NA=-1 k_ETourneyQueueDeadlineState_NA value
     * @property {number} k_ETourneyQueueDeadlineState_ExpiringSoon=101 k_ETourneyQueueDeadlineState_ExpiringSoon value
     */
    $root.ETourneyQueueDeadlineState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_ETourneyQueueDeadlineState_Normal"] = 0;
        values[valuesById[1] = "k_ETourneyQueueDeadlineState_Missed"] = 1;
        values[valuesById[2] = "k_ETourneyQueueDeadlineState_ExpiredOK"] = 2;
        values[valuesById[3] = "k_ETourneyQueueDeadlineState_SeekingBye"] = 3;
        values[valuesById[4] = "k_ETourneyQueueDeadlineState_EligibleForRefund"] = 4;
        values[valuesById[-1] = "k_ETourneyQueueDeadlineState_NA"] = -1;
        values[valuesById[101] = "k_ETourneyQueueDeadlineState_ExpiringSoon"] = 101;
        return values;
    })();
    
    /**
     * EMatchOutcome enum.
     * @exports EMatchOutcome
     * @enum {number}
     * @property {number} k_EMatchOutcome_Unknown=0 k_EMatchOutcome_Unknown value
     * @property {number} k_EMatchOutcome_RadVictory=2 k_EMatchOutcome_RadVictory value
     * @property {number} k_EMatchOutcome_DireVictory=3 k_EMatchOutcome_DireVictory value
     * @property {number} k_EMatchOutcome_NotScored_PoorNetworkConditions=64 k_EMatchOutcome_NotScored_PoorNetworkConditions value
     * @property {number} k_EMatchOutcome_NotScored_Leaver=65 k_EMatchOutcome_NotScored_Leaver value
     * @property {number} k_EMatchOutcome_NotScored_ServerCrash=66 k_EMatchOutcome_NotScored_ServerCrash value
     * @property {number} k_EMatchOutcome_NotScored_NeverStarted=67 k_EMatchOutcome_NotScored_NeverStarted value
     * @property {number} k_EMatchOutcome_NotScored_Canceled=68 k_EMatchOutcome_NotScored_Canceled value
     * @property {number} k_EMatchOutcome_NotScored_Suspicious=69 k_EMatchOutcome_NotScored_Suspicious value
     */
    $root.EMatchOutcome = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_EMatchOutcome_Unknown"] = 0;
        values[valuesById[2] = "k_EMatchOutcome_RadVictory"] = 2;
        values[valuesById[3] = "k_EMatchOutcome_DireVictory"] = 3;
        values[valuesById[64] = "k_EMatchOutcome_NotScored_PoorNetworkConditions"] = 64;
        values[valuesById[65] = "k_EMatchOutcome_NotScored_Leaver"] = 65;
        values[valuesById[66] = "k_EMatchOutcome_NotScored_ServerCrash"] = 66;
        values[valuesById[67] = "k_EMatchOutcome_NotScored_NeverStarted"] = 67;
        values[valuesById[68] = "k_EMatchOutcome_NotScored_Canceled"] = 68;
        values[valuesById[69] = "k_EMatchOutcome_NotScored_Suspicious"] = 69;
        return values;
    })();
    
    /**
     * ELaneType enum.
     * @exports ELaneType
     * @enum {number}
     * @property {number} LANE_TYPE_UNKNOWN=0 LANE_TYPE_UNKNOWN value
     * @property {number} LANE_TYPE_SAFE=1 LANE_TYPE_SAFE value
     * @property {number} LANE_TYPE_OFF=2 LANE_TYPE_OFF value
     * @property {number} LANE_TYPE_MID=3 LANE_TYPE_MID value
     * @property {number} LANE_TYPE_JUNGLE=4 LANE_TYPE_JUNGLE value
     * @property {number} LANE_TYPE_ROAM=5 LANE_TYPE_ROAM value
     */
    $root.ELaneType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LANE_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "LANE_TYPE_SAFE"] = 1;
        values[valuesById[2] = "LANE_TYPE_OFF"] = 2;
        values[valuesById[3] = "LANE_TYPE_MID"] = 3;
        values[valuesById[4] = "LANE_TYPE_JUNGLE"] = 4;
        values[valuesById[5] = "LANE_TYPE_ROAM"] = 5;
        return values;
    })();
    
    /**
     * EBadgeType enum.
     * @exports EBadgeType
     * @enum {number}
     * @property {number} k_EBadgeType_TI7_Midweek=1 k_EBadgeType_TI7_Midweek value
     * @property {number} k_EBadgeType_TI7_Finals=2 k_EBadgeType_TI7_Finals value
     * @property {number} k_EBadgeType_TI7_AllEvent=3 k_EBadgeType_TI7_AllEvent value
     * @property {number} k_EBadgeType_TI8_Midweek=4 k_EBadgeType_TI8_Midweek value
     * @property {number} k_EBadgeType_TI8_Finals=5 k_EBadgeType_TI8_Finals value
     * @property {number} k_EBadgeType_TI8_AllEvent=6 k_EBadgeType_TI8_AllEvent value
     */
    $root.EBadgeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "k_EBadgeType_TI7_Midweek"] = 1;
        values[valuesById[2] = "k_EBadgeType_TI7_Finals"] = 2;
        values[valuesById[3] = "k_EBadgeType_TI7_AllEvent"] = 3;
        values[valuesById[4] = "k_EBadgeType_TI8_Midweek"] = 4;
        values[valuesById[5] = "k_EBadgeType_TI8_Finals"] = 5;
        values[valuesById[6] = "k_EBadgeType_TI8_AllEvent"] = 6;
        return values;
    })();
    
    /**
     * ELeagueStatus enum.
     * @exports ELeagueStatus
     * @enum {number}
     * @property {number} LEAGUE_STATUS_UNSET=0 LEAGUE_STATUS_UNSET value
     * @property {number} LEAGUE_STATUS_UNSUBMITTED=1 LEAGUE_STATUS_UNSUBMITTED value
     * @property {number} LEAGUE_STATUS_SUBMITTED=2 LEAGUE_STATUS_SUBMITTED value
     * @property {number} LEAGUE_STATUS_ACCEPTED=3 LEAGUE_STATUS_ACCEPTED value
     * @property {number} LEAGUE_STATUS_REJECTED=4 LEAGUE_STATUS_REJECTED value
     * @property {number} LEAGUE_STATUS_CONCLUDED=5 LEAGUE_STATUS_CONCLUDED value
     * @property {number} LEAGUE_STATUS_DELETED=6 LEAGUE_STATUS_DELETED value
     */
    $root.ELeagueStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_STATUS_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_STATUS_UNSUBMITTED"] = 1;
        values[valuesById[2] = "LEAGUE_STATUS_SUBMITTED"] = 2;
        values[valuesById[3] = "LEAGUE_STATUS_ACCEPTED"] = 3;
        values[valuesById[4] = "LEAGUE_STATUS_REJECTED"] = 4;
        values[valuesById[5] = "LEAGUE_STATUS_CONCLUDED"] = 5;
        values[valuesById[6] = "LEAGUE_STATUS_DELETED"] = 6;
        return values;
    })();
    
    /**
     * ELeagueRegion enum.
     * @exports ELeagueRegion
     * @enum {number}
     * @property {number} LEAGUE_REGION_UNSET=0 LEAGUE_REGION_UNSET value
     * @property {number} LEAGUE_REGION_NA=1 LEAGUE_REGION_NA value
     * @property {number} LEAGUE_REGION_SA=2 LEAGUE_REGION_SA value
     * @property {number} LEAGUE_REGION_EUROPE=3 LEAGUE_REGION_EUROPE value
     * @property {number} LEAGUE_REGION_CIS=4 LEAGUE_REGION_CIS value
     * @property {number} LEAGUE_REGION_CHINA=5 LEAGUE_REGION_CHINA value
     * @property {number} LEAGUE_REGION_SEA=6 LEAGUE_REGION_SEA value
     */
    $root.ELeagueRegion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_REGION_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_REGION_NA"] = 1;
        values[valuesById[2] = "LEAGUE_REGION_SA"] = 2;
        values[valuesById[3] = "LEAGUE_REGION_EUROPE"] = 3;
        values[valuesById[4] = "LEAGUE_REGION_CIS"] = 4;
        values[valuesById[5] = "LEAGUE_REGION_CHINA"] = 5;
        values[valuesById[6] = "LEAGUE_REGION_SEA"] = 6;
        return values;
    })();
    
    /**
     * ELeagueTier enum.
     * @exports ELeagueTier
     * @enum {number}
     * @property {number} LEAGUE_TIER_UNSET=0 LEAGUE_TIER_UNSET value
     * @property {number} LEAGUE_TIER_AMATEUR=1 LEAGUE_TIER_AMATEUR value
     * @property {number} LEAGUE_TIER_PROFESSIONAL=2 LEAGUE_TIER_PROFESSIONAL value
     * @property {number} LEAGUE_TIER_MINOR=3 LEAGUE_TIER_MINOR value
     * @property {number} LEAGUE_TIER_MAJOR=4 LEAGUE_TIER_MAJOR value
     * @property {number} LEAGUE_TIER_INTERNATIONAL=5 LEAGUE_TIER_INTERNATIONAL value
     * @property {number} LEAGUE_TIER_DPC_QUALIFIER=6 LEAGUE_TIER_DPC_QUALIFIER value
     */
    $root.ELeagueTier = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_TIER_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_TIER_AMATEUR"] = 1;
        values[valuesById[2] = "LEAGUE_TIER_PROFESSIONAL"] = 2;
        values[valuesById[3] = "LEAGUE_TIER_MINOR"] = 3;
        values[valuesById[4] = "LEAGUE_TIER_MAJOR"] = 4;
        values[valuesById[5] = "LEAGUE_TIER_INTERNATIONAL"] = 5;
        values[valuesById[6] = "LEAGUE_TIER_DPC_QUALIFIER"] = 6;
        return values;
    })();
    
    /**
     * ELeagueTierCategory enum.
     * @exports ELeagueTierCategory
     * @enum {number}
     * @property {number} LEAGUE_TIER_CATEGORY_AMATEUR=1 LEAGUE_TIER_CATEGORY_AMATEUR value
     * @property {number} LEAGUE_TIER_CATEGORY_PROFESSIONAL=2 LEAGUE_TIER_CATEGORY_PROFESSIONAL value
     * @property {number} LEAGUE_TIER_CATEGORY_DPC=3 LEAGUE_TIER_CATEGORY_DPC value
     */
    $root.ELeagueTierCategory = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "LEAGUE_TIER_CATEGORY_AMATEUR"] = 1;
        values[valuesById[2] = "LEAGUE_TIER_CATEGORY_PROFESSIONAL"] = 2;
        values[valuesById[3] = "LEAGUE_TIER_CATEGORY_DPC"] = 3;
        return values;
    })();
    
    /**
     * ELeagueFlags enum.
     * @exports ELeagueFlags
     * @enum {number}
     * @property {number} LEAGUE_FLAGS_NONE=0 LEAGUE_FLAGS_NONE value
     * @property {number} LEAGUE_ACCEPTED_AGREEMENT=1 LEAGUE_ACCEPTED_AGREEMENT value
     * @property {number} LEAGUE_PAYMENT_EMAIL_SENT=2 LEAGUE_PAYMENT_EMAIL_SENT value
     * @property {number} LEAGUE_COMPENDIUM_ALLOWED=4 LEAGUE_COMPENDIUM_ALLOWED value
     * @property {number} LEAGUE_COMPENDIUM_PUBLIC=8 LEAGUE_COMPENDIUM_PUBLIC value
     */
    $root.ELeagueFlags = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_FLAGS_NONE"] = 0;
        values[valuesById[1] = "LEAGUE_ACCEPTED_AGREEMENT"] = 1;
        values[valuesById[2] = "LEAGUE_PAYMENT_EMAIL_SENT"] = 2;
        values[valuesById[4] = "LEAGUE_COMPENDIUM_ALLOWED"] = 4;
        values[valuesById[8] = "LEAGUE_COMPENDIUM_PUBLIC"] = 8;
        return values;
    })();
    
    /**
     * ELeagueBroadcastProvider enum.
     * @exports ELeagueBroadcastProvider
     * @enum {number}
     * @property {number} LEAGUE_BROADCAST_UNKNOWN=0 LEAGUE_BROADCAST_UNKNOWN value
     * @property {number} LEAGUE_BROADCAST_STEAM=1 LEAGUE_BROADCAST_STEAM value
     * @property {number} LEAGUE_BROADCAST_TWITCH=2 LEAGUE_BROADCAST_TWITCH value
     * @property {number} LEAGUE_BROADCAST_YOUTUBE=3 LEAGUE_BROADCAST_YOUTUBE value
     * @property {number} LEAGUE_BROADCAST_OTHER=100 LEAGUE_BROADCAST_OTHER value
     */
    $root.ELeagueBroadcastProvider = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_BROADCAST_UNKNOWN"] = 0;
        values[valuesById[1] = "LEAGUE_BROADCAST_STEAM"] = 1;
        values[valuesById[2] = "LEAGUE_BROADCAST_TWITCH"] = 2;
        values[valuesById[3] = "LEAGUE_BROADCAST_YOUTUBE"] = 3;
        values[valuesById[100] = "LEAGUE_BROADCAST_OTHER"] = 100;
        return values;
    })();
    
    /**
     * ELeaguePhase enum.
     * @exports ELeaguePhase
     * @enum {number}
     * @property {number} LEAGUE_PHASE_UNSET=0 LEAGUE_PHASE_UNSET value
     * @property {number} LEAGUE_PHASE_REGIONAL_QUALIFIER=1 LEAGUE_PHASE_REGIONAL_QUALIFIER value
     * @property {number} LEAGUE_PHASE_GROUP_STAGE=2 LEAGUE_PHASE_GROUP_STAGE value
     * @property {number} LEAGUE_PHASE_MAIN_EVENT=3 LEAGUE_PHASE_MAIN_EVENT value
     */
    $root.ELeaguePhase = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_PHASE_UNSET"] = 0;
        values[valuesById[1] = "LEAGUE_PHASE_REGIONAL_QUALIFIER"] = 1;
        values[valuesById[2] = "LEAGUE_PHASE_GROUP_STAGE"] = 2;
        values[valuesById[3] = "LEAGUE_PHASE_MAIN_EVENT"] = 3;
        return values;
    })();
    
    /**
     * ELeagueAuditAction enum.
     * @exports ELeagueAuditAction
     * @enum {number}
     * @property {number} LEAGUE_AUDIT_ACTION_INVALID=0 LEAGUE_AUDIT_ACTION_INVALID value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_CREATE=1 LEAGUE_AUDIT_ACTION_LEAGUE_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_EDIT=2 LEAGUE_AUDIT_ACTION_LEAGUE_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_DELETE=3 LEAGUE_AUDIT_ACTION_LEAGUE_DELETE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD=4 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE=5 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE=6 LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD=7 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE=8 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED=9 LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED=10 LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED=11 LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL=12 LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM=13 LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM=14 LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START=15 LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END=16 LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM=17 LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM=18 LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED=19 LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED value
     * @property {number} LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT=20 LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE=100 LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY=101 LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM=102 LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM=103 LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING=104 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT=105 LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE=106 LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED=107 LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING=108 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING=109 LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_CREATE=200 LEAGUE_AUDIT_ACTION_NODE_CREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_DESTROY=201 LEAGUE_AUDIT_ACTION_NODE_DESTROY value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE=202 LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_TEAM=203 LEAGUE_AUDIT_ACTION_NODE_SET_TEAM value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID=204 LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING=205 LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_SET_TIME=206 LEAGUE_AUDIT_ACTION_NODE_SET_TIME value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED=207 LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_COMPLETED=208 LEAGUE_AUDIT_ACTION_NODE_COMPLETED value
     * @property {number} LEAGUE_AUDIT_ACTION_NODE_EDIT=209 LEAGUE_AUDIT_ACTION_NODE_EDIT value
     */
    $root.ELeagueAuditAction = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEAGUE_AUDIT_ACTION_INVALID"] = 0;
        values[valuesById[1] = "LEAGUE_AUDIT_ACTION_LEAGUE_CREATE"] = 1;
        values[valuesById[2] = "LEAGUE_AUDIT_ACTION_LEAGUE_EDIT"] = 2;
        values[valuesById[3] = "LEAGUE_AUDIT_ACTION_LEAGUE_DELETE"] = 3;
        values[valuesById[4] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD"] = 4;
        values[valuesById[5] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE"] = 5;
        values[valuesById[6] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE"] = 6;
        values[valuesById[7] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD"] = 7;
        values[valuesById[8] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE"] = 8;
        values[valuesById[9] = "LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED"] = 9;
        values[valuesById[10] = "LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED"] = 10;
        values[valuesById[11] = "LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED"] = 11;
        values[valuesById[12] = "LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL"] = 12;
        values[valuesById[13] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM"] = 13;
        values[valuesById[14] = "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM"] = 14;
        values[valuesById[15] = "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START"] = 15;
        values[valuesById[16] = "LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END"] = 16;
        values[valuesById[17] = "LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM"] = 17;
        values[valuesById[18] = "LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM"] = 18;
        values[valuesById[19] = "LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED"] = 19;
        values[valuesById[20] = "LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT"] = 20;
        values[valuesById[100] = "LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE"] = 100;
        values[valuesById[101] = "LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY"] = 101;
        values[valuesById[102] = "LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM"] = 102;
        values[valuesById[103] = "LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM"] = 103;
        values[valuesById[104] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING"] = 104;
        values[valuesById[105] = "LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT"] = 105;
        values[valuesById[106] = "LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE"] = 106;
        values[valuesById[107] = "LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED"] = 107;
        values[valuesById[108] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING"] = 108;
        values[valuesById[109] = "LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING"] = 109;
        values[valuesById[200] = "LEAGUE_AUDIT_ACTION_NODE_CREATE"] = 200;
        values[valuesById[201] = "LEAGUE_AUDIT_ACTION_NODE_DESTROY"] = 201;
        values[valuesById[202] = "LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE"] = 202;
        values[valuesById[203] = "LEAGUE_AUDIT_ACTION_NODE_SET_TEAM"] = 203;
        values[valuesById[204] = "LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID"] = 204;
        values[valuesById[205] = "LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING"] = 205;
        values[valuesById[206] = "LEAGUE_AUDIT_ACTION_NODE_SET_TIME"] = 206;
        values[valuesById[207] = "LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED"] = 207;
        values[valuesById[208] = "LEAGUE_AUDIT_ACTION_NODE_COMPLETED"] = 208;
        values[valuesById[209] = "LEAGUE_AUDIT_ACTION_NODE_EDIT"] = 209;
        return values;
    })();
    
    /**
     * DOTA_COMBATLOG_TYPES enum.
     * @exports DOTA_COMBATLOG_TYPES
     * @enum {number}
     * @property {number} DOTA_COMBATLOG_INVALID=-1 DOTA_COMBATLOG_INVALID value
     * @property {number} DOTA_COMBATLOG_DAMAGE=0 DOTA_COMBATLOG_DAMAGE value
     * @property {number} DOTA_COMBATLOG_HEAL=1 DOTA_COMBATLOG_HEAL value
     * @property {number} DOTA_COMBATLOG_MODIFIER_ADD=2 DOTA_COMBATLOG_MODIFIER_ADD value
     * @property {number} DOTA_COMBATLOG_MODIFIER_REMOVE=3 DOTA_COMBATLOG_MODIFIER_REMOVE value
     * @property {number} DOTA_COMBATLOG_DEATH=4 DOTA_COMBATLOG_DEATH value
     * @property {number} DOTA_COMBATLOG_ABILITY=5 DOTA_COMBATLOG_ABILITY value
     * @property {number} DOTA_COMBATLOG_ITEM=6 DOTA_COMBATLOG_ITEM value
     * @property {number} DOTA_COMBATLOG_LOCATION=7 DOTA_COMBATLOG_LOCATION value
     * @property {number} DOTA_COMBATLOG_GOLD=8 DOTA_COMBATLOG_GOLD value
     * @property {number} DOTA_COMBATLOG_GAME_STATE=9 DOTA_COMBATLOG_GAME_STATE value
     * @property {number} DOTA_COMBATLOG_XP=10 DOTA_COMBATLOG_XP value
     * @property {number} DOTA_COMBATLOG_PURCHASE=11 DOTA_COMBATLOG_PURCHASE value
     * @property {number} DOTA_COMBATLOG_BUYBACK=12 DOTA_COMBATLOG_BUYBACK value
     * @property {number} DOTA_COMBATLOG_ABILITY_TRIGGER=13 DOTA_COMBATLOG_ABILITY_TRIGGER value
     * @property {number} DOTA_COMBATLOG_PLAYERSTATS=14 DOTA_COMBATLOG_PLAYERSTATS value
     * @property {number} DOTA_COMBATLOG_MULTIKILL=15 DOTA_COMBATLOG_MULTIKILL value
     * @property {number} DOTA_COMBATLOG_KILLSTREAK=16 DOTA_COMBATLOG_KILLSTREAK value
     * @property {number} DOTA_COMBATLOG_TEAM_BUILDING_KILL=17 DOTA_COMBATLOG_TEAM_BUILDING_KILL value
     * @property {number} DOTA_COMBATLOG_FIRST_BLOOD=18 DOTA_COMBATLOG_FIRST_BLOOD value
     * @property {number} DOTA_COMBATLOG_MODIFIER_STACK_EVENT=19 DOTA_COMBATLOG_MODIFIER_STACK_EVENT value
     * @property {number} DOTA_COMBATLOG_NEUTRAL_CAMP_STACK=20 DOTA_COMBATLOG_NEUTRAL_CAMP_STACK value
     * @property {number} DOTA_COMBATLOG_PICKUP_RUNE=21 DOTA_COMBATLOG_PICKUP_RUNE value
     * @property {number} DOTA_COMBATLOG_REVEALED_INVISIBLE=22 DOTA_COMBATLOG_REVEALED_INVISIBLE value
     * @property {number} DOTA_COMBATLOG_HERO_SAVED=23 DOTA_COMBATLOG_HERO_SAVED value
     * @property {number} DOTA_COMBATLOG_MANA_RESTORED=24 DOTA_COMBATLOG_MANA_RESTORED value
     * @property {number} DOTA_COMBATLOG_HERO_LEVELUP=25 DOTA_COMBATLOG_HERO_LEVELUP value
     * @property {number} DOTA_COMBATLOG_BOTTLE_HEAL_ALLY=26 DOTA_COMBATLOG_BOTTLE_HEAL_ALLY value
     * @property {number} DOTA_COMBATLOG_ENDGAME_STATS=27 DOTA_COMBATLOG_ENDGAME_STATS value
     * @property {number} DOTA_COMBATLOG_INTERRUPT_CHANNEL=28 DOTA_COMBATLOG_INTERRUPT_CHANNEL value
     * @property {number} DOTA_COMBATLOG_ALLIED_GOLD=29 DOTA_COMBATLOG_ALLIED_GOLD value
     * @property {number} DOTA_COMBATLOG_AEGIS_TAKEN=30 DOTA_COMBATLOG_AEGIS_TAKEN value
     * @property {number} DOTA_COMBATLOG_MANA_DAMAGE=31 DOTA_COMBATLOG_MANA_DAMAGE value
     * @property {number} DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED=32 DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED value
     * @property {number} DOTA_COMBATLOG_UNIT_SUMMONED=33 DOTA_COMBATLOG_UNIT_SUMMONED value
     * @property {number} DOTA_COMBATLOG_ATTACK_EVADE=34 DOTA_COMBATLOG_ATTACK_EVADE value
     * @property {number} DOTA_COMBATLOG_TREE_CUT=35 DOTA_COMBATLOG_TREE_CUT value
     * @property {number} DOTA_COMBATLOG_SUCCESSFUL_SCAN=36 DOTA_COMBATLOG_SUCCESSFUL_SCAN value
     * @property {number} DOTA_COMBATLOG_END_KILLSTREAK=37 DOTA_COMBATLOG_END_KILLSTREAK value
     * @property {number} DOTA_COMBATLOG_BLOODSTONE_CHARGE=38 DOTA_COMBATLOG_BLOODSTONE_CHARGE value
     * @property {number} DOTA_COMBATLOG_CRITICAL_DAMAGE=39 DOTA_COMBATLOG_CRITICAL_DAMAGE value
     * @property {number} DOTA_COMBATLOG_SPELL_ABSORB=40 DOTA_COMBATLOG_SPELL_ABSORB value
     * @property {number} DOTA_COMBATLOG_UNIT_TELEPORTED=41 DOTA_COMBATLOG_UNIT_TELEPORTED value
     * @property {number} DOTA_COMBATLOG_KILL_EATER_EVENT=42 DOTA_COMBATLOG_KILL_EATER_EVENT value
     */
    $root.DOTA_COMBATLOG_TYPES = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "DOTA_COMBATLOG_INVALID"] = -1;
        values[valuesById[0] = "DOTA_COMBATLOG_DAMAGE"] = 0;
        values[valuesById[1] = "DOTA_COMBATLOG_HEAL"] = 1;
        values[valuesById[2] = "DOTA_COMBATLOG_MODIFIER_ADD"] = 2;
        values[valuesById[3] = "DOTA_COMBATLOG_MODIFIER_REMOVE"] = 3;
        values[valuesById[4] = "DOTA_COMBATLOG_DEATH"] = 4;
        values[valuesById[5] = "DOTA_COMBATLOG_ABILITY"] = 5;
        values[valuesById[6] = "DOTA_COMBATLOG_ITEM"] = 6;
        values[valuesById[7] = "DOTA_COMBATLOG_LOCATION"] = 7;
        values[valuesById[8] = "DOTA_COMBATLOG_GOLD"] = 8;
        values[valuesById[9] = "DOTA_COMBATLOG_GAME_STATE"] = 9;
        values[valuesById[10] = "DOTA_COMBATLOG_XP"] = 10;
        values[valuesById[11] = "DOTA_COMBATLOG_PURCHASE"] = 11;
        values[valuesById[12] = "DOTA_COMBATLOG_BUYBACK"] = 12;
        values[valuesById[13] = "DOTA_COMBATLOG_ABILITY_TRIGGER"] = 13;
        values[valuesById[14] = "DOTA_COMBATLOG_PLAYERSTATS"] = 14;
        values[valuesById[15] = "DOTA_COMBATLOG_MULTIKILL"] = 15;
        values[valuesById[16] = "DOTA_COMBATLOG_KILLSTREAK"] = 16;
        values[valuesById[17] = "DOTA_COMBATLOG_TEAM_BUILDING_KILL"] = 17;
        values[valuesById[18] = "DOTA_COMBATLOG_FIRST_BLOOD"] = 18;
        values[valuesById[19] = "DOTA_COMBATLOG_MODIFIER_STACK_EVENT"] = 19;
        values[valuesById[20] = "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK"] = 20;
        values[valuesById[21] = "DOTA_COMBATLOG_PICKUP_RUNE"] = 21;
        values[valuesById[22] = "DOTA_COMBATLOG_REVEALED_INVISIBLE"] = 22;
        values[valuesById[23] = "DOTA_COMBATLOG_HERO_SAVED"] = 23;
        values[valuesById[24] = "DOTA_COMBATLOG_MANA_RESTORED"] = 24;
        values[valuesById[25] = "DOTA_COMBATLOG_HERO_LEVELUP"] = 25;
        values[valuesById[26] = "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY"] = 26;
        values[valuesById[27] = "DOTA_COMBATLOG_ENDGAME_STATS"] = 27;
        values[valuesById[28] = "DOTA_COMBATLOG_INTERRUPT_CHANNEL"] = 28;
        values[valuesById[29] = "DOTA_COMBATLOG_ALLIED_GOLD"] = 29;
        values[valuesById[30] = "DOTA_COMBATLOG_AEGIS_TAKEN"] = 30;
        values[valuesById[31] = "DOTA_COMBATLOG_MANA_DAMAGE"] = 31;
        values[valuesById[32] = "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED"] = 32;
        values[valuesById[33] = "DOTA_COMBATLOG_UNIT_SUMMONED"] = 33;
        values[valuesById[34] = "DOTA_COMBATLOG_ATTACK_EVADE"] = 34;
        values[valuesById[35] = "DOTA_COMBATLOG_TREE_CUT"] = 35;
        values[valuesById[36] = "DOTA_COMBATLOG_SUCCESSFUL_SCAN"] = 36;
        values[valuesById[37] = "DOTA_COMBATLOG_END_KILLSTREAK"] = 37;
        values[valuesById[38] = "DOTA_COMBATLOG_BLOODSTONE_CHARGE"] = 38;
        values[valuesById[39] = "DOTA_COMBATLOG_CRITICAL_DAMAGE"] = 39;
        values[valuesById[40] = "DOTA_COMBATLOG_SPELL_ABSORB"] = 40;
        values[valuesById[41] = "DOTA_COMBATLOG_UNIT_TELEPORTED"] = 41;
        values[valuesById[42] = "DOTA_COMBATLOG_KILL_EATER_EVENT"] = 42;
        return values;
    })();
    
    /**
     * EDPCFavoriteType enum.
     * @exports EDPCFavoriteType
     * @enum {number}
     * @property {number} FAVORITE_TYPE_ALL=0 FAVORITE_TYPE_ALL value
     * @property {number} FAVORITE_TYPE_PLAYER=1 FAVORITE_TYPE_PLAYER value
     * @property {number} FAVORITE_TYPE_TEAM=2 FAVORITE_TYPE_TEAM value
     * @property {number} FAVORITE_TYPE_LEAGUE=3 FAVORITE_TYPE_LEAGUE value
     */
    $root.EDPCFavoriteType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FAVORITE_TYPE_ALL"] = 0;
        values[valuesById[1] = "FAVORITE_TYPE_PLAYER"] = 1;
        values[valuesById[2] = "FAVORITE_TYPE_TEAM"] = 2;
        values[valuesById[3] = "FAVORITE_TYPE_LEAGUE"] = 3;
        return values;
    })();
    
    /**
     * EDPCPushNotification enum.
     * @exports EDPCPushNotification
     * @enum {number}
     * @property {number} DPC_PUSH_NOTIFICATION_MATCH_STARTING=1 DPC_PUSH_NOTIFICATION_MATCH_STARTING value
     * @property {number} DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM=10 DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM value
     * @property {number} DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM=11 DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM value
     * @property {number} DPC_PUSH_NOTIFICATION_LEAGUE_RESULT=20 DPC_PUSH_NOTIFICATION_LEAGUE_RESULT value
     * @property {number} DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE=30 DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE value
     * @property {number} DPC_PUSH_NOTIFICATION_PREDICTION_RESULT=31 DPC_PUSH_NOTIFICATION_PREDICTION_RESULT value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED=40 DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY=41 DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY value
     * @property {number} DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS=42 DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS value
     */
    $root.EDPCPushNotification = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "DPC_PUSH_NOTIFICATION_MATCH_STARTING"] = 1;
        values[valuesById[10] = "DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM"] = 10;
        values[valuesById[11] = "DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM"] = 11;
        values[valuesById[20] = "DPC_PUSH_NOTIFICATION_LEAGUE_RESULT"] = 20;
        values[valuesById[30] = "DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE"] = 30;
        values[valuesById[31] = "DPC_PUSH_NOTIFICATION_PREDICTION_RESULT"] = 31;
        values[valuesById[40] = "DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED"] = 40;
        values[valuesById[41] = "DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY"] = 41;
        values[valuesById[42] = "DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS"] = 42;
        return values;
    })();
    
    /**
     * EEventActionScoreMode enum.
     * @exports EEventActionScoreMode
     * @enum {number}
     * @property {number} k_eEventActionScoreMode_Add=0 k_eEventActionScoreMode_Add value
     * @property {number} k_eEventActionScoreMode_Min=1 k_eEventActionScoreMode_Min value
     */
    $root.EEventActionScoreMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "k_eEventActionScoreMode_Add"] = 0;
        values[valuesById[1] = "k_eEventActionScoreMode_Min"] = 1;
        return values;
    })();
    
    $root.CDOTAClientHardwareSpecs = (function() {
    
        /**
         * Properties of a CDOTAClientHardwareSpecs.
         * @exports ICDOTAClientHardwareSpecs
         * @interface ICDOTAClientHardwareSpecs
         * @property {number|null} [logical_processors] CDOTAClientHardwareSpecs logical_processors
         * @property {number|Long|null} [cpu_cycles_per_second] CDOTAClientHardwareSpecs cpu_cycles_per_second
         * @property {number|Long|null} [total_physical_memory] CDOTAClientHardwareSpecs total_physical_memory
         * @property {boolean|null} [is_64_bit_os] CDOTAClientHardwareSpecs is_64_bit_os
         * @property {number|Long|null} [upload_measurement] CDOTAClientHardwareSpecs upload_measurement
         * @property {boolean|null} [prefer_not_host] CDOTAClientHardwareSpecs prefer_not_host
         */
    
        /**
         * Constructs a new CDOTAClientHardwareSpecs.
         * @exports CDOTAClientHardwareSpecs
         * @classdesc Represents a CDOTAClientHardwareSpecs.
         * @implements ICDOTAClientHardwareSpecs
         * @constructor
         * @param {ICDOTAClientHardwareSpecs=} [properties] Properties to set
         */
        function CDOTAClientHardwareSpecs(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTAClientHardwareSpecs logical_processors.
         * @member {number} logical_processors
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.logical_processors = 0;
    
        /**
         * CDOTAClientHardwareSpecs cpu_cycles_per_second.
         * @member {number|Long} cpu_cycles_per_second
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.cpu_cycles_per_second = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAClientHardwareSpecs total_physical_memory.
         * @member {number|Long} total_physical_memory
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.total_physical_memory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CDOTAClientHardwareSpecs is_64_bit_os.
         * @member {boolean} is_64_bit_os
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.is_64_bit_os = false;
    
        /**
         * CDOTAClientHardwareSpecs upload_measurement.
         * @member {number|Long} upload_measurement
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.upload_measurement = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTAClientHardwareSpecs prefer_not_host.
         * @member {boolean} prefer_not_host
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         */
        CDOTAClientHardwareSpecs.prototype.prefer_not_host = false;
    
        /**
         * Creates a new CDOTAClientHardwareSpecs instance using the specified properties.
         * @function create
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs=} [properties] Properties to set
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs instance
         */
        CDOTAClientHardwareSpecs.create = function create(properties) {
            return new CDOTAClientHardwareSpecs(properties);
        };
    
        /**
         * Encodes the specified CDOTAClientHardwareSpecs message. Does not implicitly {@link CDOTAClientHardwareSpecs.verify|verify} messages.
         * @function encode
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientHardwareSpecs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logical_processors != null && Object.hasOwnProperty.call(message, "logical_processors"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.logical_processors);
            if (message.cpu_cycles_per_second != null && Object.hasOwnProperty.call(message, "cpu_cycles_per_second"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.cpu_cycles_per_second);
            if (message.total_physical_memory != null && Object.hasOwnProperty.call(message, "total_physical_memory"))
                writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.total_physical_memory);
            if (message.is_64_bit_os != null && Object.hasOwnProperty.call(message, "is_64_bit_os"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_64_bit_os);
            if (message.upload_measurement != null && Object.hasOwnProperty.call(message, "upload_measurement"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.upload_measurement);
            if (message.prefer_not_host != null && Object.hasOwnProperty.call(message, "prefer_not_host"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.prefer_not_host);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTAClientHardwareSpecs message, length delimited. Does not implicitly {@link CDOTAClientHardwareSpecs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {ICDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTAClientHardwareSpecs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTAClientHardwareSpecs message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientHardwareSpecs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTAClientHardwareSpecs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logical_processors = reader.uint32();
                    break;
                case 2:
                    message.cpu_cycles_per_second = reader.fixed64();
                    break;
                case 3:
                    message.total_physical_memory = reader.fixed64();
                    break;
                case 4:
                    message.is_64_bit_os = reader.bool();
                    break;
                case 5:
                    message.upload_measurement = reader.uint64();
                    break;
                case 6:
                    message.prefer_not_host = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTAClientHardwareSpecs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTAClientHardwareSpecs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTAClientHardwareSpecs message.
         * @function verify
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTAClientHardwareSpecs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logical_processors != null && message.hasOwnProperty("logical_processors"))
                if (!$util.isInteger(message.logical_processors))
                    return "logical_processors: integer expected";
            if (message.cpu_cycles_per_second != null && message.hasOwnProperty("cpu_cycles_per_second"))
                if (!$util.isInteger(message.cpu_cycles_per_second) && !(message.cpu_cycles_per_second && $util.isInteger(message.cpu_cycles_per_second.low) && $util.isInteger(message.cpu_cycles_per_second.high)))
                    return "cpu_cycles_per_second: integer|Long expected";
            if (message.total_physical_memory != null && message.hasOwnProperty("total_physical_memory"))
                if (!$util.isInteger(message.total_physical_memory) && !(message.total_physical_memory && $util.isInteger(message.total_physical_memory.low) && $util.isInteger(message.total_physical_memory.high)))
                    return "total_physical_memory: integer|Long expected";
            if (message.is_64_bit_os != null && message.hasOwnProperty("is_64_bit_os"))
                if (typeof message.is_64_bit_os !== "boolean")
                    return "is_64_bit_os: boolean expected";
            if (message.upload_measurement != null && message.hasOwnProperty("upload_measurement"))
                if (!$util.isInteger(message.upload_measurement) && !(message.upload_measurement && $util.isInteger(message.upload_measurement.low) && $util.isInteger(message.upload_measurement.high)))
                    return "upload_measurement: integer|Long expected";
            if (message.prefer_not_host != null && message.hasOwnProperty("prefer_not_host"))
                if (typeof message.prefer_not_host !== "boolean")
                    return "prefer_not_host: boolean expected";
            return null;
        };
    
        /**
         * Creates a CDOTAClientHardwareSpecs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTAClientHardwareSpecs} CDOTAClientHardwareSpecs
         */
        CDOTAClientHardwareSpecs.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTAClientHardwareSpecs)
                return object;
            var message = new $root.CDOTAClientHardwareSpecs();
            if (object.logical_processors != null)
                message.logical_processors = object.logical_processors >>> 0;
            if (object.cpu_cycles_per_second != null)
                if ($util.Long)
                    (message.cpu_cycles_per_second = $util.Long.fromValue(object.cpu_cycles_per_second)).unsigned = false;
                else if (typeof object.cpu_cycles_per_second === "string")
                    message.cpu_cycles_per_second = parseInt(object.cpu_cycles_per_second, 10);
                else if (typeof object.cpu_cycles_per_second === "number")
                    message.cpu_cycles_per_second = object.cpu_cycles_per_second;
                else if (typeof object.cpu_cycles_per_second === "object")
                    message.cpu_cycles_per_second = new $util.LongBits(object.cpu_cycles_per_second.low >>> 0, object.cpu_cycles_per_second.high >>> 0).toNumber();
            if (object.total_physical_memory != null)
                if ($util.Long)
                    (message.total_physical_memory = $util.Long.fromValue(object.total_physical_memory)).unsigned = false;
                else if (typeof object.total_physical_memory === "string")
                    message.total_physical_memory = parseInt(object.total_physical_memory, 10);
                else if (typeof object.total_physical_memory === "number")
                    message.total_physical_memory = object.total_physical_memory;
                else if (typeof object.total_physical_memory === "object")
                    message.total_physical_memory = new $util.LongBits(object.total_physical_memory.low >>> 0, object.total_physical_memory.high >>> 0).toNumber();
            if (object.is_64_bit_os != null)
                message.is_64_bit_os = Boolean(object.is_64_bit_os);
            if (object.upload_measurement != null)
                if ($util.Long)
                    (message.upload_measurement = $util.Long.fromValue(object.upload_measurement)).unsigned = true;
                else if (typeof object.upload_measurement === "string")
                    message.upload_measurement = parseInt(object.upload_measurement, 10);
                else if (typeof object.upload_measurement === "number")
                    message.upload_measurement = object.upload_measurement;
                else if (typeof object.upload_measurement === "object")
                    message.upload_measurement = new $util.LongBits(object.upload_measurement.low >>> 0, object.upload_measurement.high >>> 0).toNumber(true);
            if (object.prefer_not_host != null)
                message.prefer_not_host = Boolean(object.prefer_not_host);
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTAClientHardwareSpecs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTAClientHardwareSpecs
         * @static
         * @param {CDOTAClientHardwareSpecs} message CDOTAClientHardwareSpecs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTAClientHardwareSpecs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logical_processors = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.cpu_cycles_per_second = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cpu_cycles_per_second = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.total_physical_memory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_physical_memory = options.longs === String ? "0" : 0;
                object.is_64_bit_os = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.upload_measurement = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.upload_measurement = options.longs === String ? "0" : 0;
                object.prefer_not_host = false;
            }
            if (message.logical_processors != null && message.hasOwnProperty("logical_processors"))
                object.logical_processors = message.logical_processors;
            if (message.cpu_cycles_per_second != null && message.hasOwnProperty("cpu_cycles_per_second"))
                if (typeof message.cpu_cycles_per_second === "number")
                    object.cpu_cycles_per_second = options.longs === String ? String(message.cpu_cycles_per_second) : message.cpu_cycles_per_second;
                else
                    object.cpu_cycles_per_second = options.longs === String ? $util.Long.prototype.toString.call(message.cpu_cycles_per_second) : options.longs === Number ? new $util.LongBits(message.cpu_cycles_per_second.low >>> 0, message.cpu_cycles_per_second.high >>> 0).toNumber() : message.cpu_cycles_per_second;
            if (message.total_physical_memory != null && message.hasOwnProperty("total_physical_memory"))
                if (typeof message.total_physical_memory === "number")
                    object.total_physical_memory = options.longs === String ? String(message.total_physical_memory) : message.total_physical_memory;
                else
                    object.total_physical_memory = options.longs === String ? $util.Long.prototype.toString.call(message.total_physical_memory) : options.longs === Number ? new $util.LongBits(message.total_physical_memory.low >>> 0, message.total_physical_memory.high >>> 0).toNumber() : message.total_physical_memory;
            if (message.is_64_bit_os != null && message.hasOwnProperty("is_64_bit_os"))
                object.is_64_bit_os = message.is_64_bit_os;
            if (message.upload_measurement != null && message.hasOwnProperty("upload_measurement"))
                if (typeof message.upload_measurement === "number")
                    object.upload_measurement = options.longs === String ? String(message.upload_measurement) : message.upload_measurement;
                else
                    object.upload_measurement = options.longs === String ? $util.Long.prototype.toString.call(message.upload_measurement) : options.longs === Number ? new $util.LongBits(message.upload_measurement.low >>> 0, message.upload_measurement.high >>> 0).toNumber(true) : message.upload_measurement;
            if (message.prefer_not_host != null && message.hasOwnProperty("prefer_not_host"))
                object.prefer_not_host = message.prefer_not_host;
            return object;
        };
    
        /**
         * Converts this CDOTAClientHardwareSpecs to JSON.
         * @function toJSON
         * @memberof CDOTAClientHardwareSpecs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTAClientHardwareSpecs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CDOTAClientHardwareSpecs;
    })();
    
    $root.CDOTASaveGame = (function() {
    
        /**
         * Properties of a CDOTASaveGame.
         * @exports ICDOTASaveGame
         * @interface ICDOTASaveGame
         * @property {number|Long|null} [match_id] CDOTASaveGame match_id
         * @property {number|null} [save_time] CDOTASaveGame save_time
         * @property {Array.<CDOTASaveGame.IPlayer>|null} [players] CDOTASaveGame players
         * @property {Array.<CDOTASaveGame.ISaveInstance>|null} [save_instances] CDOTASaveGame save_instances
         */
    
        /**
         * Constructs a new CDOTASaveGame.
         * @exports CDOTASaveGame
         * @classdesc Represents a CDOTASaveGame.
         * @implements ICDOTASaveGame
         * @constructor
         * @param {ICDOTASaveGame=} [properties] Properties to set
         */
        function CDOTASaveGame(properties) {
            this.players = [];
            this.save_instances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CDOTASaveGame match_id.
         * @member {number|Long} match_id
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.match_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CDOTASaveGame save_time.
         * @member {number} save_time
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.save_time = 0;
    
        /**
         * CDOTASaveGame players.
         * @member {Array.<CDOTASaveGame.IPlayer>} players
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.players = $util.emptyArray;
    
        /**
         * CDOTASaveGame save_instances.
         * @member {Array.<CDOTASaveGame.ISaveInstance>} save_instances
         * @memberof CDOTASaveGame
         * @instance
         */
        CDOTASaveGame.prototype.save_instances = $util.emptyArray;
    
        /**
         * Creates a new CDOTASaveGame instance using the specified properties.
         * @function create
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame=} [properties] Properties to set
         * @returns {CDOTASaveGame} CDOTASaveGame instance
         */
        CDOTASaveGame.create = function create(properties) {
            return new CDOTASaveGame(properties);
        };
    
        /**
         * Encodes the specified CDOTASaveGame message. Does not implicitly {@link CDOTASaveGame.verify|verify} messages.
         * @function encode
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame} message CDOTASaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASaveGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.save_time != null && Object.hasOwnProperty.call(message, "save_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.save_time);
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    $root.CDOTASaveGame.Player.encode(message.players[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.save_instances != null && message.save_instances.length)
                for (var i = 0; i < message.save_instances.length; ++i)
                    $root.CDOTASaveGame.SaveInstance.encode(message.save_instances[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.match_id != null && Object.hasOwnProperty.call(message, "match_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.match_id);
            return writer;
        };
    
        /**
         * Encodes the specified CDOTASaveGame message, length delimited. Does not implicitly {@link CDOTASaveGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CDOTASaveGame
         * @static
         * @param {ICDOTASaveGame} message CDOTASaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CDOTASaveGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CDOTASaveGame message from the specified reader or buffer.
         * @function decode
         * @memberof CDOTASaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDOTASaveGame} CDOTASaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASaveGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.match_id = reader.uint64();
                    break;
                case 2:
                    message.save_time = reader.uint32();
                    break;
                case 3:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.CDOTASaveGame.Player.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.save_instances && message.save_instances.length))
                        message.save_instances = [];
                    message.save_instances.push($root.CDOTASaveGame.SaveInstance.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CDOTASaveGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CDOTASaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CDOTASaveGame} CDOTASaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CDOTASaveGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CDOTASaveGame message.
         * @function verify
         * @memberof CDOTASaveGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CDOTASaveGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (!$util.isInteger(message.match_id) && !(message.match_id && $util.isInteger(message.match_id.low) && $util.isInteger(message.match_id.high)))
                    return "match_id: integer|Long expected";
            if (message.save_time != null && message.hasOwnProperty("save_time"))
                if (!$util.isInteger(message.save_time))
                    return "save_time: integer expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i) {
                    var error = $root.CDOTASaveGame.Player.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            if (message.save_instances != null && message.hasOwnProperty("save_instances")) {
                if (!Array.isArray(message.save_instances))
                    return "save_instances: array expected";
                for (var i = 0; i < message.save_instances.length; ++i) {
                    var error = $root.CDOTASaveGame.SaveInstance.verify(message.save_instances[i]);
                    if (error)
                        return "save_instances." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CDOTASaveGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CDOTASaveGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CDOTASaveGame} CDOTASaveGame
         */
        CDOTASaveGame.fromObject = function fromObject(object) {
            if (object instanceof $root.CDOTASaveGame)
                return object;
            var message = new $root.CDOTASaveGame();
            if (object.match_id != null)
                if ($util.Long)
                    (message.match_id = $util.Long.fromValue(object.match_id)).unsigned = true;
                else if (typeof object.match_id === "string")
                    message.match_id = parseInt(object.match_id, 10);
                else if (typeof object.match_id === "number")
                    message.match_id = object.match_id;
                else if (typeof object.match_id === "object")
                    message.match_id = new $util.LongBits(object.match_id.low >>> 0, object.match_id.high >>> 0).toNumber(true);
            if (object.save_time != null)
                message.save_time = object.save_time >>> 0;
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".CDOTASaveGame.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".CDOTASaveGame.players: object expected");
                    message.players[i] = $root.CDOTASaveGame.Player.fromObject(object.players[i]);
                }
            }
            if (object.save_instances) {
                if (!Array.isArray(object.save_instances))
                    throw TypeError(".CDOTASaveGame.save_instances: array expected");
                message.save_instances = [];
                for (var i = 0; i < object.save_instances.length; ++i) {
                    if (typeof object.save_instances[i] !== "object")
                        throw TypeError(".CDOTASaveGame.save_instances: object expected");
                    message.save_instances[i] = $root.CDOTASaveGame.SaveInstance.fromObject(object.save_instances[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CDOTASaveGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CDOTASaveGame
         * @static
         * @param {CDOTASaveGame} message CDOTASaveGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CDOTASaveGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.players = [];
                object.save_instances = [];
            }
            if (options.defaults) {
                object.save_time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.match_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.match_id = options.longs === String ? "0" : 0;
            }
            if (message.save_time != null && message.hasOwnProperty("save_time"))
                object.save_time = message.save_time;
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.CDOTASaveGame.Player.toObject(message.players[j], options);
            }
            if (message.save_instances && message.save_instances.length) {
                object.save_instances = [];
                for (var j = 0; j < message.save_instances.length; ++j)
                    object.save_instances[j] = $root.CDOTASaveGame.SaveInstance.toObject(message.save_instances[j], options);
            }
            if (message.match_id != null && message.hasOwnProperty("match_id"))
                if (typeof message.match_id === "number")
                    object.match_id = options.longs === String ? String(message.match_id) : message.match_id;
                else
                    object.match_id = options.longs === String ? $util.Long.prototype.toString.call(message.match_id) : options.longs === Number ? new $util.LongBits(message.match_id.low >>> 0, message.match_id.high >>> 0).toNumber(true) : message.match_id;
            return object;
        };
    
        /**
         * Converts this CDOTASaveGame to JSON.
         * @function toJSON
         * @memberof CDOTASaveGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CDOTASaveGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CDOTASaveGame.Player = (function() {
    
            /**
             * Properties of a Player.
             * @memberof CDOTASaveGame
             * @interface IPlayer
             * @property {DOTA_GC_TEAM|null} [team] Player team
             * @property {string|null} [name] Player name
             * @property {string|null} [hero] Player hero
             */
    
            /**
             * Constructs a new Player.
             * @memberof CDOTASaveGame
             * @classdesc Represents a Player.
             * @implements IPlayer
             * @constructor
             * @param {CDOTASaveGame.IPlayer=} [properties] Properties to set
             */
            function Player(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Player team.
             * @member {DOTA_GC_TEAM} team
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.team = 0;
    
            /**
             * Player name.
             * @member {string} name
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.name = "";
    
            /**
             * Player hero.
             * @member {string} hero
             * @memberof CDOTASaveGame.Player
             * @instance
             */
            Player.prototype.hero = "";
    
            /**
             * Creates a new Player instance using the specified properties.
             * @function create
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer=} [properties] Properties to set
             * @returns {CDOTASaveGame.Player} Player instance
             */
            Player.create = function create(properties) {
                return new Player(properties);
            };
    
            /**
             * Encodes the specified Player message. Does not implicitly {@link CDOTASaveGame.Player.verify|verify} messages.
             * @function encode
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.team);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.hero != null && Object.hasOwnProperty.call(message, "hero"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.hero);
                return writer;
            };
    
            /**
             * Encodes the specified Player message, length delimited. Does not implicitly {@link CDOTASaveGame.Player.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTASaveGame.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.Player();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.team = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.hero = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTASaveGame.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Player message.
             * @function verify
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Player.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.team != null && message.hasOwnProperty("team"))
                    switch (message.team) {
                    default:
                        return "team: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.hero != null && message.hasOwnProperty("hero"))
                    if (!$util.isString(message.hero))
                        return "hero: string expected";
                return null;
            };
    
            /**
             * Creates a Player message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTASaveGame.Player} Player
             */
            Player.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTASaveGame.Player)
                    return object;
                var message = new $root.CDOTASaveGame.Player();
                switch (object.team) {
                case "DOTA_GC_TEAM_GOOD_GUYS":
                case 0:
                    message.team = 0;
                    break;
                case "DOTA_GC_TEAM_BAD_GUYS":
                case 1:
                    message.team = 1;
                    break;
                case "DOTA_GC_TEAM_BROADCASTER":
                case 2:
                    message.team = 2;
                    break;
                case "DOTA_GC_TEAM_SPECTATOR":
                case 3:
                    message.team = 3;
                    break;
                case "DOTA_GC_TEAM_PLAYER_POOL":
                case 4:
                    message.team = 4;
                    break;
                case "DOTA_GC_TEAM_NOTEAM":
                case 5:
                    message.team = 5;
                    break;
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.hero != null)
                    message.hero = String(object.hero);
                return message;
            };
    
            /**
             * Creates a plain object from a Player message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTASaveGame.Player
             * @static
             * @param {CDOTASaveGame.Player} message Player
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Player.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.team = options.enums === String ? "DOTA_GC_TEAM_GOOD_GUYS" : 0;
                    object.name = "";
                    object.hero = "";
                }
                if (message.team != null && message.hasOwnProperty("team"))
                    object.team = options.enums === String ? $root.DOTA_GC_TEAM[message.team] : message.team;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.hero != null && message.hasOwnProperty("hero"))
                    object.hero = message.hero;
                return object;
            };
    
            /**
             * Converts this Player to JSON.
             * @function toJSON
             * @memberof CDOTASaveGame.Player
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Player.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Player;
        })();
    
        CDOTASaveGame.SaveInstance = (function() {
    
            /**
             * Properties of a SaveInstance.
             * @memberof CDOTASaveGame
             * @interface ISaveInstance
             * @property {number|null} [game_time] SaveInstance game_time
             * @property {number|null} [team1_score] SaveInstance team1_score
             * @property {number|null} [team2_score] SaveInstance team2_score
             * @property {Array.<CDOTASaveGame.SaveInstance.IPlayerPositions>|null} [player_positions] SaveInstance player_positions
             * @property {number|null} [save_id] SaveInstance save_id
             * @property {number|null} [save_time] SaveInstance save_time
             */
    
            /**
             * Constructs a new SaveInstance.
             * @memberof CDOTASaveGame
             * @classdesc Represents a SaveInstance.
             * @implements ISaveInstance
             * @constructor
             * @param {CDOTASaveGame.ISaveInstance=} [properties] Properties to set
             */
            function SaveInstance(properties) {
                this.player_positions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SaveInstance game_time.
             * @member {number} game_time
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.game_time = 0;
    
            /**
             * SaveInstance team1_score.
             * @member {number} team1_score
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.team1_score = 0;
    
            /**
             * SaveInstance team2_score.
             * @member {number} team2_score
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.team2_score = 0;
    
            /**
             * SaveInstance player_positions.
             * @member {Array.<CDOTASaveGame.SaveInstance.IPlayerPositions>} player_positions
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.player_positions = $util.emptyArray;
    
            /**
             * SaveInstance save_id.
             * @member {number} save_id
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.save_id = 0;
    
            /**
             * SaveInstance save_time.
             * @member {number} save_time
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             */
            SaveInstance.prototype.save_time = 0;
    
            /**
             * Creates a new SaveInstance instance using the specified properties.
             * @function create
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance=} [properties] Properties to set
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance instance
             */
            SaveInstance.create = function create(properties) {
                return new SaveInstance(properties);
            };
    
            /**
             * Encodes the specified SaveInstance message. Does not implicitly {@link CDOTASaveGame.SaveInstance.verify|verify} messages.
             * @function encode
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance} message SaveInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveInstance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.game_time != null && Object.hasOwnProperty.call(message, "game_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.game_time);
                if (message.team1_score != null && Object.hasOwnProperty.call(message, "team1_score"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team1_score);
                if (message.team2_score != null && Object.hasOwnProperty.call(message, "team2_score"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.team2_score);
                if (message.player_positions != null && message.player_positions.length)
                    for (var i = 0; i < message.player_positions.length; ++i)
                        $root.CDOTASaveGame.SaveInstance.PlayerPositions.encode(message.player_positions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.save_id != null && Object.hasOwnProperty.call(message, "save_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.save_id);
                if (message.save_time != null && Object.hasOwnProperty.call(message, "save_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.save_time);
                return writer;
            };
    
            /**
             * Encodes the specified SaveInstance message, length delimited. Does not implicitly {@link CDOTASaveGame.SaveInstance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.ISaveInstance} message SaveInstance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveInstance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SaveInstance message from the specified reader or buffer.
             * @function decode
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveInstance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.SaveInstance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.game_time = reader.uint32();
                        break;
                    case 3:
                        message.team1_score = reader.uint32();
                        break;
                    case 4:
                        message.team2_score = reader.uint32();
                        break;
                    case 5:
                        if (!(message.player_positions && message.player_positions.length))
                            message.player_positions = [];
                        message.player_positions.push($root.CDOTASaveGame.SaveInstance.PlayerPositions.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.save_id = reader.uint32();
                        break;
                    case 7:
                        message.save_time = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SaveInstance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveInstance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SaveInstance message.
             * @function verify
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveInstance.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.game_time != null && message.hasOwnProperty("game_time"))
                    if (!$util.isInteger(message.game_time))
                        return "game_time: integer expected";
                if (message.team1_score != null && message.hasOwnProperty("team1_score"))
                    if (!$util.isInteger(message.team1_score))
                        return "team1_score: integer expected";
                if (message.team2_score != null && message.hasOwnProperty("team2_score"))
                    if (!$util.isInteger(message.team2_score))
                        return "team2_score: integer expected";
                if (message.player_positions != null && message.hasOwnProperty("player_positions")) {
                    if (!Array.isArray(message.player_positions))
                        return "player_positions: array expected";
                    for (var i = 0; i < message.player_positions.length; ++i) {
                        var error = $root.CDOTASaveGame.SaveInstance.PlayerPositions.verify(message.player_positions[i]);
                        if (error)
                            return "player_positions." + error;
                    }
                }
                if (message.save_id != null && message.hasOwnProperty("save_id"))
                    if (!$util.isInteger(message.save_id))
                        return "save_id: integer expected";
                if (message.save_time != null && message.hasOwnProperty("save_time"))
                    if (!$util.isInteger(message.save_time))
                        return "save_time: integer expected";
                return null;
            };
    
            /**
             * Creates a SaveInstance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CDOTASaveGame.SaveInstance} SaveInstance
             */
            SaveInstance.fromObject = function fromObject(object) {
                if (object instanceof $root.CDOTASaveGame.SaveInstance)
                    return object;
                var message = new $root.CDOTASaveGame.SaveInstance();
                if (object.game_time != null)
                    message.game_time = object.game_time >>> 0;
                if (object.team1_score != null)
                    message.team1_score = object.team1_score >>> 0;
                if (object.team2_score != null)
                    message.team2_score = object.team2_score >>> 0;
                if (object.player_positions) {
                    if (!Array.isArray(object.player_positions))
                        throw TypeError(".CDOTASaveGame.SaveInstance.player_positions: array expected");
                    message.player_positions = [];
                    for (var i = 0; i < object.player_positions.length; ++i) {
                        if (typeof object.player_positions[i] !== "object")
                            throw TypeError(".CDOTASaveGame.SaveInstance.player_positions: object expected");
                        message.player_positions[i] = $root.CDOTASaveGame.SaveInstance.PlayerPositions.fromObject(object.player_positions[i]);
                    }
                }
                if (object.save_id != null)
                    message.save_id = object.save_id >>> 0;
                if (object.save_time != null)
                    message.save_time = object.save_time >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a SaveInstance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CDOTASaveGame.SaveInstance
             * @static
             * @param {CDOTASaveGame.SaveInstance} message SaveInstance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveInstance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.player_positions = [];
                if (options.defaults) {
                    object.game_time = 0;
                    object.team1_score = 0;
                    object.team2_score = 0;
                    object.save_id = 0;
                    object.save_time = 0;
                }
                if (message.game_time != null && message.hasOwnProperty("game_time"))
                    object.game_time = message.game_time;
                if (message.team1_score != null && message.hasOwnProperty("team1_score"))
                    object.team1_score = message.team1_score;
                if (message.team2_score != null && message.hasOwnProperty("team2_score"))
                    object.team2_score = message.team2_score;
                if (message.player_positions && message.player_positions.length) {
                    object.player_positions = [];
                    for (var j = 0; j < message.player_positions.length; ++j)
                        object.player_positions[j] = $root.CDOTASaveGame.SaveInstance.PlayerPositions.toObject(message.player_positions[j], options);
                }
                if (message.save_id != null && message.hasOwnProperty("save_id"))
                    object.save_id = message.save_id;
                if (message.save_time != null && message.hasOwnProperty("save_time"))
                    object.save_time = message.save_time;
                return object;
            };
    
            /**
             * Converts this SaveInstance to JSON.
             * @function toJSON
             * @memberof CDOTASaveGame.SaveInstance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveInstance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            SaveInstance.PlayerPositions = (function() {
    
                /**
                 * Properties of a PlayerPositions.
                 * @memberof CDOTASaveGame.SaveInstance
                 * @interface IPlayerPositions
                 * @property {number|null} [x] PlayerPositions x
                 * @property {number|null} [y] PlayerPositions y
                 */
    
                /**
                 * Constructs a new PlayerPositions.
                 * @memberof CDOTASaveGame.SaveInstance
                 * @classdesc Represents a PlayerPositions.
                 * @implements IPlayerPositions
                 * @constructor
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions=} [properties] Properties to set
                 */
                function PlayerPositions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PlayerPositions x.
                 * @member {number} x
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 */
                PlayerPositions.prototype.x = 0;
    
                /**
                 * PlayerPositions y.
                 * @member {number} y
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 */
                PlayerPositions.prototype.y = 0;
    
                /**
                 * Creates a new PlayerPositions instance using the specified properties.
                 * @function create
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions=} [properties] Properties to set
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions instance
                 */
                PlayerPositions.create = function create(properties) {
                    return new PlayerPositions(properties);
                };
    
                /**
                 * Encodes the specified PlayerPositions message. Does not implicitly {@link CDOTASaveGame.SaveInstance.PlayerPositions.verify|verify} messages.
                 * @function encode
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions} message PlayerPositions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayerPositions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                    return writer;
                };
    
                /**
                 * Encodes the specified PlayerPositions message, length delimited. Does not implicitly {@link CDOTASaveGame.SaveInstance.PlayerPositions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.IPlayerPositions} message PlayerPositions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayerPositions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PlayerPositions message from the specified reader or buffer.
                 * @function decode
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayerPositions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDOTASaveGame.SaveInstance.PlayerPositions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.x = reader.float();
                            break;
                        case 2:
                            message.y = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PlayerPositions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayerPositions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PlayerPositions message.
                 * @function verify
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayerPositions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    return null;
                };
    
                /**
                 * Creates a PlayerPositions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CDOTASaveGame.SaveInstance.PlayerPositions} PlayerPositions
                 */
                PlayerPositions.fromObject = function fromObject(object) {
                    if (object instanceof $root.CDOTASaveGame.SaveInstance.PlayerPositions)
                        return object;
                    var message = new $root.CDOTASaveGame.SaveInstance.PlayerPositions();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PlayerPositions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @static
                 * @param {CDOTASaveGame.SaveInstance.PlayerPositions} message PlayerPositions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayerPositions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    return object;
                };
    
                /**
                 * Converts this PlayerPositions to JSON.
                 * @function toJSON
                 * @memberof CDOTASaveGame.SaveInstance.PlayerPositions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayerPositions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PlayerPositions;
            })();
    
            return SaveInstance;
        })();
    
        return CDOTASaveGame;
    })();
    
    $root.CMsgDOTACombatLogEntry = (function() {
    
        /**
         * Properties of a CMsgDOTACombatLogEntry.
         * @exports ICMsgDOTACombatLogEntry
         * @interface ICMsgDOTACombatLogEntry
         * @property {DOTA_COMBATLOG_TYPES|null} [type] CMsgDOTACombatLogEntry type
         * @property {number|null} [target_name] CMsgDOTACombatLogEntry target_name
         * @property {number|null} [target_source_name] CMsgDOTACombatLogEntry target_source_name
         * @property {number|null} [attacker_name] CMsgDOTACombatLogEntry attacker_name
         * @property {number|null} [damage_source_name] CMsgDOTACombatLogEntry damage_source_name
         * @property {number|null} [inflictor_name] CMsgDOTACombatLogEntry inflictor_name
         * @property {boolean|null} [is_attacker_illusion] CMsgDOTACombatLogEntry is_attacker_illusion
         * @property {boolean|null} [is_attacker_hero] CMsgDOTACombatLogEntry is_attacker_hero
         * @property {boolean|null} [is_target_illusion] CMsgDOTACombatLogEntry is_target_illusion
         * @property {boolean|null} [is_target_hero] CMsgDOTACombatLogEntry is_target_hero
         * @property {boolean|null} [is_visible_radiant] CMsgDOTACombatLogEntry is_visible_radiant
         * @property {boolean|null} [is_visible_dire] CMsgDOTACombatLogEntry is_visible_dire
         * @property {number|null} [value] CMsgDOTACombatLogEntry value
         * @property {number|null} [health] CMsgDOTACombatLogEntry health
         * @property {number|null} [timestamp] CMsgDOTACombatLogEntry timestamp
         * @property {number|null} [stun_duration] CMsgDOTACombatLogEntry stun_duration
         * @property {number|null} [slow_duration] CMsgDOTACombatLogEntry slow_duration
         * @property {boolean|null} [is_ability_toggle_on] CMsgDOTACombatLogEntry is_ability_toggle_on
         * @property {boolean|null} [is_ability_toggle_off] CMsgDOTACombatLogEntry is_ability_toggle_off
         * @property {number|null} [ability_level] CMsgDOTACombatLogEntry ability_level
         * @property {number|null} [location_x] CMsgDOTACombatLogEntry location_x
         * @property {number|null} [location_y] CMsgDOTACombatLogEntry location_y
         * @property {number|null} [gold_reason] CMsgDOTACombatLogEntry gold_reason
         * @property {number|null} [timestamp_raw] CMsgDOTACombatLogEntry timestamp_raw
         * @property {number|null} [modifier_duration] CMsgDOTACombatLogEntry modifier_duration
         * @property {number|null} [xp_reason] CMsgDOTACombatLogEntry xp_reason
         * @property {number|null} [last_hits] CMsgDOTACombatLogEntry last_hits
         * @property {number|null} [attacker_team] CMsgDOTACombatLogEntry attacker_team
         * @property {number|null} [target_team] CMsgDOTACombatLogEntry target_team
         * @property {number|null} [obs_wards_placed] CMsgDOTACombatLogEntry obs_wards_placed
         * @property {number|null} [assist_player0] CMsgDOTACombatLogEntry assist_player0
         * @property {number|null} [assist_player1] CMsgDOTACombatLogEntry assist_player1
         * @property {number|null} [assist_player2] CMsgDOTACombatLogEntry assist_player2
         * @property {number|null} [assist_player3] CMsgDOTACombatLogEntry assist_player3
         * @property {number|null} [stack_count] CMsgDOTACombatLogEntry stack_count
         * @property {boolean|null} [hidden_modifier] CMsgDOTACombatLogEntry hidden_modifier
         * @property {boolean|null} [is_target_building] CMsgDOTACombatLogEntry is_target_building
         * @property {number|null} [neutral_camp_type] CMsgDOTACombatLogEntry neutral_camp_type
         * @property {number|null} [rune_type] CMsgDOTACombatLogEntry rune_type
         * @property {Array.<number>|null} [assist_players] CMsgDOTACombatLogEntry assist_players
         * @property {boolean|null} [is_heal_save] CMsgDOTACombatLogEntry is_heal_save
         * @property {boolean|null} [is_ultimate_ability] CMsgDOTACombatLogEntry is_ultimate_ability
         * @property {number|null} [attacker_hero_level] CMsgDOTACombatLogEntry attacker_hero_level
         * @property {number|null} [target_hero_level] CMsgDOTACombatLogEntry target_hero_level
         * @property {number|null} [xpm] CMsgDOTACombatLogEntry xpm
         * @property {number|null} [gpm] CMsgDOTACombatLogEntry gpm
         * @property {number|null} [event_location] CMsgDOTACombatLogEntry event_location
         * @property {boolean|null} [target_is_self] CMsgDOTACombatLogEntry target_is_self
         * @property {number|null} [damage_type] CMsgDOTACombatLogEntry damage_type
         * @property {boolean|null} [invisibility_modifier] CMsgDOTACombatLogEntry invisibility_modifier
         * @property {number|null} [damage_category] CMsgDOTACombatLogEntry damage_category
         * @property {number|null} [networth] CMsgDOTACombatLogEntry networth
         * @property {number|null} [building_type] CMsgDOTACombatLogEntry building_type
         * @property {number|null} [modifier_elapsed_duration] CMsgDOTACombatLogEntry modifier_elapsed_duration
         * @property {boolean|null} [silence_modifier] CMsgDOTACombatLogEntry silence_modifier
         * @property {boolean|null} [heal_from_lifesteal] CMsgDOTACombatLogEntry heal_from_lifesteal
         * @property {boolean|null} [modifier_purged] CMsgDOTACombatLogEntry modifier_purged
         * @property {boolean|null} [spell_evaded] CMsgDOTACombatLogEntry spell_evaded
         * @property {boolean|null} [motion_controller_modifier] CMsgDOTACombatLogEntry motion_controller_modifier
         * @property {boolean|null} [long_range_kill] CMsgDOTACombatLogEntry long_range_kill
         * @property {number|null} [modifier_purge_ability] CMsgDOTACombatLogEntry modifier_purge_ability
         * @property {number|null} [modifier_purge_npc] CMsgDOTACombatLogEntry modifier_purge_npc
         * @property {boolean|null} [root_modifier] CMsgDOTACombatLogEntry root_modifier
         * @property {number|null} [total_unit_death_count] CMsgDOTACombatLogEntry total_unit_death_count
         * @property {boolean|null} [aura_modifier] CMsgDOTACombatLogEntry aura_modifier
         * @property {boolean|null} [armor_debuff_modifier] CMsgDOTACombatLogEntry armor_debuff_modifier
         * @property {boolean|null} [no_physical_damage_modifier] CMsgDOTACombatLogEntry no_physical_damage_modifier
         * @property {number|null} [modifier_ability] CMsgDOTACombatLogEntry modifier_ability
         * @property {boolean|null} [modifier_hidden] CMsgDOTACombatLogEntry modifier_hidden
         * @property {boolean|null} [inflictor_is_stolen_ability] CMsgDOTACombatLogEntry inflictor_is_stolen_ability
         * @property {number|null} [kill_eater_event] CMsgDOTACombatLogEntry kill_eater_event
         * @property {number|null} [unit_status_label] CMsgDOTACombatLogEntry unit_status_label
         * @property {boolean|null} [spell_generated_attack] CMsgDOTACombatLogEntry spell_generated_attack
         * @property {boolean|null} [at_night_time] CMsgDOTACombatLogEntry at_night_time
         * @property {boolean|null} [attacker_has_scepter] CMsgDOTACombatLogEntry attacker_has_scepter
         */
    
        /**
         * Constructs a new CMsgDOTACombatLogEntry.
         * @exports CMsgDOTACombatLogEntry
         * @classdesc Represents a CMsgDOTACombatLogEntry.
         * @implements ICMsgDOTACombatLogEntry
         * @constructor
         * @param {ICMsgDOTACombatLogEntry=} [properties] Properties to set
         */
        function CMsgDOTACombatLogEntry(properties) {
            this.assist_players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgDOTACombatLogEntry type.
         * @member {DOTA_COMBATLOG_TYPES} type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.type = -1;
    
        /**
         * CMsgDOTACombatLogEntry target_name.
         * @member {number} target_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_source_name.
         * @member {number} target_source_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_source_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry attacker_name.
         * @member {number} attacker_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry damage_source_name.
         * @member {number} damage_source_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_source_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry inflictor_name.
         * @member {number} inflictor_name
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.inflictor_name = 0;
    
        /**
         * CMsgDOTACombatLogEntry is_attacker_illusion.
         * @member {boolean} is_attacker_illusion
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_attacker_illusion = false;
    
        /**
         * CMsgDOTACombatLogEntry is_attacker_hero.
         * @member {boolean} is_attacker_hero
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_attacker_hero = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_illusion.
         * @member {boolean} is_target_illusion
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_illusion = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_hero.
         * @member {boolean} is_target_hero
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_hero = false;
    
        /**
         * CMsgDOTACombatLogEntry is_visible_radiant.
         * @member {boolean} is_visible_radiant
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_visible_radiant = false;
    
        /**
         * CMsgDOTACombatLogEntry is_visible_dire.
         * @member {boolean} is_visible_dire
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_visible_dire = false;
    
        /**
         * CMsgDOTACombatLogEntry value.
         * @member {number} value
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.value = 0;
    
        /**
         * CMsgDOTACombatLogEntry health.
         * @member {number} health
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.health = 0;
    
        /**
         * CMsgDOTACombatLogEntry timestamp.
         * @member {number} timestamp
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.timestamp = 0;
    
        /**
         * CMsgDOTACombatLogEntry stun_duration.
         * @member {number} stun_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.stun_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry slow_duration.
         * @member {number} slow_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.slow_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry is_ability_toggle_on.
         * @member {boolean} is_ability_toggle_on
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ability_toggle_on = false;
    
        /**
         * CMsgDOTACombatLogEntry is_ability_toggle_off.
         * @member {boolean} is_ability_toggle_off
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ability_toggle_off = false;
    
        /**
         * CMsgDOTACombatLogEntry ability_level.
         * @member {number} ability_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.ability_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry location_x.
         * @member {number} location_x
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.location_x = 0;
    
        /**
         * CMsgDOTACombatLogEntry location_y.
         * @member {number} location_y
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.location_y = 0;
    
        /**
         * CMsgDOTACombatLogEntry gold_reason.
         * @member {number} gold_reason
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.gold_reason = 0;
    
        /**
         * CMsgDOTACombatLogEntry timestamp_raw.
         * @member {number} timestamp_raw
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.timestamp_raw = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_duration.
         * @member {number} modifier_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry xp_reason.
         * @member {number} xp_reason
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.xp_reason = 0;
    
        /**
         * CMsgDOTACombatLogEntry last_hits.
         * @member {number} last_hits
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.last_hits = 0;
    
        /**
         * CMsgDOTACombatLogEntry attacker_team.
         * @member {number} attacker_team
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_team = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_team.
         * @member {number} target_team
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_team = 0;
    
        /**
         * CMsgDOTACombatLogEntry obs_wards_placed.
         * @member {number} obs_wards_placed
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.obs_wards_placed = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player0.
         * @member {number} assist_player0
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player0 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player1.
         * @member {number} assist_player1
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player1 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player2.
         * @member {number} assist_player2
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player2 = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_player3.
         * @member {number} assist_player3
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_player3 = 0;
    
        /**
         * CMsgDOTACombatLogEntry stack_count.
         * @member {number} stack_count
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.stack_count = 0;
    
        /**
         * CMsgDOTACombatLogEntry hidden_modifier.
         * @member {boolean} hidden_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.hidden_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry is_target_building.
         * @member {boolean} is_target_building
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_target_building = false;
    
        /**
         * CMsgDOTACombatLogEntry neutral_camp_type.
         * @member {number} neutral_camp_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.neutral_camp_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry rune_type.
         * @member {number} rune_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.rune_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry assist_players.
         * @member {Array.<number>} assist_players
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.assist_players = $util.emptyArray;
    
        /**
         * CMsgDOTACombatLogEntry is_heal_save.
         * @member {boolean} is_heal_save
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_heal_save = false;
    
        /**
         * CMsgDOTACombatLogEntry is_ultimate_ability.
         * @member {boolean} is_ultimate_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.is_ultimate_ability = false;
    
        /**
         * CMsgDOTACombatLogEntry attacker_hero_level.
         * @member {number} attacker_hero_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_hero_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_hero_level.
         * @member {number} target_hero_level
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_hero_level = 0;
    
        /**
         * CMsgDOTACombatLogEntry xpm.
         * @member {number} xpm
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.xpm = 0;
    
        /**
         * CMsgDOTACombatLogEntry gpm.
         * @member {number} gpm
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.gpm = 0;
    
        /**
         * CMsgDOTACombatLogEntry event_location.
         * @member {number} event_location
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.event_location = 0;
    
        /**
         * CMsgDOTACombatLogEntry target_is_self.
         * @member {boolean} target_is_self
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.target_is_self = false;
    
        /**
         * CMsgDOTACombatLogEntry damage_type.
         * @member {number} damage_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry invisibility_modifier.
         * @member {boolean} invisibility_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.invisibility_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry damage_category.
         * @member {number} damage_category
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.damage_category = 0;
    
        /**
         * CMsgDOTACombatLogEntry networth.
         * @member {number} networth
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.networth = 0;
    
        /**
         * CMsgDOTACombatLogEntry building_type.
         * @member {number} building_type
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.building_type = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_elapsed_duration.
         * @member {number} modifier_elapsed_duration
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_elapsed_duration = 0;
    
        /**
         * CMsgDOTACombatLogEntry silence_modifier.
         * @member {boolean} silence_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.silence_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry heal_from_lifesteal.
         * @member {boolean} heal_from_lifesteal
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.heal_from_lifesteal = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purged.
         * @member {boolean} modifier_purged
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purged = false;
    
        /**
         * CMsgDOTACombatLogEntry spell_evaded.
         * @member {boolean} spell_evaded
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.spell_evaded = false;
    
        /**
         * CMsgDOTACombatLogEntry motion_controller_modifier.
         * @member {boolean} motion_controller_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.motion_controller_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry long_range_kill.
         * @member {boolean} long_range_kill
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.long_range_kill = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purge_ability.
         * @member {number} modifier_purge_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purge_ability = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_purge_npc.
         * @member {number} modifier_purge_npc
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_purge_npc = 0;
    
        /**
         * CMsgDOTACombatLogEntry root_modifier.
         * @member {boolean} root_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.root_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry total_unit_death_count.
         * @member {number} total_unit_death_count
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.total_unit_death_count = 0;
    
        /**
         * CMsgDOTACombatLogEntry aura_modifier.
         * @member {boolean} aura_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.aura_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry armor_debuff_modifier.
         * @member {boolean} armor_debuff_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.armor_debuff_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry no_physical_damage_modifier.
         * @member {boolean} no_physical_damage_modifier
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.no_physical_damage_modifier = false;
    
        /**
         * CMsgDOTACombatLogEntry modifier_ability.
         * @member {number} modifier_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_ability = 0;
    
        /**
         * CMsgDOTACombatLogEntry modifier_hidden.
         * @member {boolean} modifier_hidden
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.modifier_hidden = false;
    
        /**
         * CMsgDOTACombatLogEntry inflictor_is_stolen_ability.
         * @member {boolean} inflictor_is_stolen_ability
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.inflictor_is_stolen_ability = false;
    
        /**
         * CMsgDOTACombatLogEntry kill_eater_event.
         * @member {number} kill_eater_event
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.kill_eater_event = 0;
    
        /**
         * CMsgDOTACombatLogEntry unit_status_label.
         * @member {number} unit_status_label
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.unit_status_label = 0;
    
        /**
         * CMsgDOTACombatLogEntry spell_generated_attack.
         * @member {boolean} spell_generated_attack
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.spell_generated_attack = false;
    
        /**
         * CMsgDOTACombatLogEntry at_night_time.
         * @member {boolean} at_night_time
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.at_night_time = false;
    
        /**
         * CMsgDOTACombatLogEntry attacker_has_scepter.
         * @member {boolean} attacker_has_scepter
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         */
        CMsgDOTACombatLogEntry.prototype.attacker_has_scepter = false;
    
        /**
         * Creates a new CMsgDOTACombatLogEntry instance using the specified properties.
         * @function create
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry=} [properties] Properties to set
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry instance
         */
        CMsgDOTACombatLogEntry.create = function create(properties) {
            return new CMsgDOTACombatLogEntry(properties);
        };
    
        /**
         * Encodes the specified CMsgDOTACombatLogEntry message. Does not implicitly {@link CMsgDOTACombatLogEntry.verify|verify} messages.
         * @function encode
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACombatLogEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.target_name != null && Object.hasOwnProperty.call(message, "target_name"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_name);
            if (message.target_source_name != null && Object.hasOwnProperty.call(message, "target_source_name"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.target_source_name);
            if (message.attacker_name != null && Object.hasOwnProperty.call(message, "attacker_name"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.attacker_name);
            if (message.damage_source_name != null && Object.hasOwnProperty.call(message, "damage_source_name"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.damage_source_name);
            if (message.inflictor_name != null && Object.hasOwnProperty.call(message, "inflictor_name"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.inflictor_name);
            if (message.is_attacker_illusion != null && Object.hasOwnProperty.call(message, "is_attacker_illusion"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.is_attacker_illusion);
            if (message.is_attacker_hero != null && Object.hasOwnProperty.call(message, "is_attacker_hero"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.is_attacker_hero);
            if (message.is_target_illusion != null && Object.hasOwnProperty.call(message, "is_target_illusion"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.is_target_illusion);
            if (message.is_target_hero != null && Object.hasOwnProperty.call(message, "is_target_hero"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.is_target_hero);
            if (message.is_visible_radiant != null && Object.hasOwnProperty.call(message, "is_visible_radiant"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.is_visible_radiant);
            if (message.is_visible_dire != null && Object.hasOwnProperty.call(message, "is_visible_dire"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.is_visible_dire);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.value);
            if (message.health != null && Object.hasOwnProperty.call(message, "health"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.health);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.timestamp);
            if (message.stun_duration != null && Object.hasOwnProperty.call(message, "stun_duration"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.stun_duration);
            if (message.slow_duration != null && Object.hasOwnProperty.call(message, "slow_duration"))
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.slow_duration);
            if (message.is_ability_toggle_on != null && Object.hasOwnProperty.call(message, "is_ability_toggle_on"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.is_ability_toggle_on);
            if (message.is_ability_toggle_off != null && Object.hasOwnProperty.call(message, "is_ability_toggle_off"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.is_ability_toggle_off);
            if (message.ability_level != null && Object.hasOwnProperty.call(message, "ability_level"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.ability_level);
            if (message.location_x != null && Object.hasOwnProperty.call(message, "location_x"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.location_x);
            if (message.location_y != null && Object.hasOwnProperty.call(message, "location_y"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.location_y);
            if (message.gold_reason != null && Object.hasOwnProperty.call(message, "gold_reason"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.gold_reason);
            if (message.timestamp_raw != null && Object.hasOwnProperty.call(message, "timestamp_raw"))
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.timestamp_raw);
            if (message.modifier_duration != null && Object.hasOwnProperty.call(message, "modifier_duration"))
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.modifier_duration);
            if (message.xp_reason != null && Object.hasOwnProperty.call(message, "xp_reason"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.xp_reason);
            if (message.last_hits != null && Object.hasOwnProperty.call(message, "last_hits"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.last_hits);
            if (message.attacker_team != null && Object.hasOwnProperty.call(message, "attacker_team"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.attacker_team);
            if (message.target_team != null && Object.hasOwnProperty.call(message, "target_team"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint32(message.target_team);
            if (message.obs_wards_placed != null && Object.hasOwnProperty.call(message, "obs_wards_placed"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.obs_wards_placed);
            if (message.assist_player0 != null && Object.hasOwnProperty.call(message, "assist_player0"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint32(message.assist_player0);
            if (message.assist_player1 != null && Object.hasOwnProperty.call(message, "assist_player1"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint32(message.assist_player1);
            if (message.assist_player2 != null && Object.hasOwnProperty.call(message, "assist_player2"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.assist_player2);
            if (message.assist_player3 != null && Object.hasOwnProperty.call(message, "assist_player3"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint32(message.assist_player3);
            if (message.stack_count != null && Object.hasOwnProperty.call(message, "stack_count"))
                writer.uint32(/* id 35, wireType 0 =*/280).uint32(message.stack_count);
            if (message.hidden_modifier != null && Object.hasOwnProperty.call(message, "hidden_modifier"))
                writer.uint32(/* id 36, wireType 0 =*/288).bool(message.hidden_modifier);
            if (message.is_target_building != null && Object.hasOwnProperty.call(message, "is_target_building"))
                writer.uint32(/* id 37, wireType 0 =*/296).bool(message.is_target_building);
            if (message.neutral_camp_type != null && Object.hasOwnProperty.call(message, "neutral_camp_type"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.neutral_camp_type);
            if (message.rune_type != null && Object.hasOwnProperty.call(message, "rune_type"))
                writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.rune_type);
            if (message.assist_players != null && message.assist_players.length)
                for (var i = 0; i < message.assist_players.length; ++i)
                    writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.assist_players[i]);
            if (message.is_heal_save != null && Object.hasOwnProperty.call(message, "is_heal_save"))
                writer.uint32(/* id 41, wireType 0 =*/328).bool(message.is_heal_save);
            if (message.is_ultimate_ability != null && Object.hasOwnProperty.call(message, "is_ultimate_ability"))
                writer.uint32(/* id 42, wireType 0 =*/336).bool(message.is_ultimate_ability);
            if (message.attacker_hero_level != null && Object.hasOwnProperty.call(message, "attacker_hero_level"))
                writer.uint32(/* id 43, wireType 0 =*/344).uint32(message.attacker_hero_level);
            if (message.target_hero_level != null && Object.hasOwnProperty.call(message, "target_hero_level"))
                writer.uint32(/* id 44, wireType 0 =*/352).uint32(message.target_hero_level);
            if (message.xpm != null && Object.hasOwnProperty.call(message, "xpm"))
                writer.uint32(/* id 45, wireType 0 =*/360).uint32(message.xpm);
            if (message.gpm != null && Object.hasOwnProperty.call(message, "gpm"))
                writer.uint32(/* id 46, wireType 0 =*/368).uint32(message.gpm);
            if (message.event_location != null && Object.hasOwnProperty.call(message, "event_location"))
                writer.uint32(/* id 47, wireType 0 =*/376).uint32(message.event_location);
            if (message.target_is_self != null && Object.hasOwnProperty.call(message, "target_is_self"))
                writer.uint32(/* id 48, wireType 0 =*/384).bool(message.target_is_self);
            if (message.damage_type != null && Object.hasOwnProperty.call(message, "damage_type"))
                writer.uint32(/* id 49, wireType 0 =*/392).uint32(message.damage_type);
            if (message.invisibility_modifier != null && Object.hasOwnProperty.call(message, "invisibility_modifier"))
                writer.uint32(/* id 50, wireType 0 =*/400).bool(message.invisibility_modifier);
            if (message.damage_category != null && Object.hasOwnProperty.call(message, "damage_category"))
                writer.uint32(/* id 51, wireType 0 =*/408).uint32(message.damage_category);
            if (message.networth != null && Object.hasOwnProperty.call(message, "networth"))
                writer.uint32(/* id 52, wireType 0 =*/416).uint32(message.networth);
            if (message.building_type != null && Object.hasOwnProperty.call(message, "building_type"))
                writer.uint32(/* id 53, wireType 0 =*/424).uint32(message.building_type);
            if (message.modifier_elapsed_duration != null && Object.hasOwnProperty.call(message, "modifier_elapsed_duration"))
                writer.uint32(/* id 54, wireType 5 =*/437).float(message.modifier_elapsed_duration);
            if (message.silence_modifier != null && Object.hasOwnProperty.call(message, "silence_modifier"))
                writer.uint32(/* id 55, wireType 0 =*/440).bool(message.silence_modifier);
            if (message.heal_from_lifesteal != null && Object.hasOwnProperty.call(message, "heal_from_lifesteal"))
                writer.uint32(/* id 56, wireType 0 =*/448).bool(message.heal_from_lifesteal);
            if (message.modifier_purged != null && Object.hasOwnProperty.call(message, "modifier_purged"))
                writer.uint32(/* id 57, wireType 0 =*/456).bool(message.modifier_purged);
            if (message.spell_evaded != null && Object.hasOwnProperty.call(message, "spell_evaded"))
                writer.uint32(/* id 58, wireType 0 =*/464).bool(message.spell_evaded);
            if (message.motion_controller_modifier != null && Object.hasOwnProperty.call(message, "motion_controller_modifier"))
                writer.uint32(/* id 59, wireType 0 =*/472).bool(message.motion_controller_modifier);
            if (message.long_range_kill != null && Object.hasOwnProperty.call(message, "long_range_kill"))
                writer.uint32(/* id 60, wireType 0 =*/480).bool(message.long_range_kill);
            if (message.modifier_purge_ability != null && Object.hasOwnProperty.call(message, "modifier_purge_ability"))
                writer.uint32(/* id 61, wireType 0 =*/488).uint32(message.modifier_purge_ability);
            if (message.modifier_purge_npc != null && Object.hasOwnProperty.call(message, "modifier_purge_npc"))
                writer.uint32(/* id 62, wireType 0 =*/496).uint32(message.modifier_purge_npc);
            if (message.root_modifier != null && Object.hasOwnProperty.call(message, "root_modifier"))
                writer.uint32(/* id 63, wireType 0 =*/504).bool(message.root_modifier);
            if (message.total_unit_death_count != null && Object.hasOwnProperty.call(message, "total_unit_death_count"))
                writer.uint32(/* id 64, wireType 0 =*/512).uint32(message.total_unit_death_count);
            if (message.aura_modifier != null && Object.hasOwnProperty.call(message, "aura_modifier"))
                writer.uint32(/* id 65, wireType 0 =*/520).bool(message.aura_modifier);
            if (message.armor_debuff_modifier != null && Object.hasOwnProperty.call(message, "armor_debuff_modifier"))
                writer.uint32(/* id 66, wireType 0 =*/528).bool(message.armor_debuff_modifier);
            if (message.no_physical_damage_modifier != null && Object.hasOwnProperty.call(message, "no_physical_damage_modifier"))
                writer.uint32(/* id 67, wireType 0 =*/536).bool(message.no_physical_damage_modifier);
            if (message.modifier_ability != null && Object.hasOwnProperty.call(message, "modifier_ability"))
                writer.uint32(/* id 68, wireType 0 =*/544).uint32(message.modifier_ability);
            if (message.modifier_hidden != null && Object.hasOwnProperty.call(message, "modifier_hidden"))
                writer.uint32(/* id 69, wireType 0 =*/552).bool(message.modifier_hidden);
            if (message.inflictor_is_stolen_ability != null && Object.hasOwnProperty.call(message, "inflictor_is_stolen_ability"))
                writer.uint32(/* id 70, wireType 0 =*/560).bool(message.inflictor_is_stolen_ability);
            if (message.kill_eater_event != null && Object.hasOwnProperty.call(message, "kill_eater_event"))
                writer.uint32(/* id 71, wireType 0 =*/568).uint32(message.kill_eater_event);
            if (message.unit_status_label != null && Object.hasOwnProperty.call(message, "unit_status_label"))
                writer.uint32(/* id 72, wireType 0 =*/576).uint32(message.unit_status_label);
            if (message.spell_generated_attack != null && Object.hasOwnProperty.call(message, "spell_generated_attack"))
                writer.uint32(/* id 73, wireType 0 =*/584).bool(message.spell_generated_attack);
            if (message.at_night_time != null && Object.hasOwnProperty.call(message, "at_night_time"))
                writer.uint32(/* id 74, wireType 0 =*/592).bool(message.at_night_time);
            if (message.attacker_has_scepter != null && Object.hasOwnProperty.call(message, "attacker_has_scepter"))
                writer.uint32(/* id 75, wireType 0 =*/600).bool(message.attacker_has_scepter);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgDOTACombatLogEntry message, length delimited. Does not implicitly {@link CMsgDOTACombatLogEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {ICMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgDOTACombatLogEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgDOTACombatLogEntry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACombatLogEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgDOTACombatLogEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.target_name = reader.uint32();
                    break;
                case 3:
                    message.target_source_name = reader.uint32();
                    break;
                case 4:
                    message.attacker_name = reader.uint32();
                    break;
                case 5:
                    message.damage_source_name = reader.uint32();
                    break;
                case 6:
                    message.inflictor_name = reader.uint32();
                    break;
                case 7:
                    message.is_attacker_illusion = reader.bool();
                    break;
                case 8:
                    message.is_attacker_hero = reader.bool();
                    break;
                case 9:
                    message.is_target_illusion = reader.bool();
                    break;
                case 10:
                    message.is_target_hero = reader.bool();
                    break;
                case 11:
                    message.is_visible_radiant = reader.bool();
                    break;
                case 12:
                    message.is_visible_dire = reader.bool();
                    break;
                case 13:
                    message.value = reader.uint32();
                    break;
                case 14:
                    message.health = reader.int32();
                    break;
                case 15:
                    message.timestamp = reader.float();
                    break;
                case 16:
                    message.stun_duration = reader.float();
                    break;
                case 17:
                    message.slow_duration = reader.float();
                    break;
                case 18:
                    message.is_ability_toggle_on = reader.bool();
                    break;
                case 19:
                    message.is_ability_toggle_off = reader.bool();
                    break;
                case 20:
                    message.ability_level = reader.uint32();
                    break;
                case 21:
                    message.location_x = reader.float();
                    break;
                case 22:
                    message.location_y = reader.float();
                    break;
                case 23:
                    message.gold_reason = reader.uint32();
                    break;
                case 24:
                    message.timestamp_raw = reader.float();
                    break;
                case 25:
                    message.modifier_duration = reader.float();
                    break;
                case 26:
                    message.xp_reason = reader.uint32();
                    break;
                case 27:
                    message.last_hits = reader.uint32();
                    break;
                case 28:
                    message.attacker_team = reader.uint32();
                    break;
                case 29:
                    message.target_team = reader.uint32();
                    break;
                case 30:
                    message.obs_wards_placed = reader.uint32();
                    break;
                case 31:
                    message.assist_player0 = reader.uint32();
                    break;
                case 32:
                    message.assist_player1 = reader.uint32();
                    break;
                case 33:
                    message.assist_player2 = reader.uint32();
                    break;
                case 34:
                    message.assist_player3 = reader.uint32();
                    break;
                case 35:
                    message.stack_count = reader.uint32();
                    break;
                case 36:
                    message.hidden_modifier = reader.bool();
                    break;
                case 37:
                    message.is_target_building = reader.bool();
                    break;
                case 38:
                    message.neutral_camp_type = reader.uint32();
                    break;
                case 39:
                    message.rune_type = reader.uint32();
                    break;
                case 40:
                    if (!(message.assist_players && message.assist_players.length))
                        message.assist_players = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.assist_players.push(reader.uint32());
                    } else
                        message.assist_players.push(reader.uint32());
                    break;
                case 41:
                    message.is_heal_save = reader.bool();
                    break;
                case 42:
                    message.is_ultimate_ability = reader.bool();
                    break;
                case 43:
                    message.attacker_hero_level = reader.uint32();
                    break;
                case 44:
                    message.target_hero_level = reader.uint32();
                    break;
                case 45:
                    message.xpm = reader.uint32();
                    break;
                case 46:
                    message.gpm = reader.uint32();
                    break;
                case 47:
                    message.event_location = reader.uint32();
                    break;
                case 48:
                    message.target_is_self = reader.bool();
                    break;
                case 49:
                    message.damage_type = reader.uint32();
                    break;
                case 50:
                    message.invisibility_modifier = reader.bool();
                    break;
                case 51:
                    message.damage_category = reader.uint32();
                    break;
                case 52:
                    message.networth = reader.uint32();
                    break;
                case 53:
                    message.building_type = reader.uint32();
                    break;
                case 54:
                    message.modifier_elapsed_duration = reader.float();
                    break;
                case 55:
                    message.silence_modifier = reader.bool();
                    break;
                case 56:
                    message.heal_from_lifesteal = reader.bool();
                    break;
                case 57:
                    message.modifier_purged = reader.bool();
                    break;
                case 58:
                    message.spell_evaded = reader.bool();
                    break;
                case 59:
                    message.motion_controller_modifier = reader.bool();
                    break;
                case 60:
                    message.long_range_kill = reader.bool();
                    break;
                case 61:
                    message.modifier_purge_ability = reader.uint32();
                    break;
                case 62:
                    message.modifier_purge_npc = reader.uint32();
                    break;
                case 63:
                    message.root_modifier = reader.bool();
                    break;
                case 64:
                    message.total_unit_death_count = reader.uint32();
                    break;
                case 65:
                    message.aura_modifier = reader.bool();
                    break;
                case 66:
                    message.armor_debuff_modifier = reader.bool();
                    break;
                case 67:
                    message.no_physical_damage_modifier = reader.bool();
                    break;
                case 68:
                    message.modifier_ability = reader.uint32();
                    break;
                case 69:
                    message.modifier_hidden = reader.bool();
                    break;
                case 70:
                    message.inflictor_is_stolen_ability = reader.bool();
                    break;
                case 71:
                    message.kill_eater_event = reader.uint32();
                    break;
                case 72:
                    message.unit_status_label = reader.uint32();
                    break;
                case 73:
                    message.spell_generated_attack = reader.bool();
                    break;
                case 74:
                    message.at_night_time = reader.bool();
                    break;
                case 75:
                    message.attacker_has_scepter = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgDOTACombatLogEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgDOTACombatLogEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgDOTACombatLogEntry message.
         * @function verify
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgDOTACombatLogEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                    break;
                }
            if (message.target_name != null && message.hasOwnProperty("target_name"))
                if (!$util.isInteger(message.target_name))
                    return "target_name: integer expected";
            if (message.target_source_name != null && message.hasOwnProperty("target_source_name"))
                if (!$util.isInteger(message.target_source_name))
                    return "target_source_name: integer expected";
            if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                if (!$util.isInteger(message.attacker_name))
                    return "attacker_name: integer expected";
            if (message.damage_source_name != null && message.hasOwnProperty("damage_source_name"))
                if (!$util.isInteger(message.damage_source_name))
                    return "damage_source_name: integer expected";
            if (message.inflictor_name != null && message.hasOwnProperty("inflictor_name"))
                if (!$util.isInteger(message.inflictor_name))
                    return "inflictor_name: integer expected";
            if (message.is_attacker_illusion != null && message.hasOwnProperty("is_attacker_illusion"))
                if (typeof message.is_attacker_illusion !== "boolean")
                    return "is_attacker_illusion: boolean expected";
            if (message.is_attacker_hero != null && message.hasOwnProperty("is_attacker_hero"))
                if (typeof message.is_attacker_hero !== "boolean")
                    return "is_attacker_hero: boolean expected";
            if (message.is_target_illusion != null && message.hasOwnProperty("is_target_illusion"))
                if (typeof message.is_target_illusion !== "boolean")
                    return "is_target_illusion: boolean expected";
            if (message.is_target_hero != null && message.hasOwnProperty("is_target_hero"))
                if (typeof message.is_target_hero !== "boolean")
                    return "is_target_hero: boolean expected";
            if (message.is_visible_radiant != null && message.hasOwnProperty("is_visible_radiant"))
                if (typeof message.is_visible_radiant !== "boolean")
                    return "is_visible_radiant: boolean expected";
            if (message.is_visible_dire != null && message.hasOwnProperty("is_visible_dire"))
                if (typeof message.is_visible_dire !== "boolean")
                    return "is_visible_dire: boolean expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            if (message.health != null && message.hasOwnProperty("health"))
                if (!$util.isInteger(message.health))
                    return "health: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.stun_duration != null && message.hasOwnProperty("stun_duration"))
                if (typeof message.stun_duration !== "number")
                    return "stun_duration: number expected";
            if (message.slow_duration != null && message.hasOwnProperty("slow_duration"))
                if (typeof message.slow_duration !== "number")
                    return "slow_duration: number expected";
            if (message.is_ability_toggle_on != null && message.hasOwnProperty("is_ability_toggle_on"))
                if (typeof message.is_ability_toggle_on !== "boolean")
                    return "is_ability_toggle_on: boolean expected";
            if (message.is_ability_toggle_off != null && message.hasOwnProperty("is_ability_toggle_off"))
                if (typeof message.is_ability_toggle_off !== "boolean")
                    return "is_ability_toggle_off: boolean expected";
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                if (!$util.isInteger(message.ability_level))
                    return "ability_level: integer expected";
            if (message.location_x != null && message.hasOwnProperty("location_x"))
                if (typeof message.location_x !== "number")
                    return "location_x: number expected";
            if (message.location_y != null && message.hasOwnProperty("location_y"))
                if (typeof message.location_y !== "number")
                    return "location_y: number expected";
            if (message.gold_reason != null && message.hasOwnProperty("gold_reason"))
                if (!$util.isInteger(message.gold_reason))
                    return "gold_reason: integer expected";
            if (message.timestamp_raw != null && message.hasOwnProperty("timestamp_raw"))
                if (typeof message.timestamp_raw !== "number")
                    return "timestamp_raw: number expected";
            if (message.modifier_duration != null && message.hasOwnProperty("modifier_duration"))
                if (typeof message.modifier_duration !== "number")
                    return "modifier_duration: number expected";
            if (message.xp_reason != null && message.hasOwnProperty("xp_reason"))
                if (!$util.isInteger(message.xp_reason))
                    return "xp_reason: integer expected";
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                if (!$util.isInteger(message.last_hits))
                    return "last_hits: integer expected";
            if (message.attacker_team != null && message.hasOwnProperty("attacker_team"))
                if (!$util.isInteger(message.attacker_team))
                    return "attacker_team: integer expected";
            if (message.target_team != null && message.hasOwnProperty("target_team"))
                if (!$util.isInteger(message.target_team))
                    return "target_team: integer expected";
            if (message.obs_wards_placed != null && message.hasOwnProperty("obs_wards_placed"))
                if (!$util.isInteger(message.obs_wards_placed))
                    return "obs_wards_placed: integer expected";
            if (message.assist_player0 != null && message.hasOwnProperty("assist_player0"))
                if (!$util.isInteger(message.assist_player0))
                    return "assist_player0: integer expected";
            if (message.assist_player1 != null && message.hasOwnProperty("assist_player1"))
                if (!$util.isInteger(message.assist_player1))
                    return "assist_player1: integer expected";
            if (message.assist_player2 != null && message.hasOwnProperty("assist_player2"))
                if (!$util.isInteger(message.assist_player2))
                    return "assist_player2: integer expected";
            if (message.assist_player3 != null && message.hasOwnProperty("assist_player3"))
                if (!$util.isInteger(message.assist_player3))
                    return "assist_player3: integer expected";
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                if (!$util.isInteger(message.stack_count))
                    return "stack_count: integer expected";
            if (message.hidden_modifier != null && message.hasOwnProperty("hidden_modifier"))
                if (typeof message.hidden_modifier !== "boolean")
                    return "hidden_modifier: boolean expected";
            if (message.is_target_building != null && message.hasOwnProperty("is_target_building"))
                if (typeof message.is_target_building !== "boolean")
                    return "is_target_building: boolean expected";
            if (message.neutral_camp_type != null && message.hasOwnProperty("neutral_camp_type"))
                if (!$util.isInteger(message.neutral_camp_type))
                    return "neutral_camp_type: integer expected";
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                if (!$util.isInteger(message.rune_type))
                    return "rune_type: integer expected";
            if (message.assist_players != null && message.hasOwnProperty("assist_players")) {
                if (!Array.isArray(message.assist_players))
                    return "assist_players: array expected";
                for (var i = 0; i < message.assist_players.length; ++i)
                    if (!$util.isInteger(message.assist_players[i]))
                        return "assist_players: integer[] expected";
            }
            if (message.is_heal_save != null && message.hasOwnProperty("is_heal_save"))
                if (typeof message.is_heal_save !== "boolean")
                    return "is_heal_save: boolean expected";
            if (message.is_ultimate_ability != null && message.hasOwnProperty("is_ultimate_ability"))
                if (typeof message.is_ultimate_ability !== "boolean")
                    return "is_ultimate_ability: boolean expected";
            if (message.attacker_hero_level != null && message.hasOwnProperty("attacker_hero_level"))
                if (!$util.isInteger(message.attacker_hero_level))
                    return "attacker_hero_level: integer expected";
            if (message.target_hero_level != null && message.hasOwnProperty("target_hero_level"))
                if (!$util.isInteger(message.target_hero_level))
                    return "target_hero_level: integer expected";
            if (message.xpm != null && message.hasOwnProperty("xpm"))
                if (!$util.isInteger(message.xpm))
                    return "xpm: integer expected";
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                if (!$util.isInteger(message.gpm))
                    return "gpm: integer expected";
            if (message.event_location != null && message.hasOwnProperty("event_location"))
                if (!$util.isInteger(message.event_location))
                    return "event_location: integer expected";
            if (message.target_is_self != null && message.hasOwnProperty("target_is_self"))
                if (typeof message.target_is_self !== "boolean")
                    return "target_is_self: boolean expected";
            if (message.damage_type != null && message.hasOwnProperty("damage_type"))
                if (!$util.isInteger(message.damage_type))
                    return "damage_type: integer expected";
            if (message.invisibility_modifier != null && message.hasOwnProperty("invisibility_modifier"))
                if (typeof message.invisibility_modifier !== "boolean")
                    return "invisibility_modifier: boolean expected";
            if (message.damage_category != null && message.hasOwnProperty("damage_category"))
                if (!$util.isInteger(message.damage_category))
                    return "damage_category: integer expected";
            if (message.networth != null && message.hasOwnProperty("networth"))
                if (!$util.isInteger(message.networth))
                    return "networth: integer expected";
            if (message.building_type != null && message.hasOwnProperty("building_type"))
                if (!$util.isInteger(message.building_type))
                    return "building_type: integer expected";
            if (message.modifier_elapsed_duration != null && message.hasOwnProperty("modifier_elapsed_duration"))
                if (typeof message.modifier_elapsed_duration !== "number")
                    return "modifier_elapsed_duration: number expected";
            if (message.silence_modifier != null && message.hasOwnProperty("silence_modifier"))
                if (typeof message.silence_modifier !== "boolean")
                    return "silence_modifier: boolean expected";
            if (message.heal_from_lifesteal != null && message.hasOwnProperty("heal_from_lifesteal"))
                if (typeof message.heal_from_lifesteal !== "boolean")
                    return "heal_from_lifesteal: boolean expected";
            if (message.modifier_purged != null && message.hasOwnProperty("modifier_purged"))
                if (typeof message.modifier_purged !== "boolean")
                    return "modifier_purged: boolean expected";
            if (message.spell_evaded != null && message.hasOwnProperty("spell_evaded"))
                if (typeof message.spell_evaded !== "boolean")
                    return "spell_evaded: boolean expected";
            if (message.motion_controller_modifier != null && message.hasOwnProperty("motion_controller_modifier"))
                if (typeof message.motion_controller_modifier !== "boolean")
                    return "motion_controller_modifier: boolean expected";
            if (message.long_range_kill != null && message.hasOwnProperty("long_range_kill"))
                if (typeof message.long_range_kill !== "boolean")
                    return "long_range_kill: boolean expected";
            if (message.modifier_purge_ability != null && message.hasOwnProperty("modifier_purge_ability"))
                if (!$util.isInteger(message.modifier_purge_ability))
                    return "modifier_purge_ability: integer expected";
            if (message.modifier_purge_npc != null && message.hasOwnProperty("modifier_purge_npc"))
                if (!$util.isInteger(message.modifier_purge_npc))
                    return "modifier_purge_npc: integer expected";
            if (message.root_modifier != null && message.hasOwnProperty("root_modifier"))
                if (typeof message.root_modifier !== "boolean")
                    return "root_modifier: boolean expected";
            if (message.total_unit_death_count != null && message.hasOwnProperty("total_unit_death_count"))
                if (!$util.isInteger(message.total_unit_death_count))
                    return "total_unit_death_count: integer expected";
            if (message.aura_modifier != null && message.hasOwnProperty("aura_modifier"))
                if (typeof message.aura_modifier !== "boolean")
                    return "aura_modifier: boolean expected";
            if (message.armor_debuff_modifier != null && message.hasOwnProperty("armor_debuff_modifier"))
                if (typeof message.armor_debuff_modifier !== "boolean")
                    return "armor_debuff_modifier: boolean expected";
            if (message.no_physical_damage_modifier != null && message.hasOwnProperty("no_physical_damage_modifier"))
                if (typeof message.no_physical_damage_modifier !== "boolean")
                    return "no_physical_damage_modifier: boolean expected";
            if (message.modifier_ability != null && message.hasOwnProperty("modifier_ability"))
                if (!$util.isInteger(message.modifier_ability))
                    return "modifier_ability: integer expected";
            if (message.modifier_hidden != null && message.hasOwnProperty("modifier_hidden"))
                if (typeof message.modifier_hidden !== "boolean")
                    return "modifier_hidden: boolean expected";
            if (message.inflictor_is_stolen_ability != null && message.hasOwnProperty("inflictor_is_stolen_ability"))
                if (typeof message.inflictor_is_stolen_ability !== "boolean")
                    return "inflictor_is_stolen_ability: boolean expected";
            if (message.kill_eater_event != null && message.hasOwnProperty("kill_eater_event"))
                if (!$util.isInteger(message.kill_eater_event))
                    return "kill_eater_event: integer expected";
            if (message.unit_status_label != null && message.hasOwnProperty("unit_status_label"))
                if (!$util.isInteger(message.unit_status_label))
                    return "unit_status_label: integer expected";
            if (message.spell_generated_attack != null && message.hasOwnProperty("spell_generated_attack"))
                if (typeof message.spell_generated_attack !== "boolean")
                    return "spell_generated_attack: boolean expected";
            if (message.at_night_time != null && message.hasOwnProperty("at_night_time"))
                if (typeof message.at_night_time !== "boolean")
                    return "at_night_time: boolean expected";
            if (message.attacker_has_scepter != null && message.hasOwnProperty("attacker_has_scepter"))
                if (typeof message.attacker_has_scepter !== "boolean")
                    return "attacker_has_scepter: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgDOTACombatLogEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgDOTACombatLogEntry} CMsgDOTACombatLogEntry
         */
        CMsgDOTACombatLogEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgDOTACombatLogEntry)
                return object;
            var message = new $root.CMsgDOTACombatLogEntry();
            switch (object.type) {
            case "DOTA_COMBATLOG_INVALID":
            case -1:
                message.type = -1;
                break;
            case "DOTA_COMBATLOG_DAMAGE":
            case 0:
                message.type = 0;
                break;
            case "DOTA_COMBATLOG_HEAL":
            case 1:
                message.type = 1;
                break;
            case "DOTA_COMBATLOG_MODIFIER_ADD":
            case 2:
                message.type = 2;
                break;
            case "DOTA_COMBATLOG_MODIFIER_REMOVE":
            case 3:
                message.type = 3;
                break;
            case "DOTA_COMBATLOG_DEATH":
            case 4:
                message.type = 4;
                break;
            case "DOTA_COMBATLOG_ABILITY":
            case 5:
                message.type = 5;
                break;
            case "DOTA_COMBATLOG_ITEM":
            case 6:
                message.type = 6;
                break;
            case "DOTA_COMBATLOG_LOCATION":
            case 7:
                message.type = 7;
                break;
            case "DOTA_COMBATLOG_GOLD":
            case 8:
                message.type = 8;
                break;
            case "DOTA_COMBATLOG_GAME_STATE":
            case 9:
                message.type = 9;
                break;
            case "DOTA_COMBATLOG_XP":
            case 10:
                message.type = 10;
                break;
            case "DOTA_COMBATLOG_PURCHASE":
            case 11:
                message.type = 11;
                break;
            case "DOTA_COMBATLOG_BUYBACK":
            case 12:
                message.type = 12;
                break;
            case "DOTA_COMBATLOG_ABILITY_TRIGGER":
            case 13:
                message.type = 13;
                break;
            case "DOTA_COMBATLOG_PLAYERSTATS":
            case 14:
                message.type = 14;
                break;
            case "DOTA_COMBATLOG_MULTIKILL":
            case 15:
                message.type = 15;
                break;
            case "DOTA_COMBATLOG_KILLSTREAK":
            case 16:
                message.type = 16;
                break;
            case "DOTA_COMBATLOG_TEAM_BUILDING_KILL":
            case 17:
                message.type = 17;
                break;
            case "DOTA_COMBATLOG_FIRST_BLOOD":
            case 18:
                message.type = 18;
                break;
            case "DOTA_COMBATLOG_MODIFIER_STACK_EVENT":
            case 19:
                message.type = 19;
                break;
            case "DOTA_COMBATLOG_NEUTRAL_CAMP_STACK":
            case 20:
                message.type = 20;
                break;
            case "DOTA_COMBATLOG_PICKUP_RUNE":
            case 21:
                message.type = 21;
                break;
            case "DOTA_COMBATLOG_REVEALED_INVISIBLE":
            case 22:
                message.type = 22;
                break;
            case "DOTA_COMBATLOG_HERO_SAVED":
            case 23:
                message.type = 23;
                break;
            case "DOTA_COMBATLOG_MANA_RESTORED":
            case 24:
                message.type = 24;
                break;
            case "DOTA_COMBATLOG_HERO_LEVELUP":
            case 25:
                message.type = 25;
                break;
            case "DOTA_COMBATLOG_BOTTLE_HEAL_ALLY":
            case 26:
                message.type = 26;
                break;
            case "DOTA_COMBATLOG_ENDGAME_STATS":
            case 27:
                message.type = 27;
                break;
            case "DOTA_COMBATLOG_INTERRUPT_CHANNEL":
            case 28:
                message.type = 28;
                break;
            case "DOTA_COMBATLOG_ALLIED_GOLD":
            case 29:
                message.type = 29;
                break;
            case "DOTA_COMBATLOG_AEGIS_TAKEN":
            case 30:
                message.type = 30;
                break;
            case "DOTA_COMBATLOG_MANA_DAMAGE":
            case 31:
                message.type = 31;
                break;
            case "DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED":
            case 32:
                message.type = 32;
                break;
            case "DOTA_COMBATLOG_UNIT_SUMMONED":
            case 33:
                message.type = 33;
                break;
            case "DOTA_COMBATLOG_ATTACK_EVADE":
            case 34:
                message.type = 34;
                break;
            case "DOTA_COMBATLOG_TREE_CUT":
            case 35:
                message.type = 35;
                break;
            case "DOTA_COMBATLOG_SUCCESSFUL_SCAN":
            case 36:
                message.type = 36;
                break;
            case "DOTA_COMBATLOG_END_KILLSTREAK":
            case 37:
                message.type = 37;
                break;
            case "DOTA_COMBATLOG_BLOODSTONE_CHARGE":
            case 38:
                message.type = 38;
                break;
            case "DOTA_COMBATLOG_CRITICAL_DAMAGE":
            case 39:
                message.type = 39;
                break;
            case "DOTA_COMBATLOG_SPELL_ABSORB":
            case 40:
                message.type = 40;
                break;
            case "DOTA_COMBATLOG_UNIT_TELEPORTED":
            case 41:
                message.type = 41;
                break;
            case "DOTA_COMBATLOG_KILL_EATER_EVENT":
            case 42:
                message.type = 42;
                break;
            }
            if (object.target_name != null)
                message.target_name = object.target_name >>> 0;
            if (object.target_source_name != null)
                message.target_source_name = object.target_source_name >>> 0;
            if (object.attacker_name != null)
                message.attacker_name = object.attacker_name >>> 0;
            if (object.damage_source_name != null)
                message.damage_source_name = object.damage_source_name >>> 0;
            if (object.inflictor_name != null)
                message.inflictor_name = object.inflictor_name >>> 0;
            if (object.is_attacker_illusion != null)
                message.is_attacker_illusion = Boolean(object.is_attacker_illusion);
            if (object.is_attacker_hero != null)
                message.is_attacker_hero = Boolean(object.is_attacker_hero);
            if (object.is_target_illusion != null)
                message.is_target_illusion = Boolean(object.is_target_illusion);
            if (object.is_target_hero != null)
                message.is_target_hero = Boolean(object.is_target_hero);
            if (object.is_visible_radiant != null)
                message.is_visible_radiant = Boolean(object.is_visible_radiant);
            if (object.is_visible_dire != null)
                message.is_visible_dire = Boolean(object.is_visible_dire);
            if (object.value != null)
                message.value = object.value >>> 0;
            if (object.health != null)
                message.health = object.health | 0;
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.stun_duration != null)
                message.stun_duration = Number(object.stun_duration);
            if (object.slow_duration != null)
                message.slow_duration = Number(object.slow_duration);
            if (object.is_ability_toggle_on != null)
                message.is_ability_toggle_on = Boolean(object.is_ability_toggle_on);
            if (object.is_ability_toggle_off != null)
                message.is_ability_toggle_off = Boolean(object.is_ability_toggle_off);
            if (object.ability_level != null)
                message.ability_level = object.ability_level >>> 0;
            if (object.location_x != null)
                message.location_x = Number(object.location_x);
            if (object.location_y != null)
                message.location_y = Number(object.location_y);
            if (object.gold_reason != null)
                message.gold_reason = object.gold_reason >>> 0;
            if (object.timestamp_raw != null)
                message.timestamp_raw = Number(object.timestamp_raw);
            if (object.modifier_duration != null)
                message.modifier_duration = Number(object.modifier_duration);
            if (object.xp_reason != null)
                message.xp_reason = object.xp_reason >>> 0;
            if (object.last_hits != null)
                message.last_hits = object.last_hits >>> 0;
            if (object.attacker_team != null)
                message.attacker_team = object.attacker_team >>> 0;
            if (object.target_team != null)
                message.target_team = object.target_team >>> 0;
            if (object.obs_wards_placed != null)
                message.obs_wards_placed = object.obs_wards_placed >>> 0;
            if (object.assist_player0 != null)
                message.assist_player0 = object.assist_player0 >>> 0;
            if (object.assist_player1 != null)
                message.assist_player1 = object.assist_player1 >>> 0;
            if (object.assist_player2 != null)
                message.assist_player2 = object.assist_player2 >>> 0;
            if (object.assist_player3 != null)
                message.assist_player3 = object.assist_player3 >>> 0;
            if (object.stack_count != null)
                message.stack_count = object.stack_count >>> 0;
            if (object.hidden_modifier != null)
                message.hidden_modifier = Boolean(object.hidden_modifier);
            if (object.is_target_building != null)
                message.is_target_building = Boolean(object.is_target_building);
            if (object.neutral_camp_type != null)
                message.neutral_camp_type = object.neutral_camp_type >>> 0;
            if (object.rune_type != null)
                message.rune_type = object.rune_type >>> 0;
            if (object.assist_players) {
                if (!Array.isArray(object.assist_players))
                    throw TypeError(".CMsgDOTACombatLogEntry.assist_players: array expected");
                message.assist_players = [];
                for (var i = 0; i < object.assist_players.length; ++i)
                    message.assist_players[i] = object.assist_players[i] >>> 0;
            }
            if (object.is_heal_save != null)
                message.is_heal_save = Boolean(object.is_heal_save);
            if (object.is_ultimate_ability != null)
                message.is_ultimate_ability = Boolean(object.is_ultimate_ability);
            if (object.attacker_hero_level != null)
                message.attacker_hero_level = object.attacker_hero_level >>> 0;
            if (object.target_hero_level != null)
                message.target_hero_level = object.target_hero_level >>> 0;
            if (object.xpm != null)
                message.xpm = object.xpm >>> 0;
            if (object.gpm != null)
                message.gpm = object.gpm >>> 0;
            if (object.event_location != null)
                message.event_location = object.event_location >>> 0;
            if (object.target_is_self != null)
                message.target_is_self = Boolean(object.target_is_self);
            if (object.damage_type != null)
                message.damage_type = object.damage_type >>> 0;
            if (object.invisibility_modifier != null)
                message.invisibility_modifier = Boolean(object.invisibility_modifier);
            if (object.damage_category != null)
                message.damage_category = object.damage_category >>> 0;
            if (object.networth != null)
                message.networth = object.networth >>> 0;
            if (object.building_type != null)
                message.building_type = object.building_type >>> 0;
            if (object.modifier_elapsed_duration != null)
                message.modifier_elapsed_duration = Number(object.modifier_elapsed_duration);
            if (object.silence_modifier != null)
                message.silence_modifier = Boolean(object.silence_modifier);
            if (object.heal_from_lifesteal != null)
                message.heal_from_lifesteal = Boolean(object.heal_from_lifesteal);
            if (object.modifier_purged != null)
                message.modifier_purged = Boolean(object.modifier_purged);
            if (object.spell_evaded != null)
                message.spell_evaded = Boolean(object.spell_evaded);
            if (object.motion_controller_modifier != null)
                message.motion_controller_modifier = Boolean(object.motion_controller_modifier);
            if (object.long_range_kill != null)
                message.long_range_kill = Boolean(object.long_range_kill);
            if (object.modifier_purge_ability != null)
                message.modifier_purge_ability = object.modifier_purge_ability >>> 0;
            if (object.modifier_purge_npc != null)
                message.modifier_purge_npc = object.modifier_purge_npc >>> 0;
            if (object.root_modifier != null)
                message.root_modifier = Boolean(object.root_modifier);
            if (object.total_unit_death_count != null)
                message.total_unit_death_count = object.total_unit_death_count >>> 0;
            if (object.aura_modifier != null)
                message.aura_modifier = Boolean(object.aura_modifier);
            if (object.armor_debuff_modifier != null)
                message.armor_debuff_modifier = Boolean(object.armor_debuff_modifier);
            if (object.no_physical_damage_modifier != null)
                message.no_physical_damage_modifier = Boolean(object.no_physical_damage_modifier);
            if (object.modifier_ability != null)
                message.modifier_ability = object.modifier_ability >>> 0;
            if (object.modifier_hidden != null)
                message.modifier_hidden = Boolean(object.modifier_hidden);
            if (object.inflictor_is_stolen_ability != null)
                message.inflictor_is_stolen_ability = Boolean(object.inflictor_is_stolen_ability);
            if (object.kill_eater_event != null)
                message.kill_eater_event = object.kill_eater_event >>> 0;
            if (object.unit_status_label != null)
                message.unit_status_label = object.unit_status_label >>> 0;
            if (object.spell_generated_attack != null)
                message.spell_generated_attack = Boolean(object.spell_generated_attack);
            if (object.at_night_time != null)
                message.at_night_time = Boolean(object.at_night_time);
            if (object.attacker_has_scepter != null)
                message.attacker_has_scepter = Boolean(object.attacker_has_scepter);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgDOTACombatLogEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgDOTACombatLogEntry
         * @static
         * @param {CMsgDOTACombatLogEntry} message CMsgDOTACombatLogEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgDOTACombatLogEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.assist_players = [];
            if (options.defaults) {
                object.type = options.enums === String ? "DOTA_COMBATLOG_INVALID" : -1;
                object.target_name = 0;
                object.target_source_name = 0;
                object.attacker_name = 0;
                object.damage_source_name = 0;
                object.inflictor_name = 0;
                object.is_attacker_illusion = false;
                object.is_attacker_hero = false;
                object.is_target_illusion = false;
                object.is_target_hero = false;
                object.is_visible_radiant = false;
                object.is_visible_dire = false;
                object.value = 0;
                object.health = 0;
                object.timestamp = 0;
                object.stun_duration = 0;
                object.slow_duration = 0;
                object.is_ability_toggle_on = false;
                object.is_ability_toggle_off = false;
                object.ability_level = 0;
                object.location_x = 0;
                object.location_y = 0;
                object.gold_reason = 0;
                object.timestamp_raw = 0;
                object.modifier_duration = 0;
                object.xp_reason = 0;
                object.last_hits = 0;
                object.attacker_team = 0;
                object.target_team = 0;
                object.obs_wards_placed = 0;
                object.assist_player0 = 0;
                object.assist_player1 = 0;
                object.assist_player2 = 0;
                object.assist_player3 = 0;
                object.stack_count = 0;
                object.hidden_modifier = false;
                object.is_target_building = false;
                object.neutral_camp_type = 0;
                object.rune_type = 0;
                object.is_heal_save = false;
                object.is_ultimate_ability = false;
                object.attacker_hero_level = 0;
                object.target_hero_level = 0;
                object.xpm = 0;
                object.gpm = 0;
                object.event_location = 0;
                object.target_is_self = false;
                object.damage_type = 0;
                object.invisibility_modifier = false;
                object.damage_category = 0;
                object.networth = 0;
                object.building_type = 0;
                object.modifier_elapsed_duration = 0;
                object.silence_modifier = false;
                object.heal_from_lifesteal = false;
                object.modifier_purged = false;
                object.spell_evaded = false;
                object.motion_controller_modifier = false;
                object.long_range_kill = false;
                object.modifier_purge_ability = 0;
                object.modifier_purge_npc = 0;
                object.root_modifier = false;
                object.total_unit_death_count = 0;
                object.aura_modifier = false;
                object.armor_debuff_modifier = false;
                object.no_physical_damage_modifier = false;
                object.modifier_ability = 0;
                object.modifier_hidden = false;
                object.inflictor_is_stolen_ability = false;
                object.kill_eater_event = 0;
                object.unit_status_label = 0;
                object.spell_generated_attack = false;
                object.at_night_time = false;
                object.attacker_has_scepter = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.DOTA_COMBATLOG_TYPES[message.type] : message.type;
            if (message.target_name != null && message.hasOwnProperty("target_name"))
                object.target_name = message.target_name;
            if (message.target_source_name != null && message.hasOwnProperty("target_source_name"))
                object.target_source_name = message.target_source_name;
            if (message.attacker_name != null && message.hasOwnProperty("attacker_name"))
                object.attacker_name = message.attacker_name;
            if (message.damage_source_name != null && message.hasOwnProperty("damage_source_name"))
                object.damage_source_name = message.damage_source_name;
            if (message.inflictor_name != null && message.hasOwnProperty("inflictor_name"))
                object.inflictor_name = message.inflictor_name;
            if (message.is_attacker_illusion != null && message.hasOwnProperty("is_attacker_illusion"))
                object.is_attacker_illusion = message.is_attacker_illusion;
            if (message.is_attacker_hero != null && message.hasOwnProperty("is_attacker_hero"))
                object.is_attacker_hero = message.is_attacker_hero;
            if (message.is_target_illusion != null && message.hasOwnProperty("is_target_illusion"))
                object.is_target_illusion = message.is_target_illusion;
            if (message.is_target_hero != null && message.hasOwnProperty("is_target_hero"))
                object.is_target_hero = message.is_target_hero;
            if (message.is_visible_radiant != null && message.hasOwnProperty("is_visible_radiant"))
                object.is_visible_radiant = message.is_visible_radiant;
            if (message.is_visible_dire != null && message.hasOwnProperty("is_visible_dire"))
                object.is_visible_dire = message.is_visible_dire;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = message.health;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.stun_duration != null && message.hasOwnProperty("stun_duration"))
                object.stun_duration = options.json && !isFinite(message.stun_duration) ? String(message.stun_duration) : message.stun_duration;
            if (message.slow_duration != null && message.hasOwnProperty("slow_duration"))
                object.slow_duration = options.json && !isFinite(message.slow_duration) ? String(message.slow_duration) : message.slow_duration;
            if (message.is_ability_toggle_on != null && message.hasOwnProperty("is_ability_toggle_on"))
                object.is_ability_toggle_on = message.is_ability_toggle_on;
            if (message.is_ability_toggle_off != null && message.hasOwnProperty("is_ability_toggle_off"))
                object.is_ability_toggle_off = message.is_ability_toggle_off;
            if (message.ability_level != null && message.hasOwnProperty("ability_level"))
                object.ability_level = message.ability_level;
            if (message.location_x != null && message.hasOwnProperty("location_x"))
                object.location_x = options.json && !isFinite(message.location_x) ? String(message.location_x) : message.location_x;
            if (message.location_y != null && message.hasOwnProperty("location_y"))
                object.location_y = options.json && !isFinite(message.location_y) ? String(message.location_y) : message.location_y;
            if (message.gold_reason != null && message.hasOwnProperty("gold_reason"))
                object.gold_reason = message.gold_reason;
            if (message.timestamp_raw != null && message.hasOwnProperty("timestamp_raw"))
                object.timestamp_raw = options.json && !isFinite(message.timestamp_raw) ? String(message.timestamp_raw) : message.timestamp_raw;
            if (message.modifier_duration != null && message.hasOwnProperty("modifier_duration"))
                object.modifier_duration = options.json && !isFinite(message.modifier_duration) ? String(message.modifier_duration) : message.modifier_duration;
            if (message.xp_reason != null && message.hasOwnProperty("xp_reason"))
                object.xp_reason = message.xp_reason;
            if (message.last_hits != null && message.hasOwnProperty("last_hits"))
                object.last_hits = message.last_hits;
            if (message.attacker_team != null && message.hasOwnProperty("attacker_team"))
                object.attacker_team = message.attacker_team;
            if (message.target_team != null && message.hasOwnProperty("target_team"))
                object.target_team = message.target_team;
            if (message.obs_wards_placed != null && message.hasOwnProperty("obs_wards_placed"))
                object.obs_wards_placed = message.obs_wards_placed;
            if (message.assist_player0 != null && message.hasOwnProperty("assist_player0"))
                object.assist_player0 = message.assist_player0;
            if (message.assist_player1 != null && message.hasOwnProperty("assist_player1"))
                object.assist_player1 = message.assist_player1;
            if (message.assist_player2 != null && message.hasOwnProperty("assist_player2"))
                object.assist_player2 = message.assist_player2;
            if (message.assist_player3 != null && message.hasOwnProperty("assist_player3"))
                object.assist_player3 = message.assist_player3;
            if (message.stack_count != null && message.hasOwnProperty("stack_count"))
                object.stack_count = message.stack_count;
            if (message.hidden_modifier != null && message.hasOwnProperty("hidden_modifier"))
                object.hidden_modifier = message.hidden_modifier;
            if (message.is_target_building != null && message.hasOwnProperty("is_target_building"))
                object.is_target_building = message.is_target_building;
            if (message.neutral_camp_type != null && message.hasOwnProperty("neutral_camp_type"))
                object.neutral_camp_type = message.neutral_camp_type;
            if (message.rune_type != null && message.hasOwnProperty("rune_type"))
                object.rune_type = message.rune_type;
            if (message.assist_players && message.assist_players.length) {
                object.assist_players = [];
                for (var j = 0; j < message.assist_players.length; ++j)
                    object.assist_players[j] = message.assist_players[j];
            }
            if (message.is_heal_save != null && message.hasOwnProperty("is_heal_save"))
                object.is_heal_save = message.is_heal_save;
            if (message.is_ultimate_ability != null && message.hasOwnProperty("is_ultimate_ability"))
                object.is_ultimate_ability = message.is_ultimate_ability;
            if (message.attacker_hero_level != null && message.hasOwnProperty("attacker_hero_level"))
                object.attacker_hero_level = message.attacker_hero_level;
            if (message.target_hero_level != null && message.hasOwnProperty("target_hero_level"))
                object.target_hero_level = message.target_hero_level;
            if (message.xpm != null && message.hasOwnProperty("xpm"))
                object.xpm = message.xpm;
            if (message.gpm != null && message.hasOwnProperty("gpm"))
                object.gpm = message.gpm;
            if (message.event_location != null && message.hasOwnProperty("event_location"))
                object.event_location = message.event_location;
            if (message.target_is_self != null && message.hasOwnProperty("target_is_self"))
                object.target_is_self = message.target_is_self;
            if (message.damage_type != null && message.hasOwnProperty("damage_type"))
                object.damage_type = message.damage_type;
            if (message.invisibility_modifier != null && message.hasOwnProperty("invisibility_modifier"))
                object.invisibility_modifier = message.invisibility_modifier;
            if (message.damage_category != null && message.hasOwnProperty("damage_category"))
                object.damage_category = message.damage_category;
            if (message.networth != null && message.hasOwnProperty("networth"))
                object.networth = message.networth;
            if (message.building_type != null && message.hasOwnProperty("building_type"))
                object.building_type = message.building_type;
            if (message.modifier_elapsed_duration != null && message.hasOwnProperty("modifier_elapsed_duration"))
                object.modifier_elapsed_duration = options.json && !isFinite(message.modifier_elapsed_duration) ? String(message.modifier_elapsed_duration) : message.modifier_elapsed_duration;
            if (message.silence_modifier != null && message.hasOwnProperty("silence_modifier"))
                object.silence_modifier = message.silence_modifier;
            if (message.heal_from_lifesteal != null && message.hasOwnProperty("heal_from_lifesteal"))
                object.heal_from_lifesteal = message.heal_from_lifesteal;
            if (message.modifier_purged != null && message.hasOwnProperty("modifier_purged"))
                object.modifier_purged = message.modifier_purged;
            if (message.spell_evaded != null && message.hasOwnProperty("spell_evaded"))
                object.spell_evaded = message.spell_evaded;
            if (message.motion_controller_modifier != null && message.hasOwnProperty("motion_controller_modifier"))
                object.motion_controller_modifier = message.motion_controller_modifier;
            if (message.long_range_kill != null && message.hasOwnProperty("long_range_kill"))
                object.long_range_kill = message.long_range_kill;
            if (message.modifier_purge_ability != null && message.hasOwnProperty("modifier_purge_ability"))
                object.modifier_purge_ability = message.modifier_purge_ability;
            if (message.modifier_purge_npc != null && message.hasOwnProperty("modifier_purge_npc"))
                object.modifier_purge_npc = message.modifier_purge_npc;
            if (message.root_modifier != null && message.hasOwnProperty("root_modifier"))
                object.root_modifier = message.root_modifier;
            if (message.total_unit_death_count != null && message.hasOwnProperty("total_unit_death_count"))
                object.total_unit_death_count = message.total_unit_death_count;
            if (message.aura_modifier != null && message.hasOwnProperty("aura_modifier"))
                object.aura_modifier = message.aura_modifier;
            if (message.armor_debuff_modifier != null && message.hasOwnProperty("armor_debuff_modifier"))
                object.armor_debuff_modifier = message.armor_debuff_modifier;
            if (message.no_physical_damage_modifier != null && message.hasOwnProperty("no_physical_damage_modifier"))
                object.no_physical_damage_modifier = message.no_physical_damage_modifier;
            if (message.modifier_ability != null && message.hasOwnProperty("modifier_ability"))
                object.modifier_ability = message.modifier_ability;
            if (message.modifier_hidden != null && message.hasOwnProperty("modifier_hidden"))
                object.modifier_hidden = message.modifier_hidden;
            if (message.inflictor_is_stolen_ability != null && message.hasOwnProperty("inflictor_is_stolen_ability"))
                object.inflictor_is_stolen_ability = message.inflictor_is_stolen_ability;
            if (message.kill_eater_event != null && message.hasOwnProperty("kill_eater_event"))
                object.kill_eater_event = message.kill_eater_event;
            if (message.unit_status_label != null && message.hasOwnProperty("unit_status_label"))
                object.unit_status_label = message.unit_status_label;
            if (message.spell_generated_attack != null && message.hasOwnProperty("spell_generated_attack"))
                object.spell_generated_attack = message.spell_generated_attack;
            if (message.at_night_time != null && message.hasOwnProperty("at_night_time"))
                object.at_night_time = message.at_night_time;
            if (message.attacker_has_scepter != null && message.hasOwnProperty("attacker_has_scepter"))
                object.attacker_has_scepter = message.attacker_has_scepter;
            return object;
        };
    
        /**
         * Converts this CMsgDOTACombatLogEntry to JSON.
         * @function toJSON
         * @memberof CMsgDOTACombatLogEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgDOTACombatLogEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgDOTACombatLogEntry;
    })();
    
    $root.CMsgPendingEventAward = (function() {
    
        /**
         * Properties of a CMsgPendingEventAward.
         * @exports ICMsgPendingEventAward
         * @interface ICMsgPendingEventAward
         * @property {EEvent|null} [event_id] CMsgPendingEventAward event_id
         * @property {number|null} [action_id] CMsgPendingEventAward action_id
         * @property {number|null} [num_to_grant] CMsgPendingEventAward num_to_grant
         * @property {EEventActionScoreMode|null} [score_mode] CMsgPendingEventAward score_mode
         * @property {number|null} [audit_action] CMsgPendingEventAward audit_action
         */
    
        /**
         * Constructs a new CMsgPendingEventAward.
         * @exports CMsgPendingEventAward
         * @classdesc Represents a CMsgPendingEventAward.
         * @implements ICMsgPendingEventAward
         * @constructor
         * @param {ICMsgPendingEventAward=} [properties] Properties to set
         */
        function CMsgPendingEventAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPendingEventAward event_id.
         * @member {EEvent} event_id
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.event_id = 0;
    
        /**
         * CMsgPendingEventAward action_id.
         * @member {number} action_id
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.action_id = 0;
    
        /**
         * CMsgPendingEventAward num_to_grant.
         * @member {number} num_to_grant
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.num_to_grant = 0;
    
        /**
         * CMsgPendingEventAward score_mode.
         * @member {EEventActionScoreMode} score_mode
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.score_mode = 0;
    
        /**
         * CMsgPendingEventAward audit_action.
         * @member {number} audit_action
         * @memberof CMsgPendingEventAward
         * @instance
         */
        CMsgPendingEventAward.prototype.audit_action = 0;
    
        /**
         * Creates a new CMsgPendingEventAward instance using the specified properties.
         * @function create
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward=} [properties] Properties to set
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward instance
         */
        CMsgPendingEventAward.create = function create(properties) {
            return new CMsgPendingEventAward(properties);
        };
    
        /**
         * Encodes the specified CMsgPendingEventAward message. Does not implicitly {@link CMsgPendingEventAward.verify|verify} messages.
         * @function encode
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward} message CMsgPendingEventAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPendingEventAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_id != null && Object.hasOwnProperty.call(message, "event_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event_id);
            if (message.action_id != null && Object.hasOwnProperty.call(message, "action_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.action_id);
            if (message.num_to_grant != null && Object.hasOwnProperty.call(message, "num_to_grant"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_to_grant);
            if (message.score_mode != null && Object.hasOwnProperty.call(message, "score_mode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.score_mode);
            if (message.audit_action != null && Object.hasOwnProperty.call(message, "audit_action"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.audit_action);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPendingEventAward message, length delimited. Does not implicitly {@link CMsgPendingEventAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPendingEventAward
         * @static
         * @param {ICMsgPendingEventAward} message CMsgPendingEventAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPendingEventAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPendingEventAward message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPendingEventAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPendingEventAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPendingEventAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_id = reader.int32();
                    break;
                case 2:
                    message.action_id = reader.uint32();
                    break;
                case 3:
                    message.num_to_grant = reader.uint32();
                    break;
                case 4:
                    message.score_mode = reader.int32();
                    break;
                case 5:
                    message.audit_action = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPendingEventAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPendingEventAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPendingEventAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPendingEventAward message.
         * @function verify
         * @memberof CMsgPendingEventAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPendingEventAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                switch (message.event_id) {
                default:
                    return "event_id: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                    break;
                }
            if (message.action_id != null && message.hasOwnProperty("action_id"))
                if (!$util.isInteger(message.action_id))
                    return "action_id: integer expected";
            if (message.num_to_grant != null && message.hasOwnProperty("num_to_grant"))
                if (!$util.isInteger(message.num_to_grant))
                    return "num_to_grant: integer expected";
            if (message.score_mode != null && message.hasOwnProperty("score_mode"))
                switch (message.score_mode) {
                default:
                    return "score_mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.audit_action != null && message.hasOwnProperty("audit_action"))
                if (!$util.isInteger(message.audit_action))
                    return "audit_action: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgPendingEventAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPendingEventAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPendingEventAward} CMsgPendingEventAward
         */
        CMsgPendingEventAward.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPendingEventAward)
                return object;
            var message = new $root.CMsgPendingEventAward();
            switch (object.event_id) {
            case "EVENT_ID_NONE":
            case 0:
                message.event_id = 0;
                break;
            case "EVENT_ID_DIRETIDE":
            case 1:
                message.event_id = 1;
                break;
            case "EVENT_ID_SPRING_FESTIVAL":
            case 2:
                message.event_id = 2;
                break;
            case "EVENT_ID_FROSTIVUS_2013":
            case 3:
                message.event_id = 3;
                break;
            case "EVENT_ID_COMPENDIUM_2014":
            case 4:
                message.event_id = 4;
                break;
            case "EVENT_ID_NEXON_PC_BANG":
            case 5:
                message.event_id = 5;
                break;
            case "EVENT_ID_PWRD_DAC_2015":
            case 6:
                message.event_id = 6;
                break;
            case "EVENT_ID_NEW_BLOOM_2015":
            case 7:
                message.event_id = 7;
                break;
            case "EVENT_ID_INTERNATIONAL_2015":
            case 8:
                message.event_id = 8;
                break;
            case "EVENT_ID_FALL_MAJOR_2015":
            case 9:
                message.event_id = 9;
                break;
            case "EVENT_ID_ORACLE_PA":
            case 10:
                message.event_id = 10;
                break;
            case "EVENT_ID_NEW_BLOOM_2015_PREBEAST":
            case 11:
                message.event_id = 11;
                break;
            case "EVENT_ID_FROSTIVUS":
            case 12:
                message.event_id = 12;
                break;
            case "EVENT_ID_WINTER_MAJOR_2016":
            case 13:
                message.event_id = 13;
                break;
            case "EVENT_ID_INTERNATIONAL_2016":
            case 14:
                message.event_id = 14;
                break;
            case "EVENT_ID_FALL_MAJOR_2016":
            case 15:
                message.event_id = 15;
                break;
            case "EVENT_ID_WINTER_MAJOR_2017":
            case 16:
                message.event_id = 16;
                break;
            case "EVENT_ID_NEW_BLOOM_2017":
            case 17:
                message.event_id = 17;
                break;
            case "EVENT_ID_INTERNATIONAL_2017":
            case 18:
                message.event_id = 18;
                break;
            case "EVENT_ID_PLUS_SUBSCRIPTION":
            case 19:
                message.event_id = 19;
                break;
            case "EVENT_ID_SINGLES_DAY_2017":
            case 20:
                message.event_id = 20;
                break;
            case "EVENT_ID_FROSTIVUS_2017":
            case 21:
                message.event_id = 21;
                break;
            case "EVENT_ID_INTERNATIONAL_2018":
            case 22:
                message.event_id = 22;
                break;
            case "EVENT_ID_FROSTIVUS_2018":
            case 23:
                message.event_id = 23;
                break;
            case "EVENT_ID_NEW_BLOOM_2019":
            case 24:
                message.event_id = 24;
                break;
            case "EVENT_ID_INTERNATIONAL_2019":
            case 25:
                message.event_id = 25;
                break;
            case "EVENT_ID_NEW_PLAYER_EXPERIENCE":
            case 26:
                message.event_id = 26;
                break;
            case "EVENT_ID_FROSTIVUS_2019":
            case 27:
                message.event_id = 27;
                break;
            case "EVENT_ID_NEW_BLOOM_2020":
            case 28:
                message.event_id = 28;
                break;
            case "EVENT_ID_INTERNATIONAL_2020":
            case 29:
                message.event_id = 29;
                break;
            case "EVENT_ID_TEAM_FANDOM":
            case 30:
                message.event_id = 30;
                break;
            case "EVENT_ID_DIRETIDE_2020":
            case 31:
                message.event_id = 31;
                break;
            case "EVENT_ID_COUNT":
            case 32:
                message.event_id = 32;
                break;
            }
            if (object.action_id != null)
                message.action_id = object.action_id >>> 0;
            if (object.num_to_grant != null)
                message.num_to_grant = object.num_to_grant >>> 0;
            switch (object.score_mode) {
            case "k_eEventActionScoreMode_Add":
            case 0:
                message.score_mode = 0;
                break;
            case "k_eEventActionScoreMode_Min":
            case 1:
                message.score_mode = 1;
                break;
            }
            if (object.audit_action != null)
                message.audit_action = object.audit_action >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPendingEventAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPendingEventAward
         * @static
         * @param {CMsgPendingEventAward} message CMsgPendingEventAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPendingEventAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_id = options.enums === String ? "EVENT_ID_NONE" : 0;
                object.action_id = 0;
                object.num_to_grant = 0;
                object.score_mode = options.enums === String ? "k_eEventActionScoreMode_Add" : 0;
                object.audit_action = 0;
            }
            if (message.event_id != null && message.hasOwnProperty("event_id"))
                object.event_id = options.enums === String ? $root.EEvent[message.event_id] : message.event_id;
            if (message.action_id != null && message.hasOwnProperty("action_id"))
                object.action_id = message.action_id;
            if (message.num_to_grant != null && message.hasOwnProperty("num_to_grant"))
                object.num_to_grant = message.num_to_grant;
            if (message.score_mode != null && message.hasOwnProperty("score_mode"))
                object.score_mode = options.enums === String ? $root.EEventActionScoreMode[message.score_mode] : message.score_mode;
            if (message.audit_action != null && message.hasOwnProperty("audit_action"))
                object.audit_action = message.audit_action;
            return object;
        };
    
        /**
         * Converts this CMsgPendingEventAward to JSON.
         * @function toJSON
         * @memberof CMsgPendingEventAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPendingEventAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPendingEventAward;
    })();

    return $root;
});
