/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * ETEProtobufIds enum.
     * @exports ETEProtobufIds
     * @enum {number}
     * @property {number} TE_EffectDispatchId=400 TE_EffectDispatchId value
     * @property {number} TE_ArmorRicochetId=401 TE_ArmorRicochetId value
     * @property {number} TE_BeamEntPointId=402 TE_BeamEntPointId value
     * @property {number} TE_BeamEntsId=403 TE_BeamEntsId value
     * @property {number} TE_BeamPointsId=404 TE_BeamPointsId value
     * @property {number} TE_BeamRingId=405 TE_BeamRingId value
     * @property {number} TE_BSPDecalId=407 TE_BSPDecalId value
     * @property {number} TE_BubblesId=408 TE_BubblesId value
     * @property {number} TE_BubbleTrailId=409 TE_BubbleTrailId value
     * @property {number} TE_DecalId=410 TE_DecalId value
     * @property {number} TE_WorldDecalId=411 TE_WorldDecalId value
     * @property {number} TE_EnergySplashId=412 TE_EnergySplashId value
     * @property {number} TE_FizzId=413 TE_FizzId value
     * @property {number} TE_ShatterSurfaceId=414 TE_ShatterSurfaceId value
     * @property {number} TE_GlowSpriteId=415 TE_GlowSpriteId value
     * @property {number} TE_ImpactId=416 TE_ImpactId value
     * @property {number} TE_MuzzleFlashId=417 TE_MuzzleFlashId value
     * @property {number} TE_BloodStreamId=418 TE_BloodStreamId value
     * @property {number} TE_ExplosionId=419 TE_ExplosionId value
     * @property {number} TE_DustId=420 TE_DustId value
     * @property {number} TE_LargeFunnelId=421 TE_LargeFunnelId value
     * @property {number} TE_SparksId=422 TE_SparksId value
     * @property {number} TE_PhysicsPropId=423 TE_PhysicsPropId value
     * @property {number} TE_PlayerDecalId=424 TE_PlayerDecalId value
     * @property {number} TE_ProjectedDecalId=425 TE_ProjectedDecalId value
     * @property {number} TE_SmokeId=426 TE_SmokeId value
     */
    $root.ETEProtobufIds = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[400] = "TE_EffectDispatchId"] = 400;
        values[valuesById[401] = "TE_ArmorRicochetId"] = 401;
        values[valuesById[402] = "TE_BeamEntPointId"] = 402;
        values[valuesById[403] = "TE_BeamEntsId"] = 403;
        values[valuesById[404] = "TE_BeamPointsId"] = 404;
        values[valuesById[405] = "TE_BeamRingId"] = 405;
        values[valuesById[407] = "TE_BSPDecalId"] = 407;
        values[valuesById[408] = "TE_BubblesId"] = 408;
        values[valuesById[409] = "TE_BubbleTrailId"] = 409;
        values[valuesById[410] = "TE_DecalId"] = 410;
        values[valuesById[411] = "TE_WorldDecalId"] = 411;
        values[valuesById[412] = "TE_EnergySplashId"] = 412;
        values[valuesById[413] = "TE_FizzId"] = 413;
        values[valuesById[414] = "TE_ShatterSurfaceId"] = 414;
        values[valuesById[415] = "TE_GlowSpriteId"] = 415;
        values[valuesById[416] = "TE_ImpactId"] = 416;
        values[valuesById[417] = "TE_MuzzleFlashId"] = 417;
        values[valuesById[418] = "TE_BloodStreamId"] = 418;
        values[valuesById[419] = "TE_ExplosionId"] = 419;
        values[valuesById[420] = "TE_DustId"] = 420;
        values[valuesById[421] = "TE_LargeFunnelId"] = 421;
        values[valuesById[422] = "TE_SparksId"] = 422;
        values[valuesById[423] = "TE_PhysicsPropId"] = 423;
        values[valuesById[424] = "TE_PlayerDecalId"] = 424;
        values[valuesById[425] = "TE_ProjectedDecalId"] = 425;
        values[valuesById[426] = "TE_SmokeId"] = 426;
        return values;
    })();
    
    $root.CMsgTEArmorRicochet = (function() {
    
        /**
         * Properties of a CMsgTEArmorRicochet.
         * @exports ICMsgTEArmorRicochet
         * @interface ICMsgTEArmorRicochet
         * @property {ICMsgVector|null} [pos] CMsgTEArmorRicochet pos
         * @property {ICMsgVector|null} [dir] CMsgTEArmorRicochet dir
         */
    
        /**
         * Constructs a new CMsgTEArmorRicochet.
         * @exports CMsgTEArmorRicochet
         * @classdesc Represents a CMsgTEArmorRicochet.
         * @implements ICMsgTEArmorRicochet
         * @constructor
         * @param {ICMsgTEArmorRicochet=} [properties] Properties to set
         */
        function CMsgTEArmorRicochet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEArmorRicochet pos.
         * @member {ICMsgVector|null|undefined} pos
         * @memberof CMsgTEArmorRicochet
         * @instance
         */
        CMsgTEArmorRicochet.prototype.pos = null;
    
        /**
         * CMsgTEArmorRicochet dir.
         * @member {ICMsgVector|null|undefined} dir
         * @memberof CMsgTEArmorRicochet
         * @instance
         */
        CMsgTEArmorRicochet.prototype.dir = null;
    
        /**
         * Creates a new CMsgTEArmorRicochet instance using the specified properties.
         * @function create
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {ICMsgTEArmorRicochet=} [properties] Properties to set
         * @returns {CMsgTEArmorRicochet} CMsgTEArmorRicochet instance
         */
        CMsgTEArmorRicochet.create = function create(properties) {
            return new CMsgTEArmorRicochet(properties);
        };
    
        /**
         * Encodes the specified CMsgTEArmorRicochet message. Does not implicitly {@link CMsgTEArmorRicochet.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {ICMsgTEArmorRicochet} message CMsgTEArmorRicochet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEArmorRicochet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.CMsgVector.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                $root.CMsgVector.encode(message.dir, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEArmorRicochet message, length delimited. Does not implicitly {@link CMsgTEArmorRicochet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {ICMsgTEArmorRicochet} message CMsgTEArmorRicochet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEArmorRicochet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEArmorRicochet message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEArmorRicochet} CMsgTEArmorRicochet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEArmorRicochet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEArmorRicochet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.dir = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEArmorRicochet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEArmorRicochet} CMsgTEArmorRicochet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEArmorRicochet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEArmorRicochet message.
         * @function verify
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEArmorRicochet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.CMsgVector.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.dir != null && message.hasOwnProperty("dir")) {
                var error = $root.CMsgVector.verify(message.dir);
                if (error)
                    return "dir." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTEArmorRicochet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEArmorRicochet} CMsgTEArmorRicochet
         */
        CMsgTEArmorRicochet.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEArmorRicochet)
                return object;
            var message = new $root.CMsgTEArmorRicochet();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".CMsgTEArmorRicochet.pos: object expected");
                message.pos = $root.CMsgVector.fromObject(object.pos);
            }
            if (object.dir != null) {
                if (typeof object.dir !== "object")
                    throw TypeError(".CMsgTEArmorRicochet.dir: object expected");
                message.dir = $root.CMsgVector.fromObject(object.dir);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEArmorRicochet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEArmorRicochet
         * @static
         * @param {CMsgTEArmorRicochet} message CMsgTEArmorRicochet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEArmorRicochet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.dir = null;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.CMsgVector.toObject(message.pos, options);
            if (message.dir != null && message.hasOwnProperty("dir"))
                object.dir = $root.CMsgVector.toObject(message.dir, options);
            return object;
        };
    
        /**
         * Converts this CMsgTEArmorRicochet to JSON.
         * @function toJSON
         * @memberof CMsgTEArmorRicochet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEArmorRicochet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEArmorRicochet;
    })();
    
    $root.CMsgTEBaseBeam = (function() {
    
        /**
         * Properties of a CMsgTEBaseBeam.
         * @exports ICMsgTEBaseBeam
         * @interface ICMsgTEBaseBeam
         * @property {number|Long|null} [modelindex] CMsgTEBaseBeam modelindex
         * @property {number|Long|null} [haloindex] CMsgTEBaseBeam haloindex
         * @property {number|null} [startframe] CMsgTEBaseBeam startframe
         * @property {number|null} [framerate] CMsgTEBaseBeam framerate
         * @property {number|null} [life] CMsgTEBaseBeam life
         * @property {number|null} [width] CMsgTEBaseBeam width
         * @property {number|null} [endwidth] CMsgTEBaseBeam endwidth
         * @property {number|null} [fadelength] CMsgTEBaseBeam fadelength
         * @property {number|null} [amplitude] CMsgTEBaseBeam amplitude
         * @property {number|null} [color] CMsgTEBaseBeam color
         * @property {number|null} [speed] CMsgTEBaseBeam speed
         * @property {number|null} [flags] CMsgTEBaseBeam flags
         */
    
        /**
         * Constructs a new CMsgTEBaseBeam.
         * @exports CMsgTEBaseBeam
         * @classdesc Represents a CMsgTEBaseBeam.
         * @implements ICMsgTEBaseBeam
         * @constructor
         * @param {ICMsgTEBaseBeam=} [properties] Properties to set
         */
        function CMsgTEBaseBeam(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBaseBeam modelindex.
         * @member {number|Long} modelindex
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.modelindex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgTEBaseBeam haloindex.
         * @member {number|Long} haloindex
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.haloindex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgTEBaseBeam startframe.
         * @member {number} startframe
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.startframe = 0;
    
        /**
         * CMsgTEBaseBeam framerate.
         * @member {number} framerate
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.framerate = 0;
    
        /**
         * CMsgTEBaseBeam life.
         * @member {number} life
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.life = 0;
    
        /**
         * CMsgTEBaseBeam width.
         * @member {number} width
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.width = 0;
    
        /**
         * CMsgTEBaseBeam endwidth.
         * @member {number} endwidth
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.endwidth = 0;
    
        /**
         * CMsgTEBaseBeam fadelength.
         * @member {number} fadelength
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.fadelength = 0;
    
        /**
         * CMsgTEBaseBeam amplitude.
         * @member {number} amplitude
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.amplitude = 0;
    
        /**
         * CMsgTEBaseBeam color.
         * @member {number} color
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.color = 0;
    
        /**
         * CMsgTEBaseBeam speed.
         * @member {number} speed
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.speed = 0;
    
        /**
         * CMsgTEBaseBeam flags.
         * @member {number} flags
         * @memberof CMsgTEBaseBeam
         * @instance
         */
        CMsgTEBaseBeam.prototype.flags = 0;
    
        /**
         * Creates a new CMsgTEBaseBeam instance using the specified properties.
         * @function create
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {ICMsgTEBaseBeam=} [properties] Properties to set
         * @returns {CMsgTEBaseBeam} CMsgTEBaseBeam instance
         */
        CMsgTEBaseBeam.create = function create(properties) {
            return new CMsgTEBaseBeam(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBaseBeam message. Does not implicitly {@link CMsgTEBaseBeam.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {ICMsgTEBaseBeam} message CMsgTEBaseBeam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBaseBeam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.modelindex != null && Object.hasOwnProperty.call(message, "modelindex"))
                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.modelindex);
            if (message.haloindex != null && Object.hasOwnProperty.call(message, "haloindex"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.haloindex);
            if (message.startframe != null && Object.hasOwnProperty.call(message, "startframe"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.startframe);
            if (message.framerate != null && Object.hasOwnProperty.call(message, "framerate"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.framerate);
            if (message.life != null && Object.hasOwnProperty.call(message, "life"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.life);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.width);
            if (message.endwidth != null && Object.hasOwnProperty.call(message, "endwidth"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.endwidth);
            if (message.fadelength != null && Object.hasOwnProperty.call(message, "fadelength"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.fadelength);
            if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.amplitude);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.color);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.speed);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.flags);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBaseBeam message, length delimited. Does not implicitly {@link CMsgTEBaseBeam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {ICMsgTEBaseBeam} message CMsgTEBaseBeam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBaseBeam.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBaseBeam message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBaseBeam} CMsgTEBaseBeam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBaseBeam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBaseBeam();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.modelindex = reader.fixed64();
                    break;
                case 2:
                    message.haloindex = reader.fixed64();
                    break;
                case 3:
                    message.startframe = reader.uint32();
                    break;
                case 4:
                    message.framerate = reader.uint32();
                    break;
                case 5:
                    message.life = reader.float();
                    break;
                case 6:
                    message.width = reader.float();
                    break;
                case 7:
                    message.endwidth = reader.float();
                    break;
                case 8:
                    message.fadelength = reader.uint32();
                    break;
                case 9:
                    message.amplitude = reader.float();
                    break;
                case 10:
                    message.color = reader.fixed32();
                    break;
                case 11:
                    message.speed = reader.uint32();
                    break;
                case 12:
                    message.flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBaseBeam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBaseBeam} CMsgTEBaseBeam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBaseBeam.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBaseBeam message.
         * @function verify
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBaseBeam.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.modelindex != null && message.hasOwnProperty("modelindex"))
                if (!$util.isInteger(message.modelindex) && !(message.modelindex && $util.isInteger(message.modelindex.low) && $util.isInteger(message.modelindex.high)))
                    return "modelindex: integer|Long expected";
            if (message.haloindex != null && message.hasOwnProperty("haloindex"))
                if (!$util.isInteger(message.haloindex) && !(message.haloindex && $util.isInteger(message.haloindex.low) && $util.isInteger(message.haloindex.high)))
                    return "haloindex: integer|Long expected";
            if (message.startframe != null && message.hasOwnProperty("startframe"))
                if (!$util.isInteger(message.startframe))
                    return "startframe: integer expected";
            if (message.framerate != null && message.hasOwnProperty("framerate"))
                if (!$util.isInteger(message.framerate))
                    return "framerate: integer expected";
            if (message.life != null && message.hasOwnProperty("life"))
                if (typeof message.life !== "number")
                    return "life: number expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (typeof message.width !== "number")
                    return "width: number expected";
            if (message.endwidth != null && message.hasOwnProperty("endwidth"))
                if (typeof message.endwidth !== "number")
                    return "endwidth: number expected";
            if (message.fadelength != null && message.hasOwnProperty("fadelength"))
                if (!$util.isInteger(message.fadelength))
                    return "fadelength: integer expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBaseBeam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBaseBeam} CMsgTEBaseBeam
         */
        CMsgTEBaseBeam.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBaseBeam)
                return object;
            var message = new $root.CMsgTEBaseBeam();
            if (object.modelindex != null)
                if ($util.Long)
                    (message.modelindex = $util.Long.fromValue(object.modelindex)).unsigned = false;
                else if (typeof object.modelindex === "string")
                    message.modelindex = parseInt(object.modelindex, 10);
                else if (typeof object.modelindex === "number")
                    message.modelindex = object.modelindex;
                else if (typeof object.modelindex === "object")
                    message.modelindex = new $util.LongBits(object.modelindex.low >>> 0, object.modelindex.high >>> 0).toNumber();
            if (object.haloindex != null)
                if ($util.Long)
                    (message.haloindex = $util.Long.fromValue(object.haloindex)).unsigned = false;
                else if (typeof object.haloindex === "string")
                    message.haloindex = parseInt(object.haloindex, 10);
                else if (typeof object.haloindex === "number")
                    message.haloindex = object.haloindex;
                else if (typeof object.haloindex === "object")
                    message.haloindex = new $util.LongBits(object.haloindex.low >>> 0, object.haloindex.high >>> 0).toNumber();
            if (object.startframe != null)
                message.startframe = object.startframe >>> 0;
            if (object.framerate != null)
                message.framerate = object.framerate >>> 0;
            if (object.life != null)
                message.life = Number(object.life);
            if (object.width != null)
                message.width = Number(object.width);
            if (object.endwidth != null)
                message.endwidth = Number(object.endwidth);
            if (object.fadelength != null)
                message.fadelength = object.fadelength >>> 0;
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBaseBeam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBaseBeam
         * @static
         * @param {CMsgTEBaseBeam} message CMsgTEBaseBeam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBaseBeam.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.modelindex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.modelindex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.haloindex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.haloindex = options.longs === String ? "0" : 0;
                object.startframe = 0;
                object.framerate = 0;
                object.life = 0;
                object.width = 0;
                object.endwidth = 0;
                object.fadelength = 0;
                object.amplitude = 0;
                object.color = 0;
                object.speed = 0;
                object.flags = 0;
            }
            if (message.modelindex != null && message.hasOwnProperty("modelindex"))
                if (typeof message.modelindex === "number")
                    object.modelindex = options.longs === String ? String(message.modelindex) : message.modelindex;
                else
                    object.modelindex = options.longs === String ? $util.Long.prototype.toString.call(message.modelindex) : options.longs === Number ? new $util.LongBits(message.modelindex.low >>> 0, message.modelindex.high >>> 0).toNumber() : message.modelindex;
            if (message.haloindex != null && message.hasOwnProperty("haloindex"))
                if (typeof message.haloindex === "number")
                    object.haloindex = options.longs === String ? String(message.haloindex) : message.haloindex;
                else
                    object.haloindex = options.longs === String ? $util.Long.prototype.toString.call(message.haloindex) : options.longs === Number ? new $util.LongBits(message.haloindex.low >>> 0, message.haloindex.high >>> 0).toNumber() : message.haloindex;
            if (message.startframe != null && message.hasOwnProperty("startframe"))
                object.startframe = message.startframe;
            if (message.framerate != null && message.hasOwnProperty("framerate"))
                object.framerate = message.framerate;
            if (message.life != null && message.hasOwnProperty("life"))
                object.life = options.json && !isFinite(message.life) ? String(message.life) : message.life;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
            if (message.endwidth != null && message.hasOwnProperty("endwidth"))
                object.endwidth = options.json && !isFinite(message.endwidth) ? String(message.endwidth) : message.endwidth;
            if (message.fadelength != null && message.hasOwnProperty("fadelength"))
                object.fadelength = message.fadelength;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };
    
        /**
         * Converts this CMsgTEBaseBeam to JSON.
         * @function toJSON
         * @memberof CMsgTEBaseBeam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBaseBeam.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBaseBeam;
    })();
    
    $root.CMsgTEBeamEntPoint = (function() {
    
        /**
         * Properties of a CMsgTEBeamEntPoint.
         * @exports ICMsgTEBeamEntPoint
         * @interface ICMsgTEBeamEntPoint
         * @property {ICMsgTEBaseBeam|null} [base] CMsgTEBeamEntPoint base
         * @property {number|null} [startentity] CMsgTEBeamEntPoint startentity
         * @property {number|null} [endentity] CMsgTEBeamEntPoint endentity
         * @property {ICMsgVector|null} [start] CMsgTEBeamEntPoint start
         * @property {ICMsgVector|null} [end] CMsgTEBeamEntPoint end
         */
    
        /**
         * Constructs a new CMsgTEBeamEntPoint.
         * @exports CMsgTEBeamEntPoint
         * @classdesc Represents a CMsgTEBeamEntPoint.
         * @implements ICMsgTEBeamEntPoint
         * @constructor
         * @param {ICMsgTEBeamEntPoint=} [properties] Properties to set
         */
        function CMsgTEBeamEntPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBeamEntPoint base.
         * @member {ICMsgTEBaseBeam|null|undefined} base
         * @memberof CMsgTEBeamEntPoint
         * @instance
         */
        CMsgTEBeamEntPoint.prototype.base = null;
    
        /**
         * CMsgTEBeamEntPoint startentity.
         * @member {number} startentity
         * @memberof CMsgTEBeamEntPoint
         * @instance
         */
        CMsgTEBeamEntPoint.prototype.startentity = 0;
    
        /**
         * CMsgTEBeamEntPoint endentity.
         * @member {number} endentity
         * @memberof CMsgTEBeamEntPoint
         * @instance
         */
        CMsgTEBeamEntPoint.prototype.endentity = 0;
    
        /**
         * CMsgTEBeamEntPoint start.
         * @member {ICMsgVector|null|undefined} start
         * @memberof CMsgTEBeamEntPoint
         * @instance
         */
        CMsgTEBeamEntPoint.prototype.start = null;
    
        /**
         * CMsgTEBeamEntPoint end.
         * @member {ICMsgVector|null|undefined} end
         * @memberof CMsgTEBeamEntPoint
         * @instance
         */
        CMsgTEBeamEntPoint.prototype.end = null;
    
        /**
         * Creates a new CMsgTEBeamEntPoint instance using the specified properties.
         * @function create
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {ICMsgTEBeamEntPoint=} [properties] Properties to set
         * @returns {CMsgTEBeamEntPoint} CMsgTEBeamEntPoint instance
         */
        CMsgTEBeamEntPoint.create = function create(properties) {
            return new CMsgTEBeamEntPoint(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBeamEntPoint message. Does not implicitly {@link CMsgTEBeamEntPoint.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {ICMsgTEBeamEntPoint} message CMsgTEBeamEntPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamEntPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.CMsgTEBaseBeam.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.startentity != null && Object.hasOwnProperty.call(message, "startentity"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.startentity);
            if (message.endentity != null && Object.hasOwnProperty.call(message, "endentity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.endentity);
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                $root.CMsgVector.encode(message.start, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                $root.CMsgVector.encode(message.end, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBeamEntPoint message, length delimited. Does not implicitly {@link CMsgTEBeamEntPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {ICMsgTEBeamEntPoint} message CMsgTEBeamEntPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamEntPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBeamEntPoint message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBeamEntPoint} CMsgTEBeamEntPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamEntPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBeamEntPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.CMsgTEBaseBeam.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.startentity = reader.uint32();
                    break;
                case 3:
                    message.endentity = reader.uint32();
                    break;
                case 4:
                    message.start = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.end = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBeamEntPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBeamEntPoint} CMsgTEBeamEntPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamEntPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBeamEntPoint message.
         * @function verify
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBeamEntPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.base != null && message.hasOwnProperty("base")) {
                var error = $root.CMsgTEBaseBeam.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.startentity != null && message.hasOwnProperty("startentity"))
                if (!$util.isInteger(message.startentity))
                    return "startentity: integer expected";
            if (message.endentity != null && message.hasOwnProperty("endentity"))
                if (!$util.isInteger(message.endentity))
                    return "endentity: integer expected";
            if (message.start != null && message.hasOwnProperty("start")) {
                var error = $root.CMsgVector.verify(message.start);
                if (error)
                    return "start." + error;
            }
            if (message.end != null && message.hasOwnProperty("end")) {
                var error = $root.CMsgVector.verify(message.end);
                if (error)
                    return "end." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTEBeamEntPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBeamEntPoint} CMsgTEBeamEntPoint
         */
        CMsgTEBeamEntPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBeamEntPoint)
                return object;
            var message = new $root.CMsgTEBeamEntPoint();
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".CMsgTEBeamEntPoint.base: object expected");
                message.base = $root.CMsgTEBaseBeam.fromObject(object.base);
            }
            if (object.startentity != null)
                message.startentity = object.startentity >>> 0;
            if (object.endentity != null)
                message.endentity = object.endentity >>> 0;
            if (object.start != null) {
                if (typeof object.start !== "object")
                    throw TypeError(".CMsgTEBeamEntPoint.start: object expected");
                message.start = $root.CMsgVector.fromObject(object.start);
            }
            if (object.end != null) {
                if (typeof object.end !== "object")
                    throw TypeError(".CMsgTEBeamEntPoint.end: object expected");
                message.end = $root.CMsgVector.fromObject(object.end);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBeamEntPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBeamEntPoint
         * @static
         * @param {CMsgTEBeamEntPoint} message CMsgTEBeamEntPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBeamEntPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.base = null;
                object.startentity = 0;
                object.endentity = 0;
                object.start = null;
                object.end = null;
            }
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.CMsgTEBaseBeam.toObject(message.base, options);
            if (message.startentity != null && message.hasOwnProperty("startentity"))
                object.startentity = message.startentity;
            if (message.endentity != null && message.hasOwnProperty("endentity"))
                object.endentity = message.endentity;
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = $root.CMsgVector.toObject(message.start, options);
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = $root.CMsgVector.toObject(message.end, options);
            return object;
        };
    
        /**
         * Converts this CMsgTEBeamEntPoint to JSON.
         * @function toJSON
         * @memberof CMsgTEBeamEntPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBeamEntPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBeamEntPoint;
    })();
    
    $root.CMsgTEBeamEnts = (function() {
    
        /**
         * Properties of a CMsgTEBeamEnts.
         * @exports ICMsgTEBeamEnts
         * @interface ICMsgTEBeamEnts
         * @property {ICMsgTEBaseBeam|null} [base] CMsgTEBeamEnts base
         * @property {number|null} [startentity] CMsgTEBeamEnts startentity
         * @property {number|null} [endentity] CMsgTEBeamEnts endentity
         */
    
        /**
         * Constructs a new CMsgTEBeamEnts.
         * @exports CMsgTEBeamEnts
         * @classdesc Represents a CMsgTEBeamEnts.
         * @implements ICMsgTEBeamEnts
         * @constructor
         * @param {ICMsgTEBeamEnts=} [properties] Properties to set
         */
        function CMsgTEBeamEnts(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBeamEnts base.
         * @member {ICMsgTEBaseBeam|null|undefined} base
         * @memberof CMsgTEBeamEnts
         * @instance
         */
        CMsgTEBeamEnts.prototype.base = null;
    
        /**
         * CMsgTEBeamEnts startentity.
         * @member {number} startentity
         * @memberof CMsgTEBeamEnts
         * @instance
         */
        CMsgTEBeamEnts.prototype.startentity = 0;
    
        /**
         * CMsgTEBeamEnts endentity.
         * @member {number} endentity
         * @memberof CMsgTEBeamEnts
         * @instance
         */
        CMsgTEBeamEnts.prototype.endentity = 0;
    
        /**
         * Creates a new CMsgTEBeamEnts instance using the specified properties.
         * @function create
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {ICMsgTEBeamEnts=} [properties] Properties to set
         * @returns {CMsgTEBeamEnts} CMsgTEBeamEnts instance
         */
        CMsgTEBeamEnts.create = function create(properties) {
            return new CMsgTEBeamEnts(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBeamEnts message. Does not implicitly {@link CMsgTEBeamEnts.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {ICMsgTEBeamEnts} message CMsgTEBeamEnts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamEnts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.CMsgTEBaseBeam.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.startentity != null && Object.hasOwnProperty.call(message, "startentity"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.startentity);
            if (message.endentity != null && Object.hasOwnProperty.call(message, "endentity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.endentity);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBeamEnts message, length delimited. Does not implicitly {@link CMsgTEBeamEnts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {ICMsgTEBeamEnts} message CMsgTEBeamEnts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamEnts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBeamEnts message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBeamEnts} CMsgTEBeamEnts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamEnts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBeamEnts();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.CMsgTEBaseBeam.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.startentity = reader.uint32();
                    break;
                case 3:
                    message.endentity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBeamEnts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBeamEnts} CMsgTEBeamEnts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamEnts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBeamEnts message.
         * @function verify
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBeamEnts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.base != null && message.hasOwnProperty("base")) {
                var error = $root.CMsgTEBaseBeam.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.startentity != null && message.hasOwnProperty("startentity"))
                if (!$util.isInteger(message.startentity))
                    return "startentity: integer expected";
            if (message.endentity != null && message.hasOwnProperty("endentity"))
                if (!$util.isInteger(message.endentity))
                    return "endentity: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBeamEnts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBeamEnts} CMsgTEBeamEnts
         */
        CMsgTEBeamEnts.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBeamEnts)
                return object;
            var message = new $root.CMsgTEBeamEnts();
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".CMsgTEBeamEnts.base: object expected");
                message.base = $root.CMsgTEBaseBeam.fromObject(object.base);
            }
            if (object.startentity != null)
                message.startentity = object.startentity >>> 0;
            if (object.endentity != null)
                message.endentity = object.endentity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBeamEnts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBeamEnts
         * @static
         * @param {CMsgTEBeamEnts} message CMsgTEBeamEnts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBeamEnts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.base = null;
                object.startentity = 0;
                object.endentity = 0;
            }
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.CMsgTEBaseBeam.toObject(message.base, options);
            if (message.startentity != null && message.hasOwnProperty("startentity"))
                object.startentity = message.startentity;
            if (message.endentity != null && message.hasOwnProperty("endentity"))
                object.endentity = message.endentity;
            return object;
        };
    
        /**
         * Converts this CMsgTEBeamEnts to JSON.
         * @function toJSON
         * @memberof CMsgTEBeamEnts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBeamEnts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBeamEnts;
    })();
    
    $root.CMsgTEBeamPoints = (function() {
    
        /**
         * Properties of a CMsgTEBeamPoints.
         * @exports ICMsgTEBeamPoints
         * @interface ICMsgTEBeamPoints
         * @property {ICMsgTEBaseBeam|null} [base] CMsgTEBeamPoints base
         * @property {ICMsgVector|null} [start] CMsgTEBeamPoints start
         * @property {ICMsgVector|null} [end] CMsgTEBeamPoints end
         */
    
        /**
         * Constructs a new CMsgTEBeamPoints.
         * @exports CMsgTEBeamPoints
         * @classdesc Represents a CMsgTEBeamPoints.
         * @implements ICMsgTEBeamPoints
         * @constructor
         * @param {ICMsgTEBeamPoints=} [properties] Properties to set
         */
        function CMsgTEBeamPoints(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBeamPoints base.
         * @member {ICMsgTEBaseBeam|null|undefined} base
         * @memberof CMsgTEBeamPoints
         * @instance
         */
        CMsgTEBeamPoints.prototype.base = null;
    
        /**
         * CMsgTEBeamPoints start.
         * @member {ICMsgVector|null|undefined} start
         * @memberof CMsgTEBeamPoints
         * @instance
         */
        CMsgTEBeamPoints.prototype.start = null;
    
        /**
         * CMsgTEBeamPoints end.
         * @member {ICMsgVector|null|undefined} end
         * @memberof CMsgTEBeamPoints
         * @instance
         */
        CMsgTEBeamPoints.prototype.end = null;
    
        /**
         * Creates a new CMsgTEBeamPoints instance using the specified properties.
         * @function create
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {ICMsgTEBeamPoints=} [properties] Properties to set
         * @returns {CMsgTEBeamPoints} CMsgTEBeamPoints instance
         */
        CMsgTEBeamPoints.create = function create(properties) {
            return new CMsgTEBeamPoints(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBeamPoints message. Does not implicitly {@link CMsgTEBeamPoints.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {ICMsgTEBeamPoints} message CMsgTEBeamPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamPoints.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.CMsgTEBaseBeam.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                $root.CMsgVector.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                $root.CMsgVector.encode(message.end, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBeamPoints message, length delimited. Does not implicitly {@link CMsgTEBeamPoints.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {ICMsgTEBeamPoints} message CMsgTEBeamPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamPoints.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBeamPoints message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBeamPoints} CMsgTEBeamPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamPoints.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBeamPoints();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.CMsgTEBaseBeam.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.start = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.end = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBeamPoints message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBeamPoints} CMsgTEBeamPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamPoints.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBeamPoints message.
         * @function verify
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBeamPoints.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.base != null && message.hasOwnProperty("base")) {
                var error = $root.CMsgTEBaseBeam.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.start != null && message.hasOwnProperty("start")) {
                var error = $root.CMsgVector.verify(message.start);
                if (error)
                    return "start." + error;
            }
            if (message.end != null && message.hasOwnProperty("end")) {
                var error = $root.CMsgVector.verify(message.end);
                if (error)
                    return "end." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTEBeamPoints message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBeamPoints} CMsgTEBeamPoints
         */
        CMsgTEBeamPoints.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBeamPoints)
                return object;
            var message = new $root.CMsgTEBeamPoints();
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".CMsgTEBeamPoints.base: object expected");
                message.base = $root.CMsgTEBaseBeam.fromObject(object.base);
            }
            if (object.start != null) {
                if (typeof object.start !== "object")
                    throw TypeError(".CMsgTEBeamPoints.start: object expected");
                message.start = $root.CMsgVector.fromObject(object.start);
            }
            if (object.end != null) {
                if (typeof object.end !== "object")
                    throw TypeError(".CMsgTEBeamPoints.end: object expected");
                message.end = $root.CMsgVector.fromObject(object.end);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBeamPoints message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBeamPoints
         * @static
         * @param {CMsgTEBeamPoints} message CMsgTEBeamPoints
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBeamPoints.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.base = null;
                object.start = null;
                object.end = null;
            }
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.CMsgTEBaseBeam.toObject(message.base, options);
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = $root.CMsgVector.toObject(message.start, options);
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = $root.CMsgVector.toObject(message.end, options);
            return object;
        };
    
        /**
         * Converts this CMsgTEBeamPoints to JSON.
         * @function toJSON
         * @memberof CMsgTEBeamPoints
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBeamPoints.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBeamPoints;
    })();
    
    $root.CMsgTEBeamRing = (function() {
    
        /**
         * Properties of a CMsgTEBeamRing.
         * @exports ICMsgTEBeamRing
         * @interface ICMsgTEBeamRing
         * @property {ICMsgTEBaseBeam|null} [base] CMsgTEBeamRing base
         * @property {number|null} [startentity] CMsgTEBeamRing startentity
         * @property {number|null} [endentity] CMsgTEBeamRing endentity
         */
    
        /**
         * Constructs a new CMsgTEBeamRing.
         * @exports CMsgTEBeamRing
         * @classdesc Represents a CMsgTEBeamRing.
         * @implements ICMsgTEBeamRing
         * @constructor
         * @param {ICMsgTEBeamRing=} [properties] Properties to set
         */
        function CMsgTEBeamRing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBeamRing base.
         * @member {ICMsgTEBaseBeam|null|undefined} base
         * @memberof CMsgTEBeamRing
         * @instance
         */
        CMsgTEBeamRing.prototype.base = null;
    
        /**
         * CMsgTEBeamRing startentity.
         * @member {number} startentity
         * @memberof CMsgTEBeamRing
         * @instance
         */
        CMsgTEBeamRing.prototype.startentity = 0;
    
        /**
         * CMsgTEBeamRing endentity.
         * @member {number} endentity
         * @memberof CMsgTEBeamRing
         * @instance
         */
        CMsgTEBeamRing.prototype.endentity = 0;
    
        /**
         * Creates a new CMsgTEBeamRing instance using the specified properties.
         * @function create
         * @memberof CMsgTEBeamRing
         * @static
         * @param {ICMsgTEBeamRing=} [properties] Properties to set
         * @returns {CMsgTEBeamRing} CMsgTEBeamRing instance
         */
        CMsgTEBeamRing.create = function create(properties) {
            return new CMsgTEBeamRing(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBeamRing message. Does not implicitly {@link CMsgTEBeamRing.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBeamRing
         * @static
         * @param {ICMsgTEBeamRing} message CMsgTEBeamRing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamRing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.CMsgTEBaseBeam.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.startentity != null && Object.hasOwnProperty.call(message, "startentity"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.startentity);
            if (message.endentity != null && Object.hasOwnProperty.call(message, "endentity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.endentity);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBeamRing message, length delimited. Does not implicitly {@link CMsgTEBeamRing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBeamRing
         * @static
         * @param {ICMsgTEBeamRing} message CMsgTEBeamRing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBeamRing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBeamRing message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBeamRing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBeamRing} CMsgTEBeamRing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamRing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBeamRing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.CMsgTEBaseBeam.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.startentity = reader.uint32();
                    break;
                case 3:
                    message.endentity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBeamRing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBeamRing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBeamRing} CMsgTEBeamRing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBeamRing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBeamRing message.
         * @function verify
         * @memberof CMsgTEBeamRing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBeamRing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.base != null && message.hasOwnProperty("base")) {
                var error = $root.CMsgTEBaseBeam.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.startentity != null && message.hasOwnProperty("startentity"))
                if (!$util.isInteger(message.startentity))
                    return "startentity: integer expected";
            if (message.endentity != null && message.hasOwnProperty("endentity"))
                if (!$util.isInteger(message.endentity))
                    return "endentity: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBeamRing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBeamRing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBeamRing} CMsgTEBeamRing
         */
        CMsgTEBeamRing.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBeamRing)
                return object;
            var message = new $root.CMsgTEBeamRing();
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".CMsgTEBeamRing.base: object expected");
                message.base = $root.CMsgTEBaseBeam.fromObject(object.base);
            }
            if (object.startentity != null)
                message.startentity = object.startentity >>> 0;
            if (object.endentity != null)
                message.endentity = object.endentity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBeamRing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBeamRing
         * @static
         * @param {CMsgTEBeamRing} message CMsgTEBeamRing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBeamRing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.base = null;
                object.startentity = 0;
                object.endentity = 0;
            }
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.CMsgTEBaseBeam.toObject(message.base, options);
            if (message.startentity != null && message.hasOwnProperty("startentity"))
                object.startentity = message.startentity;
            if (message.endentity != null && message.hasOwnProperty("endentity"))
                object.endentity = message.endentity;
            return object;
        };
    
        /**
         * Converts this CMsgTEBeamRing to JSON.
         * @function toJSON
         * @memberof CMsgTEBeamRing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBeamRing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBeamRing;
    })();
    
    $root.CMsgTEBSPDecal = (function() {
    
        /**
         * Properties of a CMsgTEBSPDecal.
         * @exports ICMsgTEBSPDecal
         * @interface ICMsgTEBSPDecal
         * @property {ICMsgVector|null} [origin] CMsgTEBSPDecal origin
         * @property {ICMsgVector|null} [normal] CMsgTEBSPDecal normal
         * @property {ICMsgVector|null} [saxis] CMsgTEBSPDecal saxis
         * @property {number|null} [entity] CMsgTEBSPDecal entity
         * @property {number|null} [index] CMsgTEBSPDecal index
         */
    
        /**
         * Constructs a new CMsgTEBSPDecal.
         * @exports CMsgTEBSPDecal
         * @classdesc Represents a CMsgTEBSPDecal.
         * @implements ICMsgTEBSPDecal
         * @constructor
         * @param {ICMsgTEBSPDecal=} [properties] Properties to set
         */
        function CMsgTEBSPDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBSPDecal origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEBSPDecal
         * @instance
         */
        CMsgTEBSPDecal.prototype.origin = null;
    
        /**
         * CMsgTEBSPDecal normal.
         * @member {ICMsgVector|null|undefined} normal
         * @memberof CMsgTEBSPDecal
         * @instance
         */
        CMsgTEBSPDecal.prototype.normal = null;
    
        /**
         * CMsgTEBSPDecal saxis.
         * @member {ICMsgVector|null|undefined} saxis
         * @memberof CMsgTEBSPDecal
         * @instance
         */
        CMsgTEBSPDecal.prototype.saxis = null;
    
        /**
         * CMsgTEBSPDecal entity.
         * @member {number} entity
         * @memberof CMsgTEBSPDecal
         * @instance
         */
        CMsgTEBSPDecal.prototype.entity = 0;
    
        /**
         * CMsgTEBSPDecal index.
         * @member {number} index
         * @memberof CMsgTEBSPDecal
         * @instance
         */
        CMsgTEBSPDecal.prototype.index = 0;
    
        /**
         * Creates a new CMsgTEBSPDecal instance using the specified properties.
         * @function create
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {ICMsgTEBSPDecal=} [properties] Properties to set
         * @returns {CMsgTEBSPDecal} CMsgTEBSPDecal instance
         */
        CMsgTEBSPDecal.create = function create(properties) {
            return new CMsgTEBSPDecal(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBSPDecal message. Does not implicitly {@link CMsgTEBSPDecal.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {ICMsgTEBSPDecal} message CMsgTEBSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBSPDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.normal != null && Object.hasOwnProperty.call(message, "normal"))
                $root.CMsgVector.encode(message.normal, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.saxis != null && Object.hasOwnProperty.call(message, "saxis"))
                $root.CMsgVector.encode(message.saxis, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.entity);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.index);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBSPDecal message, length delimited. Does not implicitly {@link CMsgTEBSPDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {ICMsgTEBSPDecal} message CMsgTEBSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBSPDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBSPDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBSPDecal} CMsgTEBSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBSPDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBSPDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.normal = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.saxis = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.entity = reader.uint32();
                    break;
                case 5:
                    message.index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBSPDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBSPDecal} CMsgTEBSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBSPDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBSPDecal message.
         * @function verify
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBSPDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.normal != null && message.hasOwnProperty("normal")) {
                var error = $root.CMsgVector.verify(message.normal);
                if (error)
                    return "normal." + error;
            }
            if (message.saxis != null && message.hasOwnProperty("saxis")) {
                var error = $root.CMsgVector.verify(message.saxis);
                if (error)
                    return "saxis." + error;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBSPDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBSPDecal} CMsgTEBSPDecal
         */
        CMsgTEBSPDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBSPDecal)
                return object;
            var message = new $root.CMsgTEBSPDecal();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEBSPDecal.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.normal != null) {
                if (typeof object.normal !== "object")
                    throw TypeError(".CMsgTEBSPDecal.normal: object expected");
                message.normal = $root.CMsgVector.fromObject(object.normal);
            }
            if (object.saxis != null) {
                if (typeof object.saxis !== "object")
                    throw TypeError(".CMsgTEBSPDecal.saxis: object expected");
                message.saxis = $root.CMsgVector.fromObject(object.saxis);
            }
            if (object.entity != null)
                message.entity = object.entity >>> 0;
            if (object.index != null)
                message.index = object.index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBSPDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBSPDecal
         * @static
         * @param {CMsgTEBSPDecal} message CMsgTEBSPDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBSPDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.normal = null;
                object.saxis = null;
                object.entity = 0;
                object.index = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = $root.CMsgVector.toObject(message.normal, options);
            if (message.saxis != null && message.hasOwnProperty("saxis"))
                object.saxis = $root.CMsgVector.toObject(message.saxis, options);
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };
    
        /**
         * Converts this CMsgTEBSPDecal to JSON.
         * @function toJSON
         * @memberof CMsgTEBSPDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBSPDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBSPDecal;
    })();
    
    $root.CMsgTEBubbles = (function() {
    
        /**
         * Properties of a CMsgTEBubbles.
         * @exports ICMsgTEBubbles
         * @interface ICMsgTEBubbles
         * @property {ICMsgVector|null} [mins] CMsgTEBubbles mins
         * @property {ICMsgVector|null} [maxs] CMsgTEBubbles maxs
         * @property {number|null} [height] CMsgTEBubbles height
         * @property {number|null} [count] CMsgTEBubbles count
         * @property {number|null} [speed] CMsgTEBubbles speed
         */
    
        /**
         * Constructs a new CMsgTEBubbles.
         * @exports CMsgTEBubbles
         * @classdesc Represents a CMsgTEBubbles.
         * @implements ICMsgTEBubbles
         * @constructor
         * @param {ICMsgTEBubbles=} [properties] Properties to set
         */
        function CMsgTEBubbles(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBubbles mins.
         * @member {ICMsgVector|null|undefined} mins
         * @memberof CMsgTEBubbles
         * @instance
         */
        CMsgTEBubbles.prototype.mins = null;
    
        /**
         * CMsgTEBubbles maxs.
         * @member {ICMsgVector|null|undefined} maxs
         * @memberof CMsgTEBubbles
         * @instance
         */
        CMsgTEBubbles.prototype.maxs = null;
    
        /**
         * CMsgTEBubbles height.
         * @member {number} height
         * @memberof CMsgTEBubbles
         * @instance
         */
        CMsgTEBubbles.prototype.height = 0;
    
        /**
         * CMsgTEBubbles count.
         * @member {number} count
         * @memberof CMsgTEBubbles
         * @instance
         */
        CMsgTEBubbles.prototype.count = 0;
    
        /**
         * CMsgTEBubbles speed.
         * @member {number} speed
         * @memberof CMsgTEBubbles
         * @instance
         */
        CMsgTEBubbles.prototype.speed = 0;
    
        /**
         * Creates a new CMsgTEBubbles instance using the specified properties.
         * @function create
         * @memberof CMsgTEBubbles
         * @static
         * @param {ICMsgTEBubbles=} [properties] Properties to set
         * @returns {CMsgTEBubbles} CMsgTEBubbles instance
         */
        CMsgTEBubbles.create = function create(properties) {
            return new CMsgTEBubbles(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBubbles message. Does not implicitly {@link CMsgTEBubbles.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBubbles
         * @static
         * @param {ICMsgTEBubbles} message CMsgTEBubbles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBubbles.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mins != null && Object.hasOwnProperty.call(message, "mins"))
                $root.CMsgVector.encode(message.mins, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.maxs != null && Object.hasOwnProperty.call(message, "maxs"))
                $root.CMsgVector.encode(message.maxs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.height);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.count);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.speed);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBubbles message, length delimited. Does not implicitly {@link CMsgTEBubbles.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBubbles
         * @static
         * @param {ICMsgTEBubbles} message CMsgTEBubbles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBubbles.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBubbles message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBubbles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBubbles} CMsgTEBubbles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBubbles.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBubbles();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mins = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxs = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.height = reader.float();
                    break;
                case 4:
                    message.count = reader.uint32();
                    break;
                case 5:
                    message.speed = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBubbles message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBubbles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBubbles} CMsgTEBubbles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBubbles.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBubbles message.
         * @function verify
         * @memberof CMsgTEBubbles
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBubbles.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mins != null && message.hasOwnProperty("mins")) {
                var error = $root.CMsgVector.verify(message.mins);
                if (error)
                    return "mins." + error;
            }
            if (message.maxs != null && message.hasOwnProperty("maxs")) {
                var error = $root.CMsgVector.verify(message.maxs);
                if (error)
                    return "maxs." + error;
            }
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (typeof message.speed !== "number")
                    return "speed: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBubbles message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBubbles
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBubbles} CMsgTEBubbles
         */
        CMsgTEBubbles.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBubbles)
                return object;
            var message = new $root.CMsgTEBubbles();
            if (object.mins != null) {
                if (typeof object.mins !== "object")
                    throw TypeError(".CMsgTEBubbles.mins: object expected");
                message.mins = $root.CMsgVector.fromObject(object.mins);
            }
            if (object.maxs != null) {
                if (typeof object.maxs !== "object")
                    throw TypeError(".CMsgTEBubbles.maxs: object expected");
                message.maxs = $root.CMsgVector.fromObject(object.maxs);
            }
            if (object.height != null)
                message.height = Number(object.height);
            if (object.count != null)
                message.count = object.count >>> 0;
            if (object.speed != null)
                message.speed = Number(object.speed);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBubbles message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBubbles
         * @static
         * @param {CMsgTEBubbles} message CMsgTEBubbles
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBubbles.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mins = null;
                object.maxs = null;
                object.height = 0;
                object.count = 0;
                object.speed = 0;
            }
            if (message.mins != null && message.hasOwnProperty("mins"))
                object.mins = $root.CMsgVector.toObject(message.mins, options);
            if (message.maxs != null && message.hasOwnProperty("maxs"))
                object.maxs = $root.CMsgVector.toObject(message.maxs, options);
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
            return object;
        };
    
        /**
         * Converts this CMsgTEBubbles to JSON.
         * @function toJSON
         * @memberof CMsgTEBubbles
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBubbles.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBubbles;
    })();
    
    $root.CMsgTEBubbleTrail = (function() {
    
        /**
         * Properties of a CMsgTEBubbleTrail.
         * @exports ICMsgTEBubbleTrail
         * @interface ICMsgTEBubbleTrail
         * @property {ICMsgVector|null} [mins] CMsgTEBubbleTrail mins
         * @property {ICMsgVector|null} [maxs] CMsgTEBubbleTrail maxs
         * @property {number|null} [waterz] CMsgTEBubbleTrail waterz
         * @property {number|null} [count] CMsgTEBubbleTrail count
         * @property {number|null} [speed] CMsgTEBubbleTrail speed
         */
    
        /**
         * Constructs a new CMsgTEBubbleTrail.
         * @exports CMsgTEBubbleTrail
         * @classdesc Represents a CMsgTEBubbleTrail.
         * @implements ICMsgTEBubbleTrail
         * @constructor
         * @param {ICMsgTEBubbleTrail=} [properties] Properties to set
         */
        function CMsgTEBubbleTrail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBubbleTrail mins.
         * @member {ICMsgVector|null|undefined} mins
         * @memberof CMsgTEBubbleTrail
         * @instance
         */
        CMsgTEBubbleTrail.prototype.mins = null;
    
        /**
         * CMsgTEBubbleTrail maxs.
         * @member {ICMsgVector|null|undefined} maxs
         * @memberof CMsgTEBubbleTrail
         * @instance
         */
        CMsgTEBubbleTrail.prototype.maxs = null;
    
        /**
         * CMsgTEBubbleTrail waterz.
         * @member {number} waterz
         * @memberof CMsgTEBubbleTrail
         * @instance
         */
        CMsgTEBubbleTrail.prototype.waterz = 0;
    
        /**
         * CMsgTEBubbleTrail count.
         * @member {number} count
         * @memberof CMsgTEBubbleTrail
         * @instance
         */
        CMsgTEBubbleTrail.prototype.count = 0;
    
        /**
         * CMsgTEBubbleTrail speed.
         * @member {number} speed
         * @memberof CMsgTEBubbleTrail
         * @instance
         */
        CMsgTEBubbleTrail.prototype.speed = 0;
    
        /**
         * Creates a new CMsgTEBubbleTrail instance using the specified properties.
         * @function create
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {ICMsgTEBubbleTrail=} [properties] Properties to set
         * @returns {CMsgTEBubbleTrail} CMsgTEBubbleTrail instance
         */
        CMsgTEBubbleTrail.create = function create(properties) {
            return new CMsgTEBubbleTrail(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBubbleTrail message. Does not implicitly {@link CMsgTEBubbleTrail.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {ICMsgTEBubbleTrail} message CMsgTEBubbleTrail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBubbleTrail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mins != null && Object.hasOwnProperty.call(message, "mins"))
                $root.CMsgVector.encode(message.mins, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.maxs != null && Object.hasOwnProperty.call(message, "maxs"))
                $root.CMsgVector.encode(message.maxs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.waterz != null && Object.hasOwnProperty.call(message, "waterz"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.waterz);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.count);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.speed);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBubbleTrail message, length delimited. Does not implicitly {@link CMsgTEBubbleTrail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {ICMsgTEBubbleTrail} message CMsgTEBubbleTrail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBubbleTrail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBubbleTrail message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBubbleTrail} CMsgTEBubbleTrail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBubbleTrail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBubbleTrail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mins = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxs = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.waterz = reader.float();
                    break;
                case 4:
                    message.count = reader.uint32();
                    break;
                case 5:
                    message.speed = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBubbleTrail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBubbleTrail} CMsgTEBubbleTrail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBubbleTrail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBubbleTrail message.
         * @function verify
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBubbleTrail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mins != null && message.hasOwnProperty("mins")) {
                var error = $root.CMsgVector.verify(message.mins);
                if (error)
                    return "mins." + error;
            }
            if (message.maxs != null && message.hasOwnProperty("maxs")) {
                var error = $root.CMsgVector.verify(message.maxs);
                if (error)
                    return "maxs." + error;
            }
            if (message.waterz != null && message.hasOwnProperty("waterz"))
                if (typeof message.waterz !== "number")
                    return "waterz: number expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (typeof message.speed !== "number")
                    return "speed: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBubbleTrail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBubbleTrail} CMsgTEBubbleTrail
         */
        CMsgTEBubbleTrail.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBubbleTrail)
                return object;
            var message = new $root.CMsgTEBubbleTrail();
            if (object.mins != null) {
                if (typeof object.mins !== "object")
                    throw TypeError(".CMsgTEBubbleTrail.mins: object expected");
                message.mins = $root.CMsgVector.fromObject(object.mins);
            }
            if (object.maxs != null) {
                if (typeof object.maxs !== "object")
                    throw TypeError(".CMsgTEBubbleTrail.maxs: object expected");
                message.maxs = $root.CMsgVector.fromObject(object.maxs);
            }
            if (object.waterz != null)
                message.waterz = Number(object.waterz);
            if (object.count != null)
                message.count = object.count >>> 0;
            if (object.speed != null)
                message.speed = Number(object.speed);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBubbleTrail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBubbleTrail
         * @static
         * @param {CMsgTEBubbleTrail} message CMsgTEBubbleTrail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBubbleTrail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mins = null;
                object.maxs = null;
                object.waterz = 0;
                object.count = 0;
                object.speed = 0;
            }
            if (message.mins != null && message.hasOwnProperty("mins"))
                object.mins = $root.CMsgVector.toObject(message.mins, options);
            if (message.maxs != null && message.hasOwnProperty("maxs"))
                object.maxs = $root.CMsgVector.toObject(message.maxs, options);
            if (message.waterz != null && message.hasOwnProperty("waterz"))
                object.waterz = options.json && !isFinite(message.waterz) ? String(message.waterz) : message.waterz;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
            return object;
        };
    
        /**
         * Converts this CMsgTEBubbleTrail to JSON.
         * @function toJSON
         * @memberof CMsgTEBubbleTrail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBubbleTrail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBubbleTrail;
    })();
    
    $root.CMsgTEDecal = (function() {
    
        /**
         * Properties of a CMsgTEDecal.
         * @exports ICMsgTEDecal
         * @interface ICMsgTEDecal
         * @property {ICMsgVector|null} [origin] CMsgTEDecal origin
         * @property {ICMsgVector|null} [start] CMsgTEDecal start
         * @property {number|null} [entity] CMsgTEDecal entity
         * @property {number|null} [hitbox] CMsgTEDecal hitbox
         * @property {number|null} [index] CMsgTEDecal index
         */
    
        /**
         * Constructs a new CMsgTEDecal.
         * @exports CMsgTEDecal
         * @classdesc Represents a CMsgTEDecal.
         * @implements ICMsgTEDecal
         * @constructor
         * @param {ICMsgTEDecal=} [properties] Properties to set
         */
        function CMsgTEDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEDecal origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEDecal
         * @instance
         */
        CMsgTEDecal.prototype.origin = null;
    
        /**
         * CMsgTEDecal start.
         * @member {ICMsgVector|null|undefined} start
         * @memberof CMsgTEDecal
         * @instance
         */
        CMsgTEDecal.prototype.start = null;
    
        /**
         * CMsgTEDecal entity.
         * @member {number} entity
         * @memberof CMsgTEDecal
         * @instance
         */
        CMsgTEDecal.prototype.entity = 0;
    
        /**
         * CMsgTEDecal hitbox.
         * @member {number} hitbox
         * @memberof CMsgTEDecal
         * @instance
         */
        CMsgTEDecal.prototype.hitbox = 0;
    
        /**
         * CMsgTEDecal index.
         * @member {number} index
         * @memberof CMsgTEDecal
         * @instance
         */
        CMsgTEDecal.prototype.index = 0;
    
        /**
         * Creates a new CMsgTEDecal instance using the specified properties.
         * @function create
         * @memberof CMsgTEDecal
         * @static
         * @param {ICMsgTEDecal=} [properties] Properties to set
         * @returns {CMsgTEDecal} CMsgTEDecal instance
         */
        CMsgTEDecal.create = function create(properties) {
            return new CMsgTEDecal(properties);
        };
    
        /**
         * Encodes the specified CMsgTEDecal message. Does not implicitly {@link CMsgTEDecal.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEDecal
         * @static
         * @param {ICMsgTEDecal} message CMsgTEDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                $root.CMsgVector.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entity);
            if (message.hitbox != null && Object.hasOwnProperty.call(message, "hitbox"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hitbox);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.index);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEDecal message, length delimited. Does not implicitly {@link CMsgTEDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEDecal
         * @static
         * @param {ICMsgTEDecal} message CMsgTEDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEDecal} CMsgTEDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.start = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.entity = reader.uint32();
                    break;
                case 4:
                    message.hitbox = reader.uint32();
                    break;
                case 5:
                    message.index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEDecal} CMsgTEDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEDecal message.
         * @function verify
         * @memberof CMsgTEDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.start != null && message.hasOwnProperty("start")) {
                var error = $root.CMsgVector.verify(message.start);
                if (error)
                    return "start." + error;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.hitbox != null && message.hasOwnProperty("hitbox"))
                if (!$util.isInteger(message.hitbox))
                    return "hitbox: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEDecal} CMsgTEDecal
         */
        CMsgTEDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEDecal)
                return object;
            var message = new $root.CMsgTEDecal();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEDecal.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.start != null) {
                if (typeof object.start !== "object")
                    throw TypeError(".CMsgTEDecal.start: object expected");
                message.start = $root.CMsgVector.fromObject(object.start);
            }
            if (object.entity != null)
                message.entity = object.entity >>> 0;
            if (object.hitbox != null)
                message.hitbox = object.hitbox >>> 0;
            if (object.index != null)
                message.index = object.index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEDecal
         * @static
         * @param {CMsgTEDecal} message CMsgTEDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.start = null;
                object.entity = 0;
                object.hitbox = 0;
                object.index = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = $root.CMsgVector.toObject(message.start, options);
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.hitbox != null && message.hasOwnProperty("hitbox"))
                object.hitbox = message.hitbox;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };
    
        /**
         * Converts this CMsgTEDecal to JSON.
         * @function toJSON
         * @memberof CMsgTEDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEDecal;
    })();
    
    $root.CMsgEffectData = (function() {
    
        /**
         * Properties of a CMsgEffectData.
         * @exports ICMsgEffectData
         * @interface ICMsgEffectData
         * @property {ICMsgVector|null} [origin] CMsgEffectData origin
         * @property {ICMsgVector|null} [start] CMsgEffectData start
         * @property {ICMsgVector|null} [normal] CMsgEffectData normal
         * @property {ICMsgQAngle|null} [angles] CMsgEffectData angles
         * @property {number|null} [entity] CMsgEffectData entity
         * @property {number|null} [otherentity] CMsgEffectData otherentity
         * @property {number|null} [scale] CMsgEffectData scale
         * @property {number|null} [magnitude] CMsgEffectData magnitude
         * @property {number|null} [radius] CMsgEffectData radius
         * @property {number|null} [surfaceprop] CMsgEffectData surfaceprop
         * @property {number|Long|null} [effectindex] CMsgEffectData effectindex
         * @property {number|null} [damagetype] CMsgEffectData damagetype
         * @property {number|null} [material] CMsgEffectData material
         * @property {number|null} [hitbox] CMsgEffectData hitbox
         * @property {number|null} [color] CMsgEffectData color
         * @property {number|null} [flags] CMsgEffectData flags
         * @property {number|null} [attachmentindex] CMsgEffectData attachmentindex
         * @property {number|null} [effectname] CMsgEffectData effectname
         * @property {number|null} [attachmentname] CMsgEffectData attachmentname
         */
    
        /**
         * Constructs a new CMsgEffectData.
         * @exports CMsgEffectData
         * @classdesc Represents a CMsgEffectData.
         * @implements ICMsgEffectData
         * @constructor
         * @param {ICMsgEffectData=} [properties] Properties to set
         */
        function CMsgEffectData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgEffectData origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.origin = null;
    
        /**
         * CMsgEffectData start.
         * @member {ICMsgVector|null|undefined} start
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.start = null;
    
        /**
         * CMsgEffectData normal.
         * @member {ICMsgVector|null|undefined} normal
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.normal = null;
    
        /**
         * CMsgEffectData angles.
         * @member {ICMsgQAngle|null|undefined} angles
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.angles = null;
    
        /**
         * CMsgEffectData entity.
         * @member {number} entity
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.entity = 0;
    
        /**
         * CMsgEffectData otherentity.
         * @member {number} otherentity
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.otherentity = 0;
    
        /**
         * CMsgEffectData scale.
         * @member {number} scale
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.scale = 0;
    
        /**
         * CMsgEffectData magnitude.
         * @member {number} magnitude
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.magnitude = 0;
    
        /**
         * CMsgEffectData radius.
         * @member {number} radius
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.radius = 0;
    
        /**
         * CMsgEffectData surfaceprop.
         * @member {number} surfaceprop
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.surfaceprop = 0;
    
        /**
         * CMsgEffectData effectindex.
         * @member {number|Long} effectindex
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.effectindex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgEffectData damagetype.
         * @member {number} damagetype
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.damagetype = 0;
    
        /**
         * CMsgEffectData material.
         * @member {number} material
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.material = 0;
    
        /**
         * CMsgEffectData hitbox.
         * @member {number} hitbox
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.hitbox = 0;
    
        /**
         * CMsgEffectData color.
         * @member {number} color
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.color = 0;
    
        /**
         * CMsgEffectData flags.
         * @member {number} flags
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.flags = 0;
    
        /**
         * CMsgEffectData attachmentindex.
         * @member {number} attachmentindex
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.attachmentindex = 0;
    
        /**
         * CMsgEffectData effectname.
         * @member {number} effectname
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.effectname = 0;
    
        /**
         * CMsgEffectData attachmentname.
         * @member {number} attachmentname
         * @memberof CMsgEffectData
         * @instance
         */
        CMsgEffectData.prototype.attachmentname = 0;
    
        /**
         * Creates a new CMsgEffectData instance using the specified properties.
         * @function create
         * @memberof CMsgEffectData
         * @static
         * @param {ICMsgEffectData=} [properties] Properties to set
         * @returns {CMsgEffectData} CMsgEffectData instance
         */
        CMsgEffectData.create = function create(properties) {
            return new CMsgEffectData(properties);
        };
    
        /**
         * Encodes the specified CMsgEffectData message. Does not implicitly {@link CMsgEffectData.verify|verify} messages.
         * @function encode
         * @memberof CMsgEffectData
         * @static
         * @param {ICMsgEffectData} message CMsgEffectData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgEffectData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                $root.CMsgVector.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.normal != null && Object.hasOwnProperty.call(message, "normal"))
                $root.CMsgVector.encode(message.normal, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.angles != null && Object.hasOwnProperty.call(message, "angles"))
                $root.CMsgQAngle.encode(message.angles, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.entity);
            if (message.otherentity != null && Object.hasOwnProperty.call(message, "otherentity"))
                writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.otherentity);
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.scale);
            if (message.magnitude != null && Object.hasOwnProperty.call(message, "magnitude"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.magnitude);
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.radius);
            if (message.surfaceprop != null && Object.hasOwnProperty.call(message, "surfaceprop"))
                writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.surfaceprop);
            if (message.effectindex != null && Object.hasOwnProperty.call(message, "effectindex"))
                writer.uint32(/* id 11, wireType 1 =*/89).fixed64(message.effectindex);
            if (message.damagetype != null && Object.hasOwnProperty.call(message, "damagetype"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.damagetype);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.material);
            if (message.hitbox != null && Object.hasOwnProperty.call(message, "hitbox"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.hitbox);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.color);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.flags);
            if (message.attachmentindex != null && Object.hasOwnProperty.call(message, "attachmentindex"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.attachmentindex);
            if (message.effectname != null && Object.hasOwnProperty.call(message, "effectname"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.effectname);
            if (message.attachmentname != null && Object.hasOwnProperty.call(message, "attachmentname"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.attachmentname);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgEffectData message, length delimited. Does not implicitly {@link CMsgEffectData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgEffectData
         * @static
         * @param {ICMsgEffectData} message CMsgEffectData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgEffectData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgEffectData message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgEffectData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgEffectData} CMsgEffectData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgEffectData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgEffectData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.start = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.normal = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.angles = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.entity = reader.fixed32();
                    break;
                case 6:
                    message.otherentity = reader.fixed32();
                    break;
                case 7:
                    message.scale = reader.float();
                    break;
                case 8:
                    message.magnitude = reader.float();
                    break;
                case 9:
                    message.radius = reader.float();
                    break;
                case 10:
                    message.surfaceprop = reader.fixed32();
                    break;
                case 11:
                    message.effectindex = reader.fixed64();
                    break;
                case 12:
                    message.damagetype = reader.uint32();
                    break;
                case 13:
                    message.material = reader.uint32();
                    break;
                case 14:
                    message.hitbox = reader.uint32();
                    break;
                case 15:
                    message.color = reader.uint32();
                    break;
                case 16:
                    message.flags = reader.uint32();
                    break;
                case 17:
                    message.attachmentindex = reader.int32();
                    break;
                case 18:
                    message.effectname = reader.uint32();
                    break;
                case 19:
                    message.attachmentname = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgEffectData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgEffectData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgEffectData} CMsgEffectData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgEffectData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgEffectData message.
         * @function verify
         * @memberof CMsgEffectData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgEffectData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.start != null && message.hasOwnProperty("start")) {
                var error = $root.CMsgVector.verify(message.start);
                if (error)
                    return "start." + error;
            }
            if (message.normal != null && message.hasOwnProperty("normal")) {
                var error = $root.CMsgVector.verify(message.normal);
                if (error)
                    return "normal." + error;
            }
            if (message.angles != null && message.hasOwnProperty("angles")) {
                var error = $root.CMsgQAngle.verify(message.angles);
                if (error)
                    return "angles." + error;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.otherentity != null && message.hasOwnProperty("otherentity"))
                if (!$util.isInteger(message.otherentity))
                    return "otherentity: integer expected";
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.magnitude != null && message.hasOwnProperty("magnitude"))
                if (typeof message.magnitude !== "number")
                    return "magnitude: number expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.surfaceprop != null && message.hasOwnProperty("surfaceprop"))
                if (!$util.isInteger(message.surfaceprop))
                    return "surfaceprop: integer expected";
            if (message.effectindex != null && message.hasOwnProperty("effectindex"))
                if (!$util.isInteger(message.effectindex) && !(message.effectindex && $util.isInteger(message.effectindex.low) && $util.isInteger(message.effectindex.high)))
                    return "effectindex: integer|Long expected";
            if (message.damagetype != null && message.hasOwnProperty("damagetype"))
                if (!$util.isInteger(message.damagetype))
                    return "damagetype: integer expected";
            if (message.material != null && message.hasOwnProperty("material"))
                if (!$util.isInteger(message.material))
                    return "material: integer expected";
            if (message.hitbox != null && message.hasOwnProperty("hitbox"))
                if (!$util.isInteger(message.hitbox))
                    return "hitbox: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.attachmentindex != null && message.hasOwnProperty("attachmentindex"))
                if (!$util.isInteger(message.attachmentindex))
                    return "attachmentindex: integer expected";
            if (message.effectname != null && message.hasOwnProperty("effectname"))
                if (!$util.isInteger(message.effectname))
                    return "effectname: integer expected";
            if (message.attachmentname != null && message.hasOwnProperty("attachmentname"))
                if (!$util.isInteger(message.attachmentname))
                    return "attachmentname: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgEffectData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgEffectData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgEffectData} CMsgEffectData
         */
        CMsgEffectData.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgEffectData)
                return object;
            var message = new $root.CMsgEffectData();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgEffectData.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.start != null) {
                if (typeof object.start !== "object")
                    throw TypeError(".CMsgEffectData.start: object expected");
                message.start = $root.CMsgVector.fromObject(object.start);
            }
            if (object.normal != null) {
                if (typeof object.normal !== "object")
                    throw TypeError(".CMsgEffectData.normal: object expected");
                message.normal = $root.CMsgVector.fromObject(object.normal);
            }
            if (object.angles != null) {
                if (typeof object.angles !== "object")
                    throw TypeError(".CMsgEffectData.angles: object expected");
                message.angles = $root.CMsgQAngle.fromObject(object.angles);
            }
            if (object.entity != null)
                message.entity = object.entity >>> 0;
            if (object.otherentity != null)
                message.otherentity = object.otherentity >>> 0;
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.magnitude != null)
                message.magnitude = Number(object.magnitude);
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.surfaceprop != null)
                message.surfaceprop = object.surfaceprop >>> 0;
            if (object.effectindex != null)
                if ($util.Long)
                    (message.effectindex = $util.Long.fromValue(object.effectindex)).unsigned = false;
                else if (typeof object.effectindex === "string")
                    message.effectindex = parseInt(object.effectindex, 10);
                else if (typeof object.effectindex === "number")
                    message.effectindex = object.effectindex;
                else if (typeof object.effectindex === "object")
                    message.effectindex = new $util.LongBits(object.effectindex.low >>> 0, object.effectindex.high >>> 0).toNumber();
            if (object.damagetype != null)
                message.damagetype = object.damagetype >>> 0;
            if (object.material != null)
                message.material = object.material >>> 0;
            if (object.hitbox != null)
                message.hitbox = object.hitbox >>> 0;
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.attachmentindex != null)
                message.attachmentindex = object.attachmentindex | 0;
            if (object.effectname != null)
                message.effectname = object.effectname >>> 0;
            if (object.attachmentname != null)
                message.attachmentname = object.attachmentname >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgEffectData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgEffectData
         * @static
         * @param {CMsgEffectData} message CMsgEffectData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgEffectData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.start = null;
                object.normal = null;
                object.angles = null;
                object.entity = 0;
                object.otherentity = 0;
                object.scale = 0;
                object.magnitude = 0;
                object.radius = 0;
                object.surfaceprop = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.effectindex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.effectindex = options.longs === String ? "0" : 0;
                object.damagetype = 0;
                object.material = 0;
                object.hitbox = 0;
                object.color = 0;
                object.flags = 0;
                object.attachmentindex = 0;
                object.effectname = 0;
                object.attachmentname = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = $root.CMsgVector.toObject(message.start, options);
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = $root.CMsgVector.toObject(message.normal, options);
            if (message.angles != null && message.hasOwnProperty("angles"))
                object.angles = $root.CMsgQAngle.toObject(message.angles, options);
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.otherentity != null && message.hasOwnProperty("otherentity"))
                object.otherentity = message.otherentity;
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.magnitude != null && message.hasOwnProperty("magnitude"))
                object.magnitude = options.json && !isFinite(message.magnitude) ? String(message.magnitude) : message.magnitude;
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.surfaceprop != null && message.hasOwnProperty("surfaceprop"))
                object.surfaceprop = message.surfaceprop;
            if (message.effectindex != null && message.hasOwnProperty("effectindex"))
                if (typeof message.effectindex === "number")
                    object.effectindex = options.longs === String ? String(message.effectindex) : message.effectindex;
                else
                    object.effectindex = options.longs === String ? $util.Long.prototype.toString.call(message.effectindex) : options.longs === Number ? new $util.LongBits(message.effectindex.low >>> 0, message.effectindex.high >>> 0).toNumber() : message.effectindex;
            if (message.damagetype != null && message.hasOwnProperty("damagetype"))
                object.damagetype = message.damagetype;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = message.material;
            if (message.hitbox != null && message.hasOwnProperty("hitbox"))
                object.hitbox = message.hitbox;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.attachmentindex != null && message.hasOwnProperty("attachmentindex"))
                object.attachmentindex = message.attachmentindex;
            if (message.effectname != null && message.hasOwnProperty("effectname"))
                object.effectname = message.effectname;
            if (message.attachmentname != null && message.hasOwnProperty("attachmentname"))
                object.attachmentname = message.attachmentname;
            return object;
        };
    
        /**
         * Converts this CMsgEffectData to JSON.
         * @function toJSON
         * @memberof CMsgEffectData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgEffectData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgEffectData;
    })();
    
    $root.CMsgTEEffectDispatch = (function() {
    
        /**
         * Properties of a CMsgTEEffectDispatch.
         * @exports ICMsgTEEffectDispatch
         * @interface ICMsgTEEffectDispatch
         * @property {ICMsgEffectData|null} [effectdata] CMsgTEEffectDispatch effectdata
         */
    
        /**
         * Constructs a new CMsgTEEffectDispatch.
         * @exports CMsgTEEffectDispatch
         * @classdesc Represents a CMsgTEEffectDispatch.
         * @implements ICMsgTEEffectDispatch
         * @constructor
         * @param {ICMsgTEEffectDispatch=} [properties] Properties to set
         */
        function CMsgTEEffectDispatch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEEffectDispatch effectdata.
         * @member {ICMsgEffectData|null|undefined} effectdata
         * @memberof CMsgTEEffectDispatch
         * @instance
         */
        CMsgTEEffectDispatch.prototype.effectdata = null;
    
        /**
         * Creates a new CMsgTEEffectDispatch instance using the specified properties.
         * @function create
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {ICMsgTEEffectDispatch=} [properties] Properties to set
         * @returns {CMsgTEEffectDispatch} CMsgTEEffectDispatch instance
         */
        CMsgTEEffectDispatch.create = function create(properties) {
            return new CMsgTEEffectDispatch(properties);
        };
    
        /**
         * Encodes the specified CMsgTEEffectDispatch message. Does not implicitly {@link CMsgTEEffectDispatch.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {ICMsgTEEffectDispatch} message CMsgTEEffectDispatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEEffectDispatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effectdata != null && Object.hasOwnProperty.call(message, "effectdata"))
                $root.CMsgEffectData.encode(message.effectdata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEEffectDispatch message, length delimited. Does not implicitly {@link CMsgTEEffectDispatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {ICMsgTEEffectDispatch} message CMsgTEEffectDispatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEEffectDispatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEEffectDispatch message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEEffectDispatch} CMsgTEEffectDispatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEEffectDispatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEEffectDispatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effectdata = $root.CMsgEffectData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEEffectDispatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEEffectDispatch} CMsgTEEffectDispatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEEffectDispatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEEffectDispatch message.
         * @function verify
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEEffectDispatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effectdata != null && message.hasOwnProperty("effectdata")) {
                var error = $root.CMsgEffectData.verify(message.effectdata);
                if (error)
                    return "effectdata." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTEEffectDispatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEEffectDispatch} CMsgTEEffectDispatch
         */
        CMsgTEEffectDispatch.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEEffectDispatch)
                return object;
            var message = new $root.CMsgTEEffectDispatch();
            if (object.effectdata != null) {
                if (typeof object.effectdata !== "object")
                    throw TypeError(".CMsgTEEffectDispatch.effectdata: object expected");
                message.effectdata = $root.CMsgEffectData.fromObject(object.effectdata);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEEffectDispatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEEffectDispatch
         * @static
         * @param {CMsgTEEffectDispatch} message CMsgTEEffectDispatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEEffectDispatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.effectdata = null;
            if (message.effectdata != null && message.hasOwnProperty("effectdata"))
                object.effectdata = $root.CMsgEffectData.toObject(message.effectdata, options);
            return object;
        };
    
        /**
         * Converts this CMsgTEEffectDispatch to JSON.
         * @function toJSON
         * @memberof CMsgTEEffectDispatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEEffectDispatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEEffectDispatch;
    })();
    
    $root.CMsgTEEnergySplash = (function() {
    
        /**
         * Properties of a CMsgTEEnergySplash.
         * @exports ICMsgTEEnergySplash
         * @interface ICMsgTEEnergySplash
         * @property {ICMsgVector|null} [pos] CMsgTEEnergySplash pos
         * @property {ICMsgVector|null} [dir] CMsgTEEnergySplash dir
         * @property {boolean|null} [explosive] CMsgTEEnergySplash explosive
         */
    
        /**
         * Constructs a new CMsgTEEnergySplash.
         * @exports CMsgTEEnergySplash
         * @classdesc Represents a CMsgTEEnergySplash.
         * @implements ICMsgTEEnergySplash
         * @constructor
         * @param {ICMsgTEEnergySplash=} [properties] Properties to set
         */
        function CMsgTEEnergySplash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEEnergySplash pos.
         * @member {ICMsgVector|null|undefined} pos
         * @memberof CMsgTEEnergySplash
         * @instance
         */
        CMsgTEEnergySplash.prototype.pos = null;
    
        /**
         * CMsgTEEnergySplash dir.
         * @member {ICMsgVector|null|undefined} dir
         * @memberof CMsgTEEnergySplash
         * @instance
         */
        CMsgTEEnergySplash.prototype.dir = null;
    
        /**
         * CMsgTEEnergySplash explosive.
         * @member {boolean} explosive
         * @memberof CMsgTEEnergySplash
         * @instance
         */
        CMsgTEEnergySplash.prototype.explosive = false;
    
        /**
         * Creates a new CMsgTEEnergySplash instance using the specified properties.
         * @function create
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {ICMsgTEEnergySplash=} [properties] Properties to set
         * @returns {CMsgTEEnergySplash} CMsgTEEnergySplash instance
         */
        CMsgTEEnergySplash.create = function create(properties) {
            return new CMsgTEEnergySplash(properties);
        };
    
        /**
         * Encodes the specified CMsgTEEnergySplash message. Does not implicitly {@link CMsgTEEnergySplash.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {ICMsgTEEnergySplash} message CMsgTEEnergySplash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEEnergySplash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.CMsgVector.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                $root.CMsgVector.encode(message.dir, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.explosive != null && Object.hasOwnProperty.call(message, "explosive"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.explosive);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEEnergySplash message, length delimited. Does not implicitly {@link CMsgTEEnergySplash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {ICMsgTEEnergySplash} message CMsgTEEnergySplash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEEnergySplash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEEnergySplash message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEEnergySplash} CMsgTEEnergySplash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEEnergySplash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEEnergySplash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.dir = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.explosive = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEEnergySplash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEEnergySplash} CMsgTEEnergySplash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEEnergySplash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEEnergySplash message.
         * @function verify
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEEnergySplash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.CMsgVector.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.dir != null && message.hasOwnProperty("dir")) {
                var error = $root.CMsgVector.verify(message.dir);
                if (error)
                    return "dir." + error;
            }
            if (message.explosive != null && message.hasOwnProperty("explosive"))
                if (typeof message.explosive !== "boolean")
                    return "explosive: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEEnergySplash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEEnergySplash} CMsgTEEnergySplash
         */
        CMsgTEEnergySplash.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEEnergySplash)
                return object;
            var message = new $root.CMsgTEEnergySplash();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".CMsgTEEnergySplash.pos: object expected");
                message.pos = $root.CMsgVector.fromObject(object.pos);
            }
            if (object.dir != null) {
                if (typeof object.dir !== "object")
                    throw TypeError(".CMsgTEEnergySplash.dir: object expected");
                message.dir = $root.CMsgVector.fromObject(object.dir);
            }
            if (object.explosive != null)
                message.explosive = Boolean(object.explosive);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEEnergySplash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEEnergySplash
         * @static
         * @param {CMsgTEEnergySplash} message CMsgTEEnergySplash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEEnergySplash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.dir = null;
                object.explosive = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.CMsgVector.toObject(message.pos, options);
            if (message.dir != null && message.hasOwnProperty("dir"))
                object.dir = $root.CMsgVector.toObject(message.dir, options);
            if (message.explosive != null && message.hasOwnProperty("explosive"))
                object.explosive = message.explosive;
            return object;
        };
    
        /**
         * Converts this CMsgTEEnergySplash to JSON.
         * @function toJSON
         * @memberof CMsgTEEnergySplash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEEnergySplash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEEnergySplash;
    })();
    
    $root.CMsgTEFizz = (function() {
    
        /**
         * Properties of a CMsgTEFizz.
         * @exports ICMsgTEFizz
         * @interface ICMsgTEFizz
         * @property {number|null} [entity] CMsgTEFizz entity
         * @property {number|null} [density] CMsgTEFizz density
         * @property {number|null} [current] CMsgTEFizz current
         */
    
        /**
         * Constructs a new CMsgTEFizz.
         * @exports CMsgTEFizz
         * @classdesc Represents a CMsgTEFizz.
         * @implements ICMsgTEFizz
         * @constructor
         * @param {ICMsgTEFizz=} [properties] Properties to set
         */
        function CMsgTEFizz(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEFizz entity.
         * @member {number} entity
         * @memberof CMsgTEFizz
         * @instance
         */
        CMsgTEFizz.prototype.entity = 0;
    
        /**
         * CMsgTEFizz density.
         * @member {number} density
         * @memberof CMsgTEFizz
         * @instance
         */
        CMsgTEFizz.prototype.density = 0;
    
        /**
         * CMsgTEFizz current.
         * @member {number} current
         * @memberof CMsgTEFizz
         * @instance
         */
        CMsgTEFizz.prototype.current = 0;
    
        /**
         * Creates a new CMsgTEFizz instance using the specified properties.
         * @function create
         * @memberof CMsgTEFizz
         * @static
         * @param {ICMsgTEFizz=} [properties] Properties to set
         * @returns {CMsgTEFizz} CMsgTEFizz instance
         */
        CMsgTEFizz.create = function create(properties) {
            return new CMsgTEFizz(properties);
        };
    
        /**
         * Encodes the specified CMsgTEFizz message. Does not implicitly {@link CMsgTEFizz.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEFizz
         * @static
         * @param {ICMsgTEFizz} message CMsgTEFizz message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEFizz.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.entity);
            if (message.density != null && Object.hasOwnProperty.call(message, "density"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.density);
            if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.current);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEFizz message, length delimited. Does not implicitly {@link CMsgTEFizz.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEFizz
         * @static
         * @param {ICMsgTEFizz} message CMsgTEFizz message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEFizz.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEFizz message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEFizz
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEFizz} CMsgTEFizz
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEFizz.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEFizz();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity = reader.uint32();
                    break;
                case 2:
                    message.density = reader.uint32();
                    break;
                case 3:
                    message.current = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEFizz message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEFizz
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEFizz} CMsgTEFizz
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEFizz.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEFizz message.
         * @function verify
         * @memberof CMsgTEFizz
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEFizz.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            if (message.density != null && message.hasOwnProperty("density"))
                if (!$util.isInteger(message.density))
                    return "density: integer expected";
            if (message.current != null && message.hasOwnProperty("current"))
                if (!$util.isInteger(message.current))
                    return "current: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEFizz message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEFizz
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEFizz} CMsgTEFizz
         */
        CMsgTEFizz.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEFizz)
                return object;
            var message = new $root.CMsgTEFizz();
            if (object.entity != null)
                message.entity = object.entity >>> 0;
            if (object.density != null)
                message.density = object.density >>> 0;
            if (object.current != null)
                message.current = object.current | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEFizz message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEFizz
         * @static
         * @param {CMsgTEFizz} message CMsgTEFizz
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEFizz.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity = 0;
                object.density = 0;
                object.current = 0;
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.density != null && message.hasOwnProperty("density"))
                object.density = message.density;
            if (message.current != null && message.hasOwnProperty("current"))
                object.current = message.current;
            return object;
        };
    
        /**
         * Converts this CMsgTEFizz to JSON.
         * @function toJSON
         * @memberof CMsgTEFizz
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEFizz.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEFizz;
    })();
    
    $root.CMsgTEShatterSurface = (function() {
    
        /**
         * Properties of a CMsgTEShatterSurface.
         * @exports ICMsgTEShatterSurface
         * @interface ICMsgTEShatterSurface
         * @property {ICMsgVector|null} [origin] CMsgTEShatterSurface origin
         * @property {ICMsgQAngle|null} [angles] CMsgTEShatterSurface angles
         * @property {ICMsgVector|null} [force] CMsgTEShatterSurface force
         * @property {ICMsgVector|null} [forcepos] CMsgTEShatterSurface forcepos
         * @property {number|null} [width] CMsgTEShatterSurface width
         * @property {number|null} [height] CMsgTEShatterSurface height
         * @property {number|null} [shardsize] CMsgTEShatterSurface shardsize
         * @property {number|null} [surfacetype] CMsgTEShatterSurface surfacetype
         * @property {number|null} [frontcolor] CMsgTEShatterSurface frontcolor
         * @property {number|null} [backcolor] CMsgTEShatterSurface backcolor
         */
    
        /**
         * Constructs a new CMsgTEShatterSurface.
         * @exports CMsgTEShatterSurface
         * @classdesc Represents a CMsgTEShatterSurface.
         * @implements ICMsgTEShatterSurface
         * @constructor
         * @param {ICMsgTEShatterSurface=} [properties] Properties to set
         */
        function CMsgTEShatterSurface(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEShatterSurface origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.origin = null;
    
        /**
         * CMsgTEShatterSurface angles.
         * @member {ICMsgQAngle|null|undefined} angles
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.angles = null;
    
        /**
         * CMsgTEShatterSurface force.
         * @member {ICMsgVector|null|undefined} force
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.force = null;
    
        /**
         * CMsgTEShatterSurface forcepos.
         * @member {ICMsgVector|null|undefined} forcepos
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.forcepos = null;
    
        /**
         * CMsgTEShatterSurface width.
         * @member {number} width
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.width = 0;
    
        /**
         * CMsgTEShatterSurface height.
         * @member {number} height
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.height = 0;
    
        /**
         * CMsgTEShatterSurface shardsize.
         * @member {number} shardsize
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.shardsize = 0;
    
        /**
         * CMsgTEShatterSurface surfacetype.
         * @member {number} surfacetype
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.surfacetype = 0;
    
        /**
         * CMsgTEShatterSurface frontcolor.
         * @member {number} frontcolor
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.frontcolor = 0;
    
        /**
         * CMsgTEShatterSurface backcolor.
         * @member {number} backcolor
         * @memberof CMsgTEShatterSurface
         * @instance
         */
        CMsgTEShatterSurface.prototype.backcolor = 0;
    
        /**
         * Creates a new CMsgTEShatterSurface instance using the specified properties.
         * @function create
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {ICMsgTEShatterSurface=} [properties] Properties to set
         * @returns {CMsgTEShatterSurface} CMsgTEShatterSurface instance
         */
        CMsgTEShatterSurface.create = function create(properties) {
            return new CMsgTEShatterSurface(properties);
        };
    
        /**
         * Encodes the specified CMsgTEShatterSurface message. Does not implicitly {@link CMsgTEShatterSurface.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {ICMsgTEShatterSurface} message CMsgTEShatterSurface message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEShatterSurface.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.angles != null && Object.hasOwnProperty.call(message, "angles"))
                $root.CMsgQAngle.encode(message.angles, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                $root.CMsgVector.encode(message.force, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.forcepos != null && Object.hasOwnProperty.call(message, "forcepos"))
                $root.CMsgVector.encode(message.forcepos, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.height);
            if (message.shardsize != null && Object.hasOwnProperty.call(message, "shardsize"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.shardsize);
            if (message.surfacetype != null && Object.hasOwnProperty.call(message, "surfacetype"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.surfacetype);
            if (message.frontcolor != null && Object.hasOwnProperty.call(message, "frontcolor"))
                writer.uint32(/* id 9, wireType 5 =*/77).fixed32(message.frontcolor);
            if (message.backcolor != null && Object.hasOwnProperty.call(message, "backcolor"))
                writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.backcolor);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEShatterSurface message, length delimited. Does not implicitly {@link CMsgTEShatterSurface.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {ICMsgTEShatterSurface} message CMsgTEShatterSurface message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEShatterSurface.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEShatterSurface message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEShatterSurface} CMsgTEShatterSurface
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEShatterSurface.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEShatterSurface();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.angles = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.force = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.forcepos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.width = reader.float();
                    break;
                case 6:
                    message.height = reader.float();
                    break;
                case 7:
                    message.shardsize = reader.float();
                    break;
                case 8:
                    message.surfacetype = reader.uint32();
                    break;
                case 9:
                    message.frontcolor = reader.fixed32();
                    break;
                case 10:
                    message.backcolor = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEShatterSurface message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEShatterSurface} CMsgTEShatterSurface
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEShatterSurface.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEShatterSurface message.
         * @function verify
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEShatterSurface.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.angles != null && message.hasOwnProperty("angles")) {
                var error = $root.CMsgQAngle.verify(message.angles);
                if (error)
                    return "angles." + error;
            }
            if (message.force != null && message.hasOwnProperty("force")) {
                var error = $root.CMsgVector.verify(message.force);
                if (error)
                    return "force." + error;
            }
            if (message.forcepos != null && message.hasOwnProperty("forcepos")) {
                var error = $root.CMsgVector.verify(message.forcepos);
                if (error)
                    return "forcepos." + error;
            }
            if (message.width != null && message.hasOwnProperty("width"))
                if (typeof message.width !== "number")
                    return "width: number expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            if (message.shardsize != null && message.hasOwnProperty("shardsize"))
                if (typeof message.shardsize !== "number")
                    return "shardsize: number expected";
            if (message.surfacetype != null && message.hasOwnProperty("surfacetype"))
                if (!$util.isInteger(message.surfacetype))
                    return "surfacetype: integer expected";
            if (message.frontcolor != null && message.hasOwnProperty("frontcolor"))
                if (!$util.isInteger(message.frontcolor))
                    return "frontcolor: integer expected";
            if (message.backcolor != null && message.hasOwnProperty("backcolor"))
                if (!$util.isInteger(message.backcolor))
                    return "backcolor: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEShatterSurface message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEShatterSurface} CMsgTEShatterSurface
         */
        CMsgTEShatterSurface.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEShatterSurface)
                return object;
            var message = new $root.CMsgTEShatterSurface();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEShatterSurface.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.angles != null) {
                if (typeof object.angles !== "object")
                    throw TypeError(".CMsgTEShatterSurface.angles: object expected");
                message.angles = $root.CMsgQAngle.fromObject(object.angles);
            }
            if (object.force != null) {
                if (typeof object.force !== "object")
                    throw TypeError(".CMsgTEShatterSurface.force: object expected");
                message.force = $root.CMsgVector.fromObject(object.force);
            }
            if (object.forcepos != null) {
                if (typeof object.forcepos !== "object")
                    throw TypeError(".CMsgTEShatterSurface.forcepos: object expected");
                message.forcepos = $root.CMsgVector.fromObject(object.forcepos);
            }
            if (object.width != null)
                message.width = Number(object.width);
            if (object.height != null)
                message.height = Number(object.height);
            if (object.shardsize != null)
                message.shardsize = Number(object.shardsize);
            if (object.surfacetype != null)
                message.surfacetype = object.surfacetype >>> 0;
            if (object.frontcolor != null)
                message.frontcolor = object.frontcolor >>> 0;
            if (object.backcolor != null)
                message.backcolor = object.backcolor >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEShatterSurface message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEShatterSurface
         * @static
         * @param {CMsgTEShatterSurface} message CMsgTEShatterSurface
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEShatterSurface.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.angles = null;
                object.force = null;
                object.forcepos = null;
                object.width = 0;
                object.height = 0;
                object.shardsize = 0;
                object.surfacetype = 0;
                object.frontcolor = 0;
                object.backcolor = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.angles != null && message.hasOwnProperty("angles"))
                object.angles = $root.CMsgQAngle.toObject(message.angles, options);
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = $root.CMsgVector.toObject(message.force, options);
            if (message.forcepos != null && message.hasOwnProperty("forcepos"))
                object.forcepos = $root.CMsgVector.toObject(message.forcepos, options);
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            if (message.shardsize != null && message.hasOwnProperty("shardsize"))
                object.shardsize = options.json && !isFinite(message.shardsize) ? String(message.shardsize) : message.shardsize;
            if (message.surfacetype != null && message.hasOwnProperty("surfacetype"))
                object.surfacetype = message.surfacetype;
            if (message.frontcolor != null && message.hasOwnProperty("frontcolor"))
                object.frontcolor = message.frontcolor;
            if (message.backcolor != null && message.hasOwnProperty("backcolor"))
                object.backcolor = message.backcolor;
            return object;
        };
    
        /**
         * Converts this CMsgTEShatterSurface to JSON.
         * @function toJSON
         * @memberof CMsgTEShatterSurface
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEShatterSurface.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEShatterSurface;
    })();
    
    $root.CMsgTEGlowSprite = (function() {
    
        /**
         * Properties of a CMsgTEGlowSprite.
         * @exports ICMsgTEGlowSprite
         * @interface ICMsgTEGlowSprite
         * @property {ICMsgVector|null} [origin] CMsgTEGlowSprite origin
         * @property {number|null} [scale] CMsgTEGlowSprite scale
         * @property {number|null} [life] CMsgTEGlowSprite life
         * @property {number|null} [brightness] CMsgTEGlowSprite brightness
         */
    
        /**
         * Constructs a new CMsgTEGlowSprite.
         * @exports CMsgTEGlowSprite
         * @classdesc Represents a CMsgTEGlowSprite.
         * @implements ICMsgTEGlowSprite
         * @constructor
         * @param {ICMsgTEGlowSprite=} [properties] Properties to set
         */
        function CMsgTEGlowSprite(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEGlowSprite origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEGlowSprite
         * @instance
         */
        CMsgTEGlowSprite.prototype.origin = null;
    
        /**
         * CMsgTEGlowSprite scale.
         * @member {number} scale
         * @memberof CMsgTEGlowSprite
         * @instance
         */
        CMsgTEGlowSprite.prototype.scale = 0;
    
        /**
         * CMsgTEGlowSprite life.
         * @member {number} life
         * @memberof CMsgTEGlowSprite
         * @instance
         */
        CMsgTEGlowSprite.prototype.life = 0;
    
        /**
         * CMsgTEGlowSprite brightness.
         * @member {number} brightness
         * @memberof CMsgTEGlowSprite
         * @instance
         */
        CMsgTEGlowSprite.prototype.brightness = 0;
    
        /**
         * Creates a new CMsgTEGlowSprite instance using the specified properties.
         * @function create
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {ICMsgTEGlowSprite=} [properties] Properties to set
         * @returns {CMsgTEGlowSprite} CMsgTEGlowSprite instance
         */
        CMsgTEGlowSprite.create = function create(properties) {
            return new CMsgTEGlowSprite(properties);
        };
    
        /**
         * Encodes the specified CMsgTEGlowSprite message. Does not implicitly {@link CMsgTEGlowSprite.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {ICMsgTEGlowSprite} message CMsgTEGlowSprite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEGlowSprite.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.scale);
            if (message.life != null && Object.hasOwnProperty.call(message, "life"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.life);
            if (message.brightness != null && Object.hasOwnProperty.call(message, "brightness"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.brightness);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEGlowSprite message, length delimited. Does not implicitly {@link CMsgTEGlowSprite.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {ICMsgTEGlowSprite} message CMsgTEGlowSprite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEGlowSprite.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEGlowSprite message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEGlowSprite} CMsgTEGlowSprite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEGlowSprite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEGlowSprite();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.scale = reader.float();
                    break;
                case 3:
                    message.life = reader.float();
                    break;
                case 4:
                    message.brightness = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEGlowSprite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEGlowSprite} CMsgTEGlowSprite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEGlowSprite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEGlowSprite message.
         * @function verify
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEGlowSprite.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.life != null && message.hasOwnProperty("life"))
                if (typeof message.life !== "number")
                    return "life: number expected";
            if (message.brightness != null && message.hasOwnProperty("brightness"))
                if (!$util.isInteger(message.brightness))
                    return "brightness: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEGlowSprite message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEGlowSprite} CMsgTEGlowSprite
         */
        CMsgTEGlowSprite.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEGlowSprite)
                return object;
            var message = new $root.CMsgTEGlowSprite();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEGlowSprite.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.life != null)
                message.life = Number(object.life);
            if (object.brightness != null)
                message.brightness = object.brightness >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEGlowSprite message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEGlowSprite
         * @static
         * @param {CMsgTEGlowSprite} message CMsgTEGlowSprite
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEGlowSprite.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.scale = 0;
                object.life = 0;
                object.brightness = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.life != null && message.hasOwnProperty("life"))
                object.life = options.json && !isFinite(message.life) ? String(message.life) : message.life;
            if (message.brightness != null && message.hasOwnProperty("brightness"))
                object.brightness = message.brightness;
            return object;
        };
    
        /**
         * Converts this CMsgTEGlowSprite to JSON.
         * @function toJSON
         * @memberof CMsgTEGlowSprite
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEGlowSprite.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEGlowSprite;
    })();
    
    $root.CMsgTEImpact = (function() {
    
        /**
         * Properties of a CMsgTEImpact.
         * @exports ICMsgTEImpact
         * @interface ICMsgTEImpact
         * @property {ICMsgVector|null} [origin] CMsgTEImpact origin
         * @property {ICMsgVector|null} [normal] CMsgTEImpact normal
         * @property {number|null} [type] CMsgTEImpact type
         */
    
        /**
         * Constructs a new CMsgTEImpact.
         * @exports CMsgTEImpact
         * @classdesc Represents a CMsgTEImpact.
         * @implements ICMsgTEImpact
         * @constructor
         * @param {ICMsgTEImpact=} [properties] Properties to set
         */
        function CMsgTEImpact(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEImpact origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEImpact
         * @instance
         */
        CMsgTEImpact.prototype.origin = null;
    
        /**
         * CMsgTEImpact normal.
         * @member {ICMsgVector|null|undefined} normal
         * @memberof CMsgTEImpact
         * @instance
         */
        CMsgTEImpact.prototype.normal = null;
    
        /**
         * CMsgTEImpact type.
         * @member {number} type
         * @memberof CMsgTEImpact
         * @instance
         */
        CMsgTEImpact.prototype.type = 0;
    
        /**
         * Creates a new CMsgTEImpact instance using the specified properties.
         * @function create
         * @memberof CMsgTEImpact
         * @static
         * @param {ICMsgTEImpact=} [properties] Properties to set
         * @returns {CMsgTEImpact} CMsgTEImpact instance
         */
        CMsgTEImpact.create = function create(properties) {
            return new CMsgTEImpact(properties);
        };
    
        /**
         * Encodes the specified CMsgTEImpact message. Does not implicitly {@link CMsgTEImpact.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEImpact
         * @static
         * @param {ICMsgTEImpact} message CMsgTEImpact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEImpact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.normal != null && Object.hasOwnProperty.call(message, "normal"))
                $root.CMsgVector.encode(message.normal, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.type);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEImpact message, length delimited. Does not implicitly {@link CMsgTEImpact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEImpact
         * @static
         * @param {ICMsgTEImpact} message CMsgTEImpact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEImpact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEImpact message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEImpact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEImpact} CMsgTEImpact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEImpact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEImpact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.normal = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEImpact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEImpact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEImpact} CMsgTEImpact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEImpact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEImpact message.
         * @function verify
         * @memberof CMsgTEImpact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEImpact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.normal != null && message.hasOwnProperty("normal")) {
                var error = $root.CMsgVector.verify(message.normal);
                if (error)
                    return "normal." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEImpact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEImpact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEImpact} CMsgTEImpact
         */
        CMsgTEImpact.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEImpact)
                return object;
            var message = new $root.CMsgTEImpact();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEImpact.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.normal != null) {
                if (typeof object.normal !== "object")
                    throw TypeError(".CMsgTEImpact.normal: object expected");
                message.normal = $root.CMsgVector.fromObject(object.normal);
            }
            if (object.type != null)
                message.type = object.type >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEImpact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEImpact
         * @static
         * @param {CMsgTEImpact} message CMsgTEImpact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEImpact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.normal = null;
                object.type = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = $root.CMsgVector.toObject(message.normal, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };
    
        /**
         * Converts this CMsgTEImpact to JSON.
         * @function toJSON
         * @memberof CMsgTEImpact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEImpact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEImpact;
    })();
    
    $root.CMsgTEMuzzleFlash = (function() {
    
        /**
         * Properties of a CMsgTEMuzzleFlash.
         * @exports ICMsgTEMuzzleFlash
         * @interface ICMsgTEMuzzleFlash
         * @property {ICMsgVector|null} [origin] CMsgTEMuzzleFlash origin
         * @property {ICMsgQAngle|null} [angles] CMsgTEMuzzleFlash angles
         * @property {number|null} [scale] CMsgTEMuzzleFlash scale
         * @property {number|null} [type] CMsgTEMuzzleFlash type
         */
    
        /**
         * Constructs a new CMsgTEMuzzleFlash.
         * @exports CMsgTEMuzzleFlash
         * @classdesc Represents a CMsgTEMuzzleFlash.
         * @implements ICMsgTEMuzzleFlash
         * @constructor
         * @param {ICMsgTEMuzzleFlash=} [properties] Properties to set
         */
        function CMsgTEMuzzleFlash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEMuzzleFlash origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEMuzzleFlash
         * @instance
         */
        CMsgTEMuzzleFlash.prototype.origin = null;
    
        /**
         * CMsgTEMuzzleFlash angles.
         * @member {ICMsgQAngle|null|undefined} angles
         * @memberof CMsgTEMuzzleFlash
         * @instance
         */
        CMsgTEMuzzleFlash.prototype.angles = null;
    
        /**
         * CMsgTEMuzzleFlash scale.
         * @member {number} scale
         * @memberof CMsgTEMuzzleFlash
         * @instance
         */
        CMsgTEMuzzleFlash.prototype.scale = 0;
    
        /**
         * CMsgTEMuzzleFlash type.
         * @member {number} type
         * @memberof CMsgTEMuzzleFlash
         * @instance
         */
        CMsgTEMuzzleFlash.prototype.type = 0;
    
        /**
         * Creates a new CMsgTEMuzzleFlash instance using the specified properties.
         * @function create
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {ICMsgTEMuzzleFlash=} [properties] Properties to set
         * @returns {CMsgTEMuzzleFlash} CMsgTEMuzzleFlash instance
         */
        CMsgTEMuzzleFlash.create = function create(properties) {
            return new CMsgTEMuzzleFlash(properties);
        };
    
        /**
         * Encodes the specified CMsgTEMuzzleFlash message. Does not implicitly {@link CMsgTEMuzzleFlash.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {ICMsgTEMuzzleFlash} message CMsgTEMuzzleFlash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEMuzzleFlash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.angles != null && Object.hasOwnProperty.call(message, "angles"))
                $root.CMsgQAngle.encode(message.angles, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.scale);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.type);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEMuzzleFlash message, length delimited. Does not implicitly {@link CMsgTEMuzzleFlash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {ICMsgTEMuzzleFlash} message CMsgTEMuzzleFlash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEMuzzleFlash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEMuzzleFlash message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEMuzzleFlash} CMsgTEMuzzleFlash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEMuzzleFlash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEMuzzleFlash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.angles = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.scale = reader.float();
                    break;
                case 4:
                    message.type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEMuzzleFlash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEMuzzleFlash} CMsgTEMuzzleFlash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEMuzzleFlash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEMuzzleFlash message.
         * @function verify
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEMuzzleFlash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.angles != null && message.hasOwnProperty("angles")) {
                var error = $root.CMsgQAngle.verify(message.angles);
                if (error)
                    return "angles." + error;
            }
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEMuzzleFlash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEMuzzleFlash} CMsgTEMuzzleFlash
         */
        CMsgTEMuzzleFlash.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEMuzzleFlash)
                return object;
            var message = new $root.CMsgTEMuzzleFlash();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEMuzzleFlash.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.angles != null) {
                if (typeof object.angles !== "object")
                    throw TypeError(".CMsgTEMuzzleFlash.angles: object expected");
                message.angles = $root.CMsgQAngle.fromObject(object.angles);
            }
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.type != null)
                message.type = object.type >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEMuzzleFlash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEMuzzleFlash
         * @static
         * @param {CMsgTEMuzzleFlash} message CMsgTEMuzzleFlash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEMuzzleFlash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.angles = null;
                object.scale = 0;
                object.type = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.angles != null && message.hasOwnProperty("angles"))
                object.angles = $root.CMsgQAngle.toObject(message.angles, options);
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };
    
        /**
         * Converts this CMsgTEMuzzleFlash to JSON.
         * @function toJSON
         * @memberof CMsgTEMuzzleFlash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEMuzzleFlash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEMuzzleFlash;
    })();
    
    $root.CMsgTEBloodStream = (function() {
    
        /**
         * Properties of a CMsgTEBloodStream.
         * @exports ICMsgTEBloodStream
         * @interface ICMsgTEBloodStream
         * @property {ICMsgVector|null} [origin] CMsgTEBloodStream origin
         * @property {ICMsgVector|null} [direction] CMsgTEBloodStream direction
         * @property {number|null} [color] CMsgTEBloodStream color
         * @property {number|null} [amount] CMsgTEBloodStream amount
         */
    
        /**
         * Constructs a new CMsgTEBloodStream.
         * @exports CMsgTEBloodStream
         * @classdesc Represents a CMsgTEBloodStream.
         * @implements ICMsgTEBloodStream
         * @constructor
         * @param {ICMsgTEBloodStream=} [properties] Properties to set
         */
        function CMsgTEBloodStream(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEBloodStream origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEBloodStream
         * @instance
         */
        CMsgTEBloodStream.prototype.origin = null;
    
        /**
         * CMsgTEBloodStream direction.
         * @member {ICMsgVector|null|undefined} direction
         * @memberof CMsgTEBloodStream
         * @instance
         */
        CMsgTEBloodStream.prototype.direction = null;
    
        /**
         * CMsgTEBloodStream color.
         * @member {number} color
         * @memberof CMsgTEBloodStream
         * @instance
         */
        CMsgTEBloodStream.prototype.color = 0;
    
        /**
         * CMsgTEBloodStream amount.
         * @member {number} amount
         * @memberof CMsgTEBloodStream
         * @instance
         */
        CMsgTEBloodStream.prototype.amount = 0;
    
        /**
         * Creates a new CMsgTEBloodStream instance using the specified properties.
         * @function create
         * @memberof CMsgTEBloodStream
         * @static
         * @param {ICMsgTEBloodStream=} [properties] Properties to set
         * @returns {CMsgTEBloodStream} CMsgTEBloodStream instance
         */
        CMsgTEBloodStream.create = function create(properties) {
            return new CMsgTEBloodStream(properties);
        };
    
        /**
         * Encodes the specified CMsgTEBloodStream message. Does not implicitly {@link CMsgTEBloodStream.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEBloodStream
         * @static
         * @param {ICMsgTEBloodStream} message CMsgTEBloodStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBloodStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.CMsgVector.encode(message.direction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.color);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.amount);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEBloodStream message, length delimited. Does not implicitly {@link CMsgTEBloodStream.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEBloodStream
         * @static
         * @param {ICMsgTEBloodStream} message CMsgTEBloodStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEBloodStream.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEBloodStream message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEBloodStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEBloodStream} CMsgTEBloodStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBloodStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEBloodStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.direction = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.color = reader.fixed32();
                    break;
                case 4:
                    message.amount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEBloodStream message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEBloodStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEBloodStream} CMsgTEBloodStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEBloodStream.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEBloodStream message.
         * @function verify
         * @memberof CMsgTEBloodStream
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEBloodStream.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.CMsgVector.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEBloodStream message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEBloodStream
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEBloodStream} CMsgTEBloodStream
         */
        CMsgTEBloodStream.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEBloodStream)
                return object;
            var message = new $root.CMsgTEBloodStream();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEBloodStream.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".CMsgTEBloodStream.direction: object expected");
                message.direction = $root.CMsgVector.fromObject(object.direction);
            }
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEBloodStream message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEBloodStream
         * @static
         * @param {CMsgTEBloodStream} message CMsgTEBloodStream
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEBloodStream.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.direction = null;
                object.color = 0;
                object.amount = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.CMsgVector.toObject(message.direction, options);
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };
    
        /**
         * Converts this CMsgTEBloodStream to JSON.
         * @function toJSON
         * @memberof CMsgTEBloodStream
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEBloodStream.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEBloodStream;
    })();
    
    $root.CMsgTEExplosion = (function() {
    
        /**
         * Properties of a CMsgTEExplosion.
         * @exports ICMsgTEExplosion
         * @interface ICMsgTEExplosion
         * @property {ICMsgVector|null} [origin] CMsgTEExplosion origin
         * @property {number|null} [framerate] CMsgTEExplosion framerate
         * @property {number|null} [flags] CMsgTEExplosion flags
         * @property {ICMsgVector|null} [normal] CMsgTEExplosion normal
         * @property {number|null} [materialtype] CMsgTEExplosion materialtype
         * @property {number|null} [radius] CMsgTEExplosion radius
         * @property {number|null} [magnitude] CMsgTEExplosion magnitude
         * @property {number|null} [scale] CMsgTEExplosion scale
         * @property {boolean|null} [affect_ragdolls] CMsgTEExplosion affect_ragdolls
         * @property {string|null} [effect_name] CMsgTEExplosion effect_name
         * @property {number|null} [explosion_type] CMsgTEExplosion explosion_type
         */
    
        /**
         * Constructs a new CMsgTEExplosion.
         * @exports CMsgTEExplosion
         * @classdesc Represents a CMsgTEExplosion.
         * @implements ICMsgTEExplosion
         * @constructor
         * @param {ICMsgTEExplosion=} [properties] Properties to set
         */
        function CMsgTEExplosion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEExplosion origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.origin = null;
    
        /**
         * CMsgTEExplosion framerate.
         * @member {number} framerate
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.framerate = 0;
    
        /**
         * CMsgTEExplosion flags.
         * @member {number} flags
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.flags = 0;
    
        /**
         * CMsgTEExplosion normal.
         * @member {ICMsgVector|null|undefined} normal
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.normal = null;
    
        /**
         * CMsgTEExplosion materialtype.
         * @member {number} materialtype
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.materialtype = 0;
    
        /**
         * CMsgTEExplosion radius.
         * @member {number} radius
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.radius = 0;
    
        /**
         * CMsgTEExplosion magnitude.
         * @member {number} magnitude
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.magnitude = 0;
    
        /**
         * CMsgTEExplosion scale.
         * @member {number} scale
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.scale = 0;
    
        /**
         * CMsgTEExplosion affect_ragdolls.
         * @member {boolean} affect_ragdolls
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.affect_ragdolls = false;
    
        /**
         * CMsgTEExplosion effect_name.
         * @member {string} effect_name
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.effect_name = "";
    
        /**
         * CMsgTEExplosion explosion_type.
         * @member {number} explosion_type
         * @memberof CMsgTEExplosion
         * @instance
         */
        CMsgTEExplosion.prototype.explosion_type = 0;
    
        /**
         * Creates a new CMsgTEExplosion instance using the specified properties.
         * @function create
         * @memberof CMsgTEExplosion
         * @static
         * @param {ICMsgTEExplosion=} [properties] Properties to set
         * @returns {CMsgTEExplosion} CMsgTEExplosion instance
         */
        CMsgTEExplosion.create = function create(properties) {
            return new CMsgTEExplosion(properties);
        };
    
        /**
         * Encodes the specified CMsgTEExplosion message. Does not implicitly {@link CMsgTEExplosion.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEExplosion
         * @static
         * @param {ICMsgTEExplosion} message CMsgTEExplosion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEExplosion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.framerate != null && Object.hasOwnProperty.call(message, "framerate"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.framerate);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);
            if (message.normal != null && Object.hasOwnProperty.call(message, "normal"))
                $root.CMsgVector.encode(message.normal, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.materialtype != null && Object.hasOwnProperty.call(message, "materialtype"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.materialtype);
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.radius);
            if (message.magnitude != null && Object.hasOwnProperty.call(message, "magnitude"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.magnitude);
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.scale);
            if (message.affect_ragdolls != null && Object.hasOwnProperty.call(message, "affect_ragdolls"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.affect_ragdolls);
            if (message.effect_name != null && Object.hasOwnProperty.call(message, "effect_name"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.effect_name);
            if (message.explosion_type != null && Object.hasOwnProperty.call(message, "explosion_type"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.explosion_type);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEExplosion message, length delimited. Does not implicitly {@link CMsgTEExplosion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEExplosion
         * @static
         * @param {ICMsgTEExplosion} message CMsgTEExplosion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEExplosion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEExplosion message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEExplosion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEExplosion} CMsgTEExplosion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEExplosion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEExplosion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.framerate = reader.uint32();
                    break;
                case 3:
                    message.flags = reader.uint32();
                    break;
                case 4:
                    message.normal = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.materialtype = reader.uint32();
                    break;
                case 6:
                    message.radius = reader.uint32();
                    break;
                case 7:
                    message.magnitude = reader.uint32();
                    break;
                case 8:
                    message.scale = reader.float();
                    break;
                case 9:
                    message.affect_ragdolls = reader.bool();
                    break;
                case 10:
                    message.effect_name = reader.string();
                    break;
                case 11:
                    message.explosion_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEExplosion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEExplosion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEExplosion} CMsgTEExplosion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEExplosion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEExplosion message.
         * @function verify
         * @memberof CMsgTEExplosion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEExplosion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.framerate != null && message.hasOwnProperty("framerate"))
                if (!$util.isInteger(message.framerate))
                    return "framerate: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.normal != null && message.hasOwnProperty("normal")) {
                var error = $root.CMsgVector.verify(message.normal);
                if (error)
                    return "normal." + error;
            }
            if (message.materialtype != null && message.hasOwnProperty("materialtype"))
                if (!$util.isInteger(message.materialtype))
                    return "materialtype: integer expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (!$util.isInteger(message.radius))
                    return "radius: integer expected";
            if (message.magnitude != null && message.hasOwnProperty("magnitude"))
                if (!$util.isInteger(message.magnitude))
                    return "magnitude: integer expected";
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.affect_ragdolls != null && message.hasOwnProperty("affect_ragdolls"))
                if (typeof message.affect_ragdolls !== "boolean")
                    return "affect_ragdolls: boolean expected";
            if (message.effect_name != null && message.hasOwnProperty("effect_name"))
                if (!$util.isString(message.effect_name))
                    return "effect_name: string expected";
            if (message.explosion_type != null && message.hasOwnProperty("explosion_type"))
                if (!$util.isInteger(message.explosion_type))
                    return "explosion_type: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEExplosion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEExplosion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEExplosion} CMsgTEExplosion
         */
        CMsgTEExplosion.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEExplosion)
                return object;
            var message = new $root.CMsgTEExplosion();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEExplosion.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.framerate != null)
                message.framerate = object.framerate >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.normal != null) {
                if (typeof object.normal !== "object")
                    throw TypeError(".CMsgTEExplosion.normal: object expected");
                message.normal = $root.CMsgVector.fromObject(object.normal);
            }
            if (object.materialtype != null)
                message.materialtype = object.materialtype >>> 0;
            if (object.radius != null)
                message.radius = object.radius >>> 0;
            if (object.magnitude != null)
                message.magnitude = object.magnitude >>> 0;
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.affect_ragdolls != null)
                message.affect_ragdolls = Boolean(object.affect_ragdolls);
            if (object.effect_name != null)
                message.effect_name = String(object.effect_name);
            if (object.explosion_type != null)
                message.explosion_type = object.explosion_type >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEExplosion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEExplosion
         * @static
         * @param {CMsgTEExplosion} message CMsgTEExplosion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEExplosion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.framerate = 0;
                object.flags = 0;
                object.normal = null;
                object.materialtype = 0;
                object.radius = 0;
                object.magnitude = 0;
                object.scale = 0;
                object.affect_ragdolls = false;
                object.effect_name = "";
                object.explosion_type = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.framerate != null && message.hasOwnProperty("framerate"))
                object.framerate = message.framerate;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = $root.CMsgVector.toObject(message.normal, options);
            if (message.materialtype != null && message.hasOwnProperty("materialtype"))
                object.materialtype = message.materialtype;
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = message.radius;
            if (message.magnitude != null && message.hasOwnProperty("magnitude"))
                object.magnitude = message.magnitude;
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.affect_ragdolls != null && message.hasOwnProperty("affect_ragdolls"))
                object.affect_ragdolls = message.affect_ragdolls;
            if (message.effect_name != null && message.hasOwnProperty("effect_name"))
                object.effect_name = message.effect_name;
            if (message.explosion_type != null && message.hasOwnProperty("explosion_type"))
                object.explosion_type = message.explosion_type;
            return object;
        };
    
        /**
         * Converts this CMsgTEExplosion to JSON.
         * @function toJSON
         * @memberof CMsgTEExplosion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEExplosion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEExplosion;
    })();
    
    $root.CMsgTEDust = (function() {
    
        /**
         * Properties of a CMsgTEDust.
         * @exports ICMsgTEDust
         * @interface ICMsgTEDust
         * @property {ICMsgVector|null} [origin] CMsgTEDust origin
         * @property {number|null} [size] CMsgTEDust size
         * @property {number|null} [speed] CMsgTEDust speed
         * @property {ICMsgVector|null} [direction] CMsgTEDust direction
         */
    
        /**
         * Constructs a new CMsgTEDust.
         * @exports CMsgTEDust
         * @classdesc Represents a CMsgTEDust.
         * @implements ICMsgTEDust
         * @constructor
         * @param {ICMsgTEDust=} [properties] Properties to set
         */
        function CMsgTEDust(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEDust origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEDust
         * @instance
         */
        CMsgTEDust.prototype.origin = null;
    
        /**
         * CMsgTEDust size.
         * @member {number} size
         * @memberof CMsgTEDust
         * @instance
         */
        CMsgTEDust.prototype.size = 0;
    
        /**
         * CMsgTEDust speed.
         * @member {number} speed
         * @memberof CMsgTEDust
         * @instance
         */
        CMsgTEDust.prototype.speed = 0;
    
        /**
         * CMsgTEDust direction.
         * @member {ICMsgVector|null|undefined} direction
         * @memberof CMsgTEDust
         * @instance
         */
        CMsgTEDust.prototype.direction = null;
    
        /**
         * Creates a new CMsgTEDust instance using the specified properties.
         * @function create
         * @memberof CMsgTEDust
         * @static
         * @param {ICMsgTEDust=} [properties] Properties to set
         * @returns {CMsgTEDust} CMsgTEDust instance
         */
        CMsgTEDust.create = function create(properties) {
            return new CMsgTEDust(properties);
        };
    
        /**
         * Encodes the specified CMsgTEDust message. Does not implicitly {@link CMsgTEDust.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEDust
         * @static
         * @param {ICMsgTEDust} message CMsgTEDust message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEDust.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.size);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.speed);
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.CMsgVector.encode(message.direction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEDust message, length delimited. Does not implicitly {@link CMsgTEDust.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEDust
         * @static
         * @param {ICMsgTEDust} message CMsgTEDust message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEDust.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEDust message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEDust
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEDust} CMsgTEDust
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEDust.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEDust();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.size = reader.float();
                    break;
                case 3:
                    message.speed = reader.float();
                    break;
                case 4:
                    message.direction = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEDust message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEDust
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEDust} CMsgTEDust
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEDust.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEDust message.
         * @function verify
         * @memberof CMsgTEDust
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEDust.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size !== "number")
                    return "size: number expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (typeof message.speed !== "number")
                    return "speed: number expected";
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.CMsgVector.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTEDust message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEDust
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEDust} CMsgTEDust
         */
        CMsgTEDust.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEDust)
                return object;
            var message = new $root.CMsgTEDust();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEDust.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.size != null)
                message.size = Number(object.size);
            if (object.speed != null)
                message.speed = Number(object.speed);
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".CMsgTEDust.direction: object expected");
                message.direction = $root.CMsgVector.fromObject(object.direction);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEDust message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEDust
         * @static
         * @param {CMsgTEDust} message CMsgTEDust
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEDust.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.size = 0;
                object.speed = 0;
                object.direction = null;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = options.json && !isFinite(message.size) ? String(message.size) : message.size;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.CMsgVector.toObject(message.direction, options);
            return object;
        };
    
        /**
         * Converts this CMsgTEDust to JSON.
         * @function toJSON
         * @memberof CMsgTEDust
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEDust.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEDust;
    })();
    
    $root.CMsgTELargeFunnel = (function() {
    
        /**
         * Properties of a CMsgTELargeFunnel.
         * @exports ICMsgTELargeFunnel
         * @interface ICMsgTELargeFunnel
         * @property {ICMsgVector|null} [origin] CMsgTELargeFunnel origin
         * @property {number|null} [reversed] CMsgTELargeFunnel reversed
         */
    
        /**
         * Constructs a new CMsgTELargeFunnel.
         * @exports CMsgTELargeFunnel
         * @classdesc Represents a CMsgTELargeFunnel.
         * @implements ICMsgTELargeFunnel
         * @constructor
         * @param {ICMsgTELargeFunnel=} [properties] Properties to set
         */
        function CMsgTELargeFunnel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTELargeFunnel origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTELargeFunnel
         * @instance
         */
        CMsgTELargeFunnel.prototype.origin = null;
    
        /**
         * CMsgTELargeFunnel reversed.
         * @member {number} reversed
         * @memberof CMsgTELargeFunnel
         * @instance
         */
        CMsgTELargeFunnel.prototype.reversed = 0;
    
        /**
         * Creates a new CMsgTELargeFunnel instance using the specified properties.
         * @function create
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {ICMsgTELargeFunnel=} [properties] Properties to set
         * @returns {CMsgTELargeFunnel} CMsgTELargeFunnel instance
         */
        CMsgTELargeFunnel.create = function create(properties) {
            return new CMsgTELargeFunnel(properties);
        };
    
        /**
         * Encodes the specified CMsgTELargeFunnel message. Does not implicitly {@link CMsgTELargeFunnel.verify|verify} messages.
         * @function encode
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {ICMsgTELargeFunnel} message CMsgTELargeFunnel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTELargeFunnel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.reversed != null && Object.hasOwnProperty.call(message, "reversed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.reversed);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTELargeFunnel message, length delimited. Does not implicitly {@link CMsgTELargeFunnel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {ICMsgTELargeFunnel} message CMsgTELargeFunnel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTELargeFunnel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTELargeFunnel message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTELargeFunnel} CMsgTELargeFunnel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTELargeFunnel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTELargeFunnel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.reversed = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTELargeFunnel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTELargeFunnel} CMsgTELargeFunnel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTELargeFunnel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTELargeFunnel message.
         * @function verify
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTELargeFunnel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                if (!$util.isInteger(message.reversed))
                    return "reversed: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTELargeFunnel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTELargeFunnel} CMsgTELargeFunnel
         */
        CMsgTELargeFunnel.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTELargeFunnel)
                return object;
            var message = new $root.CMsgTELargeFunnel();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTELargeFunnel.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.reversed != null)
                message.reversed = object.reversed >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTELargeFunnel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTELargeFunnel
         * @static
         * @param {CMsgTELargeFunnel} message CMsgTELargeFunnel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTELargeFunnel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.reversed = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                object.reversed = message.reversed;
            return object;
        };
    
        /**
         * Converts this CMsgTELargeFunnel to JSON.
         * @function toJSON
         * @memberof CMsgTELargeFunnel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTELargeFunnel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTELargeFunnel;
    })();
    
    $root.CMsgTESparks = (function() {
    
        /**
         * Properties of a CMsgTESparks.
         * @exports ICMsgTESparks
         * @interface ICMsgTESparks
         * @property {ICMsgVector|null} [origin] CMsgTESparks origin
         * @property {number|null} [magnitude] CMsgTESparks magnitude
         * @property {number|null} [length] CMsgTESparks length
         * @property {ICMsgVector|null} [direction] CMsgTESparks direction
         */
    
        /**
         * Constructs a new CMsgTESparks.
         * @exports CMsgTESparks
         * @classdesc Represents a CMsgTESparks.
         * @implements ICMsgTESparks
         * @constructor
         * @param {ICMsgTESparks=} [properties] Properties to set
         */
        function CMsgTESparks(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTESparks origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTESparks
         * @instance
         */
        CMsgTESparks.prototype.origin = null;
    
        /**
         * CMsgTESparks magnitude.
         * @member {number} magnitude
         * @memberof CMsgTESparks
         * @instance
         */
        CMsgTESparks.prototype.magnitude = 0;
    
        /**
         * CMsgTESparks length.
         * @member {number} length
         * @memberof CMsgTESparks
         * @instance
         */
        CMsgTESparks.prototype.length = 0;
    
        /**
         * CMsgTESparks direction.
         * @member {ICMsgVector|null|undefined} direction
         * @memberof CMsgTESparks
         * @instance
         */
        CMsgTESparks.prototype.direction = null;
    
        /**
         * Creates a new CMsgTESparks instance using the specified properties.
         * @function create
         * @memberof CMsgTESparks
         * @static
         * @param {ICMsgTESparks=} [properties] Properties to set
         * @returns {CMsgTESparks} CMsgTESparks instance
         */
        CMsgTESparks.create = function create(properties) {
            return new CMsgTESparks(properties);
        };
    
        /**
         * Encodes the specified CMsgTESparks message. Does not implicitly {@link CMsgTESparks.verify|verify} messages.
         * @function encode
         * @memberof CMsgTESparks
         * @static
         * @param {ICMsgTESparks} message CMsgTESparks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTESparks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.magnitude != null && Object.hasOwnProperty.call(message, "magnitude"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.magnitude);
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.length);
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.CMsgVector.encode(message.direction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTESparks message, length delimited. Does not implicitly {@link CMsgTESparks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTESparks
         * @static
         * @param {ICMsgTESparks} message CMsgTESparks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTESparks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTESparks message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTESparks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTESparks} CMsgTESparks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTESparks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTESparks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.magnitude = reader.uint32();
                    break;
                case 3:
                    message.length = reader.uint32();
                    break;
                case 4:
                    message.direction = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTESparks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTESparks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTESparks} CMsgTESparks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTESparks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTESparks message.
         * @function verify
         * @memberof CMsgTESparks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTESparks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.magnitude != null && message.hasOwnProperty("magnitude"))
                if (!$util.isInteger(message.magnitude))
                    return "magnitude: integer expected";
            if (message.length != null && message.hasOwnProperty("length"))
                if (!$util.isInteger(message.length))
                    return "length: integer expected";
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.CMsgVector.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTESparks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTESparks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTESparks} CMsgTESparks
         */
        CMsgTESparks.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTESparks)
                return object;
            var message = new $root.CMsgTESparks();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTESparks.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.magnitude != null)
                message.magnitude = object.magnitude >>> 0;
            if (object.length != null)
                message.length = object.length >>> 0;
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".CMsgTESparks.direction: object expected");
                message.direction = $root.CMsgVector.fromObject(object.direction);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTESparks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTESparks
         * @static
         * @param {CMsgTESparks} message CMsgTESparks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTESparks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.magnitude = 0;
                object.length = 0;
                object.direction = null;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.magnitude != null && message.hasOwnProperty("magnitude"))
                object.magnitude = message.magnitude;
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = message.length;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.CMsgVector.toObject(message.direction, options);
            return object;
        };
    
        /**
         * Converts this CMsgTESparks to JSON.
         * @function toJSON
         * @memberof CMsgTESparks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTESparks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTESparks;
    })();
    
    $root.CMsgTEPhysicsProp = (function() {
    
        /**
         * Properties of a CMsgTEPhysicsProp.
         * @exports ICMsgTEPhysicsProp
         * @interface ICMsgTEPhysicsProp
         * @property {ICMsgVector|null} [origin] CMsgTEPhysicsProp origin
         * @property {ICMsgVector|null} [velocity] CMsgTEPhysicsProp velocity
         * @property {ICMsgQAngle|null} [angles] CMsgTEPhysicsProp angles
         * @property {number|null} [skin] CMsgTEPhysicsProp skin
         * @property {number|null} [flags] CMsgTEPhysicsProp flags
         * @property {number|null} [effects] CMsgTEPhysicsProp effects
         * @property {number|null} [color] CMsgTEPhysicsProp color
         * @property {number|Long|null} [modelindex] CMsgTEPhysicsProp modelindex
         * @property {number|null} [unused_breakmodelsnottomake] CMsgTEPhysicsProp unused_breakmodelsnottomake
         * @property {number|null} [scale] CMsgTEPhysicsProp scale
         */
    
        /**
         * Constructs a new CMsgTEPhysicsProp.
         * @exports CMsgTEPhysicsProp
         * @classdesc Represents a CMsgTEPhysicsProp.
         * @implements ICMsgTEPhysicsProp
         * @constructor
         * @param {ICMsgTEPhysicsProp=} [properties] Properties to set
         */
        function CMsgTEPhysicsProp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEPhysicsProp origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.origin = null;
    
        /**
         * CMsgTEPhysicsProp velocity.
         * @member {ICMsgVector|null|undefined} velocity
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.velocity = null;
    
        /**
         * CMsgTEPhysicsProp angles.
         * @member {ICMsgQAngle|null|undefined} angles
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.angles = null;
    
        /**
         * CMsgTEPhysicsProp skin.
         * @member {number} skin
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.skin = 0;
    
        /**
         * CMsgTEPhysicsProp flags.
         * @member {number} flags
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.flags = 0;
    
        /**
         * CMsgTEPhysicsProp effects.
         * @member {number} effects
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.effects = 0;
    
        /**
         * CMsgTEPhysicsProp color.
         * @member {number} color
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.color = 0;
    
        /**
         * CMsgTEPhysicsProp modelindex.
         * @member {number|Long} modelindex
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.modelindex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgTEPhysicsProp unused_breakmodelsnottomake.
         * @member {number} unused_breakmodelsnottomake
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.unused_breakmodelsnottomake = 0;
    
        /**
         * CMsgTEPhysicsProp scale.
         * @member {number} scale
         * @memberof CMsgTEPhysicsProp
         * @instance
         */
        CMsgTEPhysicsProp.prototype.scale = 0;
    
        /**
         * Creates a new CMsgTEPhysicsProp instance using the specified properties.
         * @function create
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {ICMsgTEPhysicsProp=} [properties] Properties to set
         * @returns {CMsgTEPhysicsProp} CMsgTEPhysicsProp instance
         */
        CMsgTEPhysicsProp.create = function create(properties) {
            return new CMsgTEPhysicsProp(properties);
        };
    
        /**
         * Encodes the specified CMsgTEPhysicsProp message. Does not implicitly {@link CMsgTEPhysicsProp.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {ICMsgTEPhysicsProp} message CMsgTEPhysicsProp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEPhysicsProp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                $root.CMsgVector.encode(message.velocity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.angles != null && Object.hasOwnProperty.call(message, "angles"))
                $root.CMsgQAngle.encode(message.angles, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.skin);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.flags);
            if (message.effects != null && Object.hasOwnProperty.call(message, "effects"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.effects);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.color);
            if (message.modelindex != null && Object.hasOwnProperty.call(message, "modelindex"))
                writer.uint32(/* id 8, wireType 1 =*/65).fixed64(message.modelindex);
            if (message.unused_breakmodelsnottomake != null && Object.hasOwnProperty.call(message, "unused_breakmodelsnottomake"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.unused_breakmodelsnottomake);
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.scale);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEPhysicsProp message, length delimited. Does not implicitly {@link CMsgTEPhysicsProp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {ICMsgTEPhysicsProp} message CMsgTEPhysicsProp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEPhysicsProp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEPhysicsProp message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEPhysicsProp} CMsgTEPhysicsProp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEPhysicsProp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEPhysicsProp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.velocity = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.angles = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.skin = reader.fixed32();
                    break;
                case 5:
                    message.flags = reader.uint32();
                    break;
                case 6:
                    message.effects = reader.uint32();
                    break;
                case 7:
                    message.color = reader.fixed32();
                    break;
                case 8:
                    message.modelindex = reader.fixed64();
                    break;
                case 9:
                    message.unused_breakmodelsnottomake = reader.uint32();
                    break;
                case 10:
                    message.scale = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEPhysicsProp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEPhysicsProp} CMsgTEPhysicsProp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEPhysicsProp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEPhysicsProp message.
         * @function verify
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEPhysicsProp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.velocity != null && message.hasOwnProperty("velocity")) {
                var error = $root.CMsgVector.verify(message.velocity);
                if (error)
                    return "velocity." + error;
            }
            if (message.angles != null && message.hasOwnProperty("angles")) {
                var error = $root.CMsgQAngle.verify(message.angles);
                if (error)
                    return "angles." + error;
            }
            if (message.skin != null && message.hasOwnProperty("skin"))
                if (!$util.isInteger(message.skin))
                    return "skin: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.effects != null && message.hasOwnProperty("effects"))
                if (!$util.isInteger(message.effects))
                    return "effects: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.modelindex != null && message.hasOwnProperty("modelindex"))
                if (!$util.isInteger(message.modelindex) && !(message.modelindex && $util.isInteger(message.modelindex.low) && $util.isInteger(message.modelindex.high)))
                    return "modelindex: integer|Long expected";
            if (message.unused_breakmodelsnottomake != null && message.hasOwnProperty("unused_breakmodelsnottomake"))
                if (!$util.isInteger(message.unused_breakmodelsnottomake))
                    return "unused_breakmodelsnottomake: integer expected";
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEPhysicsProp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEPhysicsProp} CMsgTEPhysicsProp
         */
        CMsgTEPhysicsProp.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEPhysicsProp)
                return object;
            var message = new $root.CMsgTEPhysicsProp();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEPhysicsProp.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.velocity != null) {
                if (typeof object.velocity !== "object")
                    throw TypeError(".CMsgTEPhysicsProp.velocity: object expected");
                message.velocity = $root.CMsgVector.fromObject(object.velocity);
            }
            if (object.angles != null) {
                if (typeof object.angles !== "object")
                    throw TypeError(".CMsgTEPhysicsProp.angles: object expected");
                message.angles = $root.CMsgQAngle.fromObject(object.angles);
            }
            if (object.skin != null)
                message.skin = object.skin >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.effects != null)
                message.effects = object.effects >>> 0;
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.modelindex != null)
                if ($util.Long)
                    (message.modelindex = $util.Long.fromValue(object.modelindex)).unsigned = false;
                else if (typeof object.modelindex === "string")
                    message.modelindex = parseInt(object.modelindex, 10);
                else if (typeof object.modelindex === "number")
                    message.modelindex = object.modelindex;
                else if (typeof object.modelindex === "object")
                    message.modelindex = new $util.LongBits(object.modelindex.low >>> 0, object.modelindex.high >>> 0).toNumber();
            if (object.unused_breakmodelsnottomake != null)
                message.unused_breakmodelsnottomake = object.unused_breakmodelsnottomake >>> 0;
            if (object.scale != null)
                message.scale = Number(object.scale);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEPhysicsProp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEPhysicsProp
         * @static
         * @param {CMsgTEPhysicsProp} message CMsgTEPhysicsProp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEPhysicsProp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.velocity = null;
                object.angles = null;
                object.skin = 0;
                object.flags = 0;
                object.effects = 0;
                object.color = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.modelindex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.modelindex = options.longs === String ? "0" : 0;
                object.unused_breakmodelsnottomake = 0;
                object.scale = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.velocity != null && message.hasOwnProperty("velocity"))
                object.velocity = $root.CMsgVector.toObject(message.velocity, options);
            if (message.angles != null && message.hasOwnProperty("angles"))
                object.angles = $root.CMsgQAngle.toObject(message.angles, options);
            if (message.skin != null && message.hasOwnProperty("skin"))
                object.skin = message.skin;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.effects != null && message.hasOwnProperty("effects"))
                object.effects = message.effects;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.modelindex != null && message.hasOwnProperty("modelindex"))
                if (typeof message.modelindex === "number")
                    object.modelindex = options.longs === String ? String(message.modelindex) : message.modelindex;
                else
                    object.modelindex = options.longs === String ? $util.Long.prototype.toString.call(message.modelindex) : options.longs === Number ? new $util.LongBits(message.modelindex.low >>> 0, message.modelindex.high >>> 0).toNumber() : message.modelindex;
            if (message.unused_breakmodelsnottomake != null && message.hasOwnProperty("unused_breakmodelsnottomake"))
                object.unused_breakmodelsnottomake = message.unused_breakmodelsnottomake;
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            return object;
        };
    
        /**
         * Converts this CMsgTEPhysicsProp to JSON.
         * @function toJSON
         * @memberof CMsgTEPhysicsProp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEPhysicsProp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEPhysicsProp;
    })();
    
    $root.CMsgTEPlayerDecal = (function() {
    
        /**
         * Properties of a CMsgTEPlayerDecal.
         * @exports ICMsgTEPlayerDecal
         * @interface ICMsgTEPlayerDecal
         * @property {ICMsgVector|null} [origin] CMsgTEPlayerDecal origin
         * @property {number|null} [player] CMsgTEPlayerDecal player
         * @property {number|null} [entity] CMsgTEPlayerDecal entity
         */
    
        /**
         * Constructs a new CMsgTEPlayerDecal.
         * @exports CMsgTEPlayerDecal
         * @classdesc Represents a CMsgTEPlayerDecal.
         * @implements ICMsgTEPlayerDecal
         * @constructor
         * @param {ICMsgTEPlayerDecal=} [properties] Properties to set
         */
        function CMsgTEPlayerDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEPlayerDecal origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEPlayerDecal
         * @instance
         */
        CMsgTEPlayerDecal.prototype.origin = null;
    
        /**
         * CMsgTEPlayerDecal player.
         * @member {number} player
         * @memberof CMsgTEPlayerDecal
         * @instance
         */
        CMsgTEPlayerDecal.prototype.player = 0;
    
        /**
         * CMsgTEPlayerDecal entity.
         * @member {number} entity
         * @memberof CMsgTEPlayerDecal
         * @instance
         */
        CMsgTEPlayerDecal.prototype.entity = 0;
    
        /**
         * Creates a new CMsgTEPlayerDecal instance using the specified properties.
         * @function create
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {ICMsgTEPlayerDecal=} [properties] Properties to set
         * @returns {CMsgTEPlayerDecal} CMsgTEPlayerDecal instance
         */
        CMsgTEPlayerDecal.create = function create(properties) {
            return new CMsgTEPlayerDecal(properties);
        };
    
        /**
         * Encodes the specified CMsgTEPlayerDecal message. Does not implicitly {@link CMsgTEPlayerDecal.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {ICMsgTEPlayerDecal} message CMsgTEPlayerDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEPlayerDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.player);
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entity);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEPlayerDecal message, length delimited. Does not implicitly {@link CMsgTEPlayerDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {ICMsgTEPlayerDecal} message CMsgTEPlayerDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEPlayerDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEPlayerDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEPlayerDecal} CMsgTEPlayerDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEPlayerDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEPlayerDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.player = reader.uint32();
                    break;
                case 3:
                    message.entity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEPlayerDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEPlayerDecal} CMsgTEPlayerDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEPlayerDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEPlayerDecal message.
         * @function verify
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEPlayerDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.player != null && message.hasOwnProperty("player"))
                if (!$util.isInteger(message.player))
                    return "player: integer expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isInteger(message.entity))
                    return "entity: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEPlayerDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEPlayerDecal} CMsgTEPlayerDecal
         */
        CMsgTEPlayerDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEPlayerDecal)
                return object;
            var message = new $root.CMsgTEPlayerDecal();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEPlayerDecal.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.player != null)
                message.player = object.player >>> 0;
            if (object.entity != null)
                message.entity = object.entity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEPlayerDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEPlayerDecal
         * @static
         * @param {CMsgTEPlayerDecal} message CMsgTEPlayerDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEPlayerDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.player = 0;
                object.entity = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = message.player;
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            return object;
        };
    
        /**
         * Converts this CMsgTEPlayerDecal to JSON.
         * @function toJSON
         * @memberof CMsgTEPlayerDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEPlayerDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEPlayerDecal;
    })();
    
    $root.CMsgTEProjectedDecal = (function() {
    
        /**
         * Properties of a CMsgTEProjectedDecal.
         * @exports ICMsgTEProjectedDecal
         * @interface ICMsgTEProjectedDecal
         * @property {ICMsgVector|null} [origin] CMsgTEProjectedDecal origin
         * @property {ICMsgQAngle|null} [angles] CMsgTEProjectedDecal angles
         * @property {number|null} [index] CMsgTEProjectedDecal index
         * @property {number|null} [distance] CMsgTEProjectedDecal distance
         */
    
        /**
         * Constructs a new CMsgTEProjectedDecal.
         * @exports CMsgTEProjectedDecal
         * @classdesc Represents a CMsgTEProjectedDecal.
         * @implements ICMsgTEProjectedDecal
         * @constructor
         * @param {ICMsgTEProjectedDecal=} [properties] Properties to set
         */
        function CMsgTEProjectedDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEProjectedDecal origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEProjectedDecal
         * @instance
         */
        CMsgTEProjectedDecal.prototype.origin = null;
    
        /**
         * CMsgTEProjectedDecal angles.
         * @member {ICMsgQAngle|null|undefined} angles
         * @memberof CMsgTEProjectedDecal
         * @instance
         */
        CMsgTEProjectedDecal.prototype.angles = null;
    
        /**
         * CMsgTEProjectedDecal index.
         * @member {number} index
         * @memberof CMsgTEProjectedDecal
         * @instance
         */
        CMsgTEProjectedDecal.prototype.index = 0;
    
        /**
         * CMsgTEProjectedDecal distance.
         * @member {number} distance
         * @memberof CMsgTEProjectedDecal
         * @instance
         */
        CMsgTEProjectedDecal.prototype.distance = 0;
    
        /**
         * Creates a new CMsgTEProjectedDecal instance using the specified properties.
         * @function create
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {ICMsgTEProjectedDecal=} [properties] Properties to set
         * @returns {CMsgTEProjectedDecal} CMsgTEProjectedDecal instance
         */
        CMsgTEProjectedDecal.create = function create(properties) {
            return new CMsgTEProjectedDecal(properties);
        };
    
        /**
         * Encodes the specified CMsgTEProjectedDecal message. Does not implicitly {@link CMsgTEProjectedDecal.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {ICMsgTEProjectedDecal} message CMsgTEProjectedDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEProjectedDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.angles != null && Object.hasOwnProperty.call(message, "angles"))
                $root.CMsgQAngle.encode(message.angles, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.index);
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEProjectedDecal message, length delimited. Does not implicitly {@link CMsgTEProjectedDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {ICMsgTEProjectedDecal} message CMsgTEProjectedDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEProjectedDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEProjectedDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEProjectedDecal} CMsgTEProjectedDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEProjectedDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEProjectedDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.angles = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.index = reader.uint32();
                    break;
                case 4:
                    message.distance = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEProjectedDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEProjectedDecal} CMsgTEProjectedDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEProjectedDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEProjectedDecal message.
         * @function verify
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEProjectedDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.angles != null && message.hasOwnProperty("angles")) {
                var error = $root.CMsgQAngle.verify(message.angles);
                if (error)
                    return "angles." + error;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEProjectedDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEProjectedDecal} CMsgTEProjectedDecal
         */
        CMsgTEProjectedDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEProjectedDecal)
                return object;
            var message = new $root.CMsgTEProjectedDecal();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEProjectedDecal.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.angles != null) {
                if (typeof object.angles !== "object")
                    throw TypeError(".CMsgTEProjectedDecal.angles: object expected");
                message.angles = $root.CMsgQAngle.fromObject(object.angles);
            }
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.distance != null)
                message.distance = Number(object.distance);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEProjectedDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEProjectedDecal
         * @static
         * @param {CMsgTEProjectedDecal} message CMsgTEProjectedDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEProjectedDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.angles = null;
                object.index = 0;
                object.distance = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.angles != null && message.hasOwnProperty("angles"))
                object.angles = $root.CMsgQAngle.toObject(message.angles, options);
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.distance != null && message.hasOwnProperty("distance"))
                object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
            return object;
        };
    
        /**
         * Converts this CMsgTEProjectedDecal to JSON.
         * @function toJSON
         * @memberof CMsgTEProjectedDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEProjectedDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEProjectedDecal;
    })();
    
    $root.CMsgTESmoke = (function() {
    
        /**
         * Properties of a CMsgTESmoke.
         * @exports ICMsgTESmoke
         * @interface ICMsgTESmoke
         * @property {ICMsgVector|null} [origin] CMsgTESmoke origin
         * @property {number|null} [scale] CMsgTESmoke scale
         */
    
        /**
         * Constructs a new CMsgTESmoke.
         * @exports CMsgTESmoke
         * @classdesc Represents a CMsgTESmoke.
         * @implements ICMsgTESmoke
         * @constructor
         * @param {ICMsgTESmoke=} [properties] Properties to set
         */
        function CMsgTESmoke(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTESmoke origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTESmoke
         * @instance
         */
        CMsgTESmoke.prototype.origin = null;
    
        /**
         * CMsgTESmoke scale.
         * @member {number} scale
         * @memberof CMsgTESmoke
         * @instance
         */
        CMsgTESmoke.prototype.scale = 0;
    
        /**
         * Creates a new CMsgTESmoke instance using the specified properties.
         * @function create
         * @memberof CMsgTESmoke
         * @static
         * @param {ICMsgTESmoke=} [properties] Properties to set
         * @returns {CMsgTESmoke} CMsgTESmoke instance
         */
        CMsgTESmoke.create = function create(properties) {
            return new CMsgTESmoke(properties);
        };
    
        /**
         * Encodes the specified CMsgTESmoke message. Does not implicitly {@link CMsgTESmoke.verify|verify} messages.
         * @function encode
         * @memberof CMsgTESmoke
         * @static
         * @param {ICMsgTESmoke} message CMsgTESmoke message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTESmoke.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.scale);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTESmoke message, length delimited. Does not implicitly {@link CMsgTESmoke.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTESmoke
         * @static
         * @param {ICMsgTESmoke} message CMsgTESmoke message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTESmoke.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTESmoke message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTESmoke
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTESmoke} CMsgTESmoke
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTESmoke.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTESmoke();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.scale = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTESmoke message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTESmoke
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTESmoke} CMsgTESmoke
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTESmoke.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTESmoke message.
         * @function verify
         * @memberof CMsgTESmoke
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTESmoke.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgTESmoke message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTESmoke
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTESmoke} CMsgTESmoke
         */
        CMsgTESmoke.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTESmoke)
                return object;
            var message = new $root.CMsgTESmoke();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTESmoke.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.scale != null)
                message.scale = Number(object.scale);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTESmoke message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTESmoke
         * @static
         * @param {CMsgTESmoke} message CMsgTESmoke
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTESmoke.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.scale = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            return object;
        };
    
        /**
         * Converts this CMsgTESmoke to JSON.
         * @function toJSON
         * @memberof CMsgTESmoke
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTESmoke.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTESmoke;
    })();
    
    $root.CMsgTEWorldDecal = (function() {
    
        /**
         * Properties of a CMsgTEWorldDecal.
         * @exports ICMsgTEWorldDecal
         * @interface ICMsgTEWorldDecal
         * @property {ICMsgVector|null} [origin] CMsgTEWorldDecal origin
         * @property {ICMsgVector|null} [normal] CMsgTEWorldDecal normal
         * @property {number|null} [index] CMsgTEWorldDecal index
         */
    
        /**
         * Constructs a new CMsgTEWorldDecal.
         * @exports CMsgTEWorldDecal
         * @classdesc Represents a CMsgTEWorldDecal.
         * @implements ICMsgTEWorldDecal
         * @constructor
         * @param {ICMsgTEWorldDecal=} [properties] Properties to set
         */
        function CMsgTEWorldDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTEWorldDecal origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CMsgTEWorldDecal
         * @instance
         */
        CMsgTEWorldDecal.prototype.origin = null;
    
        /**
         * CMsgTEWorldDecal normal.
         * @member {ICMsgVector|null|undefined} normal
         * @memberof CMsgTEWorldDecal
         * @instance
         */
        CMsgTEWorldDecal.prototype.normal = null;
    
        /**
         * CMsgTEWorldDecal index.
         * @member {number} index
         * @memberof CMsgTEWorldDecal
         * @instance
         */
        CMsgTEWorldDecal.prototype.index = 0;
    
        /**
         * Creates a new CMsgTEWorldDecal instance using the specified properties.
         * @function create
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {ICMsgTEWorldDecal=} [properties] Properties to set
         * @returns {CMsgTEWorldDecal} CMsgTEWorldDecal instance
         */
        CMsgTEWorldDecal.create = function create(properties) {
            return new CMsgTEWorldDecal(properties);
        };
    
        /**
         * Encodes the specified CMsgTEWorldDecal message. Does not implicitly {@link CMsgTEWorldDecal.verify|verify} messages.
         * @function encode
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {ICMsgTEWorldDecal} message CMsgTEWorldDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEWorldDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.normal != null && Object.hasOwnProperty.call(message, "normal"))
                $root.CMsgVector.encode(message.normal, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.index);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTEWorldDecal message, length delimited. Does not implicitly {@link CMsgTEWorldDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {ICMsgTEWorldDecal} message CMsgTEWorldDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTEWorldDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTEWorldDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTEWorldDecal} CMsgTEWorldDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEWorldDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTEWorldDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.normal = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTEWorldDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTEWorldDecal} CMsgTEWorldDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTEWorldDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTEWorldDecal message.
         * @function verify
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTEWorldDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.normal != null && message.hasOwnProperty("normal")) {
                var error = $root.CMsgVector.verify(message.normal);
                if (error)
                    return "normal." + error;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgTEWorldDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTEWorldDecal} CMsgTEWorldDecal
         */
        CMsgTEWorldDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTEWorldDecal)
                return object;
            var message = new $root.CMsgTEWorldDecal();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CMsgTEWorldDecal.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.normal != null) {
                if (typeof object.normal !== "object")
                    throw TypeError(".CMsgTEWorldDecal.normal: object expected");
                message.normal = $root.CMsgVector.fromObject(object.normal);
            }
            if (object.index != null)
                message.index = object.index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTEWorldDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTEWorldDecal
         * @static
         * @param {CMsgTEWorldDecal} message CMsgTEWorldDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTEWorldDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.normal = null;
                object.index = 0;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = $root.CMsgVector.toObject(message.normal, options);
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };
    
        /**
         * Converts this CMsgTEWorldDecal to JSON.
         * @function toJSON
         * @memberof CMsgTEWorldDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTEWorldDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgTEWorldDecal;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.userid = reader.int32();
                    break;
                case 4:
                    message.steamid = reader.fixed64();
                    break;
                case 5:
                    message.fakeplayer = reader.bool();
                    break;
                case 6:
                    message.ishltv = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [target_entity] CEntityMsg target_entity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg target_entity.
         * @member {number} target_entity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.target_entity = 0;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entity != null && Object.hasOwnProperty.call(message, "target_entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                if (!$util.isInteger(message.target_entity))
                    return "target_entity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.target_entity != null)
                message.target_entity = object.target_entity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.target_entity = 0;
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                object.target_entity = message.target_entity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW":
            case 70:
                message.reason = 70;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [host_frametime] CNETMsg_Tick host_frametime
         * @property {number|null} [host_frametime_std_deviation] CNETMsg_Tick host_frametime_std_deviation
         * @property {number|null} [host_computationtime] CNETMsg_Tick host_computationtime
         * @property {number|null} [host_computationtime_std_deviation] CNETMsg_Tick host_computationtime_std_deviation
         * @property {number|null} [host_framestarttime_std_deviation] CNETMsg_Tick host_framestarttime_std_deviation
         * @property {number|null} [host_loss] CNETMsg_Tick host_loss
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick host_frametime.
         * @member {number} host_frametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime = 0;
    
        /**
         * CNETMsg_Tick host_frametime_std_deviation.
         * @member {number} host_frametime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_computationtime.
         * @member {number} host_computationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime = 0;
    
        /**
         * CNETMsg_Tick host_computationtime_std_deviation.
         * @member {number} host_computationtime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_framestarttime_std_deviation.
         * @member {number} host_framestarttime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_framestarttime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_loss.
         * @member {number} host_loss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_loss = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.host_frametime != null && Object.hasOwnProperty.call(message, "host_frametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.host_frametime);
            if (message.host_frametime_std_deviation != null && Object.hasOwnProperty.call(message, "host_frametime_std_deviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.host_frametime_std_deviation);
            if (message.host_computationtime != null && Object.hasOwnProperty.call(message, "host_computationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.host_computationtime);
            if (message.host_computationtime_std_deviation != null && Object.hasOwnProperty.call(message, "host_computationtime_std_deviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.host_computationtime_std_deviation);
            if (message.host_framestarttime_std_deviation != null && Object.hasOwnProperty.call(message, "host_framestarttime_std_deviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.host_framestarttime_std_deviation);
            if (message.host_loss != null && Object.hasOwnProperty.call(message, "host_loss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.host_loss);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 2:
                    message.host_frametime = reader.uint32();
                    break;
                case 3:
                    message.host_frametime_std_deviation = reader.uint32();
                    break;
                case 4:
                    message.host_computationtime = reader.uint32();
                    break;
                case 5:
                    message.host_computationtime_std_deviation = reader.uint32();
                    break;
                case 6:
                    message.host_framestarttime_std_deviation = reader.uint32();
                    break;
                case 7:
                    message.host_loss = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                if (!$util.isInteger(message.host_frametime))
                    return "host_frametime: integer expected";
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                if (!$util.isInteger(message.host_frametime_std_deviation))
                    return "host_frametime_std_deviation: integer expected";
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                if (!$util.isInteger(message.host_computationtime))
                    return "host_computationtime: integer expected";
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                if (!$util.isInteger(message.host_computationtime_std_deviation))
                    return "host_computationtime_std_deviation: integer expected";
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                if (!$util.isInteger(message.host_framestarttime_std_deviation))
                    return "host_framestarttime_std_deviation: integer expected";
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                if (!$util.isInteger(message.host_loss))
                    return "host_loss: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.host_frametime != null)
                message.host_frametime = object.host_frametime >>> 0;
            if (object.host_frametime_std_deviation != null)
                message.host_frametime_std_deviation = object.host_frametime_std_deviation >>> 0;
            if (object.host_computationtime != null)
                message.host_computationtime = object.host_computationtime >>> 0;
            if (object.host_computationtime_std_deviation != null)
                message.host_computationtime_std_deviation = object.host_computationtime_std_deviation >>> 0;
            if (object.host_framestarttime_std_deviation != null)
                message.host_framestarttime_std_deviation = object.host_framestarttime_std_deviation >>> 0;
            if (object.host_loss != null)
                message.host_loss = object.host_loss >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.host_frametime = 0;
                object.host_frametime_std_deviation = 0;
                object.host_computationtime = 0;
                object.host_computationtime_std_deviation = 0;
                object.host_framestarttime_std_deviation = 0;
                object.host_loss = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                object.host_frametime = message.host_frametime;
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                object.host_frametime_std_deviation = message.host_frametime_std_deviation;
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                object.host_computationtime = message.host_computationtime;
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                object.host_computationtime_std_deviation = message.host_computationtime_std_deviation;
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                object.host_framestarttime_std_deviation = message.host_framestarttime_std_deviation;
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                object.host_loss = message.host_loss;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signon_state] CNETMsg_SignonState signon_state
         * @property {number|null} [spawn_count] CNETMsg_SignonState spawn_count
         * @property {number|null} [num_server_players] CNETMsg_SignonState num_server_players
         * @property {Array.<string>|null} [players_networkids] CNETMsg_SignonState players_networkids
         * @property {string|null} [map_name] CNETMsg_SignonState map_name
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.players_networkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signon_state.
         * @member {SignonState_t} signon_state
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signon_state = 0;
    
        /**
         * CNETMsg_SignonState spawn_count.
         * @member {number} spawn_count
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawn_count = 0;
    
        /**
         * CNETMsg_SignonState num_server_players.
         * @member {number} num_server_players
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.num_server_players = 0;
    
        /**
         * CNETMsg_SignonState players_networkids.
         * @member {Array.<string>} players_networkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.players_networkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState map_name.
         * @member {string} map_name
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.map_name = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signon_state != null && Object.hasOwnProperty.call(message, "signon_state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signon_state);
            if (message.spawn_count != null && Object.hasOwnProperty.call(message, "spawn_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawn_count);
            if (message.num_server_players != null && Object.hasOwnProperty.call(message, "num_server_players"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_server_players);
            if (message.players_networkids != null && message.players_networkids.length)
                for (var i = 0; i < message.players_networkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.players_networkids[i]);
            if (message.map_name != null && Object.hasOwnProperty.call(message, "map_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.map_name);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signon_state = reader.int32();
                    break;
                case 2:
                    message.spawn_count = reader.uint32();
                    break;
                case 3:
                    message.num_server_players = reader.uint32();
                    break;
                case 4:
                    if (!(message.players_networkids && message.players_networkids.length))
                        message.players_networkids = [];
                    message.players_networkids.push(reader.string());
                    break;
                case 5:
                    message.map_name = reader.string();
                    break;
                case 6:
                    message.addons = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                switch (message.signon_state) {
                default:
                    return "signon_state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                if (!$util.isInteger(message.num_server_players))
                    return "num_server_players: integer expected";
            if (message.players_networkids != null && message.hasOwnProperty("players_networkids")) {
                if (!Array.isArray(message.players_networkids))
                    return "players_networkids: array expected";
                for (var i = 0; i < message.players_networkids.length; ++i)
                    if (!$util.isString(message.players_networkids[i]))
                        return "players_networkids: string[] expected";
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signon_state) {
            case "SIGNONSTATE_NONE":
            case 0:
                message.signon_state = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signon_state = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signon_state = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signon_state = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signon_state = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signon_state = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signon_state = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signon_state = 7;
                break;
            }
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count >>> 0;
            if (object.num_server_players != null)
                message.num_server_players = object.num_server_players >>> 0;
            if (object.players_networkids) {
                if (!Array.isArray(object.players_networkids))
                    throw TypeError(".CNETMsg_SignonState.players_networkids: array expected");
                message.players_networkids = [];
                for (var i = 0; i < object.players_networkids.length; ++i)
                    message.players_networkids[i] = String(object.players_networkids[i]);
            }
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.players_networkids = [];
            if (options.defaults) {
                object.signon_state = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawn_count = 0;
                object.num_server_players = 0;
                object.map_name = "";
                object.addons = "";
            }
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                object.signon_state = options.enums === String ? $root.SignonState_t[message.signon_state] : message.signon_state;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                object.num_server_players = message.num_server_players;
            if (message.players_networkids && message.players_networkids.length) {
                object.players_networkids = [];
                for (var j = 0; j < message.players_networkids.length; ++j)
                    object.players_networkids[j] = message.players_networkids[j];
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [event_name] CSVCMsg_GameEvent event_name
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent event_name.
         * @member {string} event_name
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.event_name = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.event_name = "";
                object.eventid = 0;
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [val_string] key_t val_string
             * @property {number|null} [val_float] key_t val_float
             * @property {number|null} [val_long] key_t val_long
             * @property {number|null} [val_short] key_t val_short
             * @property {number|null} [val_byte] key_t val_byte
             * @property {boolean|null} [val_bool] key_t val_bool
             * @property {number|Long|null} [val_uint64] key_t val_uint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t val_string.
             * @member {string} val_string
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_string = "";
    
            /**
             * key_t val_float.
             * @member {number} val_float
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_float = 0;
    
            /**
             * key_t val_long.
             * @member {number} val_long
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_long = 0;
    
            /**
             * key_t val_short.
             * @member {number} val_short
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_short = 0;
    
            /**
             * key_t val_byte.
             * @member {number} val_byte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_byte = 0;
    
            /**
             * key_t val_bool.
             * @member {boolean} val_bool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_bool = false;
    
            /**
             * key_t val_uint64.
             * @member {number|Long} val_uint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_uint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.val_string != null && Object.hasOwnProperty.call(message, "val_string"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.val_string);
                if (message.val_float != null && Object.hasOwnProperty.call(message, "val_float"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_float);
                if (message.val_long != null && Object.hasOwnProperty.call(message, "val_long"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.val_long);
                if (message.val_short != null && Object.hasOwnProperty.call(message, "val_short"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_short);
                if (message.val_byte != null && Object.hasOwnProperty.call(message, "val_byte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.val_byte);
                if (message.val_bool != null && Object.hasOwnProperty.call(message, "val_bool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.val_bool);
                if (message.val_uint64 != null && Object.hasOwnProperty.call(message, "val_uint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.val_uint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.val_string = reader.string();
                        break;
                    case 3:
                        message.val_float = reader.float();
                        break;
                    case 4:
                        message.val_long = reader.int32();
                        break;
                    case 5:
                        message.val_short = reader.int32();
                        break;
                    case 6:
                        message.val_byte = reader.int32();
                        break;
                    case 7:
                        message.val_bool = reader.bool();
                        break;
                    case 8:
                        message.val_uint64 = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    if (typeof message.val_float !== "number")
                        return "val_float: number expected";
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    if (!$util.isInteger(message.val_long))
                        return "val_long: integer expected";
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    if (!$util.isInteger(message.val_short))
                        return "val_short: integer expected";
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    if (!$util.isInteger(message.val_byte))
                        return "val_byte: integer expected";
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    if (typeof message.val_bool !== "boolean")
                        return "val_bool: boolean expected";
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (!$util.isInteger(message.val_uint64) && !(message.val_uint64 && $util.isInteger(message.val_uint64.low) && $util.isInteger(message.val_uint64.high)))
                        return "val_uint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_float != null)
                    message.val_float = Number(object.val_float);
                if (object.val_long != null)
                    message.val_long = object.val_long | 0;
                if (object.val_short != null)
                    message.val_short = object.val_short | 0;
                if (object.val_byte != null)
                    message.val_byte = object.val_byte | 0;
                if (object.val_bool != null)
                    message.val_bool = Boolean(object.val_bool);
                if (object.val_uint64 != null)
                    if ($util.Long)
                        (message.val_uint64 = $util.Long.fromValue(object.val_uint64)).unsigned = true;
                    else if (typeof object.val_uint64 === "string")
                        message.val_uint64 = parseInt(object.val_uint64, 10);
                    else if (typeof object.val_uint64 === "number")
                        message.val_uint64 = object.val_uint64;
                    else if (typeof object.val_uint64 === "object")
                        message.val_uint64 = new $util.LongBits(object.val_uint64.low >>> 0, object.val_uint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.val_string = "";
                    object.val_float = 0;
                    object.val_long = 0;
                    object.val_short = 0;
                    object.val_byte = 0;
                    object.val_bool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.val_uint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val_uint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    object.val_float = options.json && !isFinite(message.val_float) ? String(message.val_float) : message.val_float;
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    object.val_long = message.val_long;
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    object.val_short = message.val_short;
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    object.val_byte = message.val_byte;
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    object.val_bool = message.val_bool;
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (typeof message.val_uint64 === "number")
                        object.val_uint64 = options.longs === String ? String(message.val_uint64) : message.val_uint64;
                    else
                        object.val_uint64 = options.longs === String ? $util.Long.prototype.toString.call(message.val_uint64) : options.longs === Number ? new $util.LongBits(message.val_uint64.low >>> 0, message.val_uint64.high >>> 0).toNumber(true) : message.val_uint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msg_type] CSVCMsg_UserMessage msg_type
         * @property {Uint8Array|null} [msg_data] CSVCMsg_UserMessage msg_data
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msg_type.
         * @member {number} msg_type
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_type = 0;
    
        /**
         * CSVCMsg_UserMessage msg_data.
         * @member {Uint8Array} msg_data
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.msg_data != null && Object.hasOwnProperty.call(message, "msg_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.msg_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                if (!(message.msg_data && typeof message.msg_data.length === "number" || $util.isString(message.msg_data)))
                    return "msg_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.msg_data != null)
                if (typeof object.msg_data === "string")
                    $util.base64.decode(object.msg_data, message.msg_data = $util.newBuffer($util.base64.length(object.msg_data)), 0);
                else if (object.msg_data.length)
                    message.msg_data = object.msg_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.msg_data = "";
                else {
                    object.msg_data = [];
                    if (options.bytes !== Array)
                        object.msg_data = $util.newBuffer(object.msg_data);
                }
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                object.msg_data = options.bytes === String ? $util.base64.encode(message.msg_data, 0, message.msg_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg_data) : message.msg_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsgList_UserMessages = (function() {
    
        /**
         * Properties of a CSVCMsgList_UserMessages.
         * @exports ICSVCMsgList_UserMessages
         * @interface ICSVCMsgList_UserMessages
         * @property {Array.<CSVCMsgList_UserMessages.Iusermsg_t>|null} [usermsgs] CSVCMsgList_UserMessages usermsgs
         */
    
        /**
         * Constructs a new CSVCMsgList_UserMessages.
         * @exports CSVCMsgList_UserMessages
         * @classdesc Represents a CSVCMsgList_UserMessages.
         * @implements ICSVCMsgList_UserMessages
         * @constructor
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         */
        function CSVCMsgList_UserMessages(properties) {
            this.usermsgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_UserMessages usermsgs.
         * @member {Array.<CSVCMsgList_UserMessages.Iusermsg_t>} usermsgs
         * @memberof CSVCMsgList_UserMessages
         * @instance
         */
        CSVCMsgList_UserMessages.prototype.usermsgs = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_UserMessages instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages instance
         */
        CSVCMsgList_UserMessages.create = function create(properties) {
            return new CSVCMsgList_UserMessages(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usermsgs != null && message.usermsgs.length)
                for (var i = 0; i < message.usermsgs.length; ++i)
                    $root.CSVCMsgList_UserMessages.usermsg_t.encode(message.usermsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.usermsgs && message.usermsgs.length))
                        message.usermsgs = [];
                    message.usermsgs.push($root.CSVCMsgList_UserMessages.usermsg_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_UserMessages message.
         * @function verify
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_UserMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usermsgs != null && message.hasOwnProperty("usermsgs")) {
                if (!Array.isArray(message.usermsgs))
                    return "usermsgs: array expected";
                for (var i = 0; i < message.usermsgs.length; ++i) {
                    var error = $root.CSVCMsgList_UserMessages.usermsg_t.verify(message.usermsgs[i]);
                    if (error)
                        return "usermsgs." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_UserMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         */
        CSVCMsgList_UserMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_UserMessages)
                return object;
            var message = new $root.CSVCMsgList_UserMessages();
            if (object.usermsgs) {
                if (!Array.isArray(object.usermsgs))
                    throw TypeError(".CSVCMsgList_UserMessages.usermsgs: array expected");
                message.usermsgs = [];
                for (var i = 0; i < object.usermsgs.length; ++i) {
                    if (typeof object.usermsgs[i] !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsgs: object expected");
                    message.usermsgs[i] = $root.CSVCMsgList_UserMessages.usermsg_t.fromObject(object.usermsgs[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_UserMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {CSVCMsgList_UserMessages} message CSVCMsgList_UserMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_UserMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.usermsgs = [];
            if (message.usermsgs && message.usermsgs.length) {
                object.usermsgs = [];
                for (var j = 0; j < message.usermsgs.length; ++j)
                    object.usermsgs[j] = $root.CSVCMsgList_UserMessages.usermsg_t.toObject(message.usermsgs[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_UserMessages to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_UserMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_UserMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_UserMessages.usermsg_t = (function() {
    
            /**
             * Properties of a usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @interface Iusermsg_t
             * @property {number|null} [tick] usermsg_t tick
             * @property {ICSVCMsg_UserMessage|null} [msg] usermsg_t msg
             */
    
            /**
             * Constructs a new usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @classdesc Represents a usermsg_t.
             * @implements Iusermsg_t
             * @constructor
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             */
            function usermsg_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * usermsg_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.tick = 0;
    
            /**
             * usermsg_t msg.
             * @member {ICSVCMsg_UserMessage|null|undefined} msg
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.msg = null;
    
            /**
             * Creates a new usermsg_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t instance
             */
            usermsg_t.create = function create(properties) {
                return new usermsg_t(properties);
            };
    
            /**
             * Encodes the specified usermsg_t message. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.CSVCMsg_UserMessage.encode(message.msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified usermsg_t message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.msg = $root.CSVCMsg_UserMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a usermsg_t message.
             * @function verify
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            usermsg_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    var error = $root.CSVCMsg_UserMessage.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                return null;
            };
    
            /**
             * Creates a usermsg_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             */
            usermsg_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_UserMessages.usermsg_t)
                    return object;
                var message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsg_t.msg: object expected");
                    message.msg = $root.CSVCMsg_UserMessage.fromObject(object.msg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a usermsg_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.usermsg_t} message usermsg_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            usermsg_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.msg = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.CSVCMsg_UserMessage.toObject(message.msg, options);
                return object;
            };
    
            /**
             * Converts this usermsg_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            usermsg_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return usermsg_t;
        })();
    
        return CSVCMsgList_UserMessages;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [world_offset_pos] CNETMsg_SpawnGroup_Load world_offset_pos
         * @property {ICMsgQAngle|null} [world_offset_angle] CNETMsg_SpawnGroup_Load world_offset_angle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_pos.
         * @member {ICMsgVector|null|undefined} world_offset_pos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_pos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_angle.
         * @member {ICMsgQAngle|null|undefined} world_offset_angle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_angle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.world_offset_pos != null && Object.hasOwnProperty.call(message, "world_offset_pos"))
                $root.CMsgVector.encode(message.world_offset_pos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.world_offset_angle != null && Object.hasOwnProperty.call(message, "world_offset_angle"))
                $root.CMsgQAngle.encode(message.world_offset_angle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldname = reader.string();
                    break;
                case 2:
                    message.entitylumpname = reader.string();
                    break;
                case 3:
                    message.entityfiltername = reader.string();
                    break;
                case 4:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 5:
                    message.spawngroupownerhandle = reader.uint32();
                    break;
                case 6:
                    message.world_offset_pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.world_offset_angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                case 10:
                    message.tickcount = reader.int32();
                    break;
                case 11:
                    message.manifestincomplete = reader.bool();
                    break;
                case 12:
                    message.localnamefixup = reader.string();
                    break;
                case 13:
                    message.parentnamefixup = reader.string();
                    break;
                case 14:
                    message.manifestloadpriority = reader.int32();
                    break;
                case 15:
                    message.worldgroupid = reader.uint32();
                    break;
                case 16:
                    message.creationsequence = reader.uint32();
                    break;
                case 17:
                    message.savegamefilename = reader.string();
                    break;
                case 18:
                    message.spawngroupparenthandle = reader.uint32();
                    break;
                case 19:
                    message.leveltransition = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos")) {
                var error = $root.CMsgVector.verify(message.world_offset_pos);
                if (error)
                    return "world_offset_pos." + error;
            }
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle")) {
                var error = $root.CMsgQAngle.verify(message.world_offset_angle);
                if (error)
                    return "world_offset_angle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.world_offset_pos != null) {
                if (typeof object.world_offset_pos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_pos: object expected");
                message.world_offset_pos = $root.CMsgVector.fromObject(object.world_offset_pos);
            }
            if (object.world_offset_angle != null) {
                if (typeof object.world_offset_angle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_angle: object expected");
                message.world_offset_angle = $root.CMsgQAngle.fromObject(object.world_offset_angle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.world_offset_pos = null;
                object.world_offset_angle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos"))
                object.world_offset_pos = $root.CMsgVector.toObject(message.world_offset_pos, options);
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle"))
                object.world_offset_angle = $root.CMsgQAngle.toObject(message.world_offset_angle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 3:
                    message.manifestincomplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.tickcount = reader.int32();
                    break;
                case 3:
                    message.creationsequence = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.flags = reader.uint32();
                    break;
                case 3:
                    message.tickcount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [is_multiplayer] CSVCMsg_GameSessionConfiguration is_multiplayer
         * @property {boolean|null} [is_loadsavegame] CSVCMsg_GameSessionConfiguration is_loadsavegame
         * @property {boolean|null} [is_background_map] CSVCMsg_GameSessionConfiguration is_background_map
         * @property {boolean|null} [is_headless] CSVCMsg_GameSessionConfiguration is_headless
         * @property {number|null} [min_client_limit] CSVCMsg_GameSessionConfiguration min_client_limit
         * @property {number|null} [max_client_limit] CSVCMsg_GameSessionConfiguration max_client_limit
         * @property {number|null} [max_clients] CSVCMsg_GameSessionConfiguration max_clients
         * @property {number|null} [tick_interval] CSVCMsg_GameSessionConfiguration tick_interval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1_mapname] CSVCMsg_GameSessionConfiguration s1_mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [server_ip_address] CSVCMsg_GameSessionConfiguration server_ip_address
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [is_localonly] CSVCMsg_GameSessionConfiguration is_localonly
         * @property {boolean|null} [no_steam_server] CSVCMsg_GameSessionConfiguration no_steam_server
         * @property {boolean|null} [is_transition] CSVCMsg_GameSessionConfiguration is_transition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration is_multiplayer.
         * @member {boolean} is_multiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_multiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_loadsavegame.
         * @member {boolean} is_loadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_loadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_background_map.
         * @member {boolean} is_background_map
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_background_map = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_headless.
         * @member {boolean} is_headless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_headless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration min_client_limit.
         * @member {number} min_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.min_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_client_limit.
         * @member {number} max_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1_mapname.
         * @member {string} s1_mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1_mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration server_ip_address.
         * @member {string} server_ip_address
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.server_ip_address = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration is_localonly.
         * @member {boolean} is_localonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_localonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration no_steam_server.
         * @member {boolean} no_steam_server
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.no_steam_server = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_transition.
         * @member {boolean} is_transition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_transition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_multiplayer != null && Object.hasOwnProperty.call(message, "is_multiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_multiplayer);
            if (message.is_loadsavegame != null && Object.hasOwnProperty.call(message, "is_loadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_loadsavegame);
            if (message.is_background_map != null && Object.hasOwnProperty.call(message, "is_background_map"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_background_map);
            if (message.is_headless != null && Object.hasOwnProperty.call(message, "is_headless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_headless);
            if (message.min_client_limit != null && Object.hasOwnProperty.call(message, "min_client_limit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.min_client_limit);
            if (message.max_client_limit != null && Object.hasOwnProperty.call(message, "max_client_limit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.max_client_limit);
            if (message.max_clients != null && Object.hasOwnProperty.call(message, "max_clients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.max_clients);
            if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tick_interval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1_mapname != null && Object.hasOwnProperty.call(message, "s1_mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1_mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.server_ip_address != null && Object.hasOwnProperty.call(message, "server_ip_address"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.server_ip_address);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.is_localonly != null && Object.hasOwnProperty.call(message, "is_localonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.is_localonly);
            if (message.is_transition != null && Object.hasOwnProperty.call(message, "is_transition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_transition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.no_steam_server != null && Object.hasOwnProperty.call(message, "no_steam_server"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.no_steam_server);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_multiplayer = reader.bool();
                    break;
                case 2:
                    message.is_loadsavegame = reader.bool();
                    break;
                case 3:
                    message.is_background_map = reader.bool();
                    break;
                case 4:
                    message.is_headless = reader.bool();
                    break;
                case 5:
                    message.min_client_limit = reader.uint32();
                    break;
                case 6:
                    message.max_client_limit = reader.uint32();
                    break;
                case 7:
                    message.max_clients = reader.uint32();
                    break;
                case 8:
                    message.tick_interval = reader.fixed32();
                    break;
                case 9:
                    message.hostname = reader.string();
                    break;
                case 10:
                    message.savegamename = reader.string();
                    break;
                case 11:
                    message.s1_mapname = reader.string();
                    break;
                case 12:
                    message.gamemode = reader.string();
                    break;
                case 13:
                    message.server_ip_address = reader.string();
                    break;
                case 14:
                    message.data = reader.bytes();
                    break;
                case 15:
                    message.is_localonly = reader.bool();
                    break;
                case 19:
                    message.no_steam_server = reader.bool();
                    break;
                case 16:
                    message.is_transition = reader.bool();
                    break;
                case 17:
                    message.previouslevel = reader.string();
                    break;
                case 18:
                    message.landmarkname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                if (typeof message.is_multiplayer !== "boolean")
                    return "is_multiplayer: boolean expected";
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                if (typeof message.is_loadsavegame !== "boolean")
                    return "is_loadsavegame: boolean expected";
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                if (typeof message.is_background_map !== "boolean")
                    return "is_background_map: boolean expected";
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                if (typeof message.is_headless !== "boolean")
                    return "is_headless: boolean expected";
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                if (!$util.isInteger(message.min_client_limit))
                    return "min_client_limit: integer expected";
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                if (!$util.isInteger(message.max_client_limit))
                    return "max_client_limit: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (!$util.isInteger(message.tick_interval))
                    return "tick_interval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                if (!$util.isString(message.s1_mapname))
                    return "s1_mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                if (!$util.isString(message.server_ip_address))
                    return "server_ip_address: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                if (typeof message.is_localonly !== "boolean")
                    return "is_localonly: boolean expected";
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                if (typeof message.no_steam_server !== "boolean")
                    return "no_steam_server: boolean expected";
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                if (typeof message.is_transition !== "boolean")
                    return "is_transition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.is_multiplayer != null)
                message.is_multiplayer = Boolean(object.is_multiplayer);
            if (object.is_loadsavegame != null)
                message.is_loadsavegame = Boolean(object.is_loadsavegame);
            if (object.is_background_map != null)
                message.is_background_map = Boolean(object.is_background_map);
            if (object.is_headless != null)
                message.is_headless = Boolean(object.is_headless);
            if (object.min_client_limit != null)
                message.min_client_limit = object.min_client_limit >>> 0;
            if (object.max_client_limit != null)
                message.max_client_limit = object.max_client_limit >>> 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients >>> 0;
            if (object.tick_interval != null)
                message.tick_interval = object.tick_interval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1_mapname != null)
                message.s1_mapname = String(object.s1_mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.server_ip_address != null)
                message.server_ip_address = String(object.server_ip_address);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.is_localonly != null)
                message.is_localonly = Boolean(object.is_localonly);
            if (object.no_steam_server != null)
                message.no_steam_server = Boolean(object.no_steam_server);
            if (object.is_transition != null)
                message.is_transition = Boolean(object.is_transition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.is_multiplayer = false;
                object.is_loadsavegame = false;
                object.is_background_map = false;
                object.is_headless = false;
                object.min_client_limit = 0;
                object.max_client_limit = 0;
                object.max_clients = 0;
                object.tick_interval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1_mapname = "";
                object.gamemode = "";
                object.server_ip_address = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.is_localonly = false;
                object.is_transition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.no_steam_server = false;
            }
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                object.is_multiplayer = message.is_multiplayer;
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                object.is_loadsavegame = message.is_loadsavegame;
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                object.is_background_map = message.is_background_map;
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                object.is_headless = message.is_headless;
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                object.min_client_limit = message.min_client_limit;
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                object.max_client_limit = message.max_client_limit;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = message.tick_interval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                object.s1_mapname = message.s1_mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                object.server_ip_address = message.server_ip_address;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                object.is_localonly = message.is_localonly;
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                object.is_transition = message.is_transition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                object.no_steam_server = message.no_steam_server;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW=70 NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[70] = "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW"] = 70;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {string|null} [experimental_map_key] FieldOptions experimental_map_key
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions experimental_map_key.
                 * @member {string} experimental_map_key
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.experimental_map_key = "";
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.experimental_map_key != null && Object.hasOwnProperty.call(message, "experimental_map_key"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.experimental_map_key);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 9:
                            message.experimental_map_key = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        if (!$util.isString(message.experimental_map_key))
                            return "experimental_map_key: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.experimental_map_key != null)
                        message.experimental_map_key = String(object.experimental_map_key);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.experimental_map_key = "";
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        object.experimental_map_key = message.experimental_map_key;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 * @property {string|null} [".network_connection_token"] EnumValueOptions .network_connection_token
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * EnumValueOptions .network_connection_token.
                 * @member {string} .network_connection_token
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".network_connection_token"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".network_connection_token"] != null && Object.hasOwnProperty.call(message, ".network_connection_token"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".network_connection_token"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50500:
                            message[".network_connection_token"] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        if (!$util.isString(message[".network_connection_token"]))
                            return ".network_connection_token: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".network_connection_token"] != null)
                        message[".network_connection_token"] = String(object[".network_connection_token"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object[".network_connection_token"] = "";
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        object[".network_connection_token"] = message[".network_connection_token"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
