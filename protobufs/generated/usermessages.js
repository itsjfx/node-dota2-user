/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * EBaseUserMessages enum.
     * @exports EBaseUserMessages
     * @enum {number}
     * @property {number} UM_AchievementEvent=101 UM_AchievementEvent value
     * @property {number} UM_CloseCaption=102 UM_CloseCaption value
     * @property {number} UM_CloseCaptionDirect=103 UM_CloseCaptionDirect value
     * @property {number} UM_CurrentTimescale=104 UM_CurrentTimescale value
     * @property {number} UM_DesiredTimescale=105 UM_DesiredTimescale value
     * @property {number} UM_Fade=106 UM_Fade value
     * @property {number} UM_GameTitle=107 UM_GameTitle value
     * @property {number} UM_HintText=109 UM_HintText value
     * @property {number} UM_HudMsg=110 UM_HudMsg value
     * @property {number} UM_HudText=111 UM_HudText value
     * @property {number} UM_KeyHintText=112 UM_KeyHintText value
     * @property {number} UM_ColoredText=113 UM_ColoredText value
     * @property {number} UM_RequestState=114 UM_RequestState value
     * @property {number} UM_ResetHUD=115 UM_ResetHUD value
     * @property {number} UM_Rumble=116 UM_Rumble value
     * @property {number} UM_SayText=117 UM_SayText value
     * @property {number} UM_SayText2=118 UM_SayText2 value
     * @property {number} UM_SayTextChannel=119 UM_SayTextChannel value
     * @property {number} UM_Shake=120 UM_Shake value
     * @property {number} UM_ShakeDir=121 UM_ShakeDir value
     * @property {number} UM_TextMsg=124 UM_TextMsg value
     * @property {number} UM_ScreenTilt=125 UM_ScreenTilt value
     * @property {number} UM_Train=126 UM_Train value
     * @property {number} UM_VGUIMenu=127 UM_VGUIMenu value
     * @property {number} UM_VoiceMask=128 UM_VoiceMask value
     * @property {number} UM_VoiceSubtitle=129 UM_VoiceSubtitle value
     * @property {number} UM_SendAudio=130 UM_SendAudio value
     * @property {number} UM_ItemPickup=131 UM_ItemPickup value
     * @property {number} UM_AmmoDenied=132 UM_AmmoDenied value
     * @property {number} UM_CrosshairAngle=133 UM_CrosshairAngle value
     * @property {number} UM_ShowMenu=134 UM_ShowMenu value
     * @property {number} UM_CreditsMsg=135 UM_CreditsMsg value
     * @property {number} UM_CloseCaptionPlaceholder=142 UM_CloseCaptionPlaceholder value
     * @property {number} UM_CameraTransition=143 UM_CameraTransition value
     * @property {number} UM_AudioParameter=144 UM_AudioParameter value
     * @property {number} UM_ParticleManager=145 UM_ParticleManager value
     * @property {number} UM_HudError=146 UM_HudError value
     * @property {number} UM_CustomGameEvent=148 UM_CustomGameEvent value
     * @property {number} UM_AnimGraphUpdate=149 UM_AnimGraphUpdate value
     * @property {number} UM_HapticsManagerPulse=150 UM_HapticsManagerPulse value
     * @property {number} UM_HapticsManagerEffect=151 UM_HapticsManagerEffect value
     * @property {number} UM_MAX_BASE=200 UM_MAX_BASE value
     */
    $root.EBaseUserMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[101] = "UM_AchievementEvent"] = 101;
        values[valuesById[102] = "UM_CloseCaption"] = 102;
        values[valuesById[103] = "UM_CloseCaptionDirect"] = 103;
        values[valuesById[104] = "UM_CurrentTimescale"] = 104;
        values[valuesById[105] = "UM_DesiredTimescale"] = 105;
        values[valuesById[106] = "UM_Fade"] = 106;
        values[valuesById[107] = "UM_GameTitle"] = 107;
        values[valuesById[109] = "UM_HintText"] = 109;
        values[valuesById[110] = "UM_HudMsg"] = 110;
        values[valuesById[111] = "UM_HudText"] = 111;
        values[valuesById[112] = "UM_KeyHintText"] = 112;
        values[valuesById[113] = "UM_ColoredText"] = 113;
        values[valuesById[114] = "UM_RequestState"] = 114;
        values[valuesById[115] = "UM_ResetHUD"] = 115;
        values[valuesById[116] = "UM_Rumble"] = 116;
        values[valuesById[117] = "UM_SayText"] = 117;
        values[valuesById[118] = "UM_SayText2"] = 118;
        values[valuesById[119] = "UM_SayTextChannel"] = 119;
        values[valuesById[120] = "UM_Shake"] = 120;
        values[valuesById[121] = "UM_ShakeDir"] = 121;
        values[valuesById[124] = "UM_TextMsg"] = 124;
        values[valuesById[125] = "UM_ScreenTilt"] = 125;
        values[valuesById[126] = "UM_Train"] = 126;
        values[valuesById[127] = "UM_VGUIMenu"] = 127;
        values[valuesById[128] = "UM_VoiceMask"] = 128;
        values[valuesById[129] = "UM_VoiceSubtitle"] = 129;
        values[valuesById[130] = "UM_SendAudio"] = 130;
        values[valuesById[131] = "UM_ItemPickup"] = 131;
        values[valuesById[132] = "UM_AmmoDenied"] = 132;
        values[valuesById[133] = "UM_CrosshairAngle"] = 133;
        values[valuesById[134] = "UM_ShowMenu"] = 134;
        values[valuesById[135] = "UM_CreditsMsg"] = 135;
        values[valuesById[142] = "UM_CloseCaptionPlaceholder"] = 142;
        values[valuesById[143] = "UM_CameraTransition"] = 143;
        values[valuesById[144] = "UM_AudioParameter"] = 144;
        values[valuesById[145] = "UM_ParticleManager"] = 145;
        values[valuesById[146] = "UM_HudError"] = 146;
        values[valuesById[148] = "UM_CustomGameEvent"] = 148;
        values[valuesById[149] = "UM_AnimGraphUpdate"] = 149;
        values[valuesById[150] = "UM_HapticsManagerPulse"] = 150;
        values[valuesById[151] = "UM_HapticsManagerEffect"] = 151;
        values[valuesById[200] = "UM_MAX_BASE"] = 200;
        return values;
    })();
    
    /**
     * EBaseEntityMessages enum.
     * @exports EBaseEntityMessages
     * @enum {number}
     * @property {number} EM_PlayJingle=136 EM_PlayJingle value
     * @property {number} EM_ScreenOverlay=137 EM_ScreenOverlay value
     * @property {number} EM_RemoveAllDecals=138 EM_RemoveAllDecals value
     * @property {number} EM_PropagateForce=139 EM_PropagateForce value
     * @property {number} EM_DoSpark=140 EM_DoSpark value
     * @property {number} EM_FixAngle=141 EM_FixAngle value
     */
    $root.EBaseEntityMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[136] = "EM_PlayJingle"] = 136;
        values[valuesById[137] = "EM_ScreenOverlay"] = 137;
        values[valuesById[138] = "EM_RemoveAllDecals"] = 138;
        values[valuesById[139] = "EM_PropagateForce"] = 139;
        values[valuesById[140] = "EM_DoSpark"] = 140;
        values[valuesById[141] = "EM_FixAngle"] = 141;
        return values;
    })();
    
    /**
     * eRollType enum.
     * @exports eRollType
     * @enum {number}
     * @property {number} ROLL_NONE=-1 ROLL_NONE value
     * @property {number} ROLL_STATS=0 ROLL_STATS value
     * @property {number} ROLL_CREDITS=1 ROLL_CREDITS value
     * @property {number} ROLL_LATE_JOIN_LOGO=2 ROLL_LATE_JOIN_LOGO value
     * @property {number} ROLL_OUTTRO=3 ROLL_OUTTRO value
     */
    $root.eRollType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "ROLL_NONE"] = -1;
        values[valuesById[0] = "ROLL_STATS"] = 0;
        values[valuesById[1] = "ROLL_CREDITS"] = 1;
        values[valuesById[2] = "ROLL_LATE_JOIN_LOGO"] = 2;
        values[valuesById[3] = "ROLL_OUTTRO"] = 3;
        return values;
    })();
    
    /**
     * PARTICLE_MESSAGE enum.
     * @exports PARTICLE_MESSAGE
     * @enum {number}
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_CREATE=0 GAME_PARTICLE_MANAGER_EVENT_CREATE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE=1 GAME_PARTICLE_MANAGER_EVENT_UPDATE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD=2 GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION=3 GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK=4 GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT=5 GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET=6 GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_DESTROY=7 GAME_PARTICLE_MANAGER_EVENT_DESTROY value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING=8 GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_RELEASE=9 GAME_PARTICLE_MANAGER_EVENT_RELEASE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_LATENCY=10 GAME_PARTICLE_MANAGER_EVENT_LATENCY value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW=11 GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_FROZEN=12 GAME_PARTICLE_MANAGER_EVENT_FROZEN value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT=13 GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION=14 GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES=15 GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_TEXT=16 GAME_PARTICLE_MANAGER_EVENT_SET_TEXT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW=17 GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL=18 GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT=19 GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE=20 GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG=21 GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT=22 GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT value
     */
    $root.PARTICLE_MESSAGE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GAME_PARTICLE_MANAGER_EVENT_CREATE"] = 0;
        values[valuesById[1] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE"] = 1;
        values[valuesById[2] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD"] = 2;
        values[valuesById[3] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION"] = 3;
        values[valuesById[4] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK"] = 4;
        values[valuesById[5] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT"] = 5;
        values[valuesById[6] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET"] = 6;
        values[valuesById[7] = "GAME_PARTICLE_MANAGER_EVENT_DESTROY"] = 7;
        values[valuesById[8] = "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING"] = 8;
        values[valuesById[9] = "GAME_PARTICLE_MANAGER_EVENT_RELEASE"] = 9;
        values[valuesById[10] = "GAME_PARTICLE_MANAGER_EVENT_LATENCY"] = 10;
        values[valuesById[11] = "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW"] = 11;
        values[valuesById[12] = "GAME_PARTICLE_MANAGER_EVENT_FROZEN"] = 12;
        values[valuesById[13] = "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT"] = 13;
        values[valuesById[14] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION"] = 14;
        values[valuesById[15] = "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES"] = 15;
        values[valuesById[16] = "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT"] = 16;
        values[valuesById[17] = "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW"] = 17;
        values[valuesById[18] = "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL"] = 18;
        values[valuesById[19] = "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT"] = 19;
        values[valuesById[20] = "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE"] = 20;
        values[valuesById[21] = "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG"] = 21;
        values[valuesById[22] = "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT"] = 22;
        return values;
    })();
    
    /**
     * EHapticPulseType enum.
     * @exports EHapticPulseType
     * @enum {number}
     * @property {number} VR_HAND_HAPTIC_PULSE_LIGHT=0 VR_HAND_HAPTIC_PULSE_LIGHT value
     * @property {number} VR_HAND_HAPTIC_PULSE_MEDIUM=1 VR_HAND_HAPTIC_PULSE_MEDIUM value
     * @property {number} VR_HAND_HAPTIC_PULSE_STRONG=2 VR_HAND_HAPTIC_PULSE_STRONG value
     */
    $root.EHapticPulseType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VR_HAND_HAPTIC_PULSE_LIGHT"] = 0;
        values[valuesById[1] = "VR_HAND_HAPTIC_PULSE_MEDIUM"] = 1;
        values[valuesById[2] = "VR_HAND_HAPTIC_PULSE_STRONG"] = 2;
        return values;
    })();
    
    $root.CUserMessageAchievementEvent = (function() {
    
        /**
         * Properties of a CUserMessageAchievementEvent.
         * @exports ICUserMessageAchievementEvent
         * @interface ICUserMessageAchievementEvent
         * @property {number|null} [achievement] CUserMessageAchievementEvent achievement
         */
    
        /**
         * Constructs a new CUserMessageAchievementEvent.
         * @exports CUserMessageAchievementEvent
         * @classdesc Represents a CUserMessageAchievementEvent.
         * @implements ICUserMessageAchievementEvent
         * @constructor
         * @param {ICUserMessageAchievementEvent=} [properties] Properties to set
         */
        function CUserMessageAchievementEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAchievementEvent achievement.
         * @member {number} achievement
         * @memberof CUserMessageAchievementEvent
         * @instance
         */
        CUserMessageAchievementEvent.prototype.achievement = 0;
    
        /**
         * Creates a new CUserMessageAchievementEvent instance using the specified properties.
         * @function create
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {ICUserMessageAchievementEvent=} [properties] Properties to set
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent instance
         */
        CUserMessageAchievementEvent.create = function create(properties) {
            return new CUserMessageAchievementEvent(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAchievementEvent message. Does not implicitly {@link CUserMessageAchievementEvent.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {ICUserMessageAchievementEvent} message CUserMessageAchievementEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAchievementEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.achievement != null && Object.hasOwnProperty.call(message, "achievement"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.achievement);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAchievementEvent message, length delimited. Does not implicitly {@link CUserMessageAchievementEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {ICUserMessageAchievementEvent} message CUserMessageAchievementEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAchievementEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAchievementEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAchievementEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAchievementEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.achievement = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAchievementEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAchievementEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAchievementEvent message.
         * @function verify
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAchievementEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.achievement != null && message.hasOwnProperty("achievement"))
                if (!$util.isInteger(message.achievement))
                    return "achievement: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAchievementEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent
         */
        CUserMessageAchievementEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAchievementEvent)
                return object;
            var message = new $root.CUserMessageAchievementEvent();
            if (object.achievement != null)
                message.achievement = object.achievement >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAchievementEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {CUserMessageAchievementEvent} message CUserMessageAchievementEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAchievementEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.achievement = 0;
            if (message.achievement != null && message.hasOwnProperty("achievement"))
                object.achievement = message.achievement;
            return object;
        };
    
        /**
         * Converts this CUserMessageAchievementEvent to JSON.
         * @function toJSON
         * @memberof CUserMessageAchievementEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAchievementEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageAchievementEvent;
    })();
    
    $root.CUserMessageCloseCaption = (function() {
    
        /**
         * Properties of a CUserMessageCloseCaption.
         * @exports ICUserMessageCloseCaption
         * @interface ICUserMessageCloseCaption
         * @property {number|null} [hash] CUserMessageCloseCaption hash
         * @property {number|null} [duration] CUserMessageCloseCaption duration
         * @property {boolean|null} [from_player] CUserMessageCloseCaption from_player
         * @property {number|null} [ent_index] CUserMessageCloseCaption ent_index
         */
    
        /**
         * Constructs a new CUserMessageCloseCaption.
         * @exports CUserMessageCloseCaption
         * @classdesc Represents a CUserMessageCloseCaption.
         * @implements ICUserMessageCloseCaption
         * @constructor
         * @param {ICUserMessageCloseCaption=} [properties] Properties to set
         */
        function CUserMessageCloseCaption(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCloseCaption hash.
         * @member {number} hash
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.hash = 0;
    
        /**
         * CUserMessageCloseCaption duration.
         * @member {number} duration
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.duration = 0;
    
        /**
         * CUserMessageCloseCaption from_player.
         * @member {boolean} from_player
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.from_player = false;
    
        /**
         * CUserMessageCloseCaption ent_index.
         * @member {number} ent_index
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.ent_index = 0;
    
        /**
         * Creates a new CUserMessageCloseCaption instance using the specified properties.
         * @function create
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {ICUserMessageCloseCaption=} [properties] Properties to set
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption instance
         */
        CUserMessageCloseCaption.create = function create(properties) {
            return new CUserMessageCloseCaption(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaption message. Does not implicitly {@link CUserMessageCloseCaption.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {ICUserMessageCloseCaption} message CUserMessageCloseCaption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.hash);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.from_player != null && Object.hasOwnProperty.call(message, "from_player"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.from_player);
            if (message.ent_index != null && Object.hasOwnProperty.call(message, "ent_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ent_index);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaption message, length delimited. Does not implicitly {@link CUserMessageCloseCaption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {ICUserMessageCloseCaption} message CUserMessageCloseCaption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCloseCaption message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCloseCaption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.fixed32();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.from_player = reader.bool();
                    break;
                case 4:
                    message.ent_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCloseCaption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCloseCaption message.
         * @function verify
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCloseCaption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isInteger(message.hash))
                    return "hash: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.from_player != null && message.hasOwnProperty("from_player"))
                if (typeof message.from_player !== "boolean")
                    return "from_player: boolean expected";
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                if (!$util.isInteger(message.ent_index))
                    return "ent_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCloseCaption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption
         */
        CUserMessageCloseCaption.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCloseCaption)
                return object;
            var message = new $root.CUserMessageCloseCaption();
            if (object.hash != null)
                message.hash = object.hash >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.from_player != null)
                message.from_player = Boolean(object.from_player);
            if (object.ent_index != null)
                message.ent_index = object.ent_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCloseCaption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {CUserMessageCloseCaption} message CUserMessageCloseCaption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCloseCaption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hash = 0;
                object.duration = 0;
                object.from_player = false;
                object.ent_index = 0;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.from_player != null && message.hasOwnProperty("from_player"))
                object.from_player = message.from_player;
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                object.ent_index = message.ent_index;
            return object;
        };
    
        /**
         * Converts this CUserMessageCloseCaption to JSON.
         * @function toJSON
         * @memberof CUserMessageCloseCaption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCloseCaption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageCloseCaption;
    })();
    
    $root.CUserMessageCloseCaptionDirect = (function() {
    
        /**
         * Properties of a CUserMessageCloseCaptionDirect.
         * @exports ICUserMessageCloseCaptionDirect
         * @interface ICUserMessageCloseCaptionDirect
         * @property {number|null} [hash] CUserMessageCloseCaptionDirect hash
         * @property {number|null} [duration] CUserMessageCloseCaptionDirect duration
         * @property {boolean|null} [from_player] CUserMessageCloseCaptionDirect from_player
         * @property {number|null} [ent_index] CUserMessageCloseCaptionDirect ent_index
         */
    
        /**
         * Constructs a new CUserMessageCloseCaptionDirect.
         * @exports CUserMessageCloseCaptionDirect
         * @classdesc Represents a CUserMessageCloseCaptionDirect.
         * @implements ICUserMessageCloseCaptionDirect
         * @constructor
         * @param {ICUserMessageCloseCaptionDirect=} [properties] Properties to set
         */
        function CUserMessageCloseCaptionDirect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCloseCaptionDirect hash.
         * @member {number} hash
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.hash = 0;
    
        /**
         * CUserMessageCloseCaptionDirect duration.
         * @member {number} duration
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.duration = 0;
    
        /**
         * CUserMessageCloseCaptionDirect from_player.
         * @member {boolean} from_player
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.from_player = false;
    
        /**
         * CUserMessageCloseCaptionDirect ent_index.
         * @member {number} ent_index
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.ent_index = 0;
    
        /**
         * Creates a new CUserMessageCloseCaptionDirect instance using the specified properties.
         * @function create
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {ICUserMessageCloseCaptionDirect=} [properties] Properties to set
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect instance
         */
        CUserMessageCloseCaptionDirect.create = function create(properties) {
            return new CUserMessageCloseCaptionDirect(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionDirect message. Does not implicitly {@link CUserMessageCloseCaptionDirect.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {ICUserMessageCloseCaptionDirect} message CUserMessageCloseCaptionDirect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionDirect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.hash);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.from_player != null && Object.hasOwnProperty.call(message, "from_player"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.from_player);
            if (message.ent_index != null && Object.hasOwnProperty.call(message, "ent_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ent_index);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionDirect message, length delimited. Does not implicitly {@link CUserMessageCloseCaptionDirect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {ICUserMessageCloseCaptionDirect} message CUserMessageCloseCaptionDirect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionDirect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionDirect message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionDirect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCloseCaptionDirect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.fixed32();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.from_player = reader.bool();
                    break;
                case 4:
                    message.ent_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionDirect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionDirect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCloseCaptionDirect message.
         * @function verify
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCloseCaptionDirect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isInteger(message.hash))
                    return "hash: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.from_player != null && message.hasOwnProperty("from_player"))
                if (typeof message.from_player !== "boolean")
                    return "from_player: boolean expected";
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                if (!$util.isInteger(message.ent_index))
                    return "ent_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCloseCaptionDirect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect
         */
        CUserMessageCloseCaptionDirect.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCloseCaptionDirect)
                return object;
            var message = new $root.CUserMessageCloseCaptionDirect();
            if (object.hash != null)
                message.hash = object.hash >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.from_player != null)
                message.from_player = Boolean(object.from_player);
            if (object.ent_index != null)
                message.ent_index = object.ent_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCloseCaptionDirect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {CUserMessageCloseCaptionDirect} message CUserMessageCloseCaptionDirect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCloseCaptionDirect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hash = 0;
                object.duration = 0;
                object.from_player = false;
                object.ent_index = 0;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.from_player != null && message.hasOwnProperty("from_player"))
                object.from_player = message.from_player;
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                object.ent_index = message.ent_index;
            return object;
        };
    
        /**
         * Converts this CUserMessageCloseCaptionDirect to JSON.
         * @function toJSON
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCloseCaptionDirect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageCloseCaptionDirect;
    })();
    
    $root.CUserMessageCloseCaptionPlaceholder = (function() {
    
        /**
         * Properties of a CUserMessageCloseCaptionPlaceholder.
         * @exports ICUserMessageCloseCaptionPlaceholder
         * @interface ICUserMessageCloseCaptionPlaceholder
         * @property {string|null} [string] CUserMessageCloseCaptionPlaceholder string
         * @property {number|null} [duration] CUserMessageCloseCaptionPlaceholder duration
         * @property {boolean|null} [from_player] CUserMessageCloseCaptionPlaceholder from_player
         * @property {number|null} [ent_index] CUserMessageCloseCaptionPlaceholder ent_index
         */
    
        /**
         * Constructs a new CUserMessageCloseCaptionPlaceholder.
         * @exports CUserMessageCloseCaptionPlaceholder
         * @classdesc Represents a CUserMessageCloseCaptionPlaceholder.
         * @implements ICUserMessageCloseCaptionPlaceholder
         * @constructor
         * @param {ICUserMessageCloseCaptionPlaceholder=} [properties] Properties to set
         */
        function CUserMessageCloseCaptionPlaceholder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCloseCaptionPlaceholder string.
         * @member {string} string
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.string = "";
    
        /**
         * CUserMessageCloseCaptionPlaceholder duration.
         * @member {number} duration
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.duration = 0;
    
        /**
         * CUserMessageCloseCaptionPlaceholder from_player.
         * @member {boolean} from_player
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.from_player = false;
    
        /**
         * CUserMessageCloseCaptionPlaceholder ent_index.
         * @member {number} ent_index
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.ent_index = 0;
    
        /**
         * Creates a new CUserMessageCloseCaptionPlaceholder instance using the specified properties.
         * @function create
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {ICUserMessageCloseCaptionPlaceholder=} [properties] Properties to set
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder instance
         */
        CUserMessageCloseCaptionPlaceholder.create = function create(properties) {
            return new CUserMessageCloseCaptionPlaceholder(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionPlaceholder message. Does not implicitly {@link CUserMessageCloseCaptionPlaceholder.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {ICUserMessageCloseCaptionPlaceholder} message CUserMessageCloseCaptionPlaceholder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionPlaceholder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.string != null && Object.hasOwnProperty.call(message, "string"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.string);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.from_player != null && Object.hasOwnProperty.call(message, "from_player"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.from_player);
            if (message.ent_index != null && Object.hasOwnProperty.call(message, "ent_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ent_index);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionPlaceholder message, length delimited. Does not implicitly {@link CUserMessageCloseCaptionPlaceholder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {ICUserMessageCloseCaptionPlaceholder} message CUserMessageCloseCaptionPlaceholder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionPlaceholder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionPlaceholder message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionPlaceholder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCloseCaptionPlaceholder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.string = reader.string();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.from_player = reader.bool();
                    break;
                case 4:
                    message.ent_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionPlaceholder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionPlaceholder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCloseCaptionPlaceholder message.
         * @function verify
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCloseCaptionPlaceholder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.string != null && message.hasOwnProperty("string"))
                if (!$util.isString(message.string))
                    return "string: string expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.from_player != null && message.hasOwnProperty("from_player"))
                if (typeof message.from_player !== "boolean")
                    return "from_player: boolean expected";
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                if (!$util.isInteger(message.ent_index))
                    return "ent_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCloseCaptionPlaceholder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder
         */
        CUserMessageCloseCaptionPlaceholder.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCloseCaptionPlaceholder)
                return object;
            var message = new $root.CUserMessageCloseCaptionPlaceholder();
            if (object.string != null)
                message.string = String(object.string);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.from_player != null)
                message.from_player = Boolean(object.from_player);
            if (object.ent_index != null)
                message.ent_index = object.ent_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCloseCaptionPlaceholder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {CUserMessageCloseCaptionPlaceholder} message CUserMessageCloseCaptionPlaceholder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCloseCaptionPlaceholder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.string = "";
                object.duration = 0;
                object.from_player = false;
                object.ent_index = 0;
            }
            if (message.string != null && message.hasOwnProperty("string"))
                object.string = message.string;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.from_player != null && message.hasOwnProperty("from_player"))
                object.from_player = message.from_player;
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                object.ent_index = message.ent_index;
            return object;
        };
    
        /**
         * Converts this CUserMessageCloseCaptionPlaceholder to JSON.
         * @function toJSON
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCloseCaptionPlaceholder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageCloseCaptionPlaceholder;
    })();
    
    $root.CUserMessageCurrentTimescale = (function() {
    
        /**
         * Properties of a CUserMessageCurrentTimescale.
         * @exports ICUserMessageCurrentTimescale
         * @interface ICUserMessageCurrentTimescale
         * @property {number|null} [current] CUserMessageCurrentTimescale current
         */
    
        /**
         * Constructs a new CUserMessageCurrentTimescale.
         * @exports CUserMessageCurrentTimescale
         * @classdesc Represents a CUserMessageCurrentTimescale.
         * @implements ICUserMessageCurrentTimescale
         * @constructor
         * @param {ICUserMessageCurrentTimescale=} [properties] Properties to set
         */
        function CUserMessageCurrentTimescale(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCurrentTimescale current.
         * @member {number} current
         * @memberof CUserMessageCurrentTimescale
         * @instance
         */
        CUserMessageCurrentTimescale.prototype.current = 0;
    
        /**
         * Creates a new CUserMessageCurrentTimescale instance using the specified properties.
         * @function create
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {ICUserMessageCurrentTimescale=} [properties] Properties to set
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale instance
         */
        CUserMessageCurrentTimescale.create = function create(properties) {
            return new CUserMessageCurrentTimescale(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCurrentTimescale message. Does not implicitly {@link CUserMessageCurrentTimescale.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {ICUserMessageCurrentTimescale} message CUserMessageCurrentTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCurrentTimescale.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.current);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCurrentTimescale message, length delimited. Does not implicitly {@link CUserMessageCurrentTimescale.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {ICUserMessageCurrentTimescale} message CUserMessageCurrentTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCurrentTimescale.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCurrentTimescale message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCurrentTimescale.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCurrentTimescale();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.current = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCurrentTimescale message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCurrentTimescale.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCurrentTimescale message.
         * @function verify
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCurrentTimescale.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.current != null && message.hasOwnProperty("current"))
                if (typeof message.current !== "number")
                    return "current: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCurrentTimescale message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale
         */
        CUserMessageCurrentTimescale.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCurrentTimescale)
                return object;
            var message = new $root.CUserMessageCurrentTimescale();
            if (object.current != null)
                message.current = Number(object.current);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCurrentTimescale message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {CUserMessageCurrentTimescale} message CUserMessageCurrentTimescale
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCurrentTimescale.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.current = 0;
            if (message.current != null && message.hasOwnProperty("current"))
                object.current = options.json && !isFinite(message.current) ? String(message.current) : message.current;
            return object;
        };
    
        /**
         * Converts this CUserMessageCurrentTimescale to JSON.
         * @function toJSON
         * @memberof CUserMessageCurrentTimescale
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCurrentTimescale.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageCurrentTimescale;
    })();
    
    $root.CUserMessageDesiredTimescale = (function() {
    
        /**
         * Properties of a CUserMessageDesiredTimescale.
         * @exports ICUserMessageDesiredTimescale
         * @interface ICUserMessageDesiredTimescale
         * @property {number|null} [desired] CUserMessageDesiredTimescale desired
         * @property {number|null} [acceleration] CUserMessageDesiredTimescale acceleration
         * @property {number|null} [minblendrate] CUserMessageDesiredTimescale minblendrate
         * @property {number|null} [blenddeltamultiplier] CUserMessageDesiredTimescale blenddeltamultiplier
         */
    
        /**
         * Constructs a new CUserMessageDesiredTimescale.
         * @exports CUserMessageDesiredTimescale
         * @classdesc Represents a CUserMessageDesiredTimescale.
         * @implements ICUserMessageDesiredTimescale
         * @constructor
         * @param {ICUserMessageDesiredTimescale=} [properties] Properties to set
         */
        function CUserMessageDesiredTimescale(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageDesiredTimescale desired.
         * @member {number} desired
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.desired = 0;
    
        /**
         * CUserMessageDesiredTimescale acceleration.
         * @member {number} acceleration
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.acceleration = 0;
    
        /**
         * CUserMessageDesiredTimescale minblendrate.
         * @member {number} minblendrate
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.minblendrate = 0;
    
        /**
         * CUserMessageDesiredTimescale blenddeltamultiplier.
         * @member {number} blenddeltamultiplier
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.blenddeltamultiplier = 0;
    
        /**
         * Creates a new CUserMessageDesiredTimescale instance using the specified properties.
         * @function create
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {ICUserMessageDesiredTimescale=} [properties] Properties to set
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale instance
         */
        CUserMessageDesiredTimescale.create = function create(properties) {
            return new CUserMessageDesiredTimescale(properties);
        };
    
        /**
         * Encodes the specified CUserMessageDesiredTimescale message. Does not implicitly {@link CUserMessageDesiredTimescale.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {ICUserMessageDesiredTimescale} message CUserMessageDesiredTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageDesiredTimescale.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.desired != null && Object.hasOwnProperty.call(message, "desired"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.desired);
            if (message.acceleration != null && Object.hasOwnProperty.call(message, "acceleration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.acceleration);
            if (message.minblendrate != null && Object.hasOwnProperty.call(message, "minblendrate"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.minblendrate);
            if (message.blenddeltamultiplier != null && Object.hasOwnProperty.call(message, "blenddeltamultiplier"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.blenddeltamultiplier);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageDesiredTimescale message, length delimited. Does not implicitly {@link CUserMessageDesiredTimescale.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {ICUserMessageDesiredTimescale} message CUserMessageDesiredTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageDesiredTimescale.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageDesiredTimescale message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageDesiredTimescale.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageDesiredTimescale();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.desired = reader.float();
                    break;
                case 2:
                    message.acceleration = reader.float();
                    break;
                case 3:
                    message.minblendrate = reader.float();
                    break;
                case 4:
                    message.blenddeltamultiplier = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageDesiredTimescale message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageDesiredTimescale.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageDesiredTimescale message.
         * @function verify
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageDesiredTimescale.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.desired != null && message.hasOwnProperty("desired"))
                if (typeof message.desired !== "number")
                    return "desired: number expected";
            if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                if (typeof message.acceleration !== "number")
                    return "acceleration: number expected";
            if (message.minblendrate != null && message.hasOwnProperty("minblendrate"))
                if (typeof message.minblendrate !== "number")
                    return "minblendrate: number expected";
            if (message.blenddeltamultiplier != null && message.hasOwnProperty("blenddeltamultiplier"))
                if (typeof message.blenddeltamultiplier !== "number")
                    return "blenddeltamultiplier: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageDesiredTimescale message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale
         */
        CUserMessageDesiredTimescale.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageDesiredTimescale)
                return object;
            var message = new $root.CUserMessageDesiredTimescale();
            if (object.desired != null)
                message.desired = Number(object.desired);
            if (object.acceleration != null)
                message.acceleration = Number(object.acceleration);
            if (object.minblendrate != null)
                message.minblendrate = Number(object.minblendrate);
            if (object.blenddeltamultiplier != null)
                message.blenddeltamultiplier = Number(object.blenddeltamultiplier);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageDesiredTimescale message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {CUserMessageDesiredTimescale} message CUserMessageDesiredTimescale
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageDesiredTimescale.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.desired = 0;
                object.acceleration = 0;
                object.minblendrate = 0;
                object.blenddeltamultiplier = 0;
            }
            if (message.desired != null && message.hasOwnProperty("desired"))
                object.desired = options.json && !isFinite(message.desired) ? String(message.desired) : message.desired;
            if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                object.acceleration = options.json && !isFinite(message.acceleration) ? String(message.acceleration) : message.acceleration;
            if (message.minblendrate != null && message.hasOwnProperty("minblendrate"))
                object.minblendrate = options.json && !isFinite(message.minblendrate) ? String(message.minblendrate) : message.minblendrate;
            if (message.blenddeltamultiplier != null && message.hasOwnProperty("blenddeltamultiplier"))
                object.blenddeltamultiplier = options.json && !isFinite(message.blenddeltamultiplier) ? String(message.blenddeltamultiplier) : message.blenddeltamultiplier;
            return object;
        };
    
        /**
         * Converts this CUserMessageDesiredTimescale to JSON.
         * @function toJSON
         * @memberof CUserMessageDesiredTimescale
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageDesiredTimescale.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageDesiredTimescale;
    })();
    
    $root.CUserMessageFade = (function() {
    
        /**
         * Properties of a CUserMessageFade.
         * @exports ICUserMessageFade
         * @interface ICUserMessageFade
         * @property {number|null} [duration] CUserMessageFade duration
         * @property {number|null} [hold_time] CUserMessageFade hold_time
         * @property {number|null} [flags] CUserMessageFade flags
         * @property {number|null} [color] CUserMessageFade color
         */
    
        /**
         * Constructs a new CUserMessageFade.
         * @exports CUserMessageFade
         * @classdesc Represents a CUserMessageFade.
         * @implements ICUserMessageFade
         * @constructor
         * @param {ICUserMessageFade=} [properties] Properties to set
         */
        function CUserMessageFade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageFade duration.
         * @member {number} duration
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.duration = 0;
    
        /**
         * CUserMessageFade hold_time.
         * @member {number} hold_time
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.hold_time = 0;
    
        /**
         * CUserMessageFade flags.
         * @member {number} flags
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.flags = 0;
    
        /**
         * CUserMessageFade color.
         * @member {number} color
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.color = 0;
    
        /**
         * Creates a new CUserMessageFade instance using the specified properties.
         * @function create
         * @memberof CUserMessageFade
         * @static
         * @param {ICUserMessageFade=} [properties] Properties to set
         * @returns {CUserMessageFade} CUserMessageFade instance
         */
        CUserMessageFade.create = function create(properties) {
            return new CUserMessageFade(properties);
        };
    
        /**
         * Encodes the specified CUserMessageFade message. Does not implicitly {@link CUserMessageFade.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageFade
         * @static
         * @param {ICUserMessageFade} message CUserMessageFade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageFade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.duration);
            if (message.hold_time != null && Object.hasOwnProperty.call(message, "hold_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hold_time);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.color);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageFade message, length delimited. Does not implicitly {@link CUserMessageFade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageFade
         * @static
         * @param {ICUserMessageFade} message CUserMessageFade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageFade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageFade message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageFade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageFade} CUserMessageFade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageFade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageFade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.duration = reader.uint32();
                    break;
                case 2:
                    message.hold_time = reader.uint32();
                    break;
                case 3:
                    message.flags = reader.uint32();
                    break;
                case 4:
                    message.color = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageFade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageFade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageFade} CUserMessageFade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageFade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageFade message.
         * @function verify
         * @memberof CUserMessageFade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageFade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.hold_time != null && message.hasOwnProperty("hold_time"))
                if (!$util.isInteger(message.hold_time))
                    return "hold_time: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageFade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageFade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageFade} CUserMessageFade
         */
        CUserMessageFade.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageFade)
                return object;
            var message = new $root.CUserMessageFade();
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            if (object.hold_time != null)
                message.hold_time = object.hold_time >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.color != null)
                message.color = object.color >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageFade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageFade
         * @static
         * @param {CUserMessageFade} message CUserMessageFade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageFade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.duration = 0;
                object.hold_time = 0;
                object.flags = 0;
                object.color = 0;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.hold_time != null && message.hasOwnProperty("hold_time"))
                object.hold_time = message.hold_time;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };
    
        /**
         * Converts this CUserMessageFade to JSON.
         * @function toJSON
         * @memberof CUserMessageFade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageFade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageFade;
    })();
    
    $root.CUserMessageShake = (function() {
    
        /**
         * Properties of a CUserMessageShake.
         * @exports ICUserMessageShake
         * @interface ICUserMessageShake
         * @property {number|null} [command] CUserMessageShake command
         * @property {number|null} [amplitude] CUserMessageShake amplitude
         * @property {number|null} [frequency] CUserMessageShake frequency
         * @property {number|null} [duration] CUserMessageShake duration
         */
    
        /**
         * Constructs a new CUserMessageShake.
         * @exports CUserMessageShake
         * @classdesc Represents a CUserMessageShake.
         * @implements ICUserMessageShake
         * @constructor
         * @param {ICUserMessageShake=} [properties] Properties to set
         */
        function CUserMessageShake(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageShake command.
         * @member {number} command
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.command = 0;
    
        /**
         * CUserMessageShake amplitude.
         * @member {number} amplitude
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.amplitude = 0;
    
        /**
         * CUserMessageShake frequency.
         * @member {number} frequency
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.frequency = 0;
    
        /**
         * CUserMessageShake duration.
         * @member {number} duration
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.duration = 0;
    
        /**
         * Creates a new CUserMessageShake instance using the specified properties.
         * @function create
         * @memberof CUserMessageShake
         * @static
         * @param {ICUserMessageShake=} [properties] Properties to set
         * @returns {CUserMessageShake} CUserMessageShake instance
         */
        CUserMessageShake.create = function create(properties) {
            return new CUserMessageShake(properties);
        };
    
        /**
         * Encodes the specified CUserMessageShake message. Does not implicitly {@link CUserMessageShake.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageShake
         * @static
         * @param {ICUserMessageShake} message CUserMessageShake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.command);
            if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.amplitude);
            if (message.frequency != null && Object.hasOwnProperty.call(message, "frequency"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.frequency);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.duration);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageShake message, length delimited. Does not implicitly {@link CUserMessageShake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageShake
         * @static
         * @param {ICUserMessageShake} message CUserMessageShake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageShake message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageShake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageShake} CUserMessageShake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageShake();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.uint32();
                    break;
                case 2:
                    message.amplitude = reader.float();
                    break;
                case 3:
                    message.frequency = reader.float();
                    break;
                case 4:
                    message.duration = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageShake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageShake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageShake} CUserMessageShake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageShake message.
         * @function verify
         * @memberof CUserMessageShake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageShake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isInteger(message.command))
                    return "command: integer expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            if (message.frequency != null && message.hasOwnProperty("frequency"))
                if (typeof message.frequency !== "number")
                    return "frequency: number expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageShake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageShake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageShake} CUserMessageShake
         */
        CUserMessageShake.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageShake)
                return object;
            var message = new $root.CUserMessageShake();
            if (object.command != null)
                message.command = object.command >>> 0;
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.frequency != null)
                message.frequency = Number(object.frequency);
            if (object.duration != null)
                message.duration = Number(object.duration);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageShake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageShake
         * @static
         * @param {CUserMessageShake} message CUserMessageShake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageShake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.command = 0;
                object.amplitude = 0;
                object.frequency = 0;
                object.duration = 0;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.frequency != null && message.hasOwnProperty("frequency"))
                object.frequency = options.json && !isFinite(message.frequency) ? String(message.frequency) : message.frequency;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            return object;
        };
    
        /**
         * Converts this CUserMessageShake to JSON.
         * @function toJSON
         * @memberof CUserMessageShake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageShake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageShake;
    })();
    
    $root.CUserMessageShakeDir = (function() {
    
        /**
         * Properties of a CUserMessageShakeDir.
         * @exports ICUserMessageShakeDir
         * @interface ICUserMessageShakeDir
         * @property {ICUserMessageShake|null} [shake] CUserMessageShakeDir shake
         * @property {ICMsgVector|null} [direction] CUserMessageShakeDir direction
         */
    
        /**
         * Constructs a new CUserMessageShakeDir.
         * @exports CUserMessageShakeDir
         * @classdesc Represents a CUserMessageShakeDir.
         * @implements ICUserMessageShakeDir
         * @constructor
         * @param {ICUserMessageShakeDir=} [properties] Properties to set
         */
        function CUserMessageShakeDir(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageShakeDir shake.
         * @member {ICUserMessageShake|null|undefined} shake
         * @memberof CUserMessageShakeDir
         * @instance
         */
        CUserMessageShakeDir.prototype.shake = null;
    
        /**
         * CUserMessageShakeDir direction.
         * @member {ICMsgVector|null|undefined} direction
         * @memberof CUserMessageShakeDir
         * @instance
         */
        CUserMessageShakeDir.prototype.direction = null;
    
        /**
         * Creates a new CUserMessageShakeDir instance using the specified properties.
         * @function create
         * @memberof CUserMessageShakeDir
         * @static
         * @param {ICUserMessageShakeDir=} [properties] Properties to set
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir instance
         */
        CUserMessageShakeDir.create = function create(properties) {
            return new CUserMessageShakeDir(properties);
        };
    
        /**
         * Encodes the specified CUserMessageShakeDir message. Does not implicitly {@link CUserMessageShakeDir.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageShakeDir
         * @static
         * @param {ICUserMessageShakeDir} message CUserMessageShakeDir message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShakeDir.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shake != null && Object.hasOwnProperty.call(message, "shake"))
                $root.CUserMessageShake.encode(message.shake, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.CMsgVector.encode(message.direction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageShakeDir message, length delimited. Does not implicitly {@link CUserMessageShakeDir.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageShakeDir
         * @static
         * @param {ICUserMessageShakeDir} message CUserMessageShakeDir message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShakeDir.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageShakeDir message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageShakeDir
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShakeDir.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageShakeDir();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shake = $root.CUserMessageShake.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.direction = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageShakeDir message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageShakeDir
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShakeDir.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageShakeDir message.
         * @function verify
         * @memberof CUserMessageShakeDir
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageShakeDir.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shake != null && message.hasOwnProperty("shake")) {
                var error = $root.CUserMessageShake.verify(message.shake);
                if (error)
                    return "shake." + error;
            }
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.CMsgVector.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageShakeDir message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageShakeDir
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir
         */
        CUserMessageShakeDir.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageShakeDir)
                return object;
            var message = new $root.CUserMessageShakeDir();
            if (object.shake != null) {
                if (typeof object.shake !== "object")
                    throw TypeError(".CUserMessageShakeDir.shake: object expected");
                message.shake = $root.CUserMessageShake.fromObject(object.shake);
            }
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".CUserMessageShakeDir.direction: object expected");
                message.direction = $root.CMsgVector.fromObject(object.direction);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageShakeDir message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageShakeDir
         * @static
         * @param {CUserMessageShakeDir} message CUserMessageShakeDir
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageShakeDir.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.shake = null;
                object.direction = null;
            }
            if (message.shake != null && message.hasOwnProperty("shake"))
                object.shake = $root.CUserMessageShake.toObject(message.shake, options);
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.CMsgVector.toObject(message.direction, options);
            return object;
        };
    
        /**
         * Converts this CUserMessageShakeDir to JSON.
         * @function toJSON
         * @memberof CUserMessageShakeDir
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageShakeDir.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageShakeDir;
    })();
    
    $root.CUserMessageScreenTilt = (function() {
    
        /**
         * Properties of a CUserMessageScreenTilt.
         * @exports ICUserMessageScreenTilt
         * @interface ICUserMessageScreenTilt
         * @property {number|null} [command] CUserMessageScreenTilt command
         * @property {boolean|null} [ease_in_out] CUserMessageScreenTilt ease_in_out
         * @property {ICMsgVector|null} [angle] CUserMessageScreenTilt angle
         * @property {number|null} [duration] CUserMessageScreenTilt duration
         * @property {number|null} [time] CUserMessageScreenTilt time
         */
    
        /**
         * Constructs a new CUserMessageScreenTilt.
         * @exports CUserMessageScreenTilt
         * @classdesc Represents a CUserMessageScreenTilt.
         * @implements ICUserMessageScreenTilt
         * @constructor
         * @param {ICUserMessageScreenTilt=} [properties] Properties to set
         */
        function CUserMessageScreenTilt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageScreenTilt command.
         * @member {number} command
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.command = 0;
    
        /**
         * CUserMessageScreenTilt ease_in_out.
         * @member {boolean} ease_in_out
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.ease_in_out = false;
    
        /**
         * CUserMessageScreenTilt angle.
         * @member {ICMsgVector|null|undefined} angle
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.angle = null;
    
        /**
         * CUserMessageScreenTilt duration.
         * @member {number} duration
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.duration = 0;
    
        /**
         * CUserMessageScreenTilt time.
         * @member {number} time
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.time = 0;
    
        /**
         * Creates a new CUserMessageScreenTilt instance using the specified properties.
         * @function create
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {ICUserMessageScreenTilt=} [properties] Properties to set
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt instance
         */
        CUserMessageScreenTilt.create = function create(properties) {
            return new CUserMessageScreenTilt(properties);
        };
    
        /**
         * Encodes the specified CUserMessageScreenTilt message. Does not implicitly {@link CUserMessageScreenTilt.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {ICUserMessageScreenTilt} message CUserMessageScreenTilt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageScreenTilt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.command);
            if (message.ease_in_out != null && Object.hasOwnProperty.call(message, "ease_in_out"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ease_in_out);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgVector.encode(message.angle, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.duration);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.time);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageScreenTilt message, length delimited. Does not implicitly {@link CUserMessageScreenTilt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {ICUserMessageScreenTilt} message CUserMessageScreenTilt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageScreenTilt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageScreenTilt message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageScreenTilt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageScreenTilt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.uint32();
                    break;
                case 2:
                    message.ease_in_out = reader.bool();
                    break;
                case 3:
                    message.angle = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.duration = reader.float();
                    break;
                case 5:
                    message.time = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageScreenTilt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageScreenTilt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageScreenTilt message.
         * @function verify
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageScreenTilt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isInteger(message.command))
                    return "command: integer expected";
            if (message.ease_in_out != null && message.hasOwnProperty("ease_in_out"))
                if (typeof message.ease_in_out !== "boolean")
                    return "ease_in_out: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgVector.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time !== "number")
                    return "time: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageScreenTilt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt
         */
        CUserMessageScreenTilt.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageScreenTilt)
                return object;
            var message = new $root.CUserMessageScreenTilt();
            if (object.command != null)
                message.command = object.command >>> 0;
            if (object.ease_in_out != null)
                message.ease_in_out = Boolean(object.ease_in_out);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CUserMessageScreenTilt.angle: object expected");
                message.angle = $root.CMsgVector.fromObject(object.angle);
            }
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.time != null)
                message.time = Number(object.time);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageScreenTilt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {CUserMessageScreenTilt} message CUserMessageScreenTilt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageScreenTilt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.command = 0;
                object.ease_in_out = false;
                object.angle = null;
                object.duration = 0;
                object.time = 0;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.ease_in_out != null && message.hasOwnProperty("ease_in_out"))
                object.ease_in_out = message.ease_in_out;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgVector.toObject(message.angle, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
            return object;
        };
    
        /**
         * Converts this CUserMessageScreenTilt to JSON.
         * @function toJSON
         * @memberof CUserMessageScreenTilt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageScreenTilt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageScreenTilt;
    })();
    
    $root.CUserMessageSayText = (function() {
    
        /**
         * Properties of a CUserMessageSayText.
         * @exports ICUserMessageSayText
         * @interface ICUserMessageSayText
         * @property {number|null} [playerindex] CUserMessageSayText playerindex
         * @property {string|null} [text] CUserMessageSayText text
         * @property {boolean|null} [chat] CUserMessageSayText chat
         */
    
        /**
         * Constructs a new CUserMessageSayText.
         * @exports CUserMessageSayText
         * @classdesc Represents a CUserMessageSayText.
         * @implements ICUserMessageSayText
         * @constructor
         * @param {ICUserMessageSayText=} [properties] Properties to set
         */
        function CUserMessageSayText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSayText playerindex.
         * @member {number} playerindex
         * @memberof CUserMessageSayText
         * @instance
         */
        CUserMessageSayText.prototype.playerindex = 0;
    
        /**
         * CUserMessageSayText text.
         * @member {string} text
         * @memberof CUserMessageSayText
         * @instance
         */
        CUserMessageSayText.prototype.text = "";
    
        /**
         * CUserMessageSayText chat.
         * @member {boolean} chat
         * @memberof CUserMessageSayText
         * @instance
         */
        CUserMessageSayText.prototype.chat = false;
    
        /**
         * Creates a new CUserMessageSayText instance using the specified properties.
         * @function create
         * @memberof CUserMessageSayText
         * @static
         * @param {ICUserMessageSayText=} [properties] Properties to set
         * @returns {CUserMessageSayText} CUserMessageSayText instance
         */
        CUserMessageSayText.create = function create(properties) {
            return new CUserMessageSayText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSayText message. Does not implicitly {@link CUserMessageSayText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSayText
         * @static
         * @param {ICUserMessageSayText} message CUserMessageSayText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerindex != null && Object.hasOwnProperty.call(message, "playerindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.playerindex);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.chat != null && Object.hasOwnProperty.call(message, "chat"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.chat);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSayText message, length delimited. Does not implicitly {@link CUserMessageSayText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSayText
         * @static
         * @param {ICUserMessageSayText} message CUserMessageSayText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSayText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSayText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSayText} CUserMessageSayText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSayText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerindex = reader.uint32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.chat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSayText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSayText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSayText} CUserMessageSayText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSayText message.
         * @function verify
         * @memberof CUserMessageSayText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSayText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerindex != null && message.hasOwnProperty("playerindex"))
                if (!$util.isInteger(message.playerindex))
                    return "playerindex: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.chat != null && message.hasOwnProperty("chat"))
                if (typeof message.chat !== "boolean")
                    return "chat: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSayText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSayText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSayText} CUserMessageSayText
         */
        CUserMessageSayText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSayText)
                return object;
            var message = new $root.CUserMessageSayText();
            if (object.playerindex != null)
                message.playerindex = object.playerindex >>> 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.chat != null)
                message.chat = Boolean(object.chat);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSayText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSayText
         * @static
         * @param {CUserMessageSayText} message CUserMessageSayText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSayText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerindex = 0;
                object.text = "";
                object.chat = false;
            }
            if (message.playerindex != null && message.hasOwnProperty("playerindex"))
                object.playerindex = message.playerindex;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = message.chat;
            return object;
        };
    
        /**
         * Converts this CUserMessageSayText to JSON.
         * @function toJSON
         * @memberof CUserMessageSayText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSayText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageSayText;
    })();
    
    $root.CUserMessageSayText2 = (function() {
    
        /**
         * Properties of a CUserMessageSayText2.
         * @exports ICUserMessageSayText2
         * @interface ICUserMessageSayText2
         * @property {number|null} [entityindex] CUserMessageSayText2 entityindex
         * @property {boolean|null} [chat] CUserMessageSayText2 chat
         * @property {string|null} [messagename] CUserMessageSayText2 messagename
         * @property {string|null} [param1] CUserMessageSayText2 param1
         * @property {string|null} [param2] CUserMessageSayText2 param2
         * @property {string|null} [param3] CUserMessageSayText2 param3
         * @property {string|null} [param4] CUserMessageSayText2 param4
         */
    
        /**
         * Constructs a new CUserMessageSayText2.
         * @exports CUserMessageSayText2
         * @classdesc Represents a CUserMessageSayText2.
         * @implements ICUserMessageSayText2
         * @constructor
         * @param {ICUserMessageSayText2=} [properties] Properties to set
         */
        function CUserMessageSayText2(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSayText2 entityindex.
         * @member {number} entityindex
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.entityindex = 0;
    
        /**
         * CUserMessageSayText2 chat.
         * @member {boolean} chat
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.chat = false;
    
        /**
         * CUserMessageSayText2 messagename.
         * @member {string} messagename
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.messagename = "";
    
        /**
         * CUserMessageSayText2 param1.
         * @member {string} param1
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param1 = "";
    
        /**
         * CUserMessageSayText2 param2.
         * @member {string} param2
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param2 = "";
    
        /**
         * CUserMessageSayText2 param3.
         * @member {string} param3
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param3 = "";
    
        /**
         * CUserMessageSayText2 param4.
         * @member {string} param4
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param4 = "";
    
        /**
         * Creates a new CUserMessageSayText2 instance using the specified properties.
         * @function create
         * @memberof CUserMessageSayText2
         * @static
         * @param {ICUserMessageSayText2=} [properties] Properties to set
         * @returns {CUserMessageSayText2} CUserMessageSayText2 instance
         */
        CUserMessageSayText2.create = function create(properties) {
            return new CUserMessageSayText2(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSayText2 message. Does not implicitly {@link CUserMessageSayText2.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSayText2
         * @static
         * @param {ICUserMessageSayText2} message CUserMessageSayText2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entityindex != null && Object.hasOwnProperty.call(message, "entityindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.entityindex);
            if (message.chat != null && Object.hasOwnProperty.call(message, "chat"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.chat);
            if (message.messagename != null && Object.hasOwnProperty.call(message, "messagename"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.messagename);
            if (message.param1 != null && Object.hasOwnProperty.call(message, "param1"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.param1);
            if (message.param2 != null && Object.hasOwnProperty.call(message, "param2"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.param2);
            if (message.param3 != null && Object.hasOwnProperty.call(message, "param3"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.param3);
            if (message.param4 != null && Object.hasOwnProperty.call(message, "param4"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.param4);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSayText2 message, length delimited. Does not implicitly {@link CUserMessageSayText2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSayText2
         * @static
         * @param {ICUserMessageSayText2} message CUserMessageSayText2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSayText2 message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSayText2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSayText2} CUserMessageSayText2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSayText2();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entityindex = reader.uint32();
                    break;
                case 2:
                    message.chat = reader.bool();
                    break;
                case 3:
                    message.messagename = reader.string();
                    break;
                case 4:
                    message.param1 = reader.string();
                    break;
                case 5:
                    message.param2 = reader.string();
                    break;
                case 6:
                    message.param3 = reader.string();
                    break;
                case 7:
                    message.param4 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSayText2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSayText2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSayText2} CUserMessageSayText2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSayText2 message.
         * @function verify
         * @memberof CUserMessageSayText2
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSayText2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                if (!$util.isInteger(message.entityindex))
                    return "entityindex: integer expected";
            if (message.chat != null && message.hasOwnProperty("chat"))
                if (typeof message.chat !== "boolean")
                    return "chat: boolean expected";
            if (message.messagename != null && message.hasOwnProperty("messagename"))
                if (!$util.isString(message.messagename))
                    return "messagename: string expected";
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (!$util.isString(message.param1))
                    return "param1: string expected";
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (!$util.isString(message.param2))
                    return "param2: string expected";
            if (message.param3 != null && message.hasOwnProperty("param3"))
                if (!$util.isString(message.param3))
                    return "param3: string expected";
            if (message.param4 != null && message.hasOwnProperty("param4"))
                if (!$util.isString(message.param4))
                    return "param4: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSayText2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSayText2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSayText2} CUserMessageSayText2
         */
        CUserMessageSayText2.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSayText2)
                return object;
            var message = new $root.CUserMessageSayText2();
            if (object.entityindex != null)
                message.entityindex = object.entityindex >>> 0;
            if (object.chat != null)
                message.chat = Boolean(object.chat);
            if (object.messagename != null)
                message.messagename = String(object.messagename);
            if (object.param1 != null)
                message.param1 = String(object.param1);
            if (object.param2 != null)
                message.param2 = String(object.param2);
            if (object.param3 != null)
                message.param3 = String(object.param3);
            if (object.param4 != null)
                message.param4 = String(object.param4);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSayText2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSayText2
         * @static
         * @param {CUserMessageSayText2} message CUserMessageSayText2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSayText2.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entityindex = 0;
                object.chat = false;
                object.messagename = "";
                object.param1 = "";
                object.param2 = "";
                object.param3 = "";
                object.param4 = "";
            }
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                object.entityindex = message.entityindex;
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = message.chat;
            if (message.messagename != null && message.hasOwnProperty("messagename"))
                object.messagename = message.messagename;
            if (message.param1 != null && message.hasOwnProperty("param1"))
                object.param1 = message.param1;
            if (message.param2 != null && message.hasOwnProperty("param2"))
                object.param2 = message.param2;
            if (message.param3 != null && message.hasOwnProperty("param3"))
                object.param3 = message.param3;
            if (message.param4 != null && message.hasOwnProperty("param4"))
                object.param4 = message.param4;
            return object;
        };
    
        /**
         * Converts this CUserMessageSayText2 to JSON.
         * @function toJSON
         * @memberof CUserMessageSayText2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSayText2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageSayText2;
    })();
    
    $root.CUserMessageHudMsg = (function() {
    
        /**
         * Properties of a CUserMessageHudMsg.
         * @exports ICUserMessageHudMsg
         * @interface ICUserMessageHudMsg
         * @property {number|null} [channel] CUserMessageHudMsg channel
         * @property {number|null} [x] CUserMessageHudMsg x
         * @property {number|null} [y] CUserMessageHudMsg y
         * @property {number|null} [color1] CUserMessageHudMsg color1
         * @property {number|null} [color2] CUserMessageHudMsg color2
         * @property {number|null} [effect] CUserMessageHudMsg effect
         * @property {number|null} [fade_in_time] CUserMessageHudMsg fade_in_time
         * @property {number|null} [fade_out_time] CUserMessageHudMsg fade_out_time
         * @property {number|null} [hold_time] CUserMessageHudMsg hold_time
         * @property {number|null} [fx_time] CUserMessageHudMsg fx_time
         * @property {string|null} [message] CUserMessageHudMsg message
         */
    
        /**
         * Constructs a new CUserMessageHudMsg.
         * @exports CUserMessageHudMsg
         * @classdesc Represents a CUserMessageHudMsg.
         * @implements ICUserMessageHudMsg
         * @constructor
         * @param {ICUserMessageHudMsg=} [properties] Properties to set
         */
        function CUserMessageHudMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHudMsg channel.
         * @member {number} channel
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.channel = 0;
    
        /**
         * CUserMessageHudMsg x.
         * @member {number} x
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.x = 0;
    
        /**
         * CUserMessageHudMsg y.
         * @member {number} y
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.y = 0;
    
        /**
         * CUserMessageHudMsg color1.
         * @member {number} color1
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.color1 = 0;
    
        /**
         * CUserMessageHudMsg color2.
         * @member {number} color2
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.color2 = 0;
    
        /**
         * CUserMessageHudMsg effect.
         * @member {number} effect
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.effect = 0;
    
        /**
         * CUserMessageHudMsg fade_in_time.
         * @member {number} fade_in_time
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.fade_in_time = 0;
    
        /**
         * CUserMessageHudMsg fade_out_time.
         * @member {number} fade_out_time
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.fade_out_time = 0;
    
        /**
         * CUserMessageHudMsg hold_time.
         * @member {number} hold_time
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.hold_time = 0;
    
        /**
         * CUserMessageHudMsg fx_time.
         * @member {number} fx_time
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.fx_time = 0;
    
        /**
         * CUserMessageHudMsg message.
         * @member {string} message
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.message = "";
    
        /**
         * Creates a new CUserMessageHudMsg instance using the specified properties.
         * @function create
         * @memberof CUserMessageHudMsg
         * @static
         * @param {ICUserMessageHudMsg=} [properties] Properties to set
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg instance
         */
        CUserMessageHudMsg.create = function create(properties) {
            return new CUserMessageHudMsg(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHudMsg message. Does not implicitly {@link CUserMessageHudMsg.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHudMsg
         * @static
         * @param {ICUserMessageHudMsg} message CUserMessageHudMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.y);
            if (message.color1 != null && Object.hasOwnProperty.call(message, "color1"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.color1);
            if (message.color2 != null && Object.hasOwnProperty.call(message, "color2"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.color2);
            if (message.effect != null && Object.hasOwnProperty.call(message, "effect"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.effect);
            if (message.fade_in_time != null && Object.hasOwnProperty.call(message, "fade_in_time"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.fade_in_time);
            if (message.fade_out_time != null && Object.hasOwnProperty.call(message, "fade_out_time"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.fade_out_time);
            if (message.hold_time != null && Object.hasOwnProperty.call(message, "hold_time"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.hold_time);
            if (message.fx_time != null && Object.hasOwnProperty.call(message, "fx_time"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.fx_time);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHudMsg message, length delimited. Does not implicitly {@link CUserMessageHudMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHudMsg
         * @static
         * @param {ICUserMessageHudMsg} message CUserMessageHudMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHudMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHudMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHudMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channel = reader.uint32();
                    break;
                case 2:
                    message.x = reader.float();
                    break;
                case 3:
                    message.y = reader.float();
                    break;
                case 4:
                    message.color1 = reader.fixed32();
                    break;
                case 5:
                    message.color2 = reader.fixed32();
                    break;
                case 6:
                    message.effect = reader.uint32();
                    break;
                case 7:
                    message.fade_in_time = reader.float();
                    break;
                case 8:
                    message.fade_out_time = reader.float();
                    break;
                case 9:
                    message.hold_time = reader.float();
                    break;
                case 10:
                    message.fx_time = reader.float();
                    break;
                case 11:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHudMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHudMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHudMsg message.
         * @function verify
         * @memberof CUserMessageHudMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHudMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.color1 != null && message.hasOwnProperty("color1"))
                if (!$util.isInteger(message.color1))
                    return "color1: integer expected";
            if (message.color2 != null && message.hasOwnProperty("color2"))
                if (!$util.isInteger(message.color2))
                    return "color2: integer expected";
            if (message.effect != null && message.hasOwnProperty("effect"))
                if (!$util.isInteger(message.effect))
                    return "effect: integer expected";
            if (message.fade_in_time != null && message.hasOwnProperty("fade_in_time"))
                if (typeof message.fade_in_time !== "number")
                    return "fade_in_time: number expected";
            if (message.fade_out_time != null && message.hasOwnProperty("fade_out_time"))
                if (typeof message.fade_out_time !== "number")
                    return "fade_out_time: number expected";
            if (message.hold_time != null && message.hasOwnProperty("hold_time"))
                if (typeof message.hold_time !== "number")
                    return "hold_time: number expected";
            if (message.fx_time != null && message.hasOwnProperty("fx_time"))
                if (typeof message.fx_time !== "number")
                    return "fx_time: number expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHudMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHudMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg
         */
        CUserMessageHudMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHudMsg)
                return object;
            var message = new $root.CUserMessageHudMsg();
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.color1 != null)
                message.color1 = object.color1 >>> 0;
            if (object.color2 != null)
                message.color2 = object.color2 >>> 0;
            if (object.effect != null)
                message.effect = object.effect >>> 0;
            if (object.fade_in_time != null)
                message.fade_in_time = Number(object.fade_in_time);
            if (object.fade_out_time != null)
                message.fade_out_time = Number(object.fade_out_time);
            if (object.hold_time != null)
                message.hold_time = Number(object.hold_time);
            if (object.fx_time != null)
                message.fx_time = Number(object.fx_time);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHudMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHudMsg
         * @static
         * @param {CUserMessageHudMsg} message CUserMessageHudMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHudMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channel = 0;
                object.x = 0;
                object.y = 0;
                object.color1 = 0;
                object.color2 = 0;
                object.effect = 0;
                object.fade_in_time = 0;
                object.fade_out_time = 0;
                object.hold_time = 0;
                object.fx_time = 0;
                object.message = "";
            }
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.color1 != null && message.hasOwnProperty("color1"))
                object.color1 = message.color1;
            if (message.color2 != null && message.hasOwnProperty("color2"))
                object.color2 = message.color2;
            if (message.effect != null && message.hasOwnProperty("effect"))
                object.effect = message.effect;
            if (message.fade_in_time != null && message.hasOwnProperty("fade_in_time"))
                object.fade_in_time = options.json && !isFinite(message.fade_in_time) ? String(message.fade_in_time) : message.fade_in_time;
            if (message.fade_out_time != null && message.hasOwnProperty("fade_out_time"))
                object.fade_out_time = options.json && !isFinite(message.fade_out_time) ? String(message.fade_out_time) : message.fade_out_time;
            if (message.hold_time != null && message.hasOwnProperty("hold_time"))
                object.hold_time = options.json && !isFinite(message.hold_time) ? String(message.hold_time) : message.hold_time;
            if (message.fx_time != null && message.hasOwnProperty("fx_time"))
                object.fx_time = options.json && !isFinite(message.fx_time) ? String(message.fx_time) : message.fx_time;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CUserMessageHudMsg to JSON.
         * @function toJSON
         * @memberof CUserMessageHudMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHudMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageHudMsg;
    })();
    
    $root.CUserMessageHudText = (function() {
    
        /**
         * Properties of a CUserMessageHudText.
         * @exports ICUserMessageHudText
         * @interface ICUserMessageHudText
         * @property {string|null} [message] CUserMessageHudText message
         */
    
        /**
         * Constructs a new CUserMessageHudText.
         * @exports CUserMessageHudText
         * @classdesc Represents a CUserMessageHudText.
         * @implements ICUserMessageHudText
         * @constructor
         * @param {ICUserMessageHudText=} [properties] Properties to set
         */
        function CUserMessageHudText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHudText message.
         * @member {string} message
         * @memberof CUserMessageHudText
         * @instance
         */
        CUserMessageHudText.prototype.message = "";
    
        /**
         * Creates a new CUserMessageHudText instance using the specified properties.
         * @function create
         * @memberof CUserMessageHudText
         * @static
         * @param {ICUserMessageHudText=} [properties] Properties to set
         * @returns {CUserMessageHudText} CUserMessageHudText instance
         */
        CUserMessageHudText.create = function create(properties) {
            return new CUserMessageHudText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHudText message. Does not implicitly {@link CUserMessageHudText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHudText
         * @static
         * @param {ICUserMessageHudText} message CUserMessageHudText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHudText message, length delimited. Does not implicitly {@link CUserMessageHudText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHudText
         * @static
         * @param {ICUserMessageHudText} message CUserMessageHudText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHudText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHudText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHudText} CUserMessageHudText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHudText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHudText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHudText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHudText} CUserMessageHudText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHudText message.
         * @function verify
         * @memberof CUserMessageHudText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHudText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHudText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHudText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHudText} CUserMessageHudText
         */
        CUserMessageHudText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHudText)
                return object;
            var message = new $root.CUserMessageHudText();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHudText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHudText
         * @static
         * @param {CUserMessageHudText} message CUserMessageHudText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHudText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CUserMessageHudText to JSON.
         * @function toJSON
         * @memberof CUserMessageHudText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHudText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageHudText;
    })();
    
    $root.CUserMessageTextMsg = (function() {
    
        /**
         * Properties of a CUserMessageTextMsg.
         * @exports ICUserMessageTextMsg
         * @interface ICUserMessageTextMsg
         * @property {number|null} [dest] CUserMessageTextMsg dest
         * @property {Array.<string>|null} [param] CUserMessageTextMsg param
         */
    
        /**
         * Constructs a new CUserMessageTextMsg.
         * @exports CUserMessageTextMsg
         * @classdesc Represents a CUserMessageTextMsg.
         * @implements ICUserMessageTextMsg
         * @constructor
         * @param {ICUserMessageTextMsg=} [properties] Properties to set
         */
        function CUserMessageTextMsg(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageTextMsg dest.
         * @member {number} dest
         * @memberof CUserMessageTextMsg
         * @instance
         */
        CUserMessageTextMsg.prototype.dest = 0;
    
        /**
         * CUserMessageTextMsg param.
         * @member {Array.<string>} param
         * @memberof CUserMessageTextMsg
         * @instance
         */
        CUserMessageTextMsg.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new CUserMessageTextMsg instance using the specified properties.
         * @function create
         * @memberof CUserMessageTextMsg
         * @static
         * @param {ICUserMessageTextMsg=} [properties] Properties to set
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg instance
         */
        CUserMessageTextMsg.create = function create(properties) {
            return new CUserMessageTextMsg(properties);
        };
    
        /**
         * Encodes the specified CUserMessageTextMsg message. Does not implicitly {@link CUserMessageTextMsg.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageTextMsg
         * @static
         * @param {ICUserMessageTextMsg} message CUserMessageTextMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageTextMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.dest);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageTextMsg message, length delimited. Does not implicitly {@link CUserMessageTextMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageTextMsg
         * @static
         * @param {ICUserMessageTextMsg} message CUserMessageTextMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageTextMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageTextMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageTextMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageTextMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageTextMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = reader.uint32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    message.param.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageTextMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageTextMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageTextMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageTextMsg message.
         * @function verify
         * @memberof CUserMessageTextMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageTextMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!$util.isInteger(message.dest))
                    return "dest: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isString(message.param[i]))
                        return "param: string[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageTextMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageTextMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg
         */
        CUserMessageTextMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageTextMsg)
                return object;
            var message = new $root.CUserMessageTextMsg();
            if (object.dest != null)
                message.dest = object.dest >>> 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".CUserMessageTextMsg.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = String(object.param[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageTextMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageTextMsg
         * @static
         * @param {CUserMessageTextMsg} message CUserMessageTextMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageTextMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.dest = 0;
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = message.dest;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this CUserMessageTextMsg to JSON.
         * @function toJSON
         * @memberof CUserMessageTextMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageTextMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageTextMsg;
    })();
    
    $root.CUserMessageGameTitle = (function() {
    
        /**
         * Properties of a CUserMessageGameTitle.
         * @exports ICUserMessageGameTitle
         * @interface ICUserMessageGameTitle
         */
    
        /**
         * Constructs a new CUserMessageGameTitle.
         * @exports CUserMessageGameTitle
         * @classdesc Represents a CUserMessageGameTitle.
         * @implements ICUserMessageGameTitle
         * @constructor
         * @param {ICUserMessageGameTitle=} [properties] Properties to set
         */
        function CUserMessageGameTitle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CUserMessageGameTitle instance using the specified properties.
         * @function create
         * @memberof CUserMessageGameTitle
         * @static
         * @param {ICUserMessageGameTitle=} [properties] Properties to set
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle instance
         */
        CUserMessageGameTitle.create = function create(properties) {
            return new CUserMessageGameTitle(properties);
        };
    
        /**
         * Encodes the specified CUserMessageGameTitle message. Does not implicitly {@link CUserMessageGameTitle.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageGameTitle
         * @static
         * @param {ICUserMessageGameTitle} message CUserMessageGameTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageGameTitle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageGameTitle message, length delimited. Does not implicitly {@link CUserMessageGameTitle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageGameTitle
         * @static
         * @param {ICUserMessageGameTitle} message CUserMessageGameTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageGameTitle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageGameTitle message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageGameTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageGameTitle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageGameTitle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageGameTitle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageGameTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageGameTitle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageGameTitle message.
         * @function verify
         * @memberof CUserMessageGameTitle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageGameTitle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageGameTitle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageGameTitle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle
         */
        CUserMessageGameTitle.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageGameTitle)
                return object;
            return new $root.CUserMessageGameTitle();
        };
    
        /**
         * Creates a plain object from a CUserMessageGameTitle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageGameTitle
         * @static
         * @param {CUserMessageGameTitle} message CUserMessageGameTitle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageGameTitle.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CUserMessageGameTitle to JSON.
         * @function toJSON
         * @memberof CUserMessageGameTitle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageGameTitle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageGameTitle;
    })();
    
    $root.CUserMessageResetHUD = (function() {
    
        /**
         * Properties of a CUserMessageResetHUD.
         * @exports ICUserMessageResetHUD
         * @interface ICUserMessageResetHUD
         */
    
        /**
         * Constructs a new CUserMessageResetHUD.
         * @exports CUserMessageResetHUD
         * @classdesc Represents a CUserMessageResetHUD.
         * @implements ICUserMessageResetHUD
         * @constructor
         * @param {ICUserMessageResetHUD=} [properties] Properties to set
         */
        function CUserMessageResetHUD(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CUserMessageResetHUD instance using the specified properties.
         * @function create
         * @memberof CUserMessageResetHUD
         * @static
         * @param {ICUserMessageResetHUD=} [properties] Properties to set
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD instance
         */
        CUserMessageResetHUD.create = function create(properties) {
            return new CUserMessageResetHUD(properties);
        };
    
        /**
         * Encodes the specified CUserMessageResetHUD message. Does not implicitly {@link CUserMessageResetHUD.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageResetHUD
         * @static
         * @param {ICUserMessageResetHUD} message CUserMessageResetHUD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageResetHUD.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageResetHUD message, length delimited. Does not implicitly {@link CUserMessageResetHUD.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageResetHUD
         * @static
         * @param {ICUserMessageResetHUD} message CUserMessageResetHUD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageResetHUD.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageResetHUD message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageResetHUD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageResetHUD.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageResetHUD();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageResetHUD message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageResetHUD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageResetHUD.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageResetHUD message.
         * @function verify
         * @memberof CUserMessageResetHUD
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageResetHUD.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageResetHUD message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageResetHUD
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD
         */
        CUserMessageResetHUD.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageResetHUD)
                return object;
            return new $root.CUserMessageResetHUD();
        };
    
        /**
         * Creates a plain object from a CUserMessageResetHUD message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageResetHUD
         * @static
         * @param {CUserMessageResetHUD} message CUserMessageResetHUD
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageResetHUD.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CUserMessageResetHUD to JSON.
         * @function toJSON
         * @memberof CUserMessageResetHUD
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageResetHUD.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageResetHUD;
    })();
    
    $root.CUserMessageSendAudio = (function() {
    
        /**
         * Properties of a CUserMessageSendAudio.
         * @exports ICUserMessageSendAudio
         * @interface ICUserMessageSendAudio
         * @property {string|null} [soundname] CUserMessageSendAudio soundname
         * @property {boolean|null} [stop] CUserMessageSendAudio stop
         */
    
        /**
         * Constructs a new CUserMessageSendAudio.
         * @exports CUserMessageSendAudio
         * @classdesc Represents a CUserMessageSendAudio.
         * @implements ICUserMessageSendAudio
         * @constructor
         * @param {ICUserMessageSendAudio=} [properties] Properties to set
         */
        function CUserMessageSendAudio(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSendAudio soundname.
         * @member {string} soundname
         * @memberof CUserMessageSendAudio
         * @instance
         */
        CUserMessageSendAudio.prototype.soundname = "";
    
        /**
         * CUserMessageSendAudio stop.
         * @member {boolean} stop
         * @memberof CUserMessageSendAudio
         * @instance
         */
        CUserMessageSendAudio.prototype.stop = false;
    
        /**
         * Creates a new CUserMessageSendAudio instance using the specified properties.
         * @function create
         * @memberof CUserMessageSendAudio
         * @static
         * @param {ICUserMessageSendAudio=} [properties] Properties to set
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio instance
         */
        CUserMessageSendAudio.create = function create(properties) {
            return new CUserMessageSendAudio(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSendAudio message. Does not implicitly {@link CUserMessageSendAudio.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSendAudio
         * @static
         * @param {ICUserMessageSendAudio} message CUserMessageSendAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSendAudio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.soundname != null && Object.hasOwnProperty.call(message, "soundname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.soundname);
            if (message.stop != null && Object.hasOwnProperty.call(message, "stop"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.stop);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSendAudio message, length delimited. Does not implicitly {@link CUserMessageSendAudio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSendAudio
         * @static
         * @param {ICUserMessageSendAudio} message CUserMessageSendAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSendAudio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSendAudio message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSendAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSendAudio.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSendAudio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.soundname = reader.string();
                    break;
                case 2:
                    message.stop = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSendAudio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSendAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSendAudio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSendAudio message.
         * @function verify
         * @memberof CUserMessageSendAudio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSendAudio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.soundname != null && message.hasOwnProperty("soundname"))
                if (!$util.isString(message.soundname))
                    return "soundname: string expected";
            if (message.stop != null && message.hasOwnProperty("stop"))
                if (typeof message.stop !== "boolean")
                    return "stop: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSendAudio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSendAudio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio
         */
        CUserMessageSendAudio.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSendAudio)
                return object;
            var message = new $root.CUserMessageSendAudio();
            if (object.soundname != null)
                message.soundname = String(object.soundname);
            if (object.stop != null)
                message.stop = Boolean(object.stop);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSendAudio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSendAudio
         * @static
         * @param {CUserMessageSendAudio} message CUserMessageSendAudio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSendAudio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.soundname = "";
                object.stop = false;
            }
            if (message.soundname != null && message.hasOwnProperty("soundname"))
                object.soundname = message.soundname;
            if (message.stop != null && message.hasOwnProperty("stop"))
                object.stop = message.stop;
            return object;
        };
    
        /**
         * Converts this CUserMessageSendAudio to JSON.
         * @function toJSON
         * @memberof CUserMessageSendAudio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSendAudio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageSendAudio;
    })();
    
    $root.CUserMessageAudioParameter = (function() {
    
        /**
         * Properties of a CUserMessageAudioParameter.
         * @exports ICUserMessageAudioParameter
         * @interface ICUserMessageAudioParameter
         * @property {number|null} [parameter_type] CUserMessageAudioParameter parameter_type
         * @property {number|null} [name_hash_code] CUserMessageAudioParameter name_hash_code
         * @property {number|null} [value] CUserMessageAudioParameter value
         * @property {number|null} [int_value] CUserMessageAudioParameter int_value
         */
    
        /**
         * Constructs a new CUserMessageAudioParameter.
         * @exports CUserMessageAudioParameter
         * @classdesc Represents a CUserMessageAudioParameter.
         * @implements ICUserMessageAudioParameter
         * @constructor
         * @param {ICUserMessageAudioParameter=} [properties] Properties to set
         */
        function CUserMessageAudioParameter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAudioParameter parameter_type.
         * @member {number} parameter_type
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.parameter_type = 0;
    
        /**
         * CUserMessageAudioParameter name_hash_code.
         * @member {number} name_hash_code
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.name_hash_code = 0;
    
        /**
         * CUserMessageAudioParameter value.
         * @member {number} value
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.value = 0;
    
        /**
         * CUserMessageAudioParameter int_value.
         * @member {number} int_value
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.int_value = 0;
    
        /**
         * Creates a new CUserMessageAudioParameter instance using the specified properties.
         * @function create
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {ICUserMessageAudioParameter=} [properties] Properties to set
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter instance
         */
        CUserMessageAudioParameter.create = function create(properties) {
            return new CUserMessageAudioParameter(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAudioParameter message. Does not implicitly {@link CUserMessageAudioParameter.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {ICUserMessageAudioParameter} message CUserMessageAudioParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAudioParameter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parameter_type != null && Object.hasOwnProperty.call(message, "parameter_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.parameter_type);
            if (message.name_hash_code != null && Object.hasOwnProperty.call(message, "name_hash_code"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.name_hash_code);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.value);
            if (message.int_value != null && Object.hasOwnProperty.call(message, "int_value"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.int_value);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAudioParameter message, length delimited. Does not implicitly {@link CUserMessageAudioParameter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {ICUserMessageAudioParameter} message CUserMessageAudioParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAudioParameter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAudioParameter message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAudioParameter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAudioParameter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.parameter_type = reader.uint32();
                    break;
                case 2:
                    message.name_hash_code = reader.uint32();
                    break;
                case 3:
                    message.value = reader.float();
                    break;
                case 4:
                    message.int_value = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAudioParameter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAudioParameter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAudioParameter message.
         * @function verify
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAudioParameter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parameter_type != null && message.hasOwnProperty("parameter_type"))
                if (!$util.isInteger(message.parameter_type))
                    return "parameter_type: integer expected";
            if (message.name_hash_code != null && message.hasOwnProperty("name_hash_code"))
                if (!$util.isInteger(message.name_hash_code))
                    return "name_hash_code: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            if (message.int_value != null && message.hasOwnProperty("int_value"))
                if (!$util.isInteger(message.int_value))
                    return "int_value: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAudioParameter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter
         */
        CUserMessageAudioParameter.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAudioParameter)
                return object;
            var message = new $root.CUserMessageAudioParameter();
            if (object.parameter_type != null)
                message.parameter_type = object.parameter_type >>> 0;
            if (object.name_hash_code != null)
                message.name_hash_code = object.name_hash_code >>> 0;
            if (object.value != null)
                message.value = Number(object.value);
            if (object.int_value != null)
                message.int_value = object.int_value >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAudioParameter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {CUserMessageAudioParameter} message CUserMessageAudioParameter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAudioParameter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.parameter_type = 0;
                object.name_hash_code = 0;
                object.value = 0;
                object.int_value = 0;
            }
            if (message.parameter_type != null && message.hasOwnProperty("parameter_type"))
                object.parameter_type = message.parameter_type;
            if (message.name_hash_code != null && message.hasOwnProperty("name_hash_code"))
                object.name_hash_code = message.name_hash_code;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.int_value != null && message.hasOwnProperty("int_value"))
                object.int_value = message.int_value;
            return object;
        };
    
        /**
         * Converts this CUserMessageAudioParameter to JSON.
         * @function toJSON
         * @memberof CUserMessageAudioParameter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAudioParameter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageAudioParameter;
    })();
    
    $root.CUserMessageVoiceMask = (function() {
    
        /**
         * Properties of a CUserMessageVoiceMask.
         * @exports ICUserMessageVoiceMask
         * @interface ICUserMessageVoiceMask
         * @property {Array.<number>|null} [gamerules_masks] CUserMessageVoiceMask gamerules_masks
         * @property {Array.<number>|null} [ban_masks] CUserMessageVoiceMask ban_masks
         * @property {boolean|null} [mod_enable] CUserMessageVoiceMask mod_enable
         */
    
        /**
         * Constructs a new CUserMessageVoiceMask.
         * @exports CUserMessageVoiceMask
         * @classdesc Represents a CUserMessageVoiceMask.
         * @implements ICUserMessageVoiceMask
         * @constructor
         * @param {ICUserMessageVoiceMask=} [properties] Properties to set
         */
        function CUserMessageVoiceMask(properties) {
            this.gamerules_masks = [];
            this.ban_masks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageVoiceMask gamerules_masks.
         * @member {Array.<number>} gamerules_masks
         * @memberof CUserMessageVoiceMask
         * @instance
         */
        CUserMessageVoiceMask.prototype.gamerules_masks = $util.emptyArray;
    
        /**
         * CUserMessageVoiceMask ban_masks.
         * @member {Array.<number>} ban_masks
         * @memberof CUserMessageVoiceMask
         * @instance
         */
        CUserMessageVoiceMask.prototype.ban_masks = $util.emptyArray;
    
        /**
         * CUserMessageVoiceMask mod_enable.
         * @member {boolean} mod_enable
         * @memberof CUserMessageVoiceMask
         * @instance
         */
        CUserMessageVoiceMask.prototype.mod_enable = false;
    
        /**
         * Creates a new CUserMessageVoiceMask instance using the specified properties.
         * @function create
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {ICUserMessageVoiceMask=} [properties] Properties to set
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask instance
         */
        CUserMessageVoiceMask.create = function create(properties) {
            return new CUserMessageVoiceMask(properties);
        };
    
        /**
         * Encodes the specified CUserMessageVoiceMask message. Does not implicitly {@link CUserMessageVoiceMask.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {ICUserMessageVoiceMask} message CUserMessageVoiceMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVoiceMask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gamerules_masks != null && message.gamerules_masks.length)
                for (var i = 0; i < message.gamerules_masks.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gamerules_masks[i]);
            if (message.ban_masks != null && message.ban_masks.length)
                for (var i = 0; i < message.ban_masks.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ban_masks[i]);
            if (message.mod_enable != null && Object.hasOwnProperty.call(message, "mod_enable"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.mod_enable);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageVoiceMask message, length delimited. Does not implicitly {@link CUserMessageVoiceMask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {ICUserMessageVoiceMask} message CUserMessageVoiceMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVoiceMask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageVoiceMask message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVoiceMask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageVoiceMask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.gamerules_masks && message.gamerules_masks.length))
                        message.gamerules_masks = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.gamerules_masks.push(reader.uint32());
                    } else
                        message.gamerules_masks.push(reader.uint32());
                    break;
                case 2:
                    if (!(message.ban_masks && message.ban_masks.length))
                        message.ban_masks = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ban_masks.push(reader.uint32());
                    } else
                        message.ban_masks.push(reader.uint32());
                    break;
                case 3:
                    message.mod_enable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageVoiceMask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVoiceMask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageVoiceMask message.
         * @function verify
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageVoiceMask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gamerules_masks != null && message.hasOwnProperty("gamerules_masks")) {
                if (!Array.isArray(message.gamerules_masks))
                    return "gamerules_masks: array expected";
                for (var i = 0; i < message.gamerules_masks.length; ++i)
                    if (!$util.isInteger(message.gamerules_masks[i]))
                        return "gamerules_masks: integer[] expected";
            }
            if (message.ban_masks != null && message.hasOwnProperty("ban_masks")) {
                if (!Array.isArray(message.ban_masks))
                    return "ban_masks: array expected";
                for (var i = 0; i < message.ban_masks.length; ++i)
                    if (!$util.isInteger(message.ban_masks[i]))
                        return "ban_masks: integer[] expected";
            }
            if (message.mod_enable != null && message.hasOwnProperty("mod_enable"))
                if (typeof message.mod_enable !== "boolean")
                    return "mod_enable: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageVoiceMask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask
         */
        CUserMessageVoiceMask.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageVoiceMask)
                return object;
            var message = new $root.CUserMessageVoiceMask();
            if (object.gamerules_masks) {
                if (!Array.isArray(object.gamerules_masks))
                    throw TypeError(".CUserMessageVoiceMask.gamerules_masks: array expected");
                message.gamerules_masks = [];
                for (var i = 0; i < object.gamerules_masks.length; ++i)
                    message.gamerules_masks[i] = object.gamerules_masks[i] >>> 0;
            }
            if (object.ban_masks) {
                if (!Array.isArray(object.ban_masks))
                    throw TypeError(".CUserMessageVoiceMask.ban_masks: array expected");
                message.ban_masks = [];
                for (var i = 0; i < object.ban_masks.length; ++i)
                    message.ban_masks[i] = object.ban_masks[i] >>> 0;
            }
            if (object.mod_enable != null)
                message.mod_enable = Boolean(object.mod_enable);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageVoiceMask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {CUserMessageVoiceMask} message CUserMessageVoiceMask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageVoiceMask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.gamerules_masks = [];
                object.ban_masks = [];
            }
            if (options.defaults)
                object.mod_enable = false;
            if (message.gamerules_masks && message.gamerules_masks.length) {
                object.gamerules_masks = [];
                for (var j = 0; j < message.gamerules_masks.length; ++j)
                    object.gamerules_masks[j] = message.gamerules_masks[j];
            }
            if (message.ban_masks && message.ban_masks.length) {
                object.ban_masks = [];
                for (var j = 0; j < message.ban_masks.length; ++j)
                    object.ban_masks[j] = message.ban_masks[j];
            }
            if (message.mod_enable != null && message.hasOwnProperty("mod_enable"))
                object.mod_enable = message.mod_enable;
            return object;
        };
    
        /**
         * Converts this CUserMessageVoiceMask to JSON.
         * @function toJSON
         * @memberof CUserMessageVoiceMask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageVoiceMask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageVoiceMask;
    })();
    
    $root.CUserMessageRequestState = (function() {
    
        /**
         * Properties of a CUserMessageRequestState.
         * @exports ICUserMessageRequestState
         * @interface ICUserMessageRequestState
         */
    
        /**
         * Constructs a new CUserMessageRequestState.
         * @exports CUserMessageRequestState
         * @classdesc Represents a CUserMessageRequestState.
         * @implements ICUserMessageRequestState
         * @constructor
         * @param {ICUserMessageRequestState=} [properties] Properties to set
         */
        function CUserMessageRequestState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CUserMessageRequestState instance using the specified properties.
         * @function create
         * @memberof CUserMessageRequestState
         * @static
         * @param {ICUserMessageRequestState=} [properties] Properties to set
         * @returns {CUserMessageRequestState} CUserMessageRequestState instance
         */
        CUserMessageRequestState.create = function create(properties) {
            return new CUserMessageRequestState(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRequestState message. Does not implicitly {@link CUserMessageRequestState.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRequestState
         * @static
         * @param {ICUserMessageRequestState} message CUserMessageRequestState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRequestState message, length delimited. Does not implicitly {@link CUserMessageRequestState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRequestState
         * @static
         * @param {ICUserMessageRequestState} message CUserMessageRequestState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRequestState message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRequestState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRequestState} CUserMessageRequestState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRequestState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRequestState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRequestState} CUserMessageRequestState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRequestState message.
         * @function verify
         * @memberof CUserMessageRequestState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRequestState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRequestState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRequestState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRequestState} CUserMessageRequestState
         */
        CUserMessageRequestState.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRequestState)
                return object;
            return new $root.CUserMessageRequestState();
        };
    
        /**
         * Creates a plain object from a CUserMessageRequestState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRequestState
         * @static
         * @param {CUserMessageRequestState} message CUserMessageRequestState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRequestState.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CUserMessageRequestState to JSON.
         * @function toJSON
         * @memberof CUserMessageRequestState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRequestState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageRequestState;
    })();
    
    $root.CUserMessageHintText = (function() {
    
        /**
         * Properties of a CUserMessageHintText.
         * @exports ICUserMessageHintText
         * @interface ICUserMessageHintText
         * @property {string|null} [message] CUserMessageHintText message
         */
    
        /**
         * Constructs a new CUserMessageHintText.
         * @exports CUserMessageHintText
         * @classdesc Represents a CUserMessageHintText.
         * @implements ICUserMessageHintText
         * @constructor
         * @param {ICUserMessageHintText=} [properties] Properties to set
         */
        function CUserMessageHintText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHintText message.
         * @member {string} message
         * @memberof CUserMessageHintText
         * @instance
         */
        CUserMessageHintText.prototype.message = "";
    
        /**
         * Creates a new CUserMessageHintText instance using the specified properties.
         * @function create
         * @memberof CUserMessageHintText
         * @static
         * @param {ICUserMessageHintText=} [properties] Properties to set
         * @returns {CUserMessageHintText} CUserMessageHintText instance
         */
        CUserMessageHintText.create = function create(properties) {
            return new CUserMessageHintText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHintText message. Does not implicitly {@link CUserMessageHintText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHintText
         * @static
         * @param {ICUserMessageHintText} message CUserMessageHintText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHintText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHintText message, length delimited. Does not implicitly {@link CUserMessageHintText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHintText
         * @static
         * @param {ICUserMessageHintText} message CUserMessageHintText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHintText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHintText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHintText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHintText} CUserMessageHintText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHintText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHintText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHintText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHintText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHintText} CUserMessageHintText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHintText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHintText message.
         * @function verify
         * @memberof CUserMessageHintText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHintText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHintText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHintText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHintText} CUserMessageHintText
         */
        CUserMessageHintText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHintText)
                return object;
            var message = new $root.CUserMessageHintText();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHintText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHintText
         * @static
         * @param {CUserMessageHintText} message CUserMessageHintText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHintText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CUserMessageHintText to JSON.
         * @function toJSON
         * @memberof CUserMessageHintText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHintText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageHintText;
    })();
    
    $root.CUserMessageKeyHintText = (function() {
    
        /**
         * Properties of a CUserMessageKeyHintText.
         * @exports ICUserMessageKeyHintText
         * @interface ICUserMessageKeyHintText
         * @property {Array.<string>|null} [messages] CUserMessageKeyHintText messages
         */
    
        /**
         * Constructs a new CUserMessageKeyHintText.
         * @exports CUserMessageKeyHintText
         * @classdesc Represents a CUserMessageKeyHintText.
         * @implements ICUserMessageKeyHintText
         * @constructor
         * @param {ICUserMessageKeyHintText=} [properties] Properties to set
         */
        function CUserMessageKeyHintText(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageKeyHintText messages.
         * @member {Array.<string>} messages
         * @memberof CUserMessageKeyHintText
         * @instance
         */
        CUserMessageKeyHintText.prototype.messages = $util.emptyArray;
    
        /**
         * Creates a new CUserMessageKeyHintText instance using the specified properties.
         * @function create
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {ICUserMessageKeyHintText=} [properties] Properties to set
         * @returns {CUserMessageKeyHintText} CUserMessageKeyHintText instance
         */
        CUserMessageKeyHintText.create = function create(properties) {
            return new CUserMessageKeyHintText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageKeyHintText message. Does not implicitly {@link CUserMessageKeyHintText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {ICUserMessageKeyHintText} message CUserMessageKeyHintText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageKeyHintText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messages[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageKeyHintText message, length delimited. Does not implicitly {@link CUserMessageKeyHintText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {ICUserMessageKeyHintText} message CUserMessageKeyHintText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageKeyHintText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageKeyHintText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageKeyHintText} CUserMessageKeyHintText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageKeyHintText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageKeyHintText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageKeyHintText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageKeyHintText} CUserMessageKeyHintText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageKeyHintText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageKeyHintText message.
         * @function verify
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageKeyHintText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i)
                    if (!$util.isString(message.messages[i]))
                        return "messages: string[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageKeyHintText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageKeyHintText} CUserMessageKeyHintText
         */
        CUserMessageKeyHintText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageKeyHintText)
                return object;
            var message = new $root.CUserMessageKeyHintText();
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".CUserMessageKeyHintText.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i)
                    message.messages[i] = String(object.messages[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageKeyHintText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageKeyHintText
         * @static
         * @param {CUserMessageKeyHintText} message CUserMessageKeyHintText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageKeyHintText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = message.messages[j];
            }
            return object;
        };
    
        /**
         * Converts this CUserMessageKeyHintText to JSON.
         * @function toJSON
         * @memberof CUserMessageKeyHintText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageKeyHintText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageKeyHintText;
    })();
    
    $root.CUserMessageVoiceSubtitle = (function() {
    
        /**
         * Properties of a CUserMessageVoiceSubtitle.
         * @exports ICUserMessageVoiceSubtitle
         * @interface ICUserMessageVoiceSubtitle
         * @property {number|null} [player] CUserMessageVoiceSubtitle player
         * @property {number|null} [menu] CUserMessageVoiceSubtitle menu
         * @property {number|null} [item] CUserMessageVoiceSubtitle item
         */
    
        /**
         * Constructs a new CUserMessageVoiceSubtitle.
         * @exports CUserMessageVoiceSubtitle
         * @classdesc Represents a CUserMessageVoiceSubtitle.
         * @implements ICUserMessageVoiceSubtitle
         * @constructor
         * @param {ICUserMessageVoiceSubtitle=} [properties] Properties to set
         */
        function CUserMessageVoiceSubtitle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageVoiceSubtitle player.
         * @member {number} player
         * @memberof CUserMessageVoiceSubtitle
         * @instance
         */
        CUserMessageVoiceSubtitle.prototype.player = 0;
    
        /**
         * CUserMessageVoiceSubtitle menu.
         * @member {number} menu
         * @memberof CUserMessageVoiceSubtitle
         * @instance
         */
        CUserMessageVoiceSubtitle.prototype.menu = 0;
    
        /**
         * CUserMessageVoiceSubtitle item.
         * @member {number} item
         * @memberof CUserMessageVoiceSubtitle
         * @instance
         */
        CUserMessageVoiceSubtitle.prototype.item = 0;
    
        /**
         * Creates a new CUserMessageVoiceSubtitle instance using the specified properties.
         * @function create
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {ICUserMessageVoiceSubtitle=} [properties] Properties to set
         * @returns {CUserMessageVoiceSubtitle} CUserMessageVoiceSubtitle instance
         */
        CUserMessageVoiceSubtitle.create = function create(properties) {
            return new CUserMessageVoiceSubtitle(properties);
        };
    
        /**
         * Encodes the specified CUserMessageVoiceSubtitle message. Does not implicitly {@link CUserMessageVoiceSubtitle.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {ICUserMessageVoiceSubtitle} message CUserMessageVoiceSubtitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVoiceSubtitle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player);
            if (message.menu != null && Object.hasOwnProperty.call(message, "menu"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.menu);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.item);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageVoiceSubtitle message, length delimited. Does not implicitly {@link CUserMessageVoiceSubtitle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {ICUserMessageVoiceSubtitle} message CUserMessageVoiceSubtitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVoiceSubtitle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageVoiceSubtitle message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageVoiceSubtitle} CUserMessageVoiceSubtitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVoiceSubtitle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageVoiceSubtitle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player = reader.int32();
                    break;
                case 2:
                    message.menu = reader.int32();
                    break;
                case 3:
                    message.item = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageVoiceSubtitle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageVoiceSubtitle} CUserMessageVoiceSubtitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVoiceSubtitle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageVoiceSubtitle message.
         * @function verify
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageVoiceSubtitle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player != null && message.hasOwnProperty("player"))
                if (!$util.isInteger(message.player))
                    return "player: integer expected";
            if (message.menu != null && message.hasOwnProperty("menu"))
                if (!$util.isInteger(message.menu))
                    return "menu: integer expected";
            if (message.item != null && message.hasOwnProperty("item"))
                if (!$util.isInteger(message.item))
                    return "item: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageVoiceSubtitle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageVoiceSubtitle} CUserMessageVoiceSubtitle
         */
        CUserMessageVoiceSubtitle.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageVoiceSubtitle)
                return object;
            var message = new $root.CUserMessageVoiceSubtitle();
            if (object.player != null)
                message.player = object.player | 0;
            if (object.menu != null)
                message.menu = object.menu | 0;
            if (object.item != null)
                message.item = object.item | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageVoiceSubtitle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageVoiceSubtitle
         * @static
         * @param {CUserMessageVoiceSubtitle} message CUserMessageVoiceSubtitle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageVoiceSubtitle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player = 0;
                object.menu = 0;
                object.item = 0;
            }
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = message.player;
            if (message.menu != null && message.hasOwnProperty("menu"))
                object.menu = message.menu;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = message.item;
            return object;
        };
    
        /**
         * Converts this CUserMessageVoiceSubtitle to JSON.
         * @function toJSON
         * @memberof CUserMessageVoiceSubtitle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageVoiceSubtitle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageVoiceSubtitle;
    })();
    
    $root.CUserMessageVGUIMenu = (function() {
    
        /**
         * Properties of a CUserMessageVGUIMenu.
         * @exports ICUserMessageVGUIMenu
         * @interface ICUserMessageVGUIMenu
         * @property {string|null} [name] CUserMessageVGUIMenu name
         * @property {boolean|null} [show] CUserMessageVGUIMenu show
         * @property {Array.<CUserMessageVGUIMenu.IKeys>|null} [keys] CUserMessageVGUIMenu keys
         */
    
        /**
         * Constructs a new CUserMessageVGUIMenu.
         * @exports CUserMessageVGUIMenu
         * @classdesc Represents a CUserMessageVGUIMenu.
         * @implements ICUserMessageVGUIMenu
         * @constructor
         * @param {ICUserMessageVGUIMenu=} [properties] Properties to set
         */
        function CUserMessageVGUIMenu(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageVGUIMenu name.
         * @member {string} name
         * @memberof CUserMessageVGUIMenu
         * @instance
         */
        CUserMessageVGUIMenu.prototype.name = "";
    
        /**
         * CUserMessageVGUIMenu show.
         * @member {boolean} show
         * @memberof CUserMessageVGUIMenu
         * @instance
         */
        CUserMessageVGUIMenu.prototype.show = false;
    
        /**
         * CUserMessageVGUIMenu keys.
         * @member {Array.<CUserMessageVGUIMenu.IKeys>} keys
         * @memberof CUserMessageVGUIMenu
         * @instance
         */
        CUserMessageVGUIMenu.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CUserMessageVGUIMenu instance using the specified properties.
         * @function create
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {ICUserMessageVGUIMenu=} [properties] Properties to set
         * @returns {CUserMessageVGUIMenu} CUserMessageVGUIMenu instance
         */
        CUserMessageVGUIMenu.create = function create(properties) {
            return new CUserMessageVGUIMenu(properties);
        };
    
        /**
         * Encodes the specified CUserMessageVGUIMenu message. Does not implicitly {@link CUserMessageVGUIMenu.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {ICUserMessageVGUIMenu} message CUserMessageVGUIMenu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVGUIMenu.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.show != null && Object.hasOwnProperty.call(message, "show"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.show);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CUserMessageVGUIMenu.Keys.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageVGUIMenu message, length delimited. Does not implicitly {@link CUserMessageVGUIMenu.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {ICUserMessageVGUIMenu} message CUserMessageVGUIMenu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVGUIMenu.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageVGUIMenu message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageVGUIMenu} CUserMessageVGUIMenu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVGUIMenu.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageVGUIMenu();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.show = reader.bool();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CUserMessageVGUIMenu.Keys.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageVGUIMenu message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageVGUIMenu} CUserMessageVGUIMenu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVGUIMenu.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageVGUIMenu message.
         * @function verify
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageVGUIMenu.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.show != null && message.hasOwnProperty("show"))
                if (typeof message.show !== "boolean")
                    return "show: boolean expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CUserMessageVGUIMenu.Keys.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageVGUIMenu message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageVGUIMenu} CUserMessageVGUIMenu
         */
        CUserMessageVGUIMenu.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageVGUIMenu)
                return object;
            var message = new $root.CUserMessageVGUIMenu();
            if (object.name != null)
                message.name = String(object.name);
            if (object.show != null)
                message.show = Boolean(object.show);
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CUserMessageVGUIMenu.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CUserMessageVGUIMenu.keys: object expected");
                    message.keys[i] = $root.CUserMessageVGUIMenu.Keys.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageVGUIMenu message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageVGUIMenu
         * @static
         * @param {CUserMessageVGUIMenu} message CUserMessageVGUIMenu
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageVGUIMenu.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.name = "";
                object.show = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.show != null && message.hasOwnProperty("show"))
                object.show = message.show;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CUserMessageVGUIMenu.Keys.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CUserMessageVGUIMenu to JSON.
         * @function toJSON
         * @memberof CUserMessageVGUIMenu
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageVGUIMenu.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CUserMessageVGUIMenu.Keys = (function() {
    
            /**
             * Properties of a Keys.
             * @memberof CUserMessageVGUIMenu
             * @interface IKeys
             * @property {string|null} [name] Keys name
             * @property {string|null} [value] Keys value
             */
    
            /**
             * Constructs a new Keys.
             * @memberof CUserMessageVGUIMenu
             * @classdesc Represents a Keys.
             * @implements IKeys
             * @constructor
             * @param {CUserMessageVGUIMenu.IKeys=} [properties] Properties to set
             */
            function Keys(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Keys name.
             * @member {string} name
             * @memberof CUserMessageVGUIMenu.Keys
             * @instance
             */
            Keys.prototype.name = "";
    
            /**
             * Keys value.
             * @member {string} value
             * @memberof CUserMessageVGUIMenu.Keys
             * @instance
             */
            Keys.prototype.value = "";
    
            /**
             * Creates a new Keys instance using the specified properties.
             * @function create
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {CUserMessageVGUIMenu.IKeys=} [properties] Properties to set
             * @returns {CUserMessageVGUIMenu.Keys} Keys instance
             */
            Keys.create = function create(properties) {
                return new Keys(properties);
            };
    
            /**
             * Encodes the specified Keys message. Does not implicitly {@link CUserMessageVGUIMenu.Keys.verify|verify} messages.
             * @function encode
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {CUserMessageVGUIMenu.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified Keys message, length delimited. Does not implicitly {@link CUserMessageVGUIMenu.Keys.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {CUserMessageVGUIMenu.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Keys message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessageVGUIMenu.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageVGUIMenu.Keys();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Keys message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessageVGUIMenu.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Keys message.
             * @function verify
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Keys.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a Keys message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessageVGUIMenu.Keys} Keys
             */
            Keys.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessageVGUIMenu.Keys)
                    return object;
                var message = new $root.CUserMessageVGUIMenu.Keys();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a Keys message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessageVGUIMenu.Keys
             * @static
             * @param {CUserMessageVGUIMenu.Keys} message Keys
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Keys.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this Keys to JSON.
             * @function toJSON
             * @memberof CUserMessageVGUIMenu.Keys
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Keys.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Keys;
        })();
    
        return CUserMessageVGUIMenu;
    })();
    
    $root.CUserMessageRumble = (function() {
    
        /**
         * Properties of a CUserMessageRumble.
         * @exports ICUserMessageRumble
         * @interface ICUserMessageRumble
         * @property {number|null} [index] CUserMessageRumble index
         * @property {number|null} [data] CUserMessageRumble data
         * @property {number|null} [flags] CUserMessageRumble flags
         */
    
        /**
         * Constructs a new CUserMessageRumble.
         * @exports CUserMessageRumble
         * @classdesc Represents a CUserMessageRumble.
         * @implements ICUserMessageRumble
         * @constructor
         * @param {ICUserMessageRumble=} [properties] Properties to set
         */
        function CUserMessageRumble(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageRumble index.
         * @member {number} index
         * @memberof CUserMessageRumble
         * @instance
         */
        CUserMessageRumble.prototype.index = 0;
    
        /**
         * CUserMessageRumble data.
         * @member {number} data
         * @memberof CUserMessageRumble
         * @instance
         */
        CUserMessageRumble.prototype.data = 0;
    
        /**
         * CUserMessageRumble flags.
         * @member {number} flags
         * @memberof CUserMessageRumble
         * @instance
         */
        CUserMessageRumble.prototype.flags = 0;
    
        /**
         * Creates a new CUserMessageRumble instance using the specified properties.
         * @function create
         * @memberof CUserMessageRumble
         * @static
         * @param {ICUserMessageRumble=} [properties] Properties to set
         * @returns {CUserMessageRumble} CUserMessageRumble instance
         */
        CUserMessageRumble.create = function create(properties) {
            return new CUserMessageRumble(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRumble message. Does not implicitly {@link CUserMessageRumble.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRumble
         * @static
         * @param {ICUserMessageRumble} message CUserMessageRumble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRumble.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.data);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flags);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRumble message, length delimited. Does not implicitly {@link CUserMessageRumble.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRumble
         * @static
         * @param {ICUserMessageRumble} message CUserMessageRumble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRumble.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRumble message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRumble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRumble} CUserMessageRumble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRumble.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRumble();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.data = reader.int32();
                    break;
                case 3:
                    message.flags = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRumble message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRumble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRumble} CUserMessageRumble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRumble.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRumble message.
         * @function verify
         * @memberof CUserMessageRumble
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRumble.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isInteger(message.data))
                    return "data: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRumble message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRumble
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRumble} CUserMessageRumble
         */
        CUserMessageRumble.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRumble)
                return object;
            var message = new $root.CUserMessageRumble();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.data != null)
                message.data = object.data | 0;
            if (object.flags != null)
                message.flags = object.flags | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageRumble message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRumble
         * @static
         * @param {CUserMessageRumble} message CUserMessageRumble
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRumble.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.data = 0;
                object.flags = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };
    
        /**
         * Converts this CUserMessageRumble to JSON.
         * @function toJSON
         * @memberof CUserMessageRumble
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRumble.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageRumble;
    })();
    
    $root.CUserMessageTrain = (function() {
    
        /**
         * Properties of a CUserMessageTrain.
         * @exports ICUserMessageTrain
         * @interface ICUserMessageTrain
         * @property {number|null} [position] CUserMessageTrain position
         */
    
        /**
         * Constructs a new CUserMessageTrain.
         * @exports CUserMessageTrain
         * @classdesc Represents a CUserMessageTrain.
         * @implements ICUserMessageTrain
         * @constructor
         * @param {ICUserMessageTrain=} [properties] Properties to set
         */
        function CUserMessageTrain(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageTrain position.
         * @member {number} position
         * @memberof CUserMessageTrain
         * @instance
         */
        CUserMessageTrain.prototype.position = 0;
    
        /**
         * Creates a new CUserMessageTrain instance using the specified properties.
         * @function create
         * @memberof CUserMessageTrain
         * @static
         * @param {ICUserMessageTrain=} [properties] Properties to set
         * @returns {CUserMessageTrain} CUserMessageTrain instance
         */
        CUserMessageTrain.create = function create(properties) {
            return new CUserMessageTrain(properties);
        };
    
        /**
         * Encodes the specified CUserMessageTrain message. Does not implicitly {@link CUserMessageTrain.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageTrain
         * @static
         * @param {ICUserMessageTrain} message CUserMessageTrain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageTrain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.position);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageTrain message, length delimited. Does not implicitly {@link CUserMessageTrain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageTrain
         * @static
         * @param {ICUserMessageTrain} message CUserMessageTrain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageTrain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageTrain message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageTrain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageTrain} CUserMessageTrain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageTrain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageTrain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageTrain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageTrain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageTrain} CUserMessageTrain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageTrain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageTrain message.
         * @function verify
         * @memberof CUserMessageTrain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageTrain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isInteger(message.position))
                    return "position: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageTrain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageTrain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageTrain} CUserMessageTrain
         */
        CUserMessageTrain.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageTrain)
                return object;
            var message = new $root.CUserMessageTrain();
            if (object.position != null)
                message.position = object.position >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageTrain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageTrain
         * @static
         * @param {CUserMessageTrain} message CUserMessageTrain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageTrain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.position = 0;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };
    
        /**
         * Converts this CUserMessageTrain to JSON.
         * @function toJSON
         * @memberof CUserMessageTrain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageTrain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageTrain;
    })();
    
    $root.CUserMessageSayTextChannel = (function() {
    
        /**
         * Properties of a CUserMessageSayTextChannel.
         * @exports ICUserMessageSayTextChannel
         * @interface ICUserMessageSayTextChannel
         * @property {number|null} [player] CUserMessageSayTextChannel player
         * @property {number|null} [channel] CUserMessageSayTextChannel channel
         * @property {string|null} [text] CUserMessageSayTextChannel text
         */
    
        /**
         * Constructs a new CUserMessageSayTextChannel.
         * @exports CUserMessageSayTextChannel
         * @classdesc Represents a CUserMessageSayTextChannel.
         * @implements ICUserMessageSayTextChannel
         * @constructor
         * @param {ICUserMessageSayTextChannel=} [properties] Properties to set
         */
        function CUserMessageSayTextChannel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSayTextChannel player.
         * @member {number} player
         * @memberof CUserMessageSayTextChannel
         * @instance
         */
        CUserMessageSayTextChannel.prototype.player = 0;
    
        /**
         * CUserMessageSayTextChannel channel.
         * @member {number} channel
         * @memberof CUserMessageSayTextChannel
         * @instance
         */
        CUserMessageSayTextChannel.prototype.channel = 0;
    
        /**
         * CUserMessageSayTextChannel text.
         * @member {string} text
         * @memberof CUserMessageSayTextChannel
         * @instance
         */
        CUserMessageSayTextChannel.prototype.text = "";
    
        /**
         * Creates a new CUserMessageSayTextChannel instance using the specified properties.
         * @function create
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {ICUserMessageSayTextChannel=} [properties] Properties to set
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel instance
         */
        CUserMessageSayTextChannel.create = function create(properties) {
            return new CUserMessageSayTextChannel(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSayTextChannel message. Does not implicitly {@link CUserMessageSayTextChannel.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {ICUserMessageSayTextChannel} message CUserMessageSayTextChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayTextChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channel);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSayTextChannel message, length delimited. Does not implicitly {@link CUserMessageSayTextChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {ICUserMessageSayTextChannel} message CUserMessageSayTextChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayTextChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSayTextChannel message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayTextChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSayTextChannel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player = reader.int32();
                    break;
                case 2:
                    message.channel = reader.int32();
                    break;
                case 3:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSayTextChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayTextChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSayTextChannel message.
         * @function verify
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSayTextChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player != null && message.hasOwnProperty("player"))
                if (!$util.isInteger(message.player))
                    return "player: integer expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSayTextChannel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel
         */
        CUserMessageSayTextChannel.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSayTextChannel)
                return object;
            var message = new $root.CUserMessageSayTextChannel();
            if (object.player != null)
                message.player = object.player | 0;
            if (object.channel != null)
                message.channel = object.channel | 0;
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSayTextChannel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {CUserMessageSayTextChannel} message CUserMessageSayTextChannel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSayTextChannel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player = 0;
                object.channel = 0;
                object.text = "";
            }
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = message.player;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };
    
        /**
         * Converts this CUserMessageSayTextChannel to JSON.
         * @function toJSON
         * @memberof CUserMessageSayTextChannel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSayTextChannel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageSayTextChannel;
    })();
    
    $root.CUserMessageColoredText = (function() {
    
        /**
         * Properties of a CUserMessageColoredText.
         * @exports ICUserMessageColoredText
         * @interface ICUserMessageColoredText
         * @property {number|null} [color] CUserMessageColoredText color
         * @property {string|null} [text] CUserMessageColoredText text
         * @property {boolean|null} [reset] CUserMessageColoredText reset
         * @property {number|null} [context_player_id] CUserMessageColoredText context_player_id
         * @property {number|null} [context_value] CUserMessageColoredText context_value
         * @property {number|null} [context_team_id] CUserMessageColoredText context_team_id
         */
    
        /**
         * Constructs a new CUserMessageColoredText.
         * @exports CUserMessageColoredText
         * @classdesc Represents a CUserMessageColoredText.
         * @implements ICUserMessageColoredText
         * @constructor
         * @param {ICUserMessageColoredText=} [properties] Properties to set
         */
        function CUserMessageColoredText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageColoredText color.
         * @member {number} color
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.color = 0;
    
        /**
         * CUserMessageColoredText text.
         * @member {string} text
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.text = "";
    
        /**
         * CUserMessageColoredText reset.
         * @member {boolean} reset
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.reset = false;
    
        /**
         * CUserMessageColoredText context_player_id.
         * @member {number} context_player_id
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.context_player_id = 0;
    
        /**
         * CUserMessageColoredText context_value.
         * @member {number} context_value
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.context_value = 0;
    
        /**
         * CUserMessageColoredText context_team_id.
         * @member {number} context_team_id
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.context_team_id = 0;
    
        /**
         * Creates a new CUserMessageColoredText instance using the specified properties.
         * @function create
         * @memberof CUserMessageColoredText
         * @static
         * @param {ICUserMessageColoredText=} [properties] Properties to set
         * @returns {CUserMessageColoredText} CUserMessageColoredText instance
         */
        CUserMessageColoredText.create = function create(properties) {
            return new CUserMessageColoredText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageColoredText message. Does not implicitly {@link CUserMessageColoredText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageColoredText
         * @static
         * @param {ICUserMessageColoredText} message CUserMessageColoredText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageColoredText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.color);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.reset != null && Object.hasOwnProperty.call(message, "reset"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reset);
            if (message.context_player_id != null && Object.hasOwnProperty.call(message, "context_player_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.context_player_id);
            if (message.context_value != null && Object.hasOwnProperty.call(message, "context_value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.context_value);
            if (message.context_team_id != null && Object.hasOwnProperty.call(message, "context_team_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.context_team_id);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageColoredText message, length delimited. Does not implicitly {@link CUserMessageColoredText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageColoredText
         * @static
         * @param {ICUserMessageColoredText} message CUserMessageColoredText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageColoredText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageColoredText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageColoredText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageColoredText} CUserMessageColoredText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageColoredText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageColoredText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.color = reader.uint32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.reset = reader.bool();
                    break;
                case 4:
                    message.context_player_id = reader.int32();
                    break;
                case 5:
                    message.context_value = reader.int32();
                    break;
                case 6:
                    message.context_team_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageColoredText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageColoredText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageColoredText} CUserMessageColoredText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageColoredText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageColoredText message.
         * @function verify
         * @memberof CUserMessageColoredText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageColoredText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.reset != null && message.hasOwnProperty("reset"))
                if (typeof message.reset !== "boolean")
                    return "reset: boolean expected";
            if (message.context_player_id != null && message.hasOwnProperty("context_player_id"))
                if (!$util.isInteger(message.context_player_id))
                    return "context_player_id: integer expected";
            if (message.context_value != null && message.hasOwnProperty("context_value"))
                if (!$util.isInteger(message.context_value))
                    return "context_value: integer expected";
            if (message.context_team_id != null && message.hasOwnProperty("context_team_id"))
                if (!$util.isInteger(message.context_team_id))
                    return "context_team_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageColoredText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageColoredText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageColoredText} CUserMessageColoredText
         */
        CUserMessageColoredText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageColoredText)
                return object;
            var message = new $root.CUserMessageColoredText();
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.reset != null)
                message.reset = Boolean(object.reset);
            if (object.context_player_id != null)
                message.context_player_id = object.context_player_id | 0;
            if (object.context_value != null)
                message.context_value = object.context_value | 0;
            if (object.context_team_id != null)
                message.context_team_id = object.context_team_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageColoredText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageColoredText
         * @static
         * @param {CUserMessageColoredText} message CUserMessageColoredText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageColoredText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = 0;
                object.text = "";
                object.reset = false;
                object.context_player_id = 0;
                object.context_value = 0;
                object.context_team_id = 0;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.reset != null && message.hasOwnProperty("reset"))
                object.reset = message.reset;
            if (message.context_player_id != null && message.hasOwnProperty("context_player_id"))
                object.context_player_id = message.context_player_id;
            if (message.context_value != null && message.hasOwnProperty("context_value"))
                object.context_value = message.context_value;
            if (message.context_team_id != null && message.hasOwnProperty("context_team_id"))
                object.context_team_id = message.context_team_id;
            return object;
        };
    
        /**
         * Converts this CUserMessageColoredText to JSON.
         * @function toJSON
         * @memberof CUserMessageColoredText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageColoredText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageColoredText;
    })();
    
    $root.CUserMessageItemPickup = (function() {
    
        /**
         * Properties of a CUserMessageItemPickup.
         * @exports ICUserMessageItemPickup
         * @interface ICUserMessageItemPickup
         * @property {string|null} [itemname] CUserMessageItemPickup itemname
         */
    
        /**
         * Constructs a new CUserMessageItemPickup.
         * @exports CUserMessageItemPickup
         * @classdesc Represents a CUserMessageItemPickup.
         * @implements ICUserMessageItemPickup
         * @constructor
         * @param {ICUserMessageItemPickup=} [properties] Properties to set
         */
        function CUserMessageItemPickup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageItemPickup itemname.
         * @member {string} itemname
         * @memberof CUserMessageItemPickup
         * @instance
         */
        CUserMessageItemPickup.prototype.itemname = "";
    
        /**
         * Creates a new CUserMessageItemPickup instance using the specified properties.
         * @function create
         * @memberof CUserMessageItemPickup
         * @static
         * @param {ICUserMessageItemPickup=} [properties] Properties to set
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup instance
         */
        CUserMessageItemPickup.create = function create(properties) {
            return new CUserMessageItemPickup(properties);
        };
    
        /**
         * Encodes the specified CUserMessageItemPickup message. Does not implicitly {@link CUserMessageItemPickup.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageItemPickup
         * @static
         * @param {ICUserMessageItemPickup} message CUserMessageItemPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageItemPickup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemname != null && Object.hasOwnProperty.call(message, "itemname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.itemname);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageItemPickup message, length delimited. Does not implicitly {@link CUserMessageItemPickup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageItemPickup
         * @static
         * @param {ICUserMessageItemPickup} message CUserMessageItemPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageItemPickup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageItemPickup message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageItemPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageItemPickup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageItemPickup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageItemPickup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageItemPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageItemPickup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageItemPickup message.
         * @function verify
         * @memberof CUserMessageItemPickup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageItemPickup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemname != null && message.hasOwnProperty("itemname"))
                if (!$util.isString(message.itemname))
                    return "itemname: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageItemPickup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageItemPickup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup
         */
        CUserMessageItemPickup.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageItemPickup)
                return object;
            var message = new $root.CUserMessageItemPickup();
            if (object.itemname != null)
                message.itemname = String(object.itemname);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageItemPickup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageItemPickup
         * @static
         * @param {CUserMessageItemPickup} message CUserMessageItemPickup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageItemPickup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemname = "";
            if (message.itemname != null && message.hasOwnProperty("itemname"))
                object.itemname = message.itemname;
            return object;
        };
    
        /**
         * Converts this CUserMessageItemPickup to JSON.
         * @function toJSON
         * @memberof CUserMessageItemPickup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageItemPickup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageItemPickup;
    })();
    
    $root.CUserMessageAmmoDenied = (function() {
    
        /**
         * Properties of a CUserMessageAmmoDenied.
         * @exports ICUserMessageAmmoDenied
         * @interface ICUserMessageAmmoDenied
         * @property {number|null} [ammo_id] CUserMessageAmmoDenied ammo_id
         */
    
        /**
         * Constructs a new CUserMessageAmmoDenied.
         * @exports CUserMessageAmmoDenied
         * @classdesc Represents a CUserMessageAmmoDenied.
         * @implements ICUserMessageAmmoDenied
         * @constructor
         * @param {ICUserMessageAmmoDenied=} [properties] Properties to set
         */
        function CUserMessageAmmoDenied(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAmmoDenied ammo_id.
         * @member {number} ammo_id
         * @memberof CUserMessageAmmoDenied
         * @instance
         */
        CUserMessageAmmoDenied.prototype.ammo_id = 0;
    
        /**
         * Creates a new CUserMessageAmmoDenied instance using the specified properties.
         * @function create
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {ICUserMessageAmmoDenied=} [properties] Properties to set
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied instance
         */
        CUserMessageAmmoDenied.create = function create(properties) {
            return new CUserMessageAmmoDenied(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAmmoDenied message. Does not implicitly {@link CUserMessageAmmoDenied.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {ICUserMessageAmmoDenied} message CUserMessageAmmoDenied message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAmmoDenied.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ammo_id != null && Object.hasOwnProperty.call(message, "ammo_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ammo_id);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAmmoDenied message, length delimited. Does not implicitly {@link CUserMessageAmmoDenied.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {ICUserMessageAmmoDenied} message CUserMessageAmmoDenied message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAmmoDenied.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAmmoDenied message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAmmoDenied.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAmmoDenied();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ammo_id = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAmmoDenied message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAmmoDenied.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAmmoDenied message.
         * @function verify
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAmmoDenied.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ammo_id != null && message.hasOwnProperty("ammo_id"))
                if (!$util.isInteger(message.ammo_id))
                    return "ammo_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAmmoDenied message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied
         */
        CUserMessageAmmoDenied.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAmmoDenied)
                return object;
            var message = new $root.CUserMessageAmmoDenied();
            if (object.ammo_id != null)
                message.ammo_id = object.ammo_id >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAmmoDenied message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {CUserMessageAmmoDenied} message CUserMessageAmmoDenied
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAmmoDenied.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.ammo_id = 0;
            if (message.ammo_id != null && message.hasOwnProperty("ammo_id"))
                object.ammo_id = message.ammo_id;
            return object;
        };
    
        /**
         * Converts this CUserMessageAmmoDenied to JSON.
         * @function toJSON
         * @memberof CUserMessageAmmoDenied
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAmmoDenied.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageAmmoDenied;
    })();
    
    $root.CUserMessageCrosshairAngle = (function() {
    
        /**
         * Properties of a CUserMessageCrosshairAngle.
         * @exports ICUserMessageCrosshairAngle
         * @interface ICUserMessageCrosshairAngle
         * @property {ICMsgQAngle|null} [angcrosshair] CUserMessageCrosshairAngle angcrosshair
         */
    
        /**
         * Constructs a new CUserMessageCrosshairAngle.
         * @exports CUserMessageCrosshairAngle
         * @classdesc Represents a CUserMessageCrosshairAngle.
         * @implements ICUserMessageCrosshairAngle
         * @constructor
         * @param {ICUserMessageCrosshairAngle=} [properties] Properties to set
         */
        function CUserMessageCrosshairAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCrosshairAngle angcrosshair.
         * @member {ICMsgQAngle|null|undefined} angcrosshair
         * @memberof CUserMessageCrosshairAngle
         * @instance
         */
        CUserMessageCrosshairAngle.prototype.angcrosshair = null;
    
        /**
         * Creates a new CUserMessageCrosshairAngle instance using the specified properties.
         * @function create
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {ICUserMessageCrosshairAngle=} [properties] Properties to set
         * @returns {CUserMessageCrosshairAngle} CUserMessageCrosshairAngle instance
         */
        CUserMessageCrosshairAngle.create = function create(properties) {
            return new CUserMessageCrosshairAngle(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCrosshairAngle message. Does not implicitly {@link CUserMessageCrosshairAngle.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {ICUserMessageCrosshairAngle} message CUserMessageCrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCrosshairAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.angcrosshair != null && Object.hasOwnProperty.call(message, "angcrosshair"))
                $root.CMsgQAngle.encode(message.angcrosshair, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCrosshairAngle message, length delimited. Does not implicitly {@link CUserMessageCrosshairAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {ICUserMessageCrosshairAngle} message CUserMessageCrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCrosshairAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCrosshairAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCrosshairAngle} CUserMessageCrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCrosshairAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCrosshairAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.angcrosshair = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCrosshairAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCrosshairAngle} CUserMessageCrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCrosshairAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCrosshairAngle message.
         * @function verify
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCrosshairAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.angcrosshair != null && message.hasOwnProperty("angcrosshair")) {
                var error = $root.CMsgQAngle.verify(message.angcrosshair);
                if (error)
                    return "angcrosshair." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageCrosshairAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCrosshairAngle} CUserMessageCrosshairAngle
         */
        CUserMessageCrosshairAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCrosshairAngle)
                return object;
            var message = new $root.CUserMessageCrosshairAngle();
            if (object.angcrosshair != null) {
                if (typeof object.angcrosshair !== "object")
                    throw TypeError(".CUserMessageCrosshairAngle.angcrosshair: object expected");
                message.angcrosshair = $root.CMsgQAngle.fromObject(object.angcrosshair);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCrosshairAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCrosshairAngle
         * @static
         * @param {CUserMessageCrosshairAngle} message CUserMessageCrosshairAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCrosshairAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.angcrosshair = null;
            if (message.angcrosshair != null && message.hasOwnProperty("angcrosshair"))
                object.angcrosshair = $root.CMsgQAngle.toObject(message.angcrosshair, options);
            return object;
        };
    
        /**
         * Converts this CUserMessageCrosshairAngle to JSON.
         * @function toJSON
         * @memberof CUserMessageCrosshairAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCrosshairAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageCrosshairAngle;
    })();
    
    $root.CUserMessageShowMenu = (function() {
    
        /**
         * Properties of a CUserMessageShowMenu.
         * @exports ICUserMessageShowMenu
         * @interface ICUserMessageShowMenu
         * @property {number|null} [validslots] CUserMessageShowMenu validslots
         * @property {number|null} [displaytime] CUserMessageShowMenu displaytime
         * @property {boolean|null} [needmore] CUserMessageShowMenu needmore
         * @property {string|null} [menustring] CUserMessageShowMenu menustring
         */
    
        /**
         * Constructs a new CUserMessageShowMenu.
         * @exports CUserMessageShowMenu
         * @classdesc Represents a CUserMessageShowMenu.
         * @implements ICUserMessageShowMenu
         * @constructor
         * @param {ICUserMessageShowMenu=} [properties] Properties to set
         */
        function CUserMessageShowMenu(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageShowMenu validslots.
         * @member {number} validslots
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.validslots = 0;
    
        /**
         * CUserMessageShowMenu displaytime.
         * @member {number} displaytime
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.displaytime = 0;
    
        /**
         * CUserMessageShowMenu needmore.
         * @member {boolean} needmore
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.needmore = false;
    
        /**
         * CUserMessageShowMenu menustring.
         * @member {string} menustring
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.menustring = "";
    
        /**
         * Creates a new CUserMessageShowMenu instance using the specified properties.
         * @function create
         * @memberof CUserMessageShowMenu
         * @static
         * @param {ICUserMessageShowMenu=} [properties] Properties to set
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu instance
         */
        CUserMessageShowMenu.create = function create(properties) {
            return new CUserMessageShowMenu(properties);
        };
    
        /**
         * Encodes the specified CUserMessageShowMenu message. Does not implicitly {@link CUserMessageShowMenu.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageShowMenu
         * @static
         * @param {ICUserMessageShowMenu} message CUserMessageShowMenu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShowMenu.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validslots != null && Object.hasOwnProperty.call(message, "validslots"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.validslots);
            if (message.displaytime != null && Object.hasOwnProperty.call(message, "displaytime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.displaytime);
            if (message.needmore != null && Object.hasOwnProperty.call(message, "needmore"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needmore);
            if (message.menustring != null && Object.hasOwnProperty.call(message, "menustring"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.menustring);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageShowMenu message, length delimited. Does not implicitly {@link CUserMessageShowMenu.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageShowMenu
         * @static
         * @param {ICUserMessageShowMenu} message CUserMessageShowMenu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShowMenu.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageShowMenu message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageShowMenu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShowMenu.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageShowMenu();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.validslots = reader.uint32();
                    break;
                case 2:
                    message.displaytime = reader.uint32();
                    break;
                case 3:
                    message.needmore = reader.bool();
                    break;
                case 4:
                    message.menustring = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageShowMenu message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageShowMenu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShowMenu.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageShowMenu message.
         * @function verify
         * @memberof CUserMessageShowMenu
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageShowMenu.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validslots != null && message.hasOwnProperty("validslots"))
                if (!$util.isInteger(message.validslots))
                    return "validslots: integer expected";
            if (message.displaytime != null && message.hasOwnProperty("displaytime"))
                if (!$util.isInteger(message.displaytime))
                    return "displaytime: integer expected";
            if (message.needmore != null && message.hasOwnProperty("needmore"))
                if (typeof message.needmore !== "boolean")
                    return "needmore: boolean expected";
            if (message.menustring != null && message.hasOwnProperty("menustring"))
                if (!$util.isString(message.menustring))
                    return "menustring: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageShowMenu message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageShowMenu
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu
         */
        CUserMessageShowMenu.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageShowMenu)
                return object;
            var message = new $root.CUserMessageShowMenu();
            if (object.validslots != null)
                message.validslots = object.validslots >>> 0;
            if (object.displaytime != null)
                message.displaytime = object.displaytime >>> 0;
            if (object.needmore != null)
                message.needmore = Boolean(object.needmore);
            if (object.menustring != null)
                message.menustring = String(object.menustring);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageShowMenu message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageShowMenu
         * @static
         * @param {CUserMessageShowMenu} message CUserMessageShowMenu
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageShowMenu.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.validslots = 0;
                object.displaytime = 0;
                object.needmore = false;
                object.menustring = "";
            }
            if (message.validslots != null && message.hasOwnProperty("validslots"))
                object.validslots = message.validslots;
            if (message.displaytime != null && message.hasOwnProperty("displaytime"))
                object.displaytime = message.displaytime;
            if (message.needmore != null && message.hasOwnProperty("needmore"))
                object.needmore = message.needmore;
            if (message.menustring != null && message.hasOwnProperty("menustring"))
                object.menustring = message.menustring;
            return object;
        };
    
        /**
         * Converts this CUserMessageShowMenu to JSON.
         * @function toJSON
         * @memberof CUserMessageShowMenu
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageShowMenu.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageShowMenu;
    })();
    
    $root.CUserMessageCreditsMsg = (function() {
    
        /**
         * Properties of a CUserMessageCreditsMsg.
         * @exports ICUserMessageCreditsMsg
         * @interface ICUserMessageCreditsMsg
         * @property {eRollType|null} [rolltype] CUserMessageCreditsMsg rolltype
         * @property {number|null} [logo_length] CUserMessageCreditsMsg logo_length
         */
    
        /**
         * Constructs a new CUserMessageCreditsMsg.
         * @exports CUserMessageCreditsMsg
         * @classdesc Represents a CUserMessageCreditsMsg.
         * @implements ICUserMessageCreditsMsg
         * @constructor
         * @param {ICUserMessageCreditsMsg=} [properties] Properties to set
         */
        function CUserMessageCreditsMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCreditsMsg rolltype.
         * @member {eRollType} rolltype
         * @memberof CUserMessageCreditsMsg
         * @instance
         */
        CUserMessageCreditsMsg.prototype.rolltype = -1;
    
        /**
         * CUserMessageCreditsMsg logo_length.
         * @member {number} logo_length
         * @memberof CUserMessageCreditsMsg
         * @instance
         */
        CUserMessageCreditsMsg.prototype.logo_length = 0;
    
        /**
         * Creates a new CUserMessageCreditsMsg instance using the specified properties.
         * @function create
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {ICUserMessageCreditsMsg=} [properties] Properties to set
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg instance
         */
        CUserMessageCreditsMsg.create = function create(properties) {
            return new CUserMessageCreditsMsg(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCreditsMsg message. Does not implicitly {@link CUserMessageCreditsMsg.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {ICUserMessageCreditsMsg} message CUserMessageCreditsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCreditsMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rolltype != null && Object.hasOwnProperty.call(message, "rolltype"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rolltype);
            if (message.logo_length != null && Object.hasOwnProperty.call(message, "logo_length"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.logo_length);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCreditsMsg message, length delimited. Does not implicitly {@link CUserMessageCreditsMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {ICUserMessageCreditsMsg} message CUserMessageCreditsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCreditsMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCreditsMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCreditsMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCreditsMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rolltype = reader.int32();
                    break;
                case 2:
                    message.logo_length = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCreditsMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCreditsMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCreditsMsg message.
         * @function verify
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCreditsMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rolltype != null && message.hasOwnProperty("rolltype"))
                switch (message.rolltype) {
                default:
                    return "rolltype: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.logo_length != null && message.hasOwnProperty("logo_length"))
                if (typeof message.logo_length !== "number")
                    return "logo_length: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCreditsMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg
         */
        CUserMessageCreditsMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCreditsMsg)
                return object;
            var message = new $root.CUserMessageCreditsMsg();
            switch (object.rolltype) {
            case "ROLL_NONE":
            case -1:
                message.rolltype = -1;
                break;
            case "ROLL_STATS":
            case 0:
                message.rolltype = 0;
                break;
            case "ROLL_CREDITS":
            case 1:
                message.rolltype = 1;
                break;
            case "ROLL_LATE_JOIN_LOGO":
            case 2:
                message.rolltype = 2;
                break;
            case "ROLL_OUTTRO":
            case 3:
                message.rolltype = 3;
                break;
            }
            if (object.logo_length != null)
                message.logo_length = Number(object.logo_length);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCreditsMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {CUserMessageCreditsMsg} message CUserMessageCreditsMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCreditsMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rolltype = options.enums === String ? "ROLL_NONE" : -1;
                object.logo_length = 0;
            }
            if (message.rolltype != null && message.hasOwnProperty("rolltype"))
                object.rolltype = options.enums === String ? $root.eRollType[message.rolltype] : message.rolltype;
            if (message.logo_length != null && message.hasOwnProperty("logo_length"))
                object.logo_length = options.json && !isFinite(message.logo_length) ? String(message.logo_length) : message.logo_length;
            return object;
        };
    
        /**
         * Converts this CUserMessageCreditsMsg to JSON.
         * @function toJSON
         * @memberof CUserMessageCreditsMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCreditsMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageCreditsMsg;
    })();
    
    $root.CEntityMessagePlayJingle = (function() {
    
        /**
         * Properties of a CEntityMessagePlayJingle.
         * @exports ICEntityMessagePlayJingle
         * @interface ICEntityMessagePlayJingle
         * @property {ICEntityMsg|null} [entity_msg] CEntityMessagePlayJingle entity_msg
         */
    
        /**
         * Constructs a new CEntityMessagePlayJingle.
         * @exports CEntityMessagePlayJingle
         * @classdesc Represents a CEntityMessagePlayJingle.
         * @implements ICEntityMessagePlayJingle
         * @constructor
         * @param {ICEntityMessagePlayJingle=} [properties] Properties to set
         */
        function CEntityMessagePlayJingle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessagePlayJingle entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CEntityMessagePlayJingle
         * @instance
         */
        CEntityMessagePlayJingle.prototype.entity_msg = null;
    
        /**
         * Creates a new CEntityMessagePlayJingle instance using the specified properties.
         * @function create
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {ICEntityMessagePlayJingle=} [properties] Properties to set
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle instance
         */
        CEntityMessagePlayJingle.create = function create(properties) {
            return new CEntityMessagePlayJingle(properties);
        };
    
        /**
         * Encodes the specified CEntityMessagePlayJingle message. Does not implicitly {@link CEntityMessagePlayJingle.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {ICEntityMessagePlayJingle} message CEntityMessagePlayJingle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePlayJingle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessagePlayJingle message, length delimited. Does not implicitly {@link CEntityMessagePlayJingle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {ICEntityMessagePlayJingle} message CEntityMessagePlayJingle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePlayJingle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessagePlayJingle message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePlayJingle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessagePlayJingle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessagePlayJingle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePlayJingle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessagePlayJingle message.
         * @function verify
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessagePlayJingle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessagePlayJingle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle
         */
        CEntityMessagePlayJingle.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessagePlayJingle)
                return object;
            var message = new $root.CEntityMessagePlayJingle();
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CEntityMessagePlayJingle.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessagePlayJingle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {CEntityMessagePlayJingle} message CEntityMessagePlayJingle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessagePlayJingle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.entity_msg = null;
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessagePlayJingle to JSON.
         * @function toJSON
         * @memberof CEntityMessagePlayJingle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessagePlayJingle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMessagePlayJingle;
    })();
    
    $root.CEntityMessageScreenOverlay = (function() {
    
        /**
         * Properties of a CEntityMessageScreenOverlay.
         * @exports ICEntityMessageScreenOverlay
         * @interface ICEntityMessageScreenOverlay
         * @property {boolean|null} [start_effect] CEntityMessageScreenOverlay start_effect
         * @property {ICEntityMsg|null} [entity_msg] CEntityMessageScreenOverlay entity_msg
         */
    
        /**
         * Constructs a new CEntityMessageScreenOverlay.
         * @exports CEntityMessageScreenOverlay
         * @classdesc Represents a CEntityMessageScreenOverlay.
         * @implements ICEntityMessageScreenOverlay
         * @constructor
         * @param {ICEntityMessageScreenOverlay=} [properties] Properties to set
         */
        function CEntityMessageScreenOverlay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageScreenOverlay start_effect.
         * @member {boolean} start_effect
         * @memberof CEntityMessageScreenOverlay
         * @instance
         */
        CEntityMessageScreenOverlay.prototype.start_effect = false;
    
        /**
         * CEntityMessageScreenOverlay entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CEntityMessageScreenOverlay
         * @instance
         */
        CEntityMessageScreenOverlay.prototype.entity_msg = null;
    
        /**
         * Creates a new CEntityMessageScreenOverlay instance using the specified properties.
         * @function create
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {ICEntityMessageScreenOverlay=} [properties] Properties to set
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay instance
         */
        CEntityMessageScreenOverlay.create = function create(properties) {
            return new CEntityMessageScreenOverlay(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageScreenOverlay message. Does not implicitly {@link CEntityMessageScreenOverlay.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {ICEntityMessageScreenOverlay} message CEntityMessageScreenOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageScreenOverlay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start_effect != null && Object.hasOwnProperty.call(message, "start_effect"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.start_effect);
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageScreenOverlay message, length delimited. Does not implicitly {@link CEntityMessageScreenOverlay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {ICEntityMessageScreenOverlay} message CEntityMessageScreenOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageScreenOverlay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageScreenOverlay message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageScreenOverlay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageScreenOverlay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.start_effect = reader.bool();
                    break;
                case 2:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageScreenOverlay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageScreenOverlay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageScreenOverlay message.
         * @function verify
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageScreenOverlay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start_effect != null && message.hasOwnProperty("start_effect"))
                if (typeof message.start_effect !== "boolean")
                    return "start_effect: boolean expected";
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageScreenOverlay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay
         */
        CEntityMessageScreenOverlay.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageScreenOverlay)
                return object;
            var message = new $root.CEntityMessageScreenOverlay();
            if (object.start_effect != null)
                message.start_effect = Boolean(object.start_effect);
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CEntityMessageScreenOverlay.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageScreenOverlay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {CEntityMessageScreenOverlay} message CEntityMessageScreenOverlay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageScreenOverlay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.start_effect = false;
                object.entity_msg = null;
            }
            if (message.start_effect != null && message.hasOwnProperty("start_effect"))
                object.start_effect = message.start_effect;
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageScreenOverlay to JSON.
         * @function toJSON
         * @memberof CEntityMessageScreenOverlay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageScreenOverlay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMessageScreenOverlay;
    })();
    
    $root.CEntityMessageRemoveAllDecals = (function() {
    
        /**
         * Properties of a CEntityMessageRemoveAllDecals.
         * @exports ICEntityMessageRemoveAllDecals
         * @interface ICEntityMessageRemoveAllDecals
         * @property {boolean|null} [remove_decals] CEntityMessageRemoveAllDecals remove_decals
         * @property {ICEntityMsg|null} [entity_msg] CEntityMessageRemoveAllDecals entity_msg
         */
    
        /**
         * Constructs a new CEntityMessageRemoveAllDecals.
         * @exports CEntityMessageRemoveAllDecals
         * @classdesc Represents a CEntityMessageRemoveAllDecals.
         * @implements ICEntityMessageRemoveAllDecals
         * @constructor
         * @param {ICEntityMessageRemoveAllDecals=} [properties] Properties to set
         */
        function CEntityMessageRemoveAllDecals(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageRemoveAllDecals remove_decals.
         * @member {boolean} remove_decals
         * @memberof CEntityMessageRemoveAllDecals
         * @instance
         */
        CEntityMessageRemoveAllDecals.prototype.remove_decals = false;
    
        /**
         * CEntityMessageRemoveAllDecals entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CEntityMessageRemoveAllDecals
         * @instance
         */
        CEntityMessageRemoveAllDecals.prototype.entity_msg = null;
    
        /**
         * Creates a new CEntityMessageRemoveAllDecals instance using the specified properties.
         * @function create
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {ICEntityMessageRemoveAllDecals=} [properties] Properties to set
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals instance
         */
        CEntityMessageRemoveAllDecals.create = function create(properties) {
            return new CEntityMessageRemoveAllDecals(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageRemoveAllDecals message. Does not implicitly {@link CEntityMessageRemoveAllDecals.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {ICEntityMessageRemoveAllDecals} message CEntityMessageRemoveAllDecals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageRemoveAllDecals.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.remove_decals != null && Object.hasOwnProperty.call(message, "remove_decals"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.remove_decals);
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageRemoveAllDecals message, length delimited. Does not implicitly {@link CEntityMessageRemoveAllDecals.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {ICEntityMessageRemoveAllDecals} message CEntityMessageRemoveAllDecals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageRemoveAllDecals.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageRemoveAllDecals message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageRemoveAllDecals.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageRemoveAllDecals();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.remove_decals = reader.bool();
                    break;
                case 2:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageRemoveAllDecals message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageRemoveAllDecals.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageRemoveAllDecals message.
         * @function verify
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageRemoveAllDecals.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.remove_decals != null && message.hasOwnProperty("remove_decals"))
                if (typeof message.remove_decals !== "boolean")
                    return "remove_decals: boolean expected";
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageRemoveAllDecals message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals
         */
        CEntityMessageRemoveAllDecals.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageRemoveAllDecals)
                return object;
            var message = new $root.CEntityMessageRemoveAllDecals();
            if (object.remove_decals != null)
                message.remove_decals = Boolean(object.remove_decals);
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CEntityMessageRemoveAllDecals.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageRemoveAllDecals message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {CEntityMessageRemoveAllDecals} message CEntityMessageRemoveAllDecals
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageRemoveAllDecals.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.remove_decals = false;
                object.entity_msg = null;
            }
            if (message.remove_decals != null && message.hasOwnProperty("remove_decals"))
                object.remove_decals = message.remove_decals;
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageRemoveAllDecals to JSON.
         * @function toJSON
         * @memberof CEntityMessageRemoveAllDecals
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageRemoveAllDecals.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMessageRemoveAllDecals;
    })();
    
    $root.CEntityMessagePropagateForce = (function() {
    
        /**
         * Properties of a CEntityMessagePropagateForce.
         * @exports ICEntityMessagePropagateForce
         * @interface ICEntityMessagePropagateForce
         * @property {ICMsgVector|null} [impulse] CEntityMessagePropagateForce impulse
         * @property {ICEntityMsg|null} [entity_msg] CEntityMessagePropagateForce entity_msg
         */
    
        /**
         * Constructs a new CEntityMessagePropagateForce.
         * @exports CEntityMessagePropagateForce
         * @classdesc Represents a CEntityMessagePropagateForce.
         * @implements ICEntityMessagePropagateForce
         * @constructor
         * @param {ICEntityMessagePropagateForce=} [properties] Properties to set
         */
        function CEntityMessagePropagateForce(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessagePropagateForce impulse.
         * @member {ICMsgVector|null|undefined} impulse
         * @memberof CEntityMessagePropagateForce
         * @instance
         */
        CEntityMessagePropagateForce.prototype.impulse = null;
    
        /**
         * CEntityMessagePropagateForce entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CEntityMessagePropagateForce
         * @instance
         */
        CEntityMessagePropagateForce.prototype.entity_msg = null;
    
        /**
         * Creates a new CEntityMessagePropagateForce instance using the specified properties.
         * @function create
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {ICEntityMessagePropagateForce=} [properties] Properties to set
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce instance
         */
        CEntityMessagePropagateForce.create = function create(properties) {
            return new CEntityMessagePropagateForce(properties);
        };
    
        /**
         * Encodes the specified CEntityMessagePropagateForce message. Does not implicitly {@link CEntityMessagePropagateForce.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {ICEntityMessagePropagateForce} message CEntityMessagePropagateForce message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePropagateForce.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.impulse != null && Object.hasOwnProperty.call(message, "impulse"))
                $root.CMsgVector.encode(message.impulse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessagePropagateForce message, length delimited. Does not implicitly {@link CEntityMessagePropagateForce.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {ICEntityMessagePropagateForce} message CEntityMessagePropagateForce message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePropagateForce.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessagePropagateForce message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePropagateForce.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessagePropagateForce();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.impulse = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessagePropagateForce message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePropagateForce.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessagePropagateForce message.
         * @function verify
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessagePropagateForce.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.impulse != null && message.hasOwnProperty("impulse")) {
                var error = $root.CMsgVector.verify(message.impulse);
                if (error)
                    return "impulse." + error;
            }
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessagePropagateForce message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce
         */
        CEntityMessagePropagateForce.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessagePropagateForce)
                return object;
            var message = new $root.CEntityMessagePropagateForce();
            if (object.impulse != null) {
                if (typeof object.impulse !== "object")
                    throw TypeError(".CEntityMessagePropagateForce.impulse: object expected");
                message.impulse = $root.CMsgVector.fromObject(object.impulse);
            }
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CEntityMessagePropagateForce.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessagePropagateForce message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {CEntityMessagePropagateForce} message CEntityMessagePropagateForce
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessagePropagateForce.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.impulse = null;
                object.entity_msg = null;
            }
            if (message.impulse != null && message.hasOwnProperty("impulse"))
                object.impulse = $root.CMsgVector.toObject(message.impulse, options);
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessagePropagateForce to JSON.
         * @function toJSON
         * @memberof CEntityMessagePropagateForce
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessagePropagateForce.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMessagePropagateForce;
    })();
    
    $root.CEntityMessageDoSpark = (function() {
    
        /**
         * Properties of a CEntityMessageDoSpark.
         * @exports ICEntityMessageDoSpark
         * @interface ICEntityMessageDoSpark
         * @property {ICMsgVector|null} [origin] CEntityMessageDoSpark origin
         * @property {number|null} [entityindex] CEntityMessageDoSpark entityindex
         * @property {number|null} [radius] CEntityMessageDoSpark radius
         * @property {number|null} [color] CEntityMessageDoSpark color
         * @property {number|null} [beams] CEntityMessageDoSpark beams
         * @property {number|null} [thick] CEntityMessageDoSpark thick
         * @property {number|null} [duration] CEntityMessageDoSpark duration
         * @property {ICEntityMsg|null} [entity_msg] CEntityMessageDoSpark entity_msg
         */
    
        /**
         * Constructs a new CEntityMessageDoSpark.
         * @exports CEntityMessageDoSpark
         * @classdesc Represents a CEntityMessageDoSpark.
         * @implements ICEntityMessageDoSpark
         * @constructor
         * @param {ICEntityMessageDoSpark=} [properties] Properties to set
         */
        function CEntityMessageDoSpark(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageDoSpark origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.origin = null;
    
        /**
         * CEntityMessageDoSpark entityindex.
         * @member {number} entityindex
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.entityindex = 0;
    
        /**
         * CEntityMessageDoSpark radius.
         * @member {number} radius
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.radius = 0;
    
        /**
         * CEntityMessageDoSpark color.
         * @member {number} color
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.color = 0;
    
        /**
         * CEntityMessageDoSpark beams.
         * @member {number} beams
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.beams = 0;
    
        /**
         * CEntityMessageDoSpark thick.
         * @member {number} thick
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.thick = 0;
    
        /**
         * CEntityMessageDoSpark duration.
         * @member {number} duration
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.duration = 0;
    
        /**
         * CEntityMessageDoSpark entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.entity_msg = null;
    
        /**
         * Creates a new CEntityMessageDoSpark instance using the specified properties.
         * @function create
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {ICEntityMessageDoSpark=} [properties] Properties to set
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark instance
         */
        CEntityMessageDoSpark.create = function create(properties) {
            return new CEntityMessageDoSpark(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageDoSpark message. Does not implicitly {@link CEntityMessageDoSpark.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {ICEntityMessageDoSpark} message CEntityMessageDoSpark message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageDoSpark.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.entityindex != null && Object.hasOwnProperty.call(message, "entityindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entityindex);
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.radius);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.color);
            if (message.beams != null && Object.hasOwnProperty.call(message, "beams"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.beams);
            if (message.thick != null && Object.hasOwnProperty.call(message, "thick"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.thick);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.duration);
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageDoSpark message, length delimited. Does not implicitly {@link CEntityMessageDoSpark.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {ICEntityMessageDoSpark} message CEntityMessageDoSpark message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageDoSpark.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageDoSpark message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageDoSpark.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageDoSpark();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.entityindex = reader.uint32();
                    break;
                case 3:
                    message.radius = reader.float();
                    break;
                case 4:
                    message.color = reader.fixed32();
                    break;
                case 5:
                    message.beams = reader.uint32();
                    break;
                case 6:
                    message.thick = reader.float();
                    break;
                case 7:
                    message.duration = reader.float();
                    break;
                case 8:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageDoSpark message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageDoSpark.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageDoSpark message.
         * @function verify
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageDoSpark.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                if (!$util.isInteger(message.entityindex))
                    return "entityindex: integer expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.beams != null && message.hasOwnProperty("beams"))
                if (!$util.isInteger(message.beams))
                    return "beams: integer expected";
            if (message.thick != null && message.hasOwnProperty("thick"))
                if (typeof message.thick !== "number")
                    return "thick: number expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageDoSpark message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark
         */
        CEntityMessageDoSpark.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageDoSpark)
                return object;
            var message = new $root.CEntityMessageDoSpark();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CEntityMessageDoSpark.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.entityindex != null)
                message.entityindex = object.entityindex >>> 0;
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.beams != null)
                message.beams = object.beams >>> 0;
            if (object.thick != null)
                message.thick = Number(object.thick);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CEntityMessageDoSpark.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageDoSpark message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {CEntityMessageDoSpark} message CEntityMessageDoSpark
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageDoSpark.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.entityindex = 0;
                object.radius = 0;
                object.color = 0;
                object.beams = 0;
                object.thick = 0;
                object.duration = 0;
                object.entity_msg = null;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                object.entityindex = message.entityindex;
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.beams != null && message.hasOwnProperty("beams"))
                object.beams = message.beams;
            if (message.thick != null && message.hasOwnProperty("thick"))
                object.thick = options.json && !isFinite(message.thick) ? String(message.thick) : message.thick;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageDoSpark to JSON.
         * @function toJSON
         * @memberof CEntityMessageDoSpark
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageDoSpark.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMessageDoSpark;
    })();
    
    $root.CEntityMessageFixAngle = (function() {
    
        /**
         * Properties of a CEntityMessageFixAngle.
         * @exports ICEntityMessageFixAngle
         * @interface ICEntityMessageFixAngle
         * @property {boolean|null} [relative] CEntityMessageFixAngle relative
         * @property {ICMsgQAngle|null} [angle] CEntityMessageFixAngle angle
         * @property {ICEntityMsg|null} [entity_msg] CEntityMessageFixAngle entity_msg
         */
    
        /**
         * Constructs a new CEntityMessageFixAngle.
         * @exports CEntityMessageFixAngle
         * @classdesc Represents a CEntityMessageFixAngle.
         * @implements ICEntityMessageFixAngle
         * @constructor
         * @param {ICEntityMessageFixAngle=} [properties] Properties to set
         */
        function CEntityMessageFixAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageFixAngle relative.
         * @member {boolean} relative
         * @memberof CEntityMessageFixAngle
         * @instance
         */
        CEntityMessageFixAngle.prototype.relative = false;
    
        /**
         * CEntityMessageFixAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CEntityMessageFixAngle
         * @instance
         */
        CEntityMessageFixAngle.prototype.angle = null;
    
        /**
         * CEntityMessageFixAngle entity_msg.
         * @member {ICEntityMsg|null|undefined} entity_msg
         * @memberof CEntityMessageFixAngle
         * @instance
         */
        CEntityMessageFixAngle.prototype.entity_msg = null;
    
        /**
         * Creates a new CEntityMessageFixAngle instance using the specified properties.
         * @function create
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {ICEntityMessageFixAngle=} [properties] Properties to set
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle instance
         */
        CEntityMessageFixAngle.create = function create(properties) {
            return new CEntityMessageFixAngle(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageFixAngle message. Does not implicitly {@link CEntityMessageFixAngle.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {ICEntityMessageFixAngle} message CEntityMessageFixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageFixAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relative != null && Object.hasOwnProperty.call(message, "relative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.relative);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.entity_msg != null && Object.hasOwnProperty.call(message, "entity_msg"))
                $root.CEntityMsg.encode(message.entity_msg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageFixAngle message, length delimited. Does not implicitly {@link CEntityMessageFixAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {ICEntityMessageFixAngle} message CEntityMessageFixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageFixAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageFixAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageFixAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageFixAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.relative = reader.bool();
                    break;
                case 2:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.entity_msg = $root.CEntityMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageFixAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageFixAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageFixAngle message.
         * @function verify
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageFixAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.relative != null && message.hasOwnProperty("relative"))
                if (typeof message.relative !== "boolean")
                    return "relative: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg")) {
                var error = $root.CEntityMsg.verify(message.entity_msg);
                if (error)
                    return "entity_msg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageFixAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle
         */
        CEntityMessageFixAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageFixAngle)
                return object;
            var message = new $root.CEntityMessageFixAngle();
            if (object.relative != null)
                message.relative = Boolean(object.relative);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CEntityMessageFixAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            if (object.entity_msg != null) {
                if (typeof object.entity_msg !== "object")
                    throw TypeError(".CEntityMessageFixAngle.entity_msg: object expected");
                message.entity_msg = $root.CEntityMsg.fromObject(object.entity_msg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageFixAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {CEntityMessageFixAngle} message CEntityMessageFixAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageFixAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relative = false;
                object.angle = null;
                object.entity_msg = null;
            }
            if (message.relative != null && message.hasOwnProperty("relative"))
                object.relative = message.relative;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            if (message.entity_msg != null && message.hasOwnProperty("entity_msg"))
                object.entity_msg = $root.CEntityMsg.toObject(message.entity_msg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageFixAngle to JSON.
         * @function toJSON
         * @memberof CEntityMessageFixAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageFixAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMessageFixAngle;
    })();
    
    $root.CUserMessageCameraTransition = (function() {
    
        /**
         * Properties of a CUserMessageCameraTransition.
         * @exports ICUserMessageCameraTransition
         * @interface ICUserMessageCameraTransition
         * @property {number|null} [camera_type] CUserMessageCameraTransition camera_type
         * @property {number|null} [duration] CUserMessageCameraTransition duration
         * @property {CUserMessageCameraTransition.ITransition_DataDriven|null} [params_data_driven] CUserMessageCameraTransition params_data_driven
         */
    
        /**
         * Constructs a new CUserMessageCameraTransition.
         * @exports CUserMessageCameraTransition
         * @classdesc Represents a CUserMessageCameraTransition.
         * @implements ICUserMessageCameraTransition
         * @constructor
         * @param {ICUserMessageCameraTransition=} [properties] Properties to set
         */
        function CUserMessageCameraTransition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCameraTransition camera_type.
         * @member {number} camera_type
         * @memberof CUserMessageCameraTransition
         * @instance
         */
        CUserMessageCameraTransition.prototype.camera_type = 0;
    
        /**
         * CUserMessageCameraTransition duration.
         * @member {number} duration
         * @memberof CUserMessageCameraTransition
         * @instance
         */
        CUserMessageCameraTransition.prototype.duration = 0;
    
        /**
         * CUserMessageCameraTransition params_data_driven.
         * @member {CUserMessageCameraTransition.ITransition_DataDriven|null|undefined} params_data_driven
         * @memberof CUserMessageCameraTransition
         * @instance
         */
        CUserMessageCameraTransition.prototype.params_data_driven = null;
    
        /**
         * Creates a new CUserMessageCameraTransition instance using the specified properties.
         * @function create
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {ICUserMessageCameraTransition=} [properties] Properties to set
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition instance
         */
        CUserMessageCameraTransition.create = function create(properties) {
            return new CUserMessageCameraTransition(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCameraTransition message. Does not implicitly {@link CUserMessageCameraTransition.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {ICUserMessageCameraTransition} message CUserMessageCameraTransition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCameraTransition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.camera_type != null && Object.hasOwnProperty.call(message, "camera_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.camera_type);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.params_data_driven != null && Object.hasOwnProperty.call(message, "params_data_driven"))
                $root.CUserMessageCameraTransition.Transition_DataDriven.encode(message.params_data_driven, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCameraTransition message, length delimited. Does not implicitly {@link CUserMessageCameraTransition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {ICUserMessageCameraTransition} message CUserMessageCameraTransition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCameraTransition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCameraTransition message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCameraTransition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCameraTransition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.camera_type = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.float();
                    break;
                case 3:
                    message.params_data_driven = $root.CUserMessageCameraTransition.Transition_DataDriven.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCameraTransition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCameraTransition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCameraTransition message.
         * @function verify
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCameraTransition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.camera_type != null && message.hasOwnProperty("camera_type"))
                if (!$util.isInteger(message.camera_type))
                    return "camera_type: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.params_data_driven != null && message.hasOwnProperty("params_data_driven")) {
                var error = $root.CUserMessageCameraTransition.Transition_DataDriven.verify(message.params_data_driven);
                if (error)
                    return "params_data_driven." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageCameraTransition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition
         */
        CUserMessageCameraTransition.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCameraTransition)
                return object;
            var message = new $root.CUserMessageCameraTransition();
            if (object.camera_type != null)
                message.camera_type = object.camera_type >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.params_data_driven != null) {
                if (typeof object.params_data_driven !== "object")
                    throw TypeError(".CUserMessageCameraTransition.params_data_driven: object expected");
                message.params_data_driven = $root.CUserMessageCameraTransition.Transition_DataDriven.fromObject(object.params_data_driven);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCameraTransition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {CUserMessageCameraTransition} message CUserMessageCameraTransition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCameraTransition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.camera_type = 0;
                object.duration = 0;
                object.params_data_driven = null;
            }
            if (message.camera_type != null && message.hasOwnProperty("camera_type"))
                object.camera_type = message.camera_type;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.params_data_driven != null && message.hasOwnProperty("params_data_driven"))
                object.params_data_driven = $root.CUserMessageCameraTransition.Transition_DataDriven.toObject(message.params_data_driven, options);
            return object;
        };
    
        /**
         * Converts this CUserMessageCameraTransition to JSON.
         * @function toJSON
         * @memberof CUserMessageCameraTransition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCameraTransition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CUserMessageCameraTransition.Transition_DataDriven = (function() {
    
            /**
             * Properties of a Transition_DataDriven.
             * @memberof CUserMessageCameraTransition
             * @interface ITransition_DataDriven
             * @property {string|null} [filename] Transition_DataDriven filename
             * @property {number|null} [attach_ent_index] Transition_DataDriven attach_ent_index
             */
    
            /**
             * Constructs a new Transition_DataDriven.
             * @memberof CUserMessageCameraTransition
             * @classdesc Represents a Transition_DataDriven.
             * @implements ITransition_DataDriven
             * @constructor
             * @param {CUserMessageCameraTransition.ITransition_DataDriven=} [properties] Properties to set
             */
            function Transition_DataDriven(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Transition_DataDriven filename.
             * @member {string} filename
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             */
            Transition_DataDriven.prototype.filename = "";
    
            /**
             * Transition_DataDriven attach_ent_index.
             * @member {number} attach_ent_index
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             */
            Transition_DataDriven.prototype.attach_ent_index = 0;
    
            /**
             * Creates a new Transition_DataDriven instance using the specified properties.
             * @function create
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.ITransition_DataDriven=} [properties] Properties to set
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven instance
             */
            Transition_DataDriven.create = function create(properties) {
                return new Transition_DataDriven(properties);
            };
    
            /**
             * Encodes the specified Transition_DataDriven message. Does not implicitly {@link CUserMessageCameraTransition.Transition_DataDriven.verify|verify} messages.
             * @function encode
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.ITransition_DataDriven} message Transition_DataDriven message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transition_DataDriven.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filename);
                if (message.attach_ent_index != null && Object.hasOwnProperty.call(message, "attach_ent_index"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attach_ent_index);
                return writer;
            };
    
            /**
             * Encodes the specified Transition_DataDriven message, length delimited. Does not implicitly {@link CUserMessageCameraTransition.Transition_DataDriven.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.ITransition_DataDriven} message Transition_DataDriven message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transition_DataDriven.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Transition_DataDriven message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transition_DataDriven.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCameraTransition.Transition_DataDriven();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.filename = reader.string();
                        break;
                    case 2:
                        message.attach_ent_index = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Transition_DataDriven message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transition_DataDriven.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Transition_DataDriven message.
             * @function verify
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Transition_DataDriven.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.attach_ent_index != null && message.hasOwnProperty("attach_ent_index"))
                    if (!$util.isInteger(message.attach_ent_index))
                        return "attach_ent_index: integer expected";
                return null;
            };
    
            /**
             * Creates a Transition_DataDriven message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven
             */
            Transition_DataDriven.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessageCameraTransition.Transition_DataDriven)
                    return object;
                var message = new $root.CUserMessageCameraTransition.Transition_DataDriven();
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.attach_ent_index != null)
                    message.attach_ent_index = object.attach_ent_index | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Transition_DataDriven message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.Transition_DataDriven} message Transition_DataDriven
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transition_DataDriven.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.filename = "";
                    object.attach_ent_index = 0;
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.attach_ent_index != null && message.hasOwnProperty("attach_ent_index"))
                    object.attach_ent_index = message.attach_ent_index;
                return object;
            };
    
            /**
             * Converts this Transition_DataDriven to JSON.
             * @function toJSON
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Transition_DataDriven.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Transition_DataDriven;
        })();
    
        return CUserMessageCameraTransition;
    })();
    
    $root.CUserMsg_ParticleManager = (function() {
    
        /**
         * Properties of a CUserMsg_ParticleManager.
         * @exports ICUserMsg_ParticleManager
         * @interface ICUserMsg_ParticleManager
         * @property {PARTICLE_MESSAGE} type CUserMsg_ParticleManager type
         * @property {number} index CUserMsg_ParticleManager index
         * @property {CUserMsg_ParticleManager.IReleaseParticleIndex|null} [release_particle_index] CUserMsg_ParticleManager release_particle_index
         * @property {CUserMsg_ParticleManager.ICreateParticle|null} [create_particle] CUserMsg_ParticleManager create_particle
         * @property {CUserMsg_ParticleManager.IDestroyParticle|null} [destroy_particle] CUserMsg_ParticleManager destroy_particle
         * @property {CUserMsg_ParticleManager.IDestroyParticleInvolving|null} [destroy_particle_involving] CUserMsg_ParticleManager destroy_particle_involving
         * @property {CUserMsg_ParticleManager.IUpdateParticle|null} [update_particle] CUserMsg_ParticleManager update_particle
         * @property {CUserMsg_ParticleManager.IUpdateParticleFwd|null} [update_particle_fwd] CUserMsg_ParticleManager update_particle_fwd
         * @property {CUserMsg_ParticleManager.IUpdateParticleOrient|null} [update_particle_orient] CUserMsg_ParticleManager update_particle_orient
         * @property {CUserMsg_ParticleManager.IUpdateParticleFallback|null} [update_particle_fallback] CUserMsg_ParticleManager update_particle_fallback
         * @property {CUserMsg_ParticleManager.IUpdateParticleOffset|null} [update_particle_offset] CUserMsg_ParticleManager update_particle_offset
         * @property {CUserMsg_ParticleManager.IUpdateParticleEnt|null} [update_particle_ent] CUserMsg_ParticleManager update_particle_ent
         * @property {CUserMsg_ParticleManager.IUpdateParticleShouldDraw|null} [update_particle_should_draw] CUserMsg_ParticleManager update_particle_should_draw
         * @property {CUserMsg_ParticleManager.IUpdateParticleSetFrozen|null} [update_particle_set_frozen] CUserMsg_ParticleManager update_particle_set_frozen
         * @property {CUserMsg_ParticleManager.IChangeControlPointAttachment|null} [change_control_point_attachment] CUserMsg_ParticleManager change_control_point_attachment
         * @property {CUserMsg_ParticleManager.IUpdateEntityPosition|null} [update_entity_position] CUserMsg_ParticleManager update_entity_position
         * @property {CUserMsg_ParticleManager.ISetParticleFoWProperties|null} [set_particle_fow_properties] CUserMsg_ParticleManager set_particle_fow_properties
         * @property {CUserMsg_ParticleManager.ISetParticleText|null} [set_particle_text] CUserMsg_ParticleManager set_particle_text
         * @property {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW|null} [set_particle_should_check_fow] CUserMsg_ParticleManager set_particle_should_check_fow
         * @property {CUserMsg_ParticleManager.ISetControlPointModel|null} [set_control_point_model] CUserMsg_ParticleManager set_control_point_model
         * @property {CUserMsg_ParticleManager.ISetControlPointSnapshot|null} [set_control_point_snapshot] CUserMsg_ParticleManager set_control_point_snapshot
         * @property {CUserMsg_ParticleManager.ISetTextureAttribute|null} [set_texture_attribute] CUserMsg_ParticleManager set_texture_attribute
         * @property {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag|null} [set_scene_object_generic_flag] CUserMsg_ParticleManager set_scene_object_generic_flag
         * @property {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat|null} [set_scene_object_tint_and_desat] CUserMsg_ParticleManager set_scene_object_tint_and_desat
         */
    
        /**
         * Constructs a new CUserMsg_ParticleManager.
         * @exports CUserMsg_ParticleManager
         * @classdesc Represents a CUserMsg_ParticleManager.
         * @implements ICUserMsg_ParticleManager
         * @constructor
         * @param {ICUserMsg_ParticleManager=} [properties] Properties to set
         */
        function CUserMsg_ParticleManager(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMsg_ParticleManager type.
         * @member {PARTICLE_MESSAGE} type
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.type = 0;
    
        /**
         * CUserMsg_ParticleManager index.
         * @member {number} index
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.index = 0;
    
        /**
         * CUserMsg_ParticleManager release_particle_index.
         * @member {CUserMsg_ParticleManager.IReleaseParticleIndex|null|undefined} release_particle_index
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.release_particle_index = null;
    
        /**
         * CUserMsg_ParticleManager create_particle.
         * @member {CUserMsg_ParticleManager.ICreateParticle|null|undefined} create_particle
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.create_particle = null;
    
        /**
         * CUserMsg_ParticleManager destroy_particle.
         * @member {CUserMsg_ParticleManager.IDestroyParticle|null|undefined} destroy_particle
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.destroy_particle = null;
    
        /**
         * CUserMsg_ParticleManager destroy_particle_involving.
         * @member {CUserMsg_ParticleManager.IDestroyParticleInvolving|null|undefined} destroy_particle_involving
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.destroy_particle_involving = null;
    
        /**
         * CUserMsg_ParticleManager update_particle.
         * @member {CUserMsg_ParticleManager.IUpdateParticle|null|undefined} update_particle
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_fwd.
         * @member {CUserMsg_ParticleManager.IUpdateParticleFwd|null|undefined} update_particle_fwd
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_fwd = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_orient.
         * @member {CUserMsg_ParticleManager.IUpdateParticleOrient|null|undefined} update_particle_orient
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_orient = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_fallback.
         * @member {CUserMsg_ParticleManager.IUpdateParticleFallback|null|undefined} update_particle_fallback
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_fallback = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_offset.
         * @member {CUserMsg_ParticleManager.IUpdateParticleOffset|null|undefined} update_particle_offset
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_offset = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_ent.
         * @member {CUserMsg_ParticleManager.IUpdateParticleEnt|null|undefined} update_particle_ent
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_ent = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_should_draw.
         * @member {CUserMsg_ParticleManager.IUpdateParticleShouldDraw|null|undefined} update_particle_should_draw
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_should_draw = null;
    
        /**
         * CUserMsg_ParticleManager update_particle_set_frozen.
         * @member {CUserMsg_ParticleManager.IUpdateParticleSetFrozen|null|undefined} update_particle_set_frozen
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_particle_set_frozen = null;
    
        /**
         * CUserMsg_ParticleManager change_control_point_attachment.
         * @member {CUserMsg_ParticleManager.IChangeControlPointAttachment|null|undefined} change_control_point_attachment
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.change_control_point_attachment = null;
    
        /**
         * CUserMsg_ParticleManager update_entity_position.
         * @member {CUserMsg_ParticleManager.IUpdateEntityPosition|null|undefined} update_entity_position
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.update_entity_position = null;
    
        /**
         * CUserMsg_ParticleManager set_particle_fow_properties.
         * @member {CUserMsg_ParticleManager.ISetParticleFoWProperties|null|undefined} set_particle_fow_properties
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_particle_fow_properties = null;
    
        /**
         * CUserMsg_ParticleManager set_particle_text.
         * @member {CUserMsg_ParticleManager.ISetParticleText|null|undefined} set_particle_text
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_particle_text = null;
    
        /**
         * CUserMsg_ParticleManager set_particle_should_check_fow.
         * @member {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW|null|undefined} set_particle_should_check_fow
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_particle_should_check_fow = null;
    
        /**
         * CUserMsg_ParticleManager set_control_point_model.
         * @member {CUserMsg_ParticleManager.ISetControlPointModel|null|undefined} set_control_point_model
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_control_point_model = null;
    
        /**
         * CUserMsg_ParticleManager set_control_point_snapshot.
         * @member {CUserMsg_ParticleManager.ISetControlPointSnapshot|null|undefined} set_control_point_snapshot
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_control_point_snapshot = null;
    
        /**
         * CUserMsg_ParticleManager set_texture_attribute.
         * @member {CUserMsg_ParticleManager.ISetTextureAttribute|null|undefined} set_texture_attribute
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_texture_attribute = null;
    
        /**
         * CUserMsg_ParticleManager set_scene_object_generic_flag.
         * @member {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag|null|undefined} set_scene_object_generic_flag
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_scene_object_generic_flag = null;
    
        /**
         * CUserMsg_ParticleManager set_scene_object_tint_and_desat.
         * @member {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat|null|undefined} set_scene_object_tint_and_desat
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.set_scene_object_tint_and_desat = null;
    
        /**
         * Creates a new CUserMsg_ParticleManager instance using the specified properties.
         * @function create
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {ICUserMsg_ParticleManager=} [properties] Properties to set
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager instance
         */
        CUserMsg_ParticleManager.create = function create(properties) {
            return new CUserMsg_ParticleManager(properties);
        };
    
        /**
         * Encodes the specified CUserMsg_ParticleManager message. Does not implicitly {@link CUserMsg_ParticleManager.verify|verify} messages.
         * @function encode
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {ICUserMsg_ParticleManager} message CUserMsg_ParticleManager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_ParticleManager.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
            if (message.release_particle_index != null && Object.hasOwnProperty.call(message, "release_particle_index"))
                $root.CUserMsg_ParticleManager.ReleaseParticleIndex.encode(message.release_particle_index, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.create_particle != null && Object.hasOwnProperty.call(message, "create_particle"))
                $root.CUserMsg_ParticleManager.CreateParticle.encode(message.create_particle, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.destroy_particle != null && Object.hasOwnProperty.call(message, "destroy_particle"))
                $root.CUserMsg_ParticleManager.DestroyParticle.encode(message.destroy_particle, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.destroy_particle_involving != null && Object.hasOwnProperty.call(message, "destroy_particle_involving"))
                $root.CUserMsg_ParticleManager.DestroyParticleInvolving.encode(message.destroy_particle_involving, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.update_particle != null && Object.hasOwnProperty.call(message, "update_particle"))
                $root.CUserMsg_ParticleManager.UpdateParticle.encode(message.update_particle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.update_particle_fwd != null && Object.hasOwnProperty.call(message, "update_particle_fwd"))
                $root.CUserMsg_ParticleManager.UpdateParticleFwd.encode(message.update_particle_fwd, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.update_particle_orient != null && Object.hasOwnProperty.call(message, "update_particle_orient"))
                $root.CUserMsg_ParticleManager.UpdateParticleOrient.encode(message.update_particle_orient, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.update_particle_fallback != null && Object.hasOwnProperty.call(message, "update_particle_fallback"))
                $root.CUserMsg_ParticleManager.UpdateParticleFallback.encode(message.update_particle_fallback, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.update_particle_offset != null && Object.hasOwnProperty.call(message, "update_particle_offset"))
                $root.CUserMsg_ParticleManager.UpdateParticleOffset.encode(message.update_particle_offset, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.update_particle_ent != null && Object.hasOwnProperty.call(message, "update_particle_ent"))
                $root.CUserMsg_ParticleManager.UpdateParticleEnt.encode(message.update_particle_ent, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.update_particle_should_draw != null && Object.hasOwnProperty.call(message, "update_particle_should_draw"))
                $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.encode(message.update_particle_should_draw, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.update_particle_set_frozen != null && Object.hasOwnProperty.call(message, "update_particle_set_frozen"))
                $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.encode(message.update_particle_set_frozen, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.change_control_point_attachment != null && Object.hasOwnProperty.call(message, "change_control_point_attachment"))
                $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.encode(message.change_control_point_attachment, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.update_entity_position != null && Object.hasOwnProperty.call(message, "update_entity_position"))
                $root.CUserMsg_ParticleManager.UpdateEntityPosition.encode(message.update_entity_position, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.set_particle_fow_properties != null && Object.hasOwnProperty.call(message, "set_particle_fow_properties"))
                $root.CUserMsg_ParticleManager.SetParticleFoWProperties.encode(message.set_particle_fow_properties, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.set_particle_text != null && Object.hasOwnProperty.call(message, "set_particle_text"))
                $root.CUserMsg_ParticleManager.SetParticleText.encode(message.set_particle_text, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.set_particle_should_check_fow != null && Object.hasOwnProperty.call(message, "set_particle_should_check_fow"))
                $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.encode(message.set_particle_should_check_fow, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.set_control_point_model != null && Object.hasOwnProperty.call(message, "set_control_point_model"))
                $root.CUserMsg_ParticleManager.SetControlPointModel.encode(message.set_control_point_model, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.set_control_point_snapshot != null && Object.hasOwnProperty.call(message, "set_control_point_snapshot"))
                $root.CUserMsg_ParticleManager.SetControlPointSnapshot.encode(message.set_control_point_snapshot, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.set_texture_attribute != null && Object.hasOwnProperty.call(message, "set_texture_attribute"))
                $root.CUserMsg_ParticleManager.SetTextureAttribute.encode(message.set_texture_attribute, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.set_scene_object_generic_flag != null && Object.hasOwnProperty.call(message, "set_scene_object_generic_flag"))
                $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.encode(message.set_scene_object_generic_flag, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.set_scene_object_tint_and_desat != null && Object.hasOwnProperty.call(message, "set_scene_object_tint_and_desat"))
                $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.encode(message.set_scene_object_tint_and_desat, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMsg_ParticleManager message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {ICUserMsg_ParticleManager} message CUserMsg_ParticleManager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_ParticleManager.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMsg_ParticleManager message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_ParticleManager.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 3:
                    message.release_particle_index = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.create_particle = $root.CUserMsg_ParticleManager.CreateParticle.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.destroy_particle = $root.CUserMsg_ParticleManager.DestroyParticle.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.destroy_particle_involving = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.update_particle = $root.CUserMsg_ParticleManager.UpdateParticle.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.update_particle_fwd = $root.CUserMsg_ParticleManager.UpdateParticleFwd.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.update_particle_orient = $root.CUserMsg_ParticleManager.UpdateParticleOrient.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.update_particle_fallback = $root.CUserMsg_ParticleManager.UpdateParticleFallback.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.update_particle_offset = $root.CUserMsg_ParticleManager.UpdateParticleOffset.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.update_particle_ent = $root.CUserMsg_ParticleManager.UpdateParticleEnt.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.update_particle_should_draw = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.update_particle_set_frozen = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.change_control_point_attachment = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.update_entity_position = $root.CUserMsg_ParticleManager.UpdateEntityPosition.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.set_particle_fow_properties = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.set_particle_text = $root.CUserMsg_ParticleManager.SetParticleText.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.set_particle_should_check_fow = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.set_control_point_model = $root.CUserMsg_ParticleManager.SetControlPointModel.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.set_control_point_snapshot = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.set_texture_attribute = $root.CUserMsg_ParticleManager.SetTextureAttribute.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.set_scene_object_generic_flag = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.set_scene_object_tint_and_desat = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CUserMsg_ParticleManager message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_ParticleManager.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMsg_ParticleManager message.
         * @function verify
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMsg_ParticleManager.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
                break;
            }
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            if (message.release_particle_index != null && message.hasOwnProperty("release_particle_index")) {
                var error = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.verify(message.release_particle_index);
                if (error)
                    return "release_particle_index." + error;
            }
            if (message.create_particle != null && message.hasOwnProperty("create_particle")) {
                var error = $root.CUserMsg_ParticleManager.CreateParticle.verify(message.create_particle);
                if (error)
                    return "create_particle." + error;
            }
            if (message.destroy_particle != null && message.hasOwnProperty("destroy_particle")) {
                var error = $root.CUserMsg_ParticleManager.DestroyParticle.verify(message.destroy_particle);
                if (error)
                    return "destroy_particle." + error;
            }
            if (message.destroy_particle_involving != null && message.hasOwnProperty("destroy_particle_involving")) {
                var error = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.verify(message.destroy_particle_involving);
                if (error)
                    return "destroy_particle_involving." + error;
            }
            if (message.update_particle != null && message.hasOwnProperty("update_particle")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticle.verify(message.update_particle);
                if (error)
                    return "update_particle." + error;
            }
            if (message.update_particle_fwd != null && message.hasOwnProperty("update_particle_fwd")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleFwd.verify(message.update_particle_fwd);
                if (error)
                    return "update_particle_fwd." + error;
            }
            if (message.update_particle_orient != null && message.hasOwnProperty("update_particle_orient")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleOrient.verify(message.update_particle_orient);
                if (error)
                    return "update_particle_orient." + error;
            }
            if (message.update_particle_fallback != null && message.hasOwnProperty("update_particle_fallback")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleFallback.verify(message.update_particle_fallback);
                if (error)
                    return "update_particle_fallback." + error;
            }
            if (message.update_particle_offset != null && message.hasOwnProperty("update_particle_offset")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleOffset.verify(message.update_particle_offset);
                if (error)
                    return "update_particle_offset." + error;
            }
            if (message.update_particle_ent != null && message.hasOwnProperty("update_particle_ent")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleEnt.verify(message.update_particle_ent);
                if (error)
                    return "update_particle_ent." + error;
            }
            if (message.update_particle_should_draw != null && message.hasOwnProperty("update_particle_should_draw")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.verify(message.update_particle_should_draw);
                if (error)
                    return "update_particle_should_draw." + error;
            }
            if (message.update_particle_set_frozen != null && message.hasOwnProperty("update_particle_set_frozen")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.verify(message.update_particle_set_frozen);
                if (error)
                    return "update_particle_set_frozen." + error;
            }
            if (message.change_control_point_attachment != null && message.hasOwnProperty("change_control_point_attachment")) {
                var error = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.verify(message.change_control_point_attachment);
                if (error)
                    return "change_control_point_attachment." + error;
            }
            if (message.update_entity_position != null && message.hasOwnProperty("update_entity_position")) {
                var error = $root.CUserMsg_ParticleManager.UpdateEntityPosition.verify(message.update_entity_position);
                if (error)
                    return "update_entity_position." + error;
            }
            if (message.set_particle_fow_properties != null && message.hasOwnProperty("set_particle_fow_properties")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.verify(message.set_particle_fow_properties);
                if (error)
                    return "set_particle_fow_properties." + error;
            }
            if (message.set_particle_text != null && message.hasOwnProperty("set_particle_text")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleText.verify(message.set_particle_text);
                if (error)
                    return "set_particle_text." + error;
            }
            if (message.set_particle_should_check_fow != null && message.hasOwnProperty("set_particle_should_check_fow")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.verify(message.set_particle_should_check_fow);
                if (error)
                    return "set_particle_should_check_fow." + error;
            }
            if (message.set_control_point_model != null && message.hasOwnProperty("set_control_point_model")) {
                var error = $root.CUserMsg_ParticleManager.SetControlPointModel.verify(message.set_control_point_model);
                if (error)
                    return "set_control_point_model." + error;
            }
            if (message.set_control_point_snapshot != null && message.hasOwnProperty("set_control_point_snapshot")) {
                var error = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.verify(message.set_control_point_snapshot);
                if (error)
                    return "set_control_point_snapshot." + error;
            }
            if (message.set_texture_attribute != null && message.hasOwnProperty("set_texture_attribute")) {
                var error = $root.CUserMsg_ParticleManager.SetTextureAttribute.verify(message.set_texture_attribute);
                if (error)
                    return "set_texture_attribute." + error;
            }
            if (message.set_scene_object_generic_flag != null && message.hasOwnProperty("set_scene_object_generic_flag")) {
                var error = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.verify(message.set_scene_object_generic_flag);
                if (error)
                    return "set_scene_object_generic_flag." + error;
            }
            if (message.set_scene_object_tint_and_desat != null && message.hasOwnProperty("set_scene_object_tint_and_desat")) {
                var error = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.verify(message.set_scene_object_tint_and_desat);
                if (error)
                    return "set_scene_object_tint_and_desat." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMsg_ParticleManager message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager
         */
        CUserMsg_ParticleManager.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMsg_ParticleManager)
                return object;
            var message = new $root.CUserMsg_ParticleManager();
            switch (object.type) {
            case "GAME_PARTICLE_MANAGER_EVENT_CREATE":
            case 0:
                message.type = 0;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE":
            case 1:
                message.type = 1;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD":
            case 2:
                message.type = 2;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION":
            case 3:
                message.type = 3;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK":
            case 4:
                message.type = 4;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT":
            case 5:
                message.type = 5;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET":
            case 6:
                message.type = 6;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_DESTROY":
            case 7:
                message.type = 7;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING":
            case 8:
                message.type = 8;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_RELEASE":
            case 9:
                message.type = 9;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_LATENCY":
            case 10:
                message.type = 10;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW":
            case 11:
                message.type = 11;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_FROZEN":
            case 12:
                message.type = 12;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT":
            case 13:
                message.type = 13;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION":
            case 14:
                message.type = 14;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES":
            case 15:
                message.type = 15;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT":
            case 16:
                message.type = 16;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW":
            case 17:
                message.type = 17;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL":
            case 18:
                message.type = 18;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT":
            case 19:
                message.type = 19;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE":
            case 20:
                message.type = 20;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG":
            case 21:
                message.type = 21;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT":
            case 22:
                message.type = 22;
                break;
            }
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.release_particle_index != null) {
                if (typeof object.release_particle_index !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.release_particle_index: object expected");
                message.release_particle_index = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.fromObject(object.release_particle_index);
            }
            if (object.create_particle != null) {
                if (typeof object.create_particle !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.create_particle: object expected");
                message.create_particle = $root.CUserMsg_ParticleManager.CreateParticle.fromObject(object.create_particle);
            }
            if (object.destroy_particle != null) {
                if (typeof object.destroy_particle !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.destroy_particle: object expected");
                message.destroy_particle = $root.CUserMsg_ParticleManager.DestroyParticle.fromObject(object.destroy_particle);
            }
            if (object.destroy_particle_involving != null) {
                if (typeof object.destroy_particle_involving !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.destroy_particle_involving: object expected");
                message.destroy_particle_involving = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.fromObject(object.destroy_particle_involving);
            }
            if (object.update_particle != null) {
                if (typeof object.update_particle !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle: object expected");
                message.update_particle = $root.CUserMsg_ParticleManager.UpdateParticle.fromObject(object.update_particle);
            }
            if (object.update_particle_fwd != null) {
                if (typeof object.update_particle_fwd !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_fwd: object expected");
                message.update_particle_fwd = $root.CUserMsg_ParticleManager.UpdateParticleFwd.fromObject(object.update_particle_fwd);
            }
            if (object.update_particle_orient != null) {
                if (typeof object.update_particle_orient !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_orient: object expected");
                message.update_particle_orient = $root.CUserMsg_ParticleManager.UpdateParticleOrient.fromObject(object.update_particle_orient);
            }
            if (object.update_particle_fallback != null) {
                if (typeof object.update_particle_fallback !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_fallback: object expected");
                message.update_particle_fallback = $root.CUserMsg_ParticleManager.UpdateParticleFallback.fromObject(object.update_particle_fallback);
            }
            if (object.update_particle_offset != null) {
                if (typeof object.update_particle_offset !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_offset: object expected");
                message.update_particle_offset = $root.CUserMsg_ParticleManager.UpdateParticleOffset.fromObject(object.update_particle_offset);
            }
            if (object.update_particle_ent != null) {
                if (typeof object.update_particle_ent !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_ent: object expected");
                message.update_particle_ent = $root.CUserMsg_ParticleManager.UpdateParticleEnt.fromObject(object.update_particle_ent);
            }
            if (object.update_particle_should_draw != null) {
                if (typeof object.update_particle_should_draw !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_should_draw: object expected");
                message.update_particle_should_draw = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.fromObject(object.update_particle_should_draw);
            }
            if (object.update_particle_set_frozen != null) {
                if (typeof object.update_particle_set_frozen !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_particle_set_frozen: object expected");
                message.update_particle_set_frozen = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.fromObject(object.update_particle_set_frozen);
            }
            if (object.change_control_point_attachment != null) {
                if (typeof object.change_control_point_attachment !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.change_control_point_attachment: object expected");
                message.change_control_point_attachment = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.fromObject(object.change_control_point_attachment);
            }
            if (object.update_entity_position != null) {
                if (typeof object.update_entity_position !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.update_entity_position: object expected");
                message.update_entity_position = $root.CUserMsg_ParticleManager.UpdateEntityPosition.fromObject(object.update_entity_position);
            }
            if (object.set_particle_fow_properties != null) {
                if (typeof object.set_particle_fow_properties !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_particle_fow_properties: object expected");
                message.set_particle_fow_properties = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.fromObject(object.set_particle_fow_properties);
            }
            if (object.set_particle_text != null) {
                if (typeof object.set_particle_text !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_particle_text: object expected");
                message.set_particle_text = $root.CUserMsg_ParticleManager.SetParticleText.fromObject(object.set_particle_text);
            }
            if (object.set_particle_should_check_fow != null) {
                if (typeof object.set_particle_should_check_fow !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_particle_should_check_fow: object expected");
                message.set_particle_should_check_fow = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.fromObject(object.set_particle_should_check_fow);
            }
            if (object.set_control_point_model != null) {
                if (typeof object.set_control_point_model !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_control_point_model: object expected");
                message.set_control_point_model = $root.CUserMsg_ParticleManager.SetControlPointModel.fromObject(object.set_control_point_model);
            }
            if (object.set_control_point_snapshot != null) {
                if (typeof object.set_control_point_snapshot !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_control_point_snapshot: object expected");
                message.set_control_point_snapshot = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.fromObject(object.set_control_point_snapshot);
            }
            if (object.set_texture_attribute != null) {
                if (typeof object.set_texture_attribute !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_texture_attribute: object expected");
                message.set_texture_attribute = $root.CUserMsg_ParticleManager.SetTextureAttribute.fromObject(object.set_texture_attribute);
            }
            if (object.set_scene_object_generic_flag != null) {
                if (typeof object.set_scene_object_generic_flag !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_scene_object_generic_flag: object expected");
                message.set_scene_object_generic_flag = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.fromObject(object.set_scene_object_generic_flag);
            }
            if (object.set_scene_object_tint_and_desat != null) {
                if (typeof object.set_scene_object_tint_and_desat !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.set_scene_object_tint_and_desat: object expected");
                message.set_scene_object_tint_and_desat = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.fromObject(object.set_scene_object_tint_and_desat);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMsg_ParticleManager message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {CUserMsg_ParticleManager} message CUserMsg_ParticleManager
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMsg_ParticleManager.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "GAME_PARTICLE_MANAGER_EVENT_CREATE" : 0;
                object.index = 0;
                object.release_particle_index = null;
                object.create_particle = null;
                object.destroy_particle = null;
                object.destroy_particle_involving = null;
                object.update_particle = null;
                object.update_particle_fwd = null;
                object.update_particle_orient = null;
                object.update_particle_fallback = null;
                object.update_particle_offset = null;
                object.update_particle_ent = null;
                object.update_particle_should_draw = null;
                object.update_particle_set_frozen = null;
                object.change_control_point_attachment = null;
                object.update_entity_position = null;
                object.set_particle_fow_properties = null;
                object.set_particle_text = null;
                object.set_particle_should_check_fow = null;
                object.set_control_point_model = null;
                object.set_control_point_snapshot = null;
                object.set_texture_attribute = null;
                object.set_scene_object_generic_flag = null;
                object.set_scene_object_tint_and_desat = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.PARTICLE_MESSAGE[message.type] : message.type;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.release_particle_index != null && message.hasOwnProperty("release_particle_index"))
                object.release_particle_index = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.toObject(message.release_particle_index, options);
            if (message.create_particle != null && message.hasOwnProperty("create_particle"))
                object.create_particle = $root.CUserMsg_ParticleManager.CreateParticle.toObject(message.create_particle, options);
            if (message.destroy_particle != null && message.hasOwnProperty("destroy_particle"))
                object.destroy_particle = $root.CUserMsg_ParticleManager.DestroyParticle.toObject(message.destroy_particle, options);
            if (message.destroy_particle_involving != null && message.hasOwnProperty("destroy_particle_involving"))
                object.destroy_particle_involving = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.toObject(message.destroy_particle_involving, options);
            if (message.update_particle != null && message.hasOwnProperty("update_particle"))
                object.update_particle = $root.CUserMsg_ParticleManager.UpdateParticle.toObject(message.update_particle, options);
            if (message.update_particle_fwd != null && message.hasOwnProperty("update_particle_fwd"))
                object.update_particle_fwd = $root.CUserMsg_ParticleManager.UpdateParticleFwd.toObject(message.update_particle_fwd, options);
            if (message.update_particle_orient != null && message.hasOwnProperty("update_particle_orient"))
                object.update_particle_orient = $root.CUserMsg_ParticleManager.UpdateParticleOrient.toObject(message.update_particle_orient, options);
            if (message.update_particle_fallback != null && message.hasOwnProperty("update_particle_fallback"))
                object.update_particle_fallback = $root.CUserMsg_ParticleManager.UpdateParticleFallback.toObject(message.update_particle_fallback, options);
            if (message.update_particle_offset != null && message.hasOwnProperty("update_particle_offset"))
                object.update_particle_offset = $root.CUserMsg_ParticleManager.UpdateParticleOffset.toObject(message.update_particle_offset, options);
            if (message.update_particle_ent != null && message.hasOwnProperty("update_particle_ent"))
                object.update_particle_ent = $root.CUserMsg_ParticleManager.UpdateParticleEnt.toObject(message.update_particle_ent, options);
            if (message.update_particle_should_draw != null && message.hasOwnProperty("update_particle_should_draw"))
                object.update_particle_should_draw = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.toObject(message.update_particle_should_draw, options);
            if (message.update_particle_set_frozen != null && message.hasOwnProperty("update_particle_set_frozen"))
                object.update_particle_set_frozen = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.toObject(message.update_particle_set_frozen, options);
            if (message.change_control_point_attachment != null && message.hasOwnProperty("change_control_point_attachment"))
                object.change_control_point_attachment = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.toObject(message.change_control_point_attachment, options);
            if (message.update_entity_position != null && message.hasOwnProperty("update_entity_position"))
                object.update_entity_position = $root.CUserMsg_ParticleManager.UpdateEntityPosition.toObject(message.update_entity_position, options);
            if (message.set_particle_fow_properties != null && message.hasOwnProperty("set_particle_fow_properties"))
                object.set_particle_fow_properties = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.toObject(message.set_particle_fow_properties, options);
            if (message.set_particle_text != null && message.hasOwnProperty("set_particle_text"))
                object.set_particle_text = $root.CUserMsg_ParticleManager.SetParticleText.toObject(message.set_particle_text, options);
            if (message.set_particle_should_check_fow != null && message.hasOwnProperty("set_particle_should_check_fow"))
                object.set_particle_should_check_fow = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.toObject(message.set_particle_should_check_fow, options);
            if (message.set_control_point_model != null && message.hasOwnProperty("set_control_point_model"))
                object.set_control_point_model = $root.CUserMsg_ParticleManager.SetControlPointModel.toObject(message.set_control_point_model, options);
            if (message.set_control_point_snapshot != null && message.hasOwnProperty("set_control_point_snapshot"))
                object.set_control_point_snapshot = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.toObject(message.set_control_point_snapshot, options);
            if (message.set_texture_attribute != null && message.hasOwnProperty("set_texture_attribute"))
                object.set_texture_attribute = $root.CUserMsg_ParticleManager.SetTextureAttribute.toObject(message.set_texture_attribute, options);
            if (message.set_scene_object_generic_flag != null && message.hasOwnProperty("set_scene_object_generic_flag"))
                object.set_scene_object_generic_flag = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.toObject(message.set_scene_object_generic_flag, options);
            if (message.set_scene_object_tint_and_desat != null && message.hasOwnProperty("set_scene_object_tint_and_desat"))
                object.set_scene_object_tint_and_desat = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.toObject(message.set_scene_object_tint_and_desat, options);
            return object;
        };
    
        /**
         * Converts this CUserMsg_ParticleManager to JSON.
         * @function toJSON
         * @memberof CUserMsg_ParticleManager
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMsg_ParticleManager.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CUserMsg_ParticleManager.ReleaseParticleIndex = (function() {
    
            /**
             * Properties of a ReleaseParticleIndex.
             * @memberof CUserMsg_ParticleManager
             * @interface IReleaseParticleIndex
             */
    
            /**
             * Constructs a new ReleaseParticleIndex.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ReleaseParticleIndex.
             * @implements IReleaseParticleIndex
             * @constructor
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex=} [properties] Properties to set
             */
            function ReleaseParticleIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ReleaseParticleIndex instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex instance
             */
            ReleaseParticleIndex.create = function create(properties) {
                return new ReleaseParticleIndex(properties);
            };
    
            /**
             * Encodes the specified ReleaseParticleIndex message. Does not implicitly {@link CUserMsg_ParticleManager.ReleaseParticleIndex.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex} message ReleaseParticleIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReleaseParticleIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ReleaseParticleIndex message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ReleaseParticleIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex} message ReleaseParticleIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReleaseParticleIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ReleaseParticleIndex message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReleaseParticleIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ReleaseParticleIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ReleaseParticleIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReleaseParticleIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ReleaseParticleIndex message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReleaseParticleIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ReleaseParticleIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex
             */
            ReleaseParticleIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ReleaseParticleIndex)
                    return object;
                return new $root.CUserMsg_ParticleManager.ReleaseParticleIndex();
            };
    
            /**
             * Creates a plain object from a ReleaseParticleIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.ReleaseParticleIndex} message ReleaseParticleIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReleaseParticleIndex.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ReleaseParticleIndex to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReleaseParticleIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ReleaseParticleIndex;
        })();
    
        CUserMsg_ParticleManager.CreateParticle = (function() {
    
            /**
             * Properties of a CreateParticle.
             * @memberof CUserMsg_ParticleManager
             * @interface ICreateParticle
             * @property {number|Long|null} [particle_name_index] CreateParticle particle_name_index
             * @property {number|null} [attach_type] CreateParticle attach_type
             * @property {number|null} [entity_handle] CreateParticle entity_handle
             * @property {number|null} [entity_handle_for_modifiers] CreateParticle entity_handle_for_modifiers
             * @property {boolean|null} [apply_voice_ban_rules] CreateParticle apply_voice_ban_rules
             * @property {number|null} [team_behavior] CreateParticle team_behavior
             */
    
            /**
             * Constructs a new CreateParticle.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a CreateParticle.
             * @implements ICreateParticle
             * @constructor
             * @param {CUserMsg_ParticleManager.ICreateParticle=} [properties] Properties to set
             */
            function CreateParticle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CreateParticle particle_name_index.
             * @member {number|Long} particle_name_index
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.particle_name_index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CreateParticle attach_type.
             * @member {number} attach_type
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.attach_type = 0;
    
            /**
             * CreateParticle entity_handle.
             * @member {number} entity_handle
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.entity_handle = 0;
    
            /**
             * CreateParticle entity_handle_for_modifiers.
             * @member {number} entity_handle_for_modifiers
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.entity_handle_for_modifiers = 0;
    
            /**
             * CreateParticle apply_voice_ban_rules.
             * @member {boolean} apply_voice_ban_rules
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.apply_voice_ban_rules = false;
    
            /**
             * CreateParticle team_behavior.
             * @member {number} team_behavior
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.team_behavior = 0;
    
            /**
             * Creates a new CreateParticle instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.ICreateParticle=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle instance
             */
            CreateParticle.create = function create(properties) {
                return new CreateParticle(properties);
            };
    
            /**
             * Encodes the specified CreateParticle message. Does not implicitly {@link CUserMsg_ParticleManager.CreateParticle.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.ICreateParticle} message CreateParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateParticle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.particle_name_index != null && Object.hasOwnProperty.call(message, "particle_name_index"))
                    writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.particle_name_index);
                if (message.attach_type != null && Object.hasOwnProperty.call(message, "attach_type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attach_type);
                if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entity_handle);
                if (message.entity_handle_for_modifiers != null && Object.hasOwnProperty.call(message, "entity_handle_for_modifiers"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.entity_handle_for_modifiers);
                if (message.apply_voice_ban_rules != null && Object.hasOwnProperty.call(message, "apply_voice_ban_rules"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.apply_voice_ban_rules);
                if (message.team_behavior != null && Object.hasOwnProperty.call(message, "team_behavior"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.team_behavior);
                return writer;
            };
    
            /**
             * Encodes the specified CreateParticle message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.CreateParticle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.ICreateParticle} message CreateParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateParticle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CreateParticle message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateParticle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.CreateParticle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.particle_name_index = reader.fixed64();
                        break;
                    case 2:
                        message.attach_type = reader.int32();
                        break;
                    case 3:
                        message.entity_handle = reader.int32();
                        break;
                    case 4:
                        message.entity_handle_for_modifiers = reader.int32();
                        break;
                    case 5:
                        message.apply_voice_ban_rules = reader.bool();
                        break;
                    case 6:
                        message.team_behavior = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CreateParticle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateParticle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CreateParticle message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateParticle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.particle_name_index != null && message.hasOwnProperty("particle_name_index"))
                    if (!$util.isInteger(message.particle_name_index) && !(message.particle_name_index && $util.isInteger(message.particle_name_index.low) && $util.isInteger(message.particle_name_index.high)))
                        return "particle_name_index: integer|Long expected";
                if (message.attach_type != null && message.hasOwnProperty("attach_type"))
                    if (!$util.isInteger(message.attach_type))
                        return "attach_type: integer expected";
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    if (!$util.isInteger(message.entity_handle))
                        return "entity_handle: integer expected";
                if (message.entity_handle_for_modifiers != null && message.hasOwnProperty("entity_handle_for_modifiers"))
                    if (!$util.isInteger(message.entity_handle_for_modifiers))
                        return "entity_handle_for_modifiers: integer expected";
                if (message.apply_voice_ban_rules != null && message.hasOwnProperty("apply_voice_ban_rules"))
                    if (typeof message.apply_voice_ban_rules !== "boolean")
                        return "apply_voice_ban_rules: boolean expected";
                if (message.team_behavior != null && message.hasOwnProperty("team_behavior"))
                    if (!$util.isInteger(message.team_behavior))
                        return "team_behavior: integer expected";
                return null;
            };
    
            /**
             * Creates a CreateParticle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle
             */
            CreateParticle.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.CreateParticle)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.CreateParticle();
                if (object.particle_name_index != null)
                    if ($util.Long)
                        (message.particle_name_index = $util.Long.fromValue(object.particle_name_index)).unsigned = false;
                    else if (typeof object.particle_name_index === "string")
                        message.particle_name_index = parseInt(object.particle_name_index, 10);
                    else if (typeof object.particle_name_index === "number")
                        message.particle_name_index = object.particle_name_index;
                    else if (typeof object.particle_name_index === "object")
                        message.particle_name_index = new $util.LongBits(object.particle_name_index.low >>> 0, object.particle_name_index.high >>> 0).toNumber();
                if (object.attach_type != null)
                    message.attach_type = object.attach_type | 0;
                if (object.entity_handle != null)
                    message.entity_handle = object.entity_handle | 0;
                if (object.entity_handle_for_modifiers != null)
                    message.entity_handle_for_modifiers = object.entity_handle_for_modifiers | 0;
                if (object.apply_voice_ban_rules != null)
                    message.apply_voice_ban_rules = Boolean(object.apply_voice_ban_rules);
                if (object.team_behavior != null)
                    message.team_behavior = object.team_behavior | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a CreateParticle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.CreateParticle} message CreateParticle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateParticle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.particle_name_index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.particle_name_index = options.longs === String ? "0" : 0;
                    object.attach_type = 0;
                    object.entity_handle = 0;
                    object.entity_handle_for_modifiers = 0;
                    object.apply_voice_ban_rules = false;
                    object.team_behavior = 0;
                }
                if (message.particle_name_index != null && message.hasOwnProperty("particle_name_index"))
                    if (typeof message.particle_name_index === "number")
                        object.particle_name_index = options.longs === String ? String(message.particle_name_index) : message.particle_name_index;
                    else
                        object.particle_name_index = options.longs === String ? $util.Long.prototype.toString.call(message.particle_name_index) : options.longs === Number ? new $util.LongBits(message.particle_name_index.low >>> 0, message.particle_name_index.high >>> 0).toNumber() : message.particle_name_index;
                if (message.attach_type != null && message.hasOwnProperty("attach_type"))
                    object.attach_type = message.attach_type;
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    object.entity_handle = message.entity_handle;
                if (message.entity_handle_for_modifiers != null && message.hasOwnProperty("entity_handle_for_modifiers"))
                    object.entity_handle_for_modifiers = message.entity_handle_for_modifiers;
                if (message.apply_voice_ban_rules != null && message.hasOwnProperty("apply_voice_ban_rules"))
                    object.apply_voice_ban_rules = message.apply_voice_ban_rules;
                if (message.team_behavior != null && message.hasOwnProperty("team_behavior"))
                    object.team_behavior = message.team_behavior;
                return object;
            };
    
            /**
             * Converts this CreateParticle to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateParticle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CreateParticle;
        })();
    
        CUserMsg_ParticleManager.DestroyParticle = (function() {
    
            /**
             * Properties of a DestroyParticle.
             * @memberof CUserMsg_ParticleManager
             * @interface IDestroyParticle
             * @property {boolean|null} [destroy_immediately] DestroyParticle destroy_immediately
             */
    
            /**
             * Constructs a new DestroyParticle.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a DestroyParticle.
             * @implements IDestroyParticle
             * @constructor
             * @param {CUserMsg_ParticleManager.IDestroyParticle=} [properties] Properties to set
             */
            function DestroyParticle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DestroyParticle destroy_immediately.
             * @member {boolean} destroy_immediately
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @instance
             */
            DestroyParticle.prototype.destroy_immediately = false;
    
            /**
             * Creates a new DestroyParticle instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticle=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle instance
             */
            DestroyParticle.create = function create(properties) {
                return new DestroyParticle(properties);
            };
    
            /**
             * Encodes the specified DestroyParticle message. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticle.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticle} message DestroyParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destroy_immediately != null && Object.hasOwnProperty.call(message, "destroy_immediately"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.destroy_immediately);
                return writer;
            };
    
            /**
             * Encodes the specified DestroyParticle message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticle} message DestroyParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DestroyParticle message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.DestroyParticle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destroy_immediately = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DestroyParticle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DestroyParticle message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DestroyParticle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destroy_immediately != null && message.hasOwnProperty("destroy_immediately"))
                    if (typeof message.destroy_immediately !== "boolean")
                        return "destroy_immediately: boolean expected";
                return null;
            };
    
            /**
             * Creates a DestroyParticle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle
             */
            DestroyParticle.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.DestroyParticle)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.DestroyParticle();
                if (object.destroy_immediately != null)
                    message.destroy_immediately = Boolean(object.destroy_immediately);
                return message;
            };
    
            /**
             * Creates a plain object from a DestroyParticle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.DestroyParticle} message DestroyParticle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DestroyParticle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.destroy_immediately = false;
                if (message.destroy_immediately != null && message.hasOwnProperty("destroy_immediately"))
                    object.destroy_immediately = message.destroy_immediately;
                return object;
            };
    
            /**
             * Converts this DestroyParticle to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DestroyParticle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DestroyParticle;
        })();
    
        CUserMsg_ParticleManager.DestroyParticleInvolving = (function() {
    
            /**
             * Properties of a DestroyParticleInvolving.
             * @memberof CUserMsg_ParticleManager
             * @interface IDestroyParticleInvolving
             * @property {boolean|null} [destroy_immediately] DestroyParticleInvolving destroy_immediately
             * @property {number|null} [entity_handle] DestroyParticleInvolving entity_handle
             */
    
            /**
             * Constructs a new DestroyParticleInvolving.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a DestroyParticleInvolving.
             * @implements IDestroyParticleInvolving
             * @constructor
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving=} [properties] Properties to set
             */
            function DestroyParticleInvolving(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DestroyParticleInvolving destroy_immediately.
             * @member {boolean} destroy_immediately
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @instance
             */
            DestroyParticleInvolving.prototype.destroy_immediately = false;
    
            /**
             * DestroyParticleInvolving entity_handle.
             * @member {number} entity_handle
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @instance
             */
            DestroyParticleInvolving.prototype.entity_handle = 0;
    
            /**
             * Creates a new DestroyParticleInvolving instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving instance
             */
            DestroyParticleInvolving.create = function create(properties) {
                return new DestroyParticleInvolving(properties);
            };
    
            /**
             * Encodes the specified DestroyParticleInvolving message. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticleInvolving.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving} message DestroyParticleInvolving message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticleInvolving.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destroy_immediately != null && Object.hasOwnProperty.call(message, "destroy_immediately"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.destroy_immediately);
                if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entity_handle);
                return writer;
            };
    
            /**
             * Encodes the specified DestroyParticleInvolving message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticleInvolving.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving} message DestroyParticleInvolving message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticleInvolving.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DestroyParticleInvolving message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticleInvolving.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.DestroyParticleInvolving();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destroy_immediately = reader.bool();
                        break;
                    case 3:
                        message.entity_handle = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DestroyParticleInvolving message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticleInvolving.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DestroyParticleInvolving message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DestroyParticleInvolving.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destroy_immediately != null && message.hasOwnProperty("destroy_immediately"))
                    if (typeof message.destroy_immediately !== "boolean")
                        return "destroy_immediately: boolean expected";
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    if (!$util.isInteger(message.entity_handle))
                        return "entity_handle: integer expected";
                return null;
            };
    
            /**
             * Creates a DestroyParticleInvolving message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving
             */
            DestroyParticleInvolving.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.DestroyParticleInvolving)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.DestroyParticleInvolving();
                if (object.destroy_immediately != null)
                    message.destroy_immediately = Boolean(object.destroy_immediately);
                if (object.entity_handle != null)
                    message.entity_handle = object.entity_handle | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a DestroyParticleInvolving message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.DestroyParticleInvolving} message DestroyParticleInvolving
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DestroyParticleInvolving.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destroy_immediately = false;
                    object.entity_handle = 0;
                }
                if (message.destroy_immediately != null && message.hasOwnProperty("destroy_immediately"))
                    object.destroy_immediately = message.destroy_immediately;
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    object.entity_handle = message.entity_handle;
                return object;
            };
    
            /**
             * Converts this DestroyParticleInvolving to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DestroyParticleInvolving.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DestroyParticleInvolving;
        })();
    
        CUserMsg_ParticleManager.UpdateParticle = (function() {
    
            /**
             * Properties of an UpdateParticle.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticle
             * @property {number|null} [control_point] UpdateParticle control_point
             * @property {ICMsgVector|null} [position] UpdateParticle position
             */
    
            /**
             * Constructs a new UpdateParticle.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticle.
             * @implements IUpdateParticle
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticle=} [properties] Properties to set
             */
            function UpdateParticle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticle control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @instance
             */
            UpdateParticle.prototype.control_point = 0;
    
            /**
             * UpdateParticle position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @instance
             */
            UpdateParticle.prototype.position = null;
    
            /**
             * Creates a new UpdateParticle instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticle=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticle} UpdateParticle instance
             */
            UpdateParticle.create = function create(properties) {
                return new UpdateParticle(properties);
            };
    
            /**
             * Encodes the specified UpdateParticle message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticle.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticle} message UpdateParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticle message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticle} message UpdateParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticle message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticle} UpdateParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.position = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticle} UpdateParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticle message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticle} UpdateParticle
             */
            UpdateParticle.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticle)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticle();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticle.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticle} message UpdateParticle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.position = null;
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticle to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticle;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleFwd = (function() {
    
            /**
             * Properties of an UpdateParticleFwd.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleFwd
             * @property {number|null} [control_point] UpdateParticleFwd control_point
             * @property {ICMsgVector|null} [forward] UpdateParticleFwd forward
             */
    
            /**
             * Constructs a new UpdateParticleFwd.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleFwd.
             * @implements IUpdateParticleFwd
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd=} [properties] Properties to set
             */
            function UpdateParticleFwd(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleFwd control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @instance
             */
            UpdateParticleFwd.prototype.control_point = 0;
    
            /**
             * UpdateParticleFwd forward.
             * @member {ICMsgVector|null|undefined} forward
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @instance
             */
            UpdateParticleFwd.prototype.forward = null;
    
            /**
             * Creates a new UpdateParticleFwd instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd} UpdateParticleFwd instance
             */
            UpdateParticleFwd.create = function create(properties) {
                return new UpdateParticleFwd(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleFwd message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFwd.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd} message UpdateParticleFwd message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFwd.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.CMsgVector.encode(message.forward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleFwd message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFwd.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd} message UpdateParticleFwd message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFwd.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleFwd message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd} UpdateParticleFwd
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFwd.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleFwd();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.forward = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleFwd message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd} UpdateParticleFwd
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFwd.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleFwd message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleFwd.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    var error = $root.CMsgVector.verify(message.forward);
                    if (error)
                        return "forward." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleFwd message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd} UpdateParticleFwd
             */
            UpdateParticleFwd.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleFwd)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleFwd();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleFwd.forward: object expected");
                    message.forward = $root.CMsgVector.fromObject(object.forward);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleFwd message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleFwd} message UpdateParticleFwd
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleFwd.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.forward = null;
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.forward != null && message.hasOwnProperty("forward"))
                    object.forward = $root.CMsgVector.toObject(message.forward, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleFwd to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleFwd.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleFwd;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleOrient = (function() {
    
            /**
             * Properties of an UpdateParticleOrient.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleOrient
             * @property {number|null} [control_point] UpdateParticleOrient control_point
             * @property {ICMsgVector|null} [forward] UpdateParticleOrient forward
             * @property {ICMsgVector|null} [right] UpdateParticleOrient right
             * @property {ICMsgVector|null} [up] UpdateParticleOrient up
             * @property {ICMsgVector|null} [left] UpdateParticleOrient left
             */
    
            /**
             * Constructs a new UpdateParticleOrient.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleOrient.
             * @implements IUpdateParticleOrient
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient=} [properties] Properties to set
             */
            function UpdateParticleOrient(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleOrient control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @instance
             */
            UpdateParticleOrient.prototype.control_point = 0;
    
            /**
             * UpdateParticleOrient forward.
             * @member {ICMsgVector|null|undefined} forward
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @instance
             */
            UpdateParticleOrient.prototype.forward = null;
    
            /**
             * UpdateParticleOrient right.
             * @member {ICMsgVector|null|undefined} right
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @instance
             */
            UpdateParticleOrient.prototype.right = null;
    
            /**
             * UpdateParticleOrient up.
             * @member {ICMsgVector|null|undefined} up
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @instance
             */
            UpdateParticleOrient.prototype.up = null;
    
            /**
             * UpdateParticleOrient left.
             * @member {ICMsgVector|null|undefined} left
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @instance
             */
            UpdateParticleOrient.prototype.left = null;
    
            /**
             * Creates a new UpdateParticleOrient instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient} UpdateParticleOrient instance
             */
            UpdateParticleOrient.create = function create(properties) {
                return new UpdateParticleOrient(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleOrient message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOrient.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient} message UpdateParticleOrient message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOrient.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.CMsgVector.encode(message.forward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.right != null && Object.hasOwnProperty.call(message, "right"))
                    $root.CMsgVector.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.up != null && Object.hasOwnProperty.call(message, "up"))
                    $root.CMsgVector.encode(message.up, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.left != null && Object.hasOwnProperty.call(message, "left"))
                    $root.CMsgVector.encode(message.left, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleOrient message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOrient.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient} message UpdateParticleOrient message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOrient.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleOrient message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient} UpdateParticleOrient
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOrient.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleOrient();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.forward = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.right = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.up = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.left = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleOrient message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient} UpdateParticleOrient
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOrient.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleOrient message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleOrient.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    var error = $root.CMsgVector.verify(message.forward);
                    if (error)
                        return "forward." + error;
                }
                if (message.right != null && message.hasOwnProperty("right")) {
                    var error = $root.CMsgVector.verify(message.right);
                    if (error)
                        return "right." + error;
                }
                if (message.up != null && message.hasOwnProperty("up")) {
                    var error = $root.CMsgVector.verify(message.up);
                    if (error)
                        return "up." + error;
                }
                if (message.left != null && message.hasOwnProperty("left")) {
                    var error = $root.CMsgVector.verify(message.left);
                    if (error)
                        return "left." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleOrient message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient} UpdateParticleOrient
             */
            UpdateParticleOrient.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleOrient)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleOrient();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient.forward: object expected");
                    message.forward = $root.CMsgVector.fromObject(object.forward);
                }
                if (object.right != null) {
                    if (typeof object.right !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient.right: object expected");
                    message.right = $root.CMsgVector.fromObject(object.right);
                }
                if (object.up != null) {
                    if (typeof object.up !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient.up: object expected");
                    message.up = $root.CMsgVector.fromObject(object.up);
                }
                if (object.left != null) {
                    if (typeof object.left !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient.left: object expected");
                    message.left = $root.CMsgVector.fromObject(object.left);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleOrient message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleOrient} message UpdateParticleOrient
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleOrient.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.forward = null;
                    object.right = null;
                    object.up = null;
                    object.left = null;
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.forward != null && message.hasOwnProperty("forward"))
                    object.forward = $root.CMsgVector.toObject(message.forward, options);
                if (message.right != null && message.hasOwnProperty("right"))
                    object.right = $root.CMsgVector.toObject(message.right, options);
                if (message.up != null && message.hasOwnProperty("up"))
                    object.up = $root.CMsgVector.toObject(message.up, options);
                if (message.left != null && message.hasOwnProperty("left"))
                    object.left = $root.CMsgVector.toObject(message.left, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleOrient to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleOrient.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleOrient;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleFallback = (function() {
    
            /**
             * Properties of an UpdateParticleFallback.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleFallback
             * @property {number|null} [control_point] UpdateParticleFallback control_point
             * @property {ICMsgVector|null} [position] UpdateParticleFallback position
             */
    
            /**
             * Constructs a new UpdateParticleFallback.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleFallback.
             * @implements IUpdateParticleFallback
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback=} [properties] Properties to set
             */
            function UpdateParticleFallback(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleFallback control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @instance
             */
            UpdateParticleFallback.prototype.control_point = 0;
    
            /**
             * UpdateParticleFallback position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @instance
             */
            UpdateParticleFallback.prototype.position = null;
    
            /**
             * Creates a new UpdateParticleFallback instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback instance
             */
            UpdateParticleFallback.create = function create(properties) {
                return new UpdateParticleFallback(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleFallback message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFallback.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback} message UpdateParticleFallback message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFallback.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleFallback message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFallback.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback} message UpdateParticleFallback message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFallback.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleFallback message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFallback.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleFallback();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.position = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleFallback message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFallback.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleFallback message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleFallback.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleFallback message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback
             */
            UpdateParticleFallback.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleFallback)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleFallback();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleFallback.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleFallback message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleFallback} message UpdateParticleFallback
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleFallback.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.position = null;
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleFallback to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleFallback.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleFallback;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleOffset = (function() {
    
            /**
             * Properties of an UpdateParticleOffset.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleOffset
             * @property {number|null} [control_point] UpdateParticleOffset control_point
             * @property {ICMsgVector|null} [origin_offset] UpdateParticleOffset origin_offset
             * @property {ICMsgQAngle|null} [angle_offset] UpdateParticleOffset angle_offset
             */
    
            /**
             * Constructs a new UpdateParticleOffset.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleOffset.
             * @implements IUpdateParticleOffset
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset=} [properties] Properties to set
             */
            function UpdateParticleOffset(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleOffset control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             */
            UpdateParticleOffset.prototype.control_point = 0;
    
            /**
             * UpdateParticleOffset origin_offset.
             * @member {ICMsgVector|null|undefined} origin_offset
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             */
            UpdateParticleOffset.prototype.origin_offset = null;
    
            /**
             * UpdateParticleOffset angle_offset.
             * @member {ICMsgQAngle|null|undefined} angle_offset
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             */
            UpdateParticleOffset.prototype.angle_offset = null;
    
            /**
             * Creates a new UpdateParticleOffset instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset instance
             */
            UpdateParticleOffset.create = function create(properties) {
                return new UpdateParticleOffset(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleOffset message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOffset.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset} message UpdateParticleOffset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOffset.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.origin_offset != null && Object.hasOwnProperty.call(message, "origin_offset"))
                    $root.CMsgVector.encode(message.origin_offset, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.angle_offset != null && Object.hasOwnProperty.call(message, "angle_offset"))
                    $root.CMsgQAngle.encode(message.angle_offset, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleOffset message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOffset.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset} message UpdateParticleOffset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOffset.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleOffset message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOffset.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleOffset();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.origin_offset = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.angle_offset = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleOffset message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOffset.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleOffset message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleOffset.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.origin_offset != null && message.hasOwnProperty("origin_offset")) {
                    var error = $root.CMsgVector.verify(message.origin_offset);
                    if (error)
                        return "origin_offset." + error;
                }
                if (message.angle_offset != null && message.hasOwnProperty("angle_offset")) {
                    var error = $root.CMsgQAngle.verify(message.angle_offset);
                    if (error)
                        return "angle_offset." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleOffset message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset
             */
            UpdateParticleOffset.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleOffset)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleOffset();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.origin_offset != null) {
                    if (typeof object.origin_offset !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset: object expected");
                    message.origin_offset = $root.CMsgVector.fromObject(object.origin_offset);
                }
                if (object.angle_offset != null) {
                    if (typeof object.angle_offset !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOffset.angle_offset: object expected");
                    message.angle_offset = $root.CMsgQAngle.fromObject(object.angle_offset);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleOffset message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleOffset} message UpdateParticleOffset
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleOffset.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.origin_offset = null;
                    object.angle_offset = null;
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.origin_offset != null && message.hasOwnProperty("origin_offset"))
                    object.origin_offset = $root.CMsgVector.toObject(message.origin_offset, options);
                if (message.angle_offset != null && message.hasOwnProperty("angle_offset"))
                    object.angle_offset = $root.CMsgQAngle.toObject(message.angle_offset, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleOffset to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleOffset.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleOffset;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleEnt = (function() {
    
            /**
             * Properties of an UpdateParticleEnt.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleEnt
             * @property {number|null} [control_point] UpdateParticleEnt control_point
             * @property {number|null} [entity_handle] UpdateParticleEnt entity_handle
             * @property {number|null} [attach_type] UpdateParticleEnt attach_type
             * @property {number|null} [attachment] UpdateParticleEnt attachment
             * @property {ICMsgVector|null} [fallback_position] UpdateParticleEnt fallback_position
             * @property {boolean|null} [include_wearables] UpdateParticleEnt include_wearables
             */
    
            /**
             * Constructs a new UpdateParticleEnt.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleEnt.
             * @implements IUpdateParticleEnt
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt=} [properties] Properties to set
             */
            function UpdateParticleEnt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleEnt control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.control_point = 0;
    
            /**
             * UpdateParticleEnt entity_handle.
             * @member {number} entity_handle
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.entity_handle = 0;
    
            /**
             * UpdateParticleEnt attach_type.
             * @member {number} attach_type
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.attach_type = 0;
    
            /**
             * UpdateParticleEnt attachment.
             * @member {number} attachment
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.attachment = 0;
    
            /**
             * UpdateParticleEnt fallback_position.
             * @member {ICMsgVector|null|undefined} fallback_position
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.fallback_position = null;
    
            /**
             * UpdateParticleEnt include_wearables.
             * @member {boolean} include_wearables
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.include_wearables = false;
    
            /**
             * Creates a new UpdateParticleEnt instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt instance
             */
            UpdateParticleEnt.create = function create(properties) {
                return new UpdateParticleEnt(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleEnt message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleEnt.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt} message UpdateParticleEnt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleEnt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.entity_handle);
                if (message.attach_type != null && Object.hasOwnProperty.call(message, "attach_type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.attach_type);
                if (message.attachment != null && Object.hasOwnProperty.call(message, "attachment"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.attachment);
                if (message.fallback_position != null && Object.hasOwnProperty.call(message, "fallback_position"))
                    $root.CMsgVector.encode(message.fallback_position, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.include_wearables != null && Object.hasOwnProperty.call(message, "include_wearables"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.include_wearables);
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleEnt message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleEnt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt} message UpdateParticleEnt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleEnt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleEnt message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleEnt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleEnt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.entity_handle = reader.int32();
                        break;
                    case 3:
                        message.attach_type = reader.int32();
                        break;
                    case 4:
                        message.attachment = reader.int32();
                        break;
                    case 5:
                        message.fallback_position = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.include_wearables = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleEnt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleEnt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleEnt message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleEnt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    if (!$util.isInteger(message.entity_handle))
                        return "entity_handle: integer expected";
                if (message.attach_type != null && message.hasOwnProperty("attach_type"))
                    if (!$util.isInteger(message.attach_type))
                        return "attach_type: integer expected";
                if (message.attachment != null && message.hasOwnProperty("attachment"))
                    if (!$util.isInteger(message.attachment))
                        return "attachment: integer expected";
                if (message.fallback_position != null && message.hasOwnProperty("fallback_position")) {
                    var error = $root.CMsgVector.verify(message.fallback_position);
                    if (error)
                        return "fallback_position." + error;
                }
                if (message.include_wearables != null && message.hasOwnProperty("include_wearables"))
                    if (typeof message.include_wearables !== "boolean")
                        return "include_wearables: boolean expected";
                return null;
            };
    
            /**
             * Creates an UpdateParticleEnt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt
             */
            UpdateParticleEnt.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleEnt)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleEnt();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.entity_handle != null)
                    message.entity_handle = object.entity_handle | 0;
                if (object.attach_type != null)
                    message.attach_type = object.attach_type | 0;
                if (object.attachment != null)
                    message.attachment = object.attachment | 0;
                if (object.fallback_position != null) {
                    if (typeof object.fallback_position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position: object expected");
                    message.fallback_position = $root.CMsgVector.fromObject(object.fallback_position);
                }
                if (object.include_wearables != null)
                    message.include_wearables = Boolean(object.include_wearables);
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleEnt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleEnt} message UpdateParticleEnt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleEnt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.entity_handle = 0;
                    object.attach_type = 0;
                    object.attachment = 0;
                    object.fallback_position = null;
                    object.include_wearables = false;
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    object.entity_handle = message.entity_handle;
                if (message.attach_type != null && message.hasOwnProperty("attach_type"))
                    object.attach_type = message.attach_type;
                if (message.attachment != null && message.hasOwnProperty("attachment"))
                    object.attachment = message.attachment;
                if (message.fallback_position != null && message.hasOwnProperty("fallback_position"))
                    object.fallback_position = $root.CMsgVector.toObject(message.fallback_position, options);
                if (message.include_wearables != null && message.hasOwnProperty("include_wearables"))
                    object.include_wearables = message.include_wearables;
                return object;
            };
    
            /**
             * Converts this UpdateParticleEnt to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleEnt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleEnt;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleSetFrozen = (function() {
    
            /**
             * Properties of an UpdateParticleSetFrozen.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleSetFrozen
             * @property {boolean|null} [set_frozen] UpdateParticleSetFrozen set_frozen
             */
    
            /**
             * Constructs a new UpdateParticleSetFrozen.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleSetFrozen.
             * @implements IUpdateParticleSetFrozen
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen=} [properties] Properties to set
             */
            function UpdateParticleSetFrozen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleSetFrozen set_frozen.
             * @member {boolean} set_frozen
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @instance
             */
            UpdateParticleSetFrozen.prototype.set_frozen = false;
    
            /**
             * Creates a new UpdateParticleSetFrozen instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen instance
             */
            UpdateParticleSetFrozen.create = function create(properties) {
                return new UpdateParticleSetFrozen(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleSetFrozen message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleSetFrozen.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen} message UpdateParticleSetFrozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleSetFrozen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.set_frozen != null && Object.hasOwnProperty.call(message, "set_frozen"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.set_frozen);
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleSetFrozen message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleSetFrozen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen} message UpdateParticleSetFrozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleSetFrozen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleSetFrozen message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleSetFrozen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.set_frozen = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleSetFrozen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleSetFrozen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleSetFrozen message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleSetFrozen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.set_frozen != null && message.hasOwnProperty("set_frozen"))
                    if (typeof message.set_frozen !== "boolean")
                        return "set_frozen: boolean expected";
                return null;
            };
    
            /**
             * Creates an UpdateParticleSetFrozen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen
             */
            UpdateParticleSetFrozen.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen();
                if (object.set_frozen != null)
                    message.set_frozen = Boolean(object.set_frozen);
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleSetFrozen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleSetFrozen} message UpdateParticleSetFrozen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleSetFrozen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.set_frozen = false;
                if (message.set_frozen != null && message.hasOwnProperty("set_frozen"))
                    object.set_frozen = message.set_frozen;
                return object;
            };
    
            /**
             * Converts this UpdateParticleSetFrozen to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleSetFrozen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleSetFrozen;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleShouldDraw = (function() {
    
            /**
             * Properties of an UpdateParticleShouldDraw.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleShouldDraw
             * @property {boolean|null} [should_draw] UpdateParticleShouldDraw should_draw
             */
    
            /**
             * Constructs a new UpdateParticleShouldDraw.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleShouldDraw.
             * @implements IUpdateParticleShouldDraw
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw=} [properties] Properties to set
             */
            function UpdateParticleShouldDraw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleShouldDraw should_draw.
             * @member {boolean} should_draw
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @instance
             */
            UpdateParticleShouldDraw.prototype.should_draw = false;
    
            /**
             * Creates a new UpdateParticleShouldDraw instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw instance
             */
            UpdateParticleShouldDraw.create = function create(properties) {
                return new UpdateParticleShouldDraw(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleShouldDraw message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleShouldDraw.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw} message UpdateParticleShouldDraw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleShouldDraw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.should_draw != null && Object.hasOwnProperty.call(message, "should_draw"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.should_draw);
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleShouldDraw message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleShouldDraw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw} message UpdateParticleShouldDraw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleShouldDraw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleShouldDraw message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleShouldDraw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.should_draw = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleShouldDraw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleShouldDraw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleShouldDraw message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleShouldDraw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.should_draw != null && message.hasOwnProperty("should_draw"))
                    if (typeof message.should_draw !== "boolean")
                        return "should_draw: boolean expected";
                return null;
            };
    
            /**
             * Creates an UpdateParticleShouldDraw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw
             */
            UpdateParticleShouldDraw.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw();
                if (object.should_draw != null)
                    message.should_draw = Boolean(object.should_draw);
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleShouldDraw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleShouldDraw} message UpdateParticleShouldDraw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleShouldDraw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.should_draw = false;
                if (message.should_draw != null && message.hasOwnProperty("should_draw"))
                    object.should_draw = message.should_draw;
                return object;
            };
    
            /**
             * Converts this UpdateParticleShouldDraw to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleShouldDraw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateParticleShouldDraw;
        })();
    
        CUserMsg_ParticleManager.ChangeControlPointAttachment = (function() {
    
            /**
             * Properties of a ChangeControlPointAttachment.
             * @memberof CUserMsg_ParticleManager
             * @interface IChangeControlPointAttachment
             * @property {number|null} [attachment_old] ChangeControlPointAttachment attachment_old
             * @property {number|null} [attachment_new] ChangeControlPointAttachment attachment_new
             * @property {number|null} [entity_handle] ChangeControlPointAttachment entity_handle
             */
    
            /**
             * Constructs a new ChangeControlPointAttachment.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ChangeControlPointAttachment.
             * @implements IChangeControlPointAttachment
             * @constructor
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment=} [properties] Properties to set
             */
            function ChangeControlPointAttachment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChangeControlPointAttachment attachment_old.
             * @member {number} attachment_old
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             */
            ChangeControlPointAttachment.prototype.attachment_old = 0;
    
            /**
             * ChangeControlPointAttachment attachment_new.
             * @member {number} attachment_new
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             */
            ChangeControlPointAttachment.prototype.attachment_new = 0;
    
            /**
             * ChangeControlPointAttachment entity_handle.
             * @member {number} entity_handle
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             */
            ChangeControlPointAttachment.prototype.entity_handle = 0;
    
            /**
             * Creates a new ChangeControlPointAttachment instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment instance
             */
            ChangeControlPointAttachment.create = function create(properties) {
                return new ChangeControlPointAttachment(properties);
            };
    
            /**
             * Encodes the specified ChangeControlPointAttachment message. Does not implicitly {@link CUserMsg_ParticleManager.ChangeControlPointAttachment.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment} message ChangeControlPointAttachment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeControlPointAttachment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attachment_old != null && Object.hasOwnProperty.call(message, "attachment_old"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.attachment_old);
                if (message.attachment_new != null && Object.hasOwnProperty.call(message, "attachment_new"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attachment_new);
                if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entity_handle);
                return writer;
            };
    
            /**
             * Encodes the specified ChangeControlPointAttachment message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ChangeControlPointAttachment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment} message ChangeControlPointAttachment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeControlPointAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChangeControlPointAttachment message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeControlPointAttachment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ChangeControlPointAttachment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attachment_old = reader.int32();
                        break;
                    case 2:
                        message.attachment_new = reader.int32();
                        break;
                    case 3:
                        message.entity_handle = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChangeControlPointAttachment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeControlPointAttachment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChangeControlPointAttachment message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeControlPointAttachment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attachment_old != null && message.hasOwnProperty("attachment_old"))
                    if (!$util.isInteger(message.attachment_old))
                        return "attachment_old: integer expected";
                if (message.attachment_new != null && message.hasOwnProperty("attachment_new"))
                    if (!$util.isInteger(message.attachment_new))
                        return "attachment_new: integer expected";
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    if (!$util.isInteger(message.entity_handle))
                        return "entity_handle: integer expected";
                return null;
            };
    
            /**
             * Creates a ChangeControlPointAttachment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment
             */
            ChangeControlPointAttachment.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ChangeControlPointAttachment)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.ChangeControlPointAttachment();
                if (object.attachment_old != null)
                    message.attachment_old = object.attachment_old | 0;
                if (object.attachment_new != null)
                    message.attachment_new = object.attachment_new | 0;
                if (object.entity_handle != null)
                    message.entity_handle = object.entity_handle | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ChangeControlPointAttachment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.ChangeControlPointAttachment} message ChangeControlPointAttachment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangeControlPointAttachment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.attachment_old = 0;
                    object.attachment_new = 0;
                    object.entity_handle = 0;
                }
                if (message.attachment_old != null && message.hasOwnProperty("attachment_old"))
                    object.attachment_old = message.attachment_old;
                if (message.attachment_new != null && message.hasOwnProperty("attachment_new"))
                    object.attachment_new = message.attachment_new;
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    object.entity_handle = message.entity_handle;
                return object;
            };
    
            /**
             * Converts this ChangeControlPointAttachment to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChangeControlPointAttachment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChangeControlPointAttachment;
        })();
    
        CUserMsg_ParticleManager.UpdateEntityPosition = (function() {
    
            /**
             * Properties of an UpdateEntityPosition.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateEntityPosition
             * @property {number|null} [entity_handle] UpdateEntityPosition entity_handle
             * @property {ICMsgVector|null} [position] UpdateEntityPosition position
             */
    
            /**
             * Constructs a new UpdateEntityPosition.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateEntityPosition.
             * @implements IUpdateEntityPosition
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition=} [properties] Properties to set
             */
            function UpdateEntityPosition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateEntityPosition entity_handle.
             * @member {number} entity_handle
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @instance
             */
            UpdateEntityPosition.prototype.entity_handle = 0;
    
            /**
             * UpdateEntityPosition position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @instance
             */
            UpdateEntityPosition.prototype.position = null;
    
            /**
             * Creates a new UpdateEntityPosition instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition instance
             */
            UpdateEntityPosition.create = function create(properties) {
                return new UpdateEntityPosition(properties);
            };
    
            /**
             * Encodes the specified UpdateEntityPosition message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateEntityPosition.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition} message UpdateEntityPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateEntityPosition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entity_handle != null && Object.hasOwnProperty.call(message, "entity_handle"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity_handle);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateEntityPosition message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateEntityPosition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition} message UpdateEntityPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateEntityPosition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateEntityPosition message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateEntityPosition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateEntityPosition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.entity_handle = reader.int32();
                        break;
                    case 2:
                        message.position = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateEntityPosition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateEntityPosition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateEntityPosition message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateEntityPosition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    if (!$util.isInteger(message.entity_handle))
                        return "entity_handle: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateEntityPosition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition
             */
            UpdateEntityPosition.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateEntityPosition)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateEntityPosition();
                if (object.entity_handle != null)
                    message.entity_handle = object.entity_handle | 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateEntityPosition.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateEntityPosition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.UpdateEntityPosition} message UpdateEntityPosition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateEntityPosition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.entity_handle = 0;
                    object.position = null;
                }
                if (message.entity_handle != null && message.hasOwnProperty("entity_handle"))
                    object.entity_handle = message.entity_handle;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                return object;
            };
    
            /**
             * Converts this UpdateEntityPosition to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateEntityPosition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateEntityPosition;
        })();
    
        CUserMsg_ParticleManager.SetParticleFoWProperties = (function() {
    
            /**
             * Properties of a SetParticleFoWProperties.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleFoWProperties
             * @property {number|null} [fow_control_point] SetParticleFoWProperties fow_control_point
             * @property {number|null} [fow_control_point2] SetParticleFoWProperties fow_control_point2
             * @property {number|null} [fow_radius] SetParticleFoWProperties fow_radius
             */
    
            /**
             * Constructs a new SetParticleFoWProperties.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleFoWProperties.
             * @implements ISetParticleFoWProperties
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties=} [properties] Properties to set
             */
            function SetParticleFoWProperties(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleFoWProperties fow_control_point.
             * @member {number} fow_control_point
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             */
            SetParticleFoWProperties.prototype.fow_control_point = 0;
    
            /**
             * SetParticleFoWProperties fow_control_point2.
             * @member {number} fow_control_point2
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             */
            SetParticleFoWProperties.prototype.fow_control_point2 = 0;
    
            /**
             * SetParticleFoWProperties fow_radius.
             * @member {number} fow_radius
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             */
            SetParticleFoWProperties.prototype.fow_radius = 0;
    
            /**
             * Creates a new SetParticleFoWProperties instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties instance
             */
            SetParticleFoWProperties.create = function create(properties) {
                return new SetParticleFoWProperties(properties);
            };
    
            /**
             * Encodes the specified SetParticleFoWProperties message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleFoWProperties.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties} message SetParticleFoWProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleFoWProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fow_control_point != null && Object.hasOwnProperty.call(message, "fow_control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fow_control_point);
                if (message.fow_control_point2 != null && Object.hasOwnProperty.call(message, "fow_control_point2"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fow_control_point2);
                if (message.fow_radius != null && Object.hasOwnProperty.call(message, "fow_radius"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.fow_radius);
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleFoWProperties message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleFoWProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties} message SetParticleFoWProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleFoWProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleFoWProperties message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleFoWProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleFoWProperties();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fow_control_point = reader.int32();
                        break;
                    case 2:
                        message.fow_control_point2 = reader.int32();
                        break;
                    case 3:
                        message.fow_radius = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleFoWProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleFoWProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleFoWProperties message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleFoWProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fow_control_point != null && message.hasOwnProperty("fow_control_point"))
                    if (!$util.isInteger(message.fow_control_point))
                        return "fow_control_point: integer expected";
                if (message.fow_control_point2 != null && message.hasOwnProperty("fow_control_point2"))
                    if (!$util.isInteger(message.fow_control_point2))
                        return "fow_control_point2: integer expected";
                if (message.fow_radius != null && message.hasOwnProperty("fow_radius"))
                    if (typeof message.fow_radius !== "number")
                        return "fow_radius: number expected";
                return null;
            };
    
            /**
             * Creates a SetParticleFoWProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties
             */
            SetParticleFoWProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleFoWProperties)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleFoWProperties();
                if (object.fow_control_point != null)
                    message.fow_control_point = object.fow_control_point | 0;
                if (object.fow_control_point2 != null)
                    message.fow_control_point2 = object.fow_control_point2 | 0;
                if (object.fow_radius != null)
                    message.fow_radius = Number(object.fow_radius);
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleFoWProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleFoWProperties} message SetParticleFoWProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleFoWProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fow_control_point = 0;
                    object.fow_control_point2 = 0;
                    object.fow_radius = 0;
                }
                if (message.fow_control_point != null && message.hasOwnProperty("fow_control_point"))
                    object.fow_control_point = message.fow_control_point;
                if (message.fow_control_point2 != null && message.hasOwnProperty("fow_control_point2"))
                    object.fow_control_point2 = message.fow_control_point2;
                if (message.fow_radius != null && message.hasOwnProperty("fow_radius"))
                    object.fow_radius = options.json && !isFinite(message.fow_radius) ? String(message.fow_radius) : message.fow_radius;
                return object;
            };
    
            /**
             * Converts this SetParticleFoWProperties to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleFoWProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetParticleFoWProperties;
        })();
    
        CUserMsg_ParticleManager.SetParticleShouldCheckFoW = (function() {
    
            /**
             * Properties of a SetParticleShouldCheckFoW.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleShouldCheckFoW
             * @property {boolean|null} [check_fow] SetParticleShouldCheckFoW check_fow
             */
    
            /**
             * Constructs a new SetParticleShouldCheckFoW.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleShouldCheckFoW.
             * @implements ISetParticleShouldCheckFoW
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW=} [properties] Properties to set
             */
            function SetParticleShouldCheckFoW(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleShouldCheckFoW check_fow.
             * @member {boolean} check_fow
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @instance
             */
            SetParticleShouldCheckFoW.prototype.check_fow = false;
    
            /**
             * Creates a new SetParticleShouldCheckFoW instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW instance
             */
            SetParticleShouldCheckFoW.create = function create(properties) {
                return new SetParticleShouldCheckFoW(properties);
            };
    
            /**
             * Encodes the specified SetParticleShouldCheckFoW message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleShouldCheckFoW.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW} message SetParticleShouldCheckFoW message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleShouldCheckFoW.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.check_fow != null && Object.hasOwnProperty.call(message, "check_fow"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.check_fow);
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleShouldCheckFoW message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleShouldCheckFoW.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW} message SetParticleShouldCheckFoW message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleShouldCheckFoW.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleShouldCheckFoW message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleShouldCheckFoW.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.check_fow = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleShouldCheckFoW message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleShouldCheckFoW.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleShouldCheckFoW message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleShouldCheckFoW.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.check_fow != null && message.hasOwnProperty("check_fow"))
                    if (typeof message.check_fow !== "boolean")
                        return "check_fow: boolean expected";
                return null;
            };
    
            /**
             * Creates a SetParticleShouldCheckFoW message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW
             */
            SetParticleShouldCheckFoW.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW();
                if (object.check_fow != null)
                    message.check_fow = Boolean(object.check_fow);
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleShouldCheckFoW message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} message SetParticleShouldCheckFoW
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleShouldCheckFoW.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.check_fow = false;
                if (message.check_fow != null && message.hasOwnProperty("check_fow"))
                    object.check_fow = message.check_fow;
                return object;
            };
    
            /**
             * Converts this SetParticleShouldCheckFoW to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleShouldCheckFoW.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetParticleShouldCheckFoW;
        })();
    
        CUserMsg_ParticleManager.SetControlPointModel = (function() {
    
            /**
             * Properties of a SetControlPointModel.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetControlPointModel
             * @property {number|null} [control_point] SetControlPointModel control_point
             * @property {string|null} [model_name] SetControlPointModel model_name
             */
    
            /**
             * Constructs a new SetControlPointModel.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetControlPointModel.
             * @implements ISetControlPointModel
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetControlPointModel=} [properties] Properties to set
             */
            function SetControlPointModel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetControlPointModel control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @instance
             */
            SetControlPointModel.prototype.control_point = 0;
    
            /**
             * SetControlPointModel model_name.
             * @member {string} model_name
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @instance
             */
            SetControlPointModel.prototype.model_name = "";
    
            /**
             * Creates a new SetControlPointModel instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointModel=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel instance
             */
            SetControlPointModel.create = function create(properties) {
                return new SetControlPointModel(properties);
            };
    
            /**
             * Encodes the specified SetControlPointModel message. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointModel.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointModel} message SetControlPointModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointModel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.model_name != null && Object.hasOwnProperty.call(message, "model_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.model_name);
                return writer;
            };
    
            /**
             * Encodes the specified SetControlPointModel message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointModel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointModel} message SetControlPointModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointModel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetControlPointModel message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointModel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetControlPointModel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.model_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetControlPointModel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointModel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetControlPointModel message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetControlPointModel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.model_name != null && message.hasOwnProperty("model_name"))
                    if (!$util.isString(message.model_name))
                        return "model_name: string expected";
                return null;
            };
    
            /**
             * Creates a SetControlPointModel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel
             */
            SetControlPointModel.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetControlPointModel)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetControlPointModel();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.model_name != null)
                    message.model_name = String(object.model_name);
                return message;
            };
    
            /**
             * Creates a plain object from a SetControlPointModel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.SetControlPointModel} message SetControlPointModel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetControlPointModel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.model_name = "";
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.model_name != null && message.hasOwnProperty("model_name"))
                    object.model_name = message.model_name;
                return object;
            };
    
            /**
             * Converts this SetControlPointModel to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetControlPointModel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetControlPointModel;
        })();
    
        CUserMsg_ParticleManager.SetControlPointSnapshot = (function() {
    
            /**
             * Properties of a SetControlPointSnapshot.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetControlPointSnapshot
             * @property {number|null} [control_point] SetControlPointSnapshot control_point
             * @property {string|null} [snapshot_name] SetControlPointSnapshot snapshot_name
             */
    
            /**
             * Constructs a new SetControlPointSnapshot.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetControlPointSnapshot.
             * @implements ISetControlPointSnapshot
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot=} [properties] Properties to set
             */
            function SetControlPointSnapshot(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetControlPointSnapshot control_point.
             * @member {number} control_point
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @instance
             */
            SetControlPointSnapshot.prototype.control_point = 0;
    
            /**
             * SetControlPointSnapshot snapshot_name.
             * @member {string} snapshot_name
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @instance
             */
            SetControlPointSnapshot.prototype.snapshot_name = "";
    
            /**
             * Creates a new SetControlPointSnapshot instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot instance
             */
            SetControlPointSnapshot.create = function create(properties) {
                return new SetControlPointSnapshot(properties);
            };
    
            /**
             * Encodes the specified SetControlPointSnapshot message. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointSnapshot.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot} message SetControlPointSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointSnapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.control_point != null && Object.hasOwnProperty.call(message, "control_point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control_point);
                if (message.snapshot_name != null && Object.hasOwnProperty.call(message, "snapshot_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.snapshot_name);
                return writer;
            };
    
            /**
             * Encodes the specified SetControlPointSnapshot message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointSnapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot} message SetControlPointSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetControlPointSnapshot message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointSnapshot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetControlPointSnapshot();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.control_point = reader.int32();
                        break;
                    case 2:
                        message.snapshot_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetControlPointSnapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointSnapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetControlPointSnapshot message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetControlPointSnapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    if (!$util.isInteger(message.control_point))
                        return "control_point: integer expected";
                if (message.snapshot_name != null && message.hasOwnProperty("snapshot_name"))
                    if (!$util.isString(message.snapshot_name))
                        return "snapshot_name: string expected";
                return null;
            };
    
            /**
             * Creates a SetControlPointSnapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot
             */
            SetControlPointSnapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetControlPointSnapshot)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetControlPointSnapshot();
                if (object.control_point != null)
                    message.control_point = object.control_point | 0;
                if (object.snapshot_name != null)
                    message.snapshot_name = String(object.snapshot_name);
                return message;
            };
    
            /**
             * Creates a plain object from a SetControlPointSnapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.SetControlPointSnapshot} message SetControlPointSnapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetControlPointSnapshot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.control_point = 0;
                    object.snapshot_name = "";
                }
                if (message.control_point != null && message.hasOwnProperty("control_point"))
                    object.control_point = message.control_point;
                if (message.snapshot_name != null && message.hasOwnProperty("snapshot_name"))
                    object.snapshot_name = message.snapshot_name;
                return object;
            };
    
            /**
             * Converts this SetControlPointSnapshot to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetControlPointSnapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetControlPointSnapshot;
        })();
    
        CUserMsg_ParticleManager.SetParticleText = (function() {
    
            /**
             * Properties of a SetParticleText.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleText
             * @property {string|null} [text] SetParticleText text
             */
    
            /**
             * Constructs a new SetParticleText.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleText.
             * @implements ISetParticleText
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleText=} [properties] Properties to set
             */
            function SetParticleText(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleText text.
             * @member {string} text
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @instance
             */
            SetParticleText.prototype.text = "";
    
            /**
             * Creates a new SetParticleText instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleText=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText instance
             */
            SetParticleText.create = function create(properties) {
                return new SetParticleText(properties);
            };
    
            /**
             * Encodes the specified SetParticleText message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleText.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleText} message SetParticleText message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleText.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleText message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleText.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleText} message SetParticleText message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleText.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleText message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleText.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleText();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleText message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleText.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleText message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleText.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };
    
            /**
             * Creates a SetParticleText message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText
             */
            SetParticleText.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleText)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleText();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleText message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleText} message SetParticleText
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleText.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };
    
            /**
             * Converts this SetParticleText to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleText.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetParticleText;
        })();
    
        CUserMsg_ParticleManager.SetTextureAttribute = (function() {
    
            /**
             * Properties of a SetTextureAttribute.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetTextureAttribute
             * @property {string|null} [attribute_name] SetTextureAttribute attribute_name
             * @property {string|null} [texture_name] SetTextureAttribute texture_name
             */
    
            /**
             * Constructs a new SetTextureAttribute.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetTextureAttribute.
             * @implements ISetTextureAttribute
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute=} [properties] Properties to set
             */
            function SetTextureAttribute(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetTextureAttribute attribute_name.
             * @member {string} attribute_name
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @instance
             */
            SetTextureAttribute.prototype.attribute_name = "";
    
            /**
             * SetTextureAttribute texture_name.
             * @member {string} texture_name
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @instance
             */
            SetTextureAttribute.prototype.texture_name = "";
    
            /**
             * Creates a new SetTextureAttribute instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute instance
             */
            SetTextureAttribute.create = function create(properties) {
                return new SetTextureAttribute(properties);
            };
    
            /**
             * Encodes the specified SetTextureAttribute message. Does not implicitly {@link CUserMsg_ParticleManager.SetTextureAttribute.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute} message SetTextureAttribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetTextureAttribute.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attribute_name != null && Object.hasOwnProperty.call(message, "attribute_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.attribute_name);
                if (message.texture_name != null && Object.hasOwnProperty.call(message, "texture_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.texture_name);
                return writer;
            };
    
            /**
             * Encodes the specified SetTextureAttribute message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetTextureAttribute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute} message SetTextureAttribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetTextureAttribute.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetTextureAttribute message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetTextureAttribute.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetTextureAttribute();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.attribute_name = reader.string();
                        break;
                    case 2:
                        message.texture_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetTextureAttribute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetTextureAttribute.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetTextureAttribute message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetTextureAttribute.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attribute_name != null && message.hasOwnProperty("attribute_name"))
                    if (!$util.isString(message.attribute_name))
                        return "attribute_name: string expected";
                if (message.texture_name != null && message.hasOwnProperty("texture_name"))
                    if (!$util.isString(message.texture_name))
                        return "texture_name: string expected";
                return null;
            };
    
            /**
             * Creates a SetTextureAttribute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute
             */
            SetTextureAttribute.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetTextureAttribute)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetTextureAttribute();
                if (object.attribute_name != null)
                    message.attribute_name = String(object.attribute_name);
                if (object.texture_name != null)
                    message.texture_name = String(object.texture_name);
                return message;
            };
    
            /**
             * Creates a plain object from a SetTextureAttribute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.SetTextureAttribute} message SetTextureAttribute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetTextureAttribute.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.attribute_name = "";
                    object.texture_name = "";
                }
                if (message.attribute_name != null && message.hasOwnProperty("attribute_name"))
                    object.attribute_name = message.attribute_name;
                if (message.texture_name != null && message.hasOwnProperty("texture_name"))
                    object.texture_name = message.texture_name;
                return object;
            };
    
            /**
             * Converts this SetTextureAttribute to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetTextureAttribute.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetTextureAttribute;
        })();
    
        CUserMsg_ParticleManager.SetSceneObjectGenericFlag = (function() {
    
            /**
             * Properties of a SetSceneObjectGenericFlag.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetSceneObjectGenericFlag
             * @property {boolean|null} [flag_value] SetSceneObjectGenericFlag flag_value
             */
    
            /**
             * Constructs a new SetSceneObjectGenericFlag.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetSceneObjectGenericFlag.
             * @implements ISetSceneObjectGenericFlag
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag=} [properties] Properties to set
             */
            function SetSceneObjectGenericFlag(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetSceneObjectGenericFlag flag_value.
             * @member {boolean} flag_value
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @instance
             */
            SetSceneObjectGenericFlag.prototype.flag_value = false;
    
            /**
             * Creates a new SetSceneObjectGenericFlag instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag instance
             */
            SetSceneObjectGenericFlag.create = function create(properties) {
                return new SetSceneObjectGenericFlag(properties);
            };
    
            /**
             * Encodes the specified SetSceneObjectGenericFlag message. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectGenericFlag.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag} message SetSceneObjectGenericFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectGenericFlag.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag_value != null && Object.hasOwnProperty.call(message, "flag_value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.flag_value);
                return writer;
            };
    
            /**
             * Encodes the specified SetSceneObjectGenericFlag message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectGenericFlag.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag} message SetSceneObjectGenericFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectGenericFlag.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetSceneObjectGenericFlag message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectGenericFlag.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.flag_value = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetSceneObjectGenericFlag message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectGenericFlag.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetSceneObjectGenericFlag message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSceneObjectGenericFlag.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag_value != null && message.hasOwnProperty("flag_value"))
                    if (typeof message.flag_value !== "boolean")
                        return "flag_value: boolean expected";
                return null;
            };
    
            /**
             * Creates a SetSceneObjectGenericFlag message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag
             */
            SetSceneObjectGenericFlag.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag();
                if (object.flag_value != null)
                    message.flag_value = Boolean(object.flag_value);
                return message;
            };
    
            /**
             * Creates a plain object from a SetSceneObjectGenericFlag message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} message SetSceneObjectGenericFlag
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSceneObjectGenericFlag.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.flag_value = false;
                if (message.flag_value != null && message.hasOwnProperty("flag_value"))
                    object.flag_value = message.flag_value;
                return object;
            };
    
            /**
             * Converts this SetSceneObjectGenericFlag to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSceneObjectGenericFlag.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetSceneObjectGenericFlag;
        })();
    
        CUserMsg_ParticleManager.SetSceneObjectTintAndDesat = (function() {
    
            /**
             * Properties of a SetSceneObjectTintAndDesat.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetSceneObjectTintAndDesat
             * @property {number|null} [tint] SetSceneObjectTintAndDesat tint
             * @property {number|null} [desat] SetSceneObjectTintAndDesat desat
             */
    
            /**
             * Constructs a new SetSceneObjectTintAndDesat.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetSceneObjectTintAndDesat.
             * @implements ISetSceneObjectTintAndDesat
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat=} [properties] Properties to set
             */
            function SetSceneObjectTintAndDesat(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetSceneObjectTintAndDesat tint.
             * @member {number} tint
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @instance
             */
            SetSceneObjectTintAndDesat.prototype.tint = 0;
    
            /**
             * SetSceneObjectTintAndDesat desat.
             * @member {number} desat
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @instance
             */
            SetSceneObjectTintAndDesat.prototype.desat = 0;
    
            /**
             * Creates a new SetSceneObjectTintAndDesat instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat instance
             */
            SetSceneObjectTintAndDesat.create = function create(properties) {
                return new SetSceneObjectTintAndDesat(properties);
            };
    
            /**
             * Encodes the specified SetSceneObjectTintAndDesat message. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat} message SetSceneObjectTintAndDesat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectTintAndDesat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tint != null && Object.hasOwnProperty.call(message, "tint"))
                    writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.tint);
                if (message.desat != null && Object.hasOwnProperty.call(message, "desat"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.desat);
                return writer;
            };
    
            /**
             * Encodes the specified SetSceneObjectTintAndDesat message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat} message SetSceneObjectTintAndDesat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectTintAndDesat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetSceneObjectTintAndDesat message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectTintAndDesat.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tint = reader.fixed32();
                        break;
                    case 2:
                        message.desat = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetSceneObjectTintAndDesat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectTintAndDesat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetSceneObjectTintAndDesat message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSceneObjectTintAndDesat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tint != null && message.hasOwnProperty("tint"))
                    if (!$util.isInteger(message.tint))
                        return "tint: integer expected";
                if (message.desat != null && message.hasOwnProperty("desat"))
                    if (typeof message.desat !== "number")
                        return "desat: number expected";
                return null;
            };
    
            /**
             * Creates a SetSceneObjectTintAndDesat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat
             */
            SetSceneObjectTintAndDesat.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat();
                if (object.tint != null)
                    message.tint = object.tint >>> 0;
                if (object.desat != null)
                    message.desat = Number(object.desat);
                return message;
            };
    
            /**
             * Creates a plain object from a SetSceneObjectTintAndDesat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} message SetSceneObjectTintAndDesat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSceneObjectTintAndDesat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tint = 0;
                    object.desat = 0;
                }
                if (message.tint != null && message.hasOwnProperty("tint"))
                    object.tint = message.tint;
                if (message.desat != null && message.hasOwnProperty("desat"))
                    object.desat = options.json && !isFinite(message.desat) ? String(message.desat) : message.desat;
                return object;
            };
    
            /**
             * Converts this SetSceneObjectTintAndDesat to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSceneObjectTintAndDesat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SetSceneObjectTintAndDesat;
        })();
    
        return CUserMsg_ParticleManager;
    })();
    
    $root.CUserMsg_HudError = (function() {
    
        /**
         * Properties of a CUserMsg_HudError.
         * @exports ICUserMsg_HudError
         * @interface ICUserMsg_HudError
         * @property {number|null} [order_id] CUserMsg_HudError order_id
         */
    
        /**
         * Constructs a new CUserMsg_HudError.
         * @exports CUserMsg_HudError
         * @classdesc Represents a CUserMsg_HudError.
         * @implements ICUserMsg_HudError
         * @constructor
         * @param {ICUserMsg_HudError=} [properties] Properties to set
         */
        function CUserMsg_HudError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMsg_HudError order_id.
         * @member {number} order_id
         * @memberof CUserMsg_HudError
         * @instance
         */
        CUserMsg_HudError.prototype.order_id = 0;
    
        /**
         * Creates a new CUserMsg_HudError instance using the specified properties.
         * @function create
         * @memberof CUserMsg_HudError
         * @static
         * @param {ICUserMsg_HudError=} [properties] Properties to set
         * @returns {CUserMsg_HudError} CUserMsg_HudError instance
         */
        CUserMsg_HudError.create = function create(properties) {
            return new CUserMsg_HudError(properties);
        };
    
        /**
         * Encodes the specified CUserMsg_HudError message. Does not implicitly {@link CUserMsg_HudError.verify|verify} messages.
         * @function encode
         * @memberof CUserMsg_HudError
         * @static
         * @param {ICUserMsg_HudError} message CUserMsg_HudError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_HudError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.order_id != null && Object.hasOwnProperty.call(message, "order_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order_id);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMsg_HudError message, length delimited. Does not implicitly {@link CUserMsg_HudError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMsg_HudError
         * @static
         * @param {ICUserMsg_HudError} message CUserMsg_HudError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_HudError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMsg_HudError message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMsg_HudError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMsg_HudError} CUserMsg_HudError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_HudError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_HudError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.order_id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMsg_HudError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMsg_HudError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMsg_HudError} CUserMsg_HudError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_HudError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMsg_HudError message.
         * @function verify
         * @memberof CUserMsg_HudError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMsg_HudError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.order_id != null && message.hasOwnProperty("order_id"))
                if (!$util.isInteger(message.order_id))
                    return "order_id: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMsg_HudError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMsg_HudError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMsg_HudError} CUserMsg_HudError
         */
        CUserMsg_HudError.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMsg_HudError)
                return object;
            var message = new $root.CUserMsg_HudError();
            if (object.order_id != null)
                message.order_id = object.order_id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMsg_HudError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMsg_HudError
         * @static
         * @param {CUserMsg_HudError} message CUserMsg_HudError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMsg_HudError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.order_id = 0;
            if (message.order_id != null && message.hasOwnProperty("order_id"))
                object.order_id = message.order_id;
            return object;
        };
    
        /**
         * Converts this CUserMsg_HudError to JSON.
         * @function toJSON
         * @memberof CUserMsg_HudError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMsg_HudError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMsg_HudError;
    })();
    
    $root.CUserMsg_CustomGameEvent = (function() {
    
        /**
         * Properties of a CUserMsg_CustomGameEvent.
         * @exports ICUserMsg_CustomGameEvent
         * @interface ICUserMsg_CustomGameEvent
         * @property {string|null} [event_name] CUserMsg_CustomGameEvent event_name
         * @property {Uint8Array|null} [data] CUserMsg_CustomGameEvent data
         */
    
        /**
         * Constructs a new CUserMsg_CustomGameEvent.
         * @exports CUserMsg_CustomGameEvent
         * @classdesc Represents a CUserMsg_CustomGameEvent.
         * @implements ICUserMsg_CustomGameEvent
         * @constructor
         * @param {ICUserMsg_CustomGameEvent=} [properties] Properties to set
         */
        function CUserMsg_CustomGameEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMsg_CustomGameEvent event_name.
         * @member {string} event_name
         * @memberof CUserMsg_CustomGameEvent
         * @instance
         */
        CUserMsg_CustomGameEvent.prototype.event_name = "";
    
        /**
         * CUserMsg_CustomGameEvent data.
         * @member {Uint8Array} data
         * @memberof CUserMsg_CustomGameEvent
         * @instance
         */
        CUserMsg_CustomGameEvent.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CUserMsg_CustomGameEvent instance using the specified properties.
         * @function create
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {ICUserMsg_CustomGameEvent=} [properties] Properties to set
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent instance
         */
        CUserMsg_CustomGameEvent.create = function create(properties) {
            return new CUserMsg_CustomGameEvent(properties);
        };
    
        /**
         * Encodes the specified CUserMsg_CustomGameEvent message. Does not implicitly {@link CUserMsg_CustomGameEvent.verify|verify} messages.
         * @function encode
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {ICUserMsg_CustomGameEvent} message CUserMsg_CustomGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_CustomGameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMsg_CustomGameEvent message, length delimited. Does not implicitly {@link CUserMsg_CustomGameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {ICUserMsg_CustomGameEvent} message CUserMsg_CustomGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_CustomGameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMsg_CustomGameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_CustomGameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_CustomGameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMsg_CustomGameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_CustomGameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMsg_CustomGameEvent message.
         * @function verify
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMsg_CustomGameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CUserMsg_CustomGameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent
         */
        CUserMsg_CustomGameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMsg_CustomGameEvent)
                return object;
            var message = new $root.CUserMsg_CustomGameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMsg_CustomGameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {CUserMsg_CustomGameEvent} message CUserMsg_CustomGameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMsg_CustomGameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event_name = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CUserMsg_CustomGameEvent to JSON.
         * @function toJSON
         * @memberof CUserMsg_CustomGameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMsg_CustomGameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMsg_CustomGameEvent;
    })();
    
    $root.CUserMessageHapticsManagerPulse = (function() {
    
        /**
         * Properties of a CUserMessageHapticsManagerPulse.
         * @exports ICUserMessageHapticsManagerPulse
         * @interface ICUserMessageHapticsManagerPulse
         * @property {number|null} [hand_id] CUserMessageHapticsManagerPulse hand_id
         * @property {number|null} [effect_amplitude] CUserMessageHapticsManagerPulse effect_amplitude
         * @property {number|null} [effect_frequency] CUserMessageHapticsManagerPulse effect_frequency
         * @property {number|null} [effect_duration] CUserMessageHapticsManagerPulse effect_duration
         */
    
        /**
         * Constructs a new CUserMessageHapticsManagerPulse.
         * @exports CUserMessageHapticsManagerPulse
         * @classdesc Represents a CUserMessageHapticsManagerPulse.
         * @implements ICUserMessageHapticsManagerPulse
         * @constructor
         * @param {ICUserMessageHapticsManagerPulse=} [properties] Properties to set
         */
        function CUserMessageHapticsManagerPulse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHapticsManagerPulse hand_id.
         * @member {number} hand_id
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.hand_id = 0;
    
        /**
         * CUserMessageHapticsManagerPulse effect_amplitude.
         * @member {number} effect_amplitude
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.effect_amplitude = 0;
    
        /**
         * CUserMessageHapticsManagerPulse effect_frequency.
         * @member {number} effect_frequency
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.effect_frequency = 0;
    
        /**
         * CUserMessageHapticsManagerPulse effect_duration.
         * @member {number} effect_duration
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.effect_duration = 0;
    
        /**
         * Creates a new CUserMessageHapticsManagerPulse instance using the specified properties.
         * @function create
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {ICUserMessageHapticsManagerPulse=} [properties] Properties to set
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse instance
         */
        CUserMessageHapticsManagerPulse.create = function create(properties) {
            return new CUserMessageHapticsManagerPulse(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerPulse message. Does not implicitly {@link CUserMessageHapticsManagerPulse.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {ICUserMessageHapticsManagerPulse} message CUserMessageHapticsManagerPulse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerPulse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hand_id != null && Object.hasOwnProperty.call(message, "hand_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hand_id);
            if (message.effect_amplitude != null && Object.hasOwnProperty.call(message, "effect_amplitude"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.effect_amplitude);
            if (message.effect_frequency != null && Object.hasOwnProperty.call(message, "effect_frequency"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.effect_frequency);
            if (message.effect_duration != null && Object.hasOwnProperty.call(message, "effect_duration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.effect_duration);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerPulse message, length delimited. Does not implicitly {@link CUserMessageHapticsManagerPulse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {ICUserMessageHapticsManagerPulse} message CUserMessageHapticsManagerPulse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerPulse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerPulse message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerPulse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHapticsManagerPulse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hand_id = reader.int32();
                    break;
                case 2:
                    message.effect_amplitude = reader.float();
                    break;
                case 3:
                    message.effect_frequency = reader.float();
                    break;
                case 4:
                    message.effect_duration = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerPulse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerPulse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHapticsManagerPulse message.
         * @function verify
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHapticsManagerPulse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hand_id != null && message.hasOwnProperty("hand_id"))
                if (!$util.isInteger(message.hand_id))
                    return "hand_id: integer expected";
            if (message.effect_amplitude != null && message.hasOwnProperty("effect_amplitude"))
                if (typeof message.effect_amplitude !== "number")
                    return "effect_amplitude: number expected";
            if (message.effect_frequency != null && message.hasOwnProperty("effect_frequency"))
                if (typeof message.effect_frequency !== "number")
                    return "effect_frequency: number expected";
            if (message.effect_duration != null && message.hasOwnProperty("effect_duration"))
                if (typeof message.effect_duration !== "number")
                    return "effect_duration: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHapticsManagerPulse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse
         */
        CUserMessageHapticsManagerPulse.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHapticsManagerPulse)
                return object;
            var message = new $root.CUserMessageHapticsManagerPulse();
            if (object.hand_id != null)
                message.hand_id = object.hand_id | 0;
            if (object.effect_amplitude != null)
                message.effect_amplitude = Number(object.effect_amplitude);
            if (object.effect_frequency != null)
                message.effect_frequency = Number(object.effect_frequency);
            if (object.effect_duration != null)
                message.effect_duration = Number(object.effect_duration);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHapticsManagerPulse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {CUserMessageHapticsManagerPulse} message CUserMessageHapticsManagerPulse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHapticsManagerPulse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hand_id = 0;
                object.effect_amplitude = 0;
                object.effect_frequency = 0;
                object.effect_duration = 0;
            }
            if (message.hand_id != null && message.hasOwnProperty("hand_id"))
                object.hand_id = message.hand_id;
            if (message.effect_amplitude != null && message.hasOwnProperty("effect_amplitude"))
                object.effect_amplitude = options.json && !isFinite(message.effect_amplitude) ? String(message.effect_amplitude) : message.effect_amplitude;
            if (message.effect_frequency != null && message.hasOwnProperty("effect_frequency"))
                object.effect_frequency = options.json && !isFinite(message.effect_frequency) ? String(message.effect_frequency) : message.effect_frequency;
            if (message.effect_duration != null && message.hasOwnProperty("effect_duration"))
                object.effect_duration = options.json && !isFinite(message.effect_duration) ? String(message.effect_duration) : message.effect_duration;
            return object;
        };
    
        /**
         * Converts this CUserMessageHapticsManagerPulse to JSON.
         * @function toJSON
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHapticsManagerPulse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageHapticsManagerPulse;
    })();
    
    $root.CUserMessageHapticsManagerEffect = (function() {
    
        /**
         * Properties of a CUserMessageHapticsManagerEffect.
         * @exports ICUserMessageHapticsManagerEffect
         * @interface ICUserMessageHapticsManagerEffect
         * @property {number|null} [hand_id] CUserMessageHapticsManagerEffect hand_id
         * @property {number|null} [effect_name_hash_code] CUserMessageHapticsManagerEffect effect_name_hash_code
         * @property {number|null} [effect_scale] CUserMessageHapticsManagerEffect effect_scale
         */
    
        /**
         * Constructs a new CUserMessageHapticsManagerEffect.
         * @exports CUserMessageHapticsManagerEffect
         * @classdesc Represents a CUserMessageHapticsManagerEffect.
         * @implements ICUserMessageHapticsManagerEffect
         * @constructor
         * @param {ICUserMessageHapticsManagerEffect=} [properties] Properties to set
         */
        function CUserMessageHapticsManagerEffect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHapticsManagerEffect hand_id.
         * @member {number} hand_id
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         */
        CUserMessageHapticsManagerEffect.prototype.hand_id = 0;
    
        /**
         * CUserMessageHapticsManagerEffect effect_name_hash_code.
         * @member {number} effect_name_hash_code
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         */
        CUserMessageHapticsManagerEffect.prototype.effect_name_hash_code = 0;
    
        /**
         * CUserMessageHapticsManagerEffect effect_scale.
         * @member {number} effect_scale
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         */
        CUserMessageHapticsManagerEffect.prototype.effect_scale = 0;
    
        /**
         * Creates a new CUserMessageHapticsManagerEffect instance using the specified properties.
         * @function create
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {ICUserMessageHapticsManagerEffect=} [properties] Properties to set
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect instance
         */
        CUserMessageHapticsManagerEffect.create = function create(properties) {
            return new CUserMessageHapticsManagerEffect(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerEffect message. Does not implicitly {@link CUserMessageHapticsManagerEffect.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {ICUserMessageHapticsManagerEffect} message CUserMessageHapticsManagerEffect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerEffect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hand_id != null && Object.hasOwnProperty.call(message, "hand_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hand_id);
            if (message.effect_name_hash_code != null && Object.hasOwnProperty.call(message, "effect_name_hash_code"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.effect_name_hash_code);
            if (message.effect_scale != null && Object.hasOwnProperty.call(message, "effect_scale"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.effect_scale);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerEffect message, length delimited. Does not implicitly {@link CUserMessageHapticsManagerEffect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {ICUserMessageHapticsManagerEffect} message CUserMessageHapticsManagerEffect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerEffect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerEffect message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerEffect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHapticsManagerEffect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hand_id = reader.int32();
                    break;
                case 2:
                    message.effect_name_hash_code = reader.uint32();
                    break;
                case 3:
                    message.effect_scale = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerEffect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerEffect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHapticsManagerEffect message.
         * @function verify
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHapticsManagerEffect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hand_id != null && message.hasOwnProperty("hand_id"))
                if (!$util.isInteger(message.hand_id))
                    return "hand_id: integer expected";
            if (message.effect_name_hash_code != null && message.hasOwnProperty("effect_name_hash_code"))
                if (!$util.isInteger(message.effect_name_hash_code))
                    return "effect_name_hash_code: integer expected";
            if (message.effect_scale != null && message.hasOwnProperty("effect_scale"))
                if (typeof message.effect_scale !== "number")
                    return "effect_scale: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHapticsManagerEffect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect
         */
        CUserMessageHapticsManagerEffect.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHapticsManagerEffect)
                return object;
            var message = new $root.CUserMessageHapticsManagerEffect();
            if (object.hand_id != null)
                message.hand_id = object.hand_id | 0;
            if (object.effect_name_hash_code != null)
                message.effect_name_hash_code = object.effect_name_hash_code >>> 0;
            if (object.effect_scale != null)
                message.effect_scale = Number(object.effect_scale);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHapticsManagerEffect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {CUserMessageHapticsManagerEffect} message CUserMessageHapticsManagerEffect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHapticsManagerEffect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hand_id = 0;
                object.effect_name_hash_code = 0;
                object.effect_scale = 0;
            }
            if (message.hand_id != null && message.hasOwnProperty("hand_id"))
                object.hand_id = message.hand_id;
            if (message.effect_name_hash_code != null && message.hasOwnProperty("effect_name_hash_code"))
                object.effect_name_hash_code = message.effect_name_hash_code;
            if (message.effect_scale != null && message.hasOwnProperty("effect_scale"))
                object.effect_scale = options.json && !isFinite(message.effect_scale) ? String(message.effect_scale) : message.effect_scale;
            return object;
        };
    
        /**
         * Converts this CUserMessageHapticsManagerEffect to JSON.
         * @function toJSON
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHapticsManagerEffect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageHapticsManagerEffect;
    })();
    
    $root.CUserMessageAnimStateGraphState = (function() {
    
        /**
         * Properties of a CUserMessageAnimStateGraphState.
         * @exports ICUserMessageAnimStateGraphState
         * @interface ICUserMessageAnimStateGraphState
         * @property {number|null} [entity_index] CUserMessageAnimStateGraphState entity_index
         * @property {Uint8Array|null} [data] CUserMessageAnimStateGraphState data
         */
    
        /**
         * Constructs a new CUserMessageAnimStateGraphState.
         * @exports CUserMessageAnimStateGraphState
         * @classdesc Represents a CUserMessageAnimStateGraphState.
         * @implements ICUserMessageAnimStateGraphState
         * @constructor
         * @param {ICUserMessageAnimStateGraphState=} [properties] Properties to set
         */
        function CUserMessageAnimStateGraphState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAnimStateGraphState entity_index.
         * @member {number} entity_index
         * @memberof CUserMessageAnimStateGraphState
         * @instance
         */
        CUserMessageAnimStateGraphState.prototype.entity_index = 0;
    
        /**
         * CUserMessageAnimStateGraphState data.
         * @member {Uint8Array} data
         * @memberof CUserMessageAnimStateGraphState
         * @instance
         */
        CUserMessageAnimStateGraphState.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CUserMessageAnimStateGraphState instance using the specified properties.
         * @function create
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {ICUserMessageAnimStateGraphState=} [properties] Properties to set
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState instance
         */
        CUserMessageAnimStateGraphState.create = function create(properties) {
            return new CUserMessageAnimStateGraphState(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAnimStateGraphState message. Does not implicitly {@link CUserMessageAnimStateGraphState.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {ICUserMessageAnimStateGraphState} message CUserMessageAnimStateGraphState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAnimStateGraphState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity_index != null && Object.hasOwnProperty.call(message, "entity_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity_index);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAnimStateGraphState message, length delimited. Does not implicitly {@link CUserMessageAnimStateGraphState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {ICUserMessageAnimStateGraphState} message CUserMessageAnimStateGraphState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAnimStateGraphState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAnimStateGraphState message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAnimStateGraphState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAnimStateGraphState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity_index = reader.int32();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAnimStateGraphState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAnimStateGraphState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAnimStateGraphState message.
         * @function verify
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAnimStateGraphState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                if (!$util.isInteger(message.entity_index))
                    return "entity_index: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAnimStateGraphState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState
         */
        CUserMessageAnimStateGraphState.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAnimStateGraphState)
                return object;
            var message = new $root.CUserMessageAnimStateGraphState();
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAnimStateGraphState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {CUserMessageAnimStateGraphState} message CUserMessageAnimStateGraphState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAnimStateGraphState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entity_index = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CUserMessageAnimStateGraphState to JSON.
         * @function toJSON
         * @memberof CUserMessageAnimStateGraphState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAnimStateGraphState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CUserMessageAnimStateGraphState;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.userid = reader.int32();
                    break;
                case 4:
                    message.steamid = reader.fixed64();
                    break;
                case 5:
                    message.fakeplayer = reader.bool();
                    break;
                case 6:
                    message.ishltv = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [target_entity] CEntityMsg target_entity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg target_entity.
         * @member {number} target_entity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.target_entity = 0;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_entity != null && Object.hasOwnProperty.call(message, "target_entity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_entity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_entity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                if (!$util.isInteger(message.target_entity))
                    return "target_entity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.target_entity != null)
                message.target_entity = object.target_entity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.target_entity = 0;
            if (message.target_entity != null && message.hasOwnProperty("target_entity"))
                object.target_entity = message.target_entity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW":
            case 70:
                message.reason = 70;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [host_frametime] CNETMsg_Tick host_frametime
         * @property {number|null} [host_frametime_std_deviation] CNETMsg_Tick host_frametime_std_deviation
         * @property {number|null} [host_computationtime] CNETMsg_Tick host_computationtime
         * @property {number|null} [host_computationtime_std_deviation] CNETMsg_Tick host_computationtime_std_deviation
         * @property {number|null} [host_framestarttime_std_deviation] CNETMsg_Tick host_framestarttime_std_deviation
         * @property {number|null} [host_loss] CNETMsg_Tick host_loss
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick host_frametime.
         * @member {number} host_frametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime = 0;
    
        /**
         * CNETMsg_Tick host_frametime_std_deviation.
         * @member {number} host_frametime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_frametime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_computationtime.
         * @member {number} host_computationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime = 0;
    
        /**
         * CNETMsg_Tick host_computationtime_std_deviation.
         * @member {number} host_computationtime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_framestarttime_std_deviation.
         * @member {number} host_framestarttime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_framestarttime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_loss.
         * @member {number} host_loss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_loss = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.host_frametime != null && Object.hasOwnProperty.call(message, "host_frametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.host_frametime);
            if (message.host_frametime_std_deviation != null && Object.hasOwnProperty.call(message, "host_frametime_std_deviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.host_frametime_std_deviation);
            if (message.host_computationtime != null && Object.hasOwnProperty.call(message, "host_computationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.host_computationtime);
            if (message.host_computationtime_std_deviation != null && Object.hasOwnProperty.call(message, "host_computationtime_std_deviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.host_computationtime_std_deviation);
            if (message.host_framestarttime_std_deviation != null && Object.hasOwnProperty.call(message, "host_framestarttime_std_deviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.host_framestarttime_std_deviation);
            if (message.host_loss != null && Object.hasOwnProperty.call(message, "host_loss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.host_loss);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 2:
                    message.host_frametime = reader.uint32();
                    break;
                case 3:
                    message.host_frametime_std_deviation = reader.uint32();
                    break;
                case 4:
                    message.host_computationtime = reader.uint32();
                    break;
                case 5:
                    message.host_computationtime_std_deviation = reader.uint32();
                    break;
                case 6:
                    message.host_framestarttime_std_deviation = reader.uint32();
                    break;
                case 7:
                    message.host_loss = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                if (!$util.isInteger(message.host_frametime))
                    return "host_frametime: integer expected";
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                if (!$util.isInteger(message.host_frametime_std_deviation))
                    return "host_frametime_std_deviation: integer expected";
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                if (!$util.isInteger(message.host_computationtime))
                    return "host_computationtime: integer expected";
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                if (!$util.isInteger(message.host_computationtime_std_deviation))
                    return "host_computationtime_std_deviation: integer expected";
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                if (!$util.isInteger(message.host_framestarttime_std_deviation))
                    return "host_framestarttime_std_deviation: integer expected";
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                if (!$util.isInteger(message.host_loss))
                    return "host_loss: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.host_frametime != null)
                message.host_frametime = object.host_frametime >>> 0;
            if (object.host_frametime_std_deviation != null)
                message.host_frametime_std_deviation = object.host_frametime_std_deviation >>> 0;
            if (object.host_computationtime != null)
                message.host_computationtime = object.host_computationtime >>> 0;
            if (object.host_computationtime_std_deviation != null)
                message.host_computationtime_std_deviation = object.host_computationtime_std_deviation >>> 0;
            if (object.host_framestarttime_std_deviation != null)
                message.host_framestarttime_std_deviation = object.host_framestarttime_std_deviation >>> 0;
            if (object.host_loss != null)
                message.host_loss = object.host_loss >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.host_frametime = 0;
                object.host_frametime_std_deviation = 0;
                object.host_computationtime = 0;
                object.host_computationtime_std_deviation = 0;
                object.host_framestarttime_std_deviation = 0;
                object.host_loss = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.host_frametime != null && message.hasOwnProperty("host_frametime"))
                object.host_frametime = message.host_frametime;
            if (message.host_frametime_std_deviation != null && message.hasOwnProperty("host_frametime_std_deviation"))
                object.host_frametime_std_deviation = message.host_frametime_std_deviation;
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                object.host_computationtime = message.host_computationtime;
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                object.host_computationtime_std_deviation = message.host_computationtime_std_deviation;
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                object.host_framestarttime_std_deviation = message.host_framestarttime_std_deviation;
            if (message.host_loss != null && message.hasOwnProperty("host_loss"))
                object.host_loss = message.host_loss;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signon_state] CNETMsg_SignonState signon_state
         * @property {number|null} [spawn_count] CNETMsg_SignonState spawn_count
         * @property {number|null} [num_server_players] CNETMsg_SignonState num_server_players
         * @property {Array.<string>|null} [players_networkids] CNETMsg_SignonState players_networkids
         * @property {string|null} [map_name] CNETMsg_SignonState map_name
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.players_networkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signon_state.
         * @member {SignonState_t} signon_state
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signon_state = 0;
    
        /**
         * CNETMsg_SignonState spawn_count.
         * @member {number} spawn_count
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawn_count = 0;
    
        /**
         * CNETMsg_SignonState num_server_players.
         * @member {number} num_server_players
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.num_server_players = 0;
    
        /**
         * CNETMsg_SignonState players_networkids.
         * @member {Array.<string>} players_networkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.players_networkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState map_name.
         * @member {string} map_name
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.map_name = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signon_state != null && Object.hasOwnProperty.call(message, "signon_state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signon_state);
            if (message.spawn_count != null && Object.hasOwnProperty.call(message, "spawn_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawn_count);
            if (message.num_server_players != null && Object.hasOwnProperty.call(message, "num_server_players"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_server_players);
            if (message.players_networkids != null && message.players_networkids.length)
                for (var i = 0; i < message.players_networkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.players_networkids[i]);
            if (message.map_name != null && Object.hasOwnProperty.call(message, "map_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.map_name);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signon_state = reader.int32();
                    break;
                case 2:
                    message.spawn_count = reader.uint32();
                    break;
                case 3:
                    message.num_server_players = reader.uint32();
                    break;
                case 4:
                    if (!(message.players_networkids && message.players_networkids.length))
                        message.players_networkids = [];
                    message.players_networkids.push(reader.string());
                    break;
                case 5:
                    message.map_name = reader.string();
                    break;
                case 6:
                    message.addons = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                switch (message.signon_state) {
                default:
                    return "signon_state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                if (!$util.isInteger(message.num_server_players))
                    return "num_server_players: integer expected";
            if (message.players_networkids != null && message.hasOwnProperty("players_networkids")) {
                if (!Array.isArray(message.players_networkids))
                    return "players_networkids: array expected";
                for (var i = 0; i < message.players_networkids.length; ++i)
                    if (!$util.isString(message.players_networkids[i]))
                        return "players_networkids: string[] expected";
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signon_state) {
            case "SIGNONSTATE_NONE":
            case 0:
                message.signon_state = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signon_state = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signon_state = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signon_state = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signon_state = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signon_state = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signon_state = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signon_state = 7;
                break;
            }
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count >>> 0;
            if (object.num_server_players != null)
                message.num_server_players = object.num_server_players >>> 0;
            if (object.players_networkids) {
                if (!Array.isArray(object.players_networkids))
                    throw TypeError(".CNETMsg_SignonState.players_networkids: array expected");
                message.players_networkids = [];
                for (var i = 0; i < object.players_networkids.length; ++i)
                    message.players_networkids[i] = String(object.players_networkids[i]);
            }
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.players_networkids = [];
            if (options.defaults) {
                object.signon_state = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawn_count = 0;
                object.num_server_players = 0;
                object.map_name = "";
                object.addons = "";
            }
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                object.signon_state = options.enums === String ? $root.SignonState_t[message.signon_state] : message.signon_state;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                object.num_server_players = message.num_server_players;
            if (message.players_networkids && message.players_networkids.length) {
                object.players_networkids = [];
                for (var j = 0; j < message.players_networkids.length; ++j)
                    object.players_networkids[j] = message.players_networkids[j];
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [event_name] CSVCMsg_GameEvent event_name
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent event_name.
         * @member {string} event_name
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.event_name = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && Object.hasOwnProperty.call(message, "event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.event_name = "";
                object.eventid = 0;
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [val_string] key_t val_string
             * @property {number|null} [val_float] key_t val_float
             * @property {number|null} [val_long] key_t val_long
             * @property {number|null} [val_short] key_t val_short
             * @property {number|null} [val_byte] key_t val_byte
             * @property {boolean|null} [val_bool] key_t val_bool
             * @property {number|Long|null} [val_uint64] key_t val_uint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t val_string.
             * @member {string} val_string
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_string = "";
    
            /**
             * key_t val_float.
             * @member {number} val_float
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_float = 0;
    
            /**
             * key_t val_long.
             * @member {number} val_long
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_long = 0;
    
            /**
             * key_t val_short.
             * @member {number} val_short
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_short = 0;
    
            /**
             * key_t val_byte.
             * @member {number} val_byte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_byte = 0;
    
            /**
             * key_t val_bool.
             * @member {boolean} val_bool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_bool = false;
    
            /**
             * key_t val_uint64.
             * @member {number|Long} val_uint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_uint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.val_string != null && Object.hasOwnProperty.call(message, "val_string"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.val_string);
                if (message.val_float != null && Object.hasOwnProperty.call(message, "val_float"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_float);
                if (message.val_long != null && Object.hasOwnProperty.call(message, "val_long"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.val_long);
                if (message.val_short != null && Object.hasOwnProperty.call(message, "val_short"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_short);
                if (message.val_byte != null && Object.hasOwnProperty.call(message, "val_byte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.val_byte);
                if (message.val_bool != null && Object.hasOwnProperty.call(message, "val_bool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.val_bool);
                if (message.val_uint64 != null && Object.hasOwnProperty.call(message, "val_uint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.val_uint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.val_string = reader.string();
                        break;
                    case 3:
                        message.val_float = reader.float();
                        break;
                    case 4:
                        message.val_long = reader.int32();
                        break;
                    case 5:
                        message.val_short = reader.int32();
                        break;
                    case 6:
                        message.val_byte = reader.int32();
                        break;
                    case 7:
                        message.val_bool = reader.bool();
                        break;
                    case 8:
                        message.val_uint64 = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    if (typeof message.val_float !== "number")
                        return "val_float: number expected";
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    if (!$util.isInteger(message.val_long))
                        return "val_long: integer expected";
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    if (!$util.isInteger(message.val_short))
                        return "val_short: integer expected";
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    if (!$util.isInteger(message.val_byte))
                        return "val_byte: integer expected";
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    if (typeof message.val_bool !== "boolean")
                        return "val_bool: boolean expected";
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (!$util.isInteger(message.val_uint64) && !(message.val_uint64 && $util.isInteger(message.val_uint64.low) && $util.isInteger(message.val_uint64.high)))
                        return "val_uint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_float != null)
                    message.val_float = Number(object.val_float);
                if (object.val_long != null)
                    message.val_long = object.val_long | 0;
                if (object.val_short != null)
                    message.val_short = object.val_short | 0;
                if (object.val_byte != null)
                    message.val_byte = object.val_byte | 0;
                if (object.val_bool != null)
                    message.val_bool = Boolean(object.val_bool);
                if (object.val_uint64 != null)
                    if ($util.Long)
                        (message.val_uint64 = $util.Long.fromValue(object.val_uint64)).unsigned = true;
                    else if (typeof object.val_uint64 === "string")
                        message.val_uint64 = parseInt(object.val_uint64, 10);
                    else if (typeof object.val_uint64 === "number")
                        message.val_uint64 = object.val_uint64;
                    else if (typeof object.val_uint64 === "object")
                        message.val_uint64 = new $util.LongBits(object.val_uint64.low >>> 0, object.val_uint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.val_string = "";
                    object.val_float = 0;
                    object.val_long = 0;
                    object.val_short = 0;
                    object.val_byte = 0;
                    object.val_bool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.val_uint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val_uint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    object.val_float = options.json && !isFinite(message.val_float) ? String(message.val_float) : message.val_float;
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    object.val_long = message.val_long;
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    object.val_short = message.val_short;
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    object.val_byte = message.val_byte;
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    object.val_bool = message.val_bool;
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (typeof message.val_uint64 === "number")
                        object.val_uint64 = options.longs === String ? String(message.val_uint64) : message.val_uint64;
                    else
                        object.val_uint64 = options.longs === String ? $util.Long.prototype.toString.call(message.val_uint64) : options.longs === Number ? new $util.LongBits(message.val_uint64.low >>> 0, message.val_uint64.high >>> 0).toNumber(true) : message.val_uint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msg_type] CSVCMsg_UserMessage msg_type
         * @property {Uint8Array|null} [msg_data] CSVCMsg_UserMessage msg_data
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msg_type.
         * @member {number} msg_type
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_type = 0;
    
        /**
         * CSVCMsg_UserMessage msg_data.
         * @member {Uint8Array} msg_data
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.msg_data != null && Object.hasOwnProperty.call(message, "msg_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.msg_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                if (!(message.msg_data && typeof message.msg_data.length === "number" || $util.isString(message.msg_data)))
                    return "msg_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.msg_data != null)
                if (typeof object.msg_data === "string")
                    $util.base64.decode(object.msg_data, message.msg_data = $util.newBuffer($util.base64.length(object.msg_data)), 0);
                else if (object.msg_data.length)
                    message.msg_data = object.msg_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.msg_data = "";
                else {
                    object.msg_data = [];
                    if (options.bytes !== Array)
                        object.msg_data = $util.newBuffer(object.msg_data);
                }
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                object.msg_data = options.bytes === String ? $util.base64.encode(message.msg_data, 0, message.msg_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg_data) : message.msg_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsgList_UserMessages = (function() {
    
        /**
         * Properties of a CSVCMsgList_UserMessages.
         * @exports ICSVCMsgList_UserMessages
         * @interface ICSVCMsgList_UserMessages
         * @property {Array.<CSVCMsgList_UserMessages.Iusermsg_t>|null} [usermsgs] CSVCMsgList_UserMessages usermsgs
         */
    
        /**
         * Constructs a new CSVCMsgList_UserMessages.
         * @exports CSVCMsgList_UserMessages
         * @classdesc Represents a CSVCMsgList_UserMessages.
         * @implements ICSVCMsgList_UserMessages
         * @constructor
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         */
        function CSVCMsgList_UserMessages(properties) {
            this.usermsgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_UserMessages usermsgs.
         * @member {Array.<CSVCMsgList_UserMessages.Iusermsg_t>} usermsgs
         * @memberof CSVCMsgList_UserMessages
         * @instance
         */
        CSVCMsgList_UserMessages.prototype.usermsgs = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_UserMessages instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages=} [properties] Properties to set
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages instance
         */
        CSVCMsgList_UserMessages.create = function create(properties) {
            return new CSVCMsgList_UserMessages(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usermsgs != null && message.usermsgs.length)
                for (var i = 0; i < message.usermsgs.length; ++i)
                    $root.CSVCMsgList_UserMessages.usermsg_t.encode(message.usermsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_UserMessages message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {ICSVCMsgList_UserMessages} message CSVCMsgList_UserMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_UserMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.usermsgs && message.usermsgs.length))
                        message.usermsgs = [];
                    message.usermsgs.push($root.CSVCMsgList_UserMessages.usermsg_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_UserMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_UserMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_UserMessages message.
         * @function verify
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_UserMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usermsgs != null && message.hasOwnProperty("usermsgs")) {
                if (!Array.isArray(message.usermsgs))
                    return "usermsgs: array expected";
                for (var i = 0; i < message.usermsgs.length; ++i) {
                    var error = $root.CSVCMsgList_UserMessages.usermsg_t.verify(message.usermsgs[i]);
                    if (error)
                        return "usermsgs." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_UserMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_UserMessages} CSVCMsgList_UserMessages
         */
        CSVCMsgList_UserMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_UserMessages)
                return object;
            var message = new $root.CSVCMsgList_UserMessages();
            if (object.usermsgs) {
                if (!Array.isArray(object.usermsgs))
                    throw TypeError(".CSVCMsgList_UserMessages.usermsgs: array expected");
                message.usermsgs = [];
                for (var i = 0; i < object.usermsgs.length; ++i) {
                    if (typeof object.usermsgs[i] !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsgs: object expected");
                    message.usermsgs[i] = $root.CSVCMsgList_UserMessages.usermsg_t.fromObject(object.usermsgs[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_UserMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_UserMessages
         * @static
         * @param {CSVCMsgList_UserMessages} message CSVCMsgList_UserMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_UserMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.usermsgs = [];
            if (message.usermsgs && message.usermsgs.length) {
                object.usermsgs = [];
                for (var j = 0; j < message.usermsgs.length; ++j)
                    object.usermsgs[j] = $root.CSVCMsgList_UserMessages.usermsg_t.toObject(message.usermsgs[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_UserMessages to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_UserMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_UserMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsgList_UserMessages.usermsg_t = (function() {
    
            /**
             * Properties of a usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @interface Iusermsg_t
             * @property {number|null} [tick] usermsg_t tick
             * @property {ICSVCMsg_UserMessage|null} [msg] usermsg_t msg
             */
    
            /**
             * Constructs a new usermsg_t.
             * @memberof CSVCMsgList_UserMessages
             * @classdesc Represents a usermsg_t.
             * @implements Iusermsg_t
             * @constructor
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             */
            function usermsg_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * usermsg_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.tick = 0;
    
            /**
             * usermsg_t msg.
             * @member {ICSVCMsg_UserMessage|null|undefined} msg
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             */
            usermsg_t.prototype.msg = null;
    
            /**
             * Creates a new usermsg_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t=} [properties] Properties to set
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t instance
             */
            usermsg_t.create = function create(properties) {
                return new usermsg_t(properties);
            };
    
            /**
             * Encodes the specified usermsg_t message. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.CSVCMsg_UserMessage.encode(message.msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified usermsg_t message, length delimited. Does not implicitly {@link CSVCMsgList_UserMessages.usermsg_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.Iusermsg_t} message usermsg_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            usermsg_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tick = reader.int32();
                        break;
                    case 2:
                        message.msg = $root.CSVCMsg_UserMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a usermsg_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            usermsg_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a usermsg_t message.
             * @function verify
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            usermsg_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    var error = $root.CSVCMsg_UserMessage.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                return null;
            };
    
            /**
             * Creates a usermsg_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_UserMessages.usermsg_t} usermsg_t
             */
            usermsg_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_UserMessages.usermsg_t)
                    return object;
                var message = new $root.CSVCMsgList_UserMessages.usermsg_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".CSVCMsgList_UserMessages.usermsg_t.msg: object expected");
                    message.msg = $root.CSVCMsg_UserMessage.fromObject(object.msg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a usermsg_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @static
             * @param {CSVCMsgList_UserMessages.usermsg_t} message usermsg_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            usermsg_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.msg = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.CSVCMsg_UserMessage.toObject(message.msg, options);
                return object;
            };
    
            /**
             * Converts this usermsg_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_UserMessages.usermsg_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            usermsg_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return usermsg_t;
        })();
    
        return CSVCMsgList_UserMessages;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [world_offset_pos] CNETMsg_SpawnGroup_Load world_offset_pos
         * @property {ICMsgQAngle|null} [world_offset_angle] CNETMsg_SpawnGroup_Load world_offset_angle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_pos.
         * @member {ICMsgVector|null|undefined} world_offset_pos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_pos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load world_offset_angle.
         * @member {ICMsgQAngle|null|undefined} world_offset_angle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.world_offset_angle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.world_offset_pos != null && Object.hasOwnProperty.call(message, "world_offset_pos"))
                $root.CMsgVector.encode(message.world_offset_pos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.world_offset_angle != null && Object.hasOwnProperty.call(message, "world_offset_angle"))
                $root.CMsgQAngle.encode(message.world_offset_angle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.worldname = reader.string();
                    break;
                case 2:
                    message.entitylumpname = reader.string();
                    break;
                case 3:
                    message.entityfiltername = reader.string();
                    break;
                case 4:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 5:
                    message.spawngroupownerhandle = reader.uint32();
                    break;
                case 6:
                    message.world_offset_pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.world_offset_angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 9:
                    message.flags = reader.uint32();
                    break;
                case 10:
                    message.tickcount = reader.int32();
                    break;
                case 11:
                    message.manifestincomplete = reader.bool();
                    break;
                case 12:
                    message.localnamefixup = reader.string();
                    break;
                case 13:
                    message.parentnamefixup = reader.string();
                    break;
                case 14:
                    message.manifestloadpriority = reader.int32();
                    break;
                case 15:
                    message.worldgroupid = reader.uint32();
                    break;
                case 16:
                    message.creationsequence = reader.uint32();
                    break;
                case 17:
                    message.savegamefilename = reader.string();
                    break;
                case 18:
                    message.spawngroupparenthandle = reader.uint32();
                    break;
                case 19:
                    message.leveltransition = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos")) {
                var error = $root.CMsgVector.verify(message.world_offset_pos);
                if (error)
                    return "world_offset_pos." + error;
            }
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle")) {
                var error = $root.CMsgQAngle.verify(message.world_offset_angle);
                if (error)
                    return "world_offset_angle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.world_offset_pos != null) {
                if (typeof object.world_offset_pos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_pos: object expected");
                message.world_offset_pos = $root.CMsgVector.fromObject(object.world_offset_pos);
            }
            if (object.world_offset_angle != null) {
                if (typeof object.world_offset_angle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.world_offset_angle: object expected");
                message.world_offset_angle = $root.CMsgQAngle.fromObject(object.world_offset_angle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.world_offset_pos = null;
                object.world_offset_angle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.world_offset_pos != null && message.hasOwnProperty("world_offset_pos"))
                object.world_offset_pos = $root.CMsgVector.toObject(message.world_offset_pos, options);
            if (message.world_offset_angle != null && message.hasOwnProperty("world_offset_angle"))
                object.world_offset_angle = $root.CMsgQAngle.toObject(message.world_offset_angle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case 3:
                    message.manifestincomplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.tickcount = reader.int32();
                    break;
                case 3:
                    message.creationsequence = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case 2:
                    message.flags = reader.uint32();
                    break;
                case 3:
                    message.tickcount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [is_multiplayer] CSVCMsg_GameSessionConfiguration is_multiplayer
         * @property {boolean|null} [is_loadsavegame] CSVCMsg_GameSessionConfiguration is_loadsavegame
         * @property {boolean|null} [is_background_map] CSVCMsg_GameSessionConfiguration is_background_map
         * @property {boolean|null} [is_headless] CSVCMsg_GameSessionConfiguration is_headless
         * @property {number|null} [min_client_limit] CSVCMsg_GameSessionConfiguration min_client_limit
         * @property {number|null} [max_client_limit] CSVCMsg_GameSessionConfiguration max_client_limit
         * @property {number|null} [max_clients] CSVCMsg_GameSessionConfiguration max_clients
         * @property {number|null} [tick_interval] CSVCMsg_GameSessionConfiguration tick_interval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1_mapname] CSVCMsg_GameSessionConfiguration s1_mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [server_ip_address] CSVCMsg_GameSessionConfiguration server_ip_address
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [is_localonly] CSVCMsg_GameSessionConfiguration is_localonly
         * @property {boolean|null} [no_steam_server] CSVCMsg_GameSessionConfiguration no_steam_server
         * @property {boolean|null} [is_transition] CSVCMsg_GameSessionConfiguration is_transition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration is_multiplayer.
         * @member {boolean} is_multiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_multiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_loadsavegame.
         * @member {boolean} is_loadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_loadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_background_map.
         * @member {boolean} is_background_map
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_background_map = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_headless.
         * @member {boolean} is_headless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_headless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration min_client_limit.
         * @member {number} min_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.min_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_client_limit.
         * @member {number} max_client_limit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_client_limit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1_mapname.
         * @member {string} s1_mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1_mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration server_ip_address.
         * @member {string} server_ip_address
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.server_ip_address = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration is_localonly.
         * @member {boolean} is_localonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_localonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration no_steam_server.
         * @member {boolean} no_steam_server
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.no_steam_server = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration is_transition.
         * @member {boolean} is_transition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.is_transition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_multiplayer != null && Object.hasOwnProperty.call(message, "is_multiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_multiplayer);
            if (message.is_loadsavegame != null && Object.hasOwnProperty.call(message, "is_loadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_loadsavegame);
            if (message.is_background_map != null && Object.hasOwnProperty.call(message, "is_background_map"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_background_map);
            if (message.is_headless != null && Object.hasOwnProperty.call(message, "is_headless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_headless);
            if (message.min_client_limit != null && Object.hasOwnProperty.call(message, "min_client_limit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.min_client_limit);
            if (message.max_client_limit != null && Object.hasOwnProperty.call(message, "max_client_limit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.max_client_limit);
            if (message.max_clients != null && Object.hasOwnProperty.call(message, "max_clients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.max_clients);
            if (message.tick_interval != null && Object.hasOwnProperty.call(message, "tick_interval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tick_interval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1_mapname != null && Object.hasOwnProperty.call(message, "s1_mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1_mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.server_ip_address != null && Object.hasOwnProperty.call(message, "server_ip_address"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.server_ip_address);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.is_localonly != null && Object.hasOwnProperty.call(message, "is_localonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.is_localonly);
            if (message.is_transition != null && Object.hasOwnProperty.call(message, "is_transition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_transition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.no_steam_server != null && Object.hasOwnProperty.call(message, "no_steam_server"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.no_steam_server);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_multiplayer = reader.bool();
                    break;
                case 2:
                    message.is_loadsavegame = reader.bool();
                    break;
                case 3:
                    message.is_background_map = reader.bool();
                    break;
                case 4:
                    message.is_headless = reader.bool();
                    break;
                case 5:
                    message.min_client_limit = reader.uint32();
                    break;
                case 6:
                    message.max_client_limit = reader.uint32();
                    break;
                case 7:
                    message.max_clients = reader.uint32();
                    break;
                case 8:
                    message.tick_interval = reader.fixed32();
                    break;
                case 9:
                    message.hostname = reader.string();
                    break;
                case 10:
                    message.savegamename = reader.string();
                    break;
                case 11:
                    message.s1_mapname = reader.string();
                    break;
                case 12:
                    message.gamemode = reader.string();
                    break;
                case 13:
                    message.server_ip_address = reader.string();
                    break;
                case 14:
                    message.data = reader.bytes();
                    break;
                case 15:
                    message.is_localonly = reader.bool();
                    break;
                case 19:
                    message.no_steam_server = reader.bool();
                    break;
                case 16:
                    message.is_transition = reader.bool();
                    break;
                case 17:
                    message.previouslevel = reader.string();
                    break;
                case 18:
                    message.landmarkname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                if (typeof message.is_multiplayer !== "boolean")
                    return "is_multiplayer: boolean expected";
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                if (typeof message.is_loadsavegame !== "boolean")
                    return "is_loadsavegame: boolean expected";
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                if (typeof message.is_background_map !== "boolean")
                    return "is_background_map: boolean expected";
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                if (typeof message.is_headless !== "boolean")
                    return "is_headless: boolean expected";
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                if (!$util.isInteger(message.min_client_limit))
                    return "min_client_limit: integer expected";
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                if (!$util.isInteger(message.max_client_limit))
                    return "max_client_limit: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (!$util.isInteger(message.tick_interval))
                    return "tick_interval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                if (!$util.isString(message.s1_mapname))
                    return "s1_mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                if (!$util.isString(message.server_ip_address))
                    return "server_ip_address: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                if (typeof message.is_localonly !== "boolean")
                    return "is_localonly: boolean expected";
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                if (typeof message.no_steam_server !== "boolean")
                    return "no_steam_server: boolean expected";
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                if (typeof message.is_transition !== "boolean")
                    return "is_transition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.is_multiplayer != null)
                message.is_multiplayer = Boolean(object.is_multiplayer);
            if (object.is_loadsavegame != null)
                message.is_loadsavegame = Boolean(object.is_loadsavegame);
            if (object.is_background_map != null)
                message.is_background_map = Boolean(object.is_background_map);
            if (object.is_headless != null)
                message.is_headless = Boolean(object.is_headless);
            if (object.min_client_limit != null)
                message.min_client_limit = object.min_client_limit >>> 0;
            if (object.max_client_limit != null)
                message.max_client_limit = object.max_client_limit >>> 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients >>> 0;
            if (object.tick_interval != null)
                message.tick_interval = object.tick_interval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1_mapname != null)
                message.s1_mapname = String(object.s1_mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.server_ip_address != null)
                message.server_ip_address = String(object.server_ip_address);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.is_localonly != null)
                message.is_localonly = Boolean(object.is_localonly);
            if (object.no_steam_server != null)
                message.no_steam_server = Boolean(object.no_steam_server);
            if (object.is_transition != null)
                message.is_transition = Boolean(object.is_transition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.is_multiplayer = false;
                object.is_loadsavegame = false;
                object.is_background_map = false;
                object.is_headless = false;
                object.min_client_limit = 0;
                object.max_client_limit = 0;
                object.max_clients = 0;
                object.tick_interval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1_mapname = "";
                object.gamemode = "";
                object.server_ip_address = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.is_localonly = false;
                object.is_transition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.no_steam_server = false;
            }
            if (message.is_multiplayer != null && message.hasOwnProperty("is_multiplayer"))
                object.is_multiplayer = message.is_multiplayer;
            if (message.is_loadsavegame != null && message.hasOwnProperty("is_loadsavegame"))
                object.is_loadsavegame = message.is_loadsavegame;
            if (message.is_background_map != null && message.hasOwnProperty("is_background_map"))
                object.is_background_map = message.is_background_map;
            if (message.is_headless != null && message.hasOwnProperty("is_headless"))
                object.is_headless = message.is_headless;
            if (message.min_client_limit != null && message.hasOwnProperty("min_client_limit"))
                object.min_client_limit = message.min_client_limit;
            if (message.max_client_limit != null && message.hasOwnProperty("max_client_limit"))
                object.max_client_limit = message.max_client_limit;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = message.tick_interval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1_mapname != null && message.hasOwnProperty("s1_mapname"))
                object.s1_mapname = message.s1_mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.server_ip_address != null && message.hasOwnProperty("server_ip_address"))
                object.server_ip_address = message.server_ip_address;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.is_localonly != null && message.hasOwnProperty("is_localonly"))
                object.is_localonly = message.is_localonly;
            if (message.is_transition != null && message.hasOwnProperty("is_transition"))
                object.is_transition = message.is_transition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.no_steam_server != null && message.hasOwnProperty("no_steam_server"))
                object.no_steam_server = message.no_steam_server;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW=70 NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[70] = "NETWORK_DISCONNECT_SPLITPACKET_SEND_OVERFLOW"] = 70;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {string|null} [experimental_map_key] FieldOptions experimental_map_key
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions experimental_map_key.
                 * @member {string} experimental_map_key
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.experimental_map_key = "";
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.experimental_map_key != null && Object.hasOwnProperty.call(message, "experimental_map_key"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.experimental_map_key);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 9:
                            message.experimental_map_key = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        if (!$util.isString(message.experimental_map_key))
                            return "experimental_map_key: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.experimental_map_key != null)
                        message.experimental_map_key = String(object.experimental_map_key);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.experimental_map_key = "";
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        object.experimental_map_key = message.experimental_map_key;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 * @property {string|null} [".network_connection_token"] EnumValueOptions .network_connection_token
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * EnumValueOptions .network_connection_token.
                 * @member {string} .network_connection_token
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".network_connection_token"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".network_connection_token"] != null && Object.hasOwnProperty.call(message, ".network_connection_token"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".network_connection_token"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50500:
                            message[".network_connection_token"] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        if (!$util.isString(message[".network_connection_token"]))
                            return ".network_connection_token: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    if (object[".network_connection_token"] != null)
                        message[".network_connection_token"] = String(object[".network_connection_token"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object[".network_connection_token"] = "";
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".network_connection_token"] != null && message.hasOwnProperty(".network_connection_token"))
                        object[".network_connection_token"] = message[".network_connection_token"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
